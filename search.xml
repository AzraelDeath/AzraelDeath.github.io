<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ2987 Earthquake]]></title>
    <url>%2FBZOJ2987%20Earthquake%20%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[ProblemEarthquake Description给定 ，求满足方程 的非负整数解的个数。 Input输入一行三个整数 ，含义如上所述。 Output输出一行一个整数，表示非负整数解的个数。 Sample Input13 4 13 Sample Output112 HINT 标签：类欧几里得 Solution类欧几里得基础题。 令 ，则根据 的关系将其分为两类递归处理 若 或 ，则将 、 分离常数后可知 若 且 ，则 由于每次均将参数变为其辗转相模的结果，故而复杂度和欧几里得算法大致相同。 Code123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}lnt f(lnt a, lnt b, lnt c, lnt n) { if (!c) return 0; if (a &gt;= c || b &gt;= c) return a/c*n*(n+1)/2+b/c*(n+1)+f(a%c, b%c, c, n); return (a*n+b)/c*n-f(c, c-b-1, a, (a*n+b)/c-1);}int main() { lnt a, b, c; read(a), read(b), read(c); return printf("%lld\n", f(a, c%a, b, c/a)+c/a+1), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>类欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2187 fraction]]></title>
    <url>%2FBZOJ2187%20fraction%20%E7%B1%BB%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%2F</url>
    <content type="text"><![CDATA[Problemfraction Description给出 个正整数 ，求一个最简分数 满足 。若有多组解，输出 最小的一组，若仍有多组解，输出 最小的一组。 Input本题有多组数据，有若干行，每行 个数 。以文件的末尾作为结束。 Output对于输入的每组数据输出一个最简分数 。 Sample Input12341 3 1 22 1 3 12 1 4 11000 1001 1001 1002 Sample Output12342/55/23/12001/2003 HINT对于 的数据 , 数 据 组 数 数据保证至少存在一个最简分数符合条件。 标签：类欧几里得 Solution类欧几里得基础题。 设 为满足 的 ，考虑将其转化为规模更小的问题。 若 和 间相差至少一个整数，则 为最小符合条件的整数， 为 若 且 ，则一定有等价不等式 ，于是将问题转化为 ，求出 后颠倒分子分母得到 若 或 ，令 ，则有 ，问题转化为 ，求出 后即可还原出 由于每次均将参数变为其辗转相模的结果，故而复杂度和欧几里得算法大致相同。 Code12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef double dnt;typedef long long lnt;lnt gcd(lnt x, lnt y) {return y ? gcd(y, x%y) : x;}lnt flr(lnt x, lnt y) {return (lnt)floor((dnt)x/(dnt)y);}lnt cel(lnt x, lnt y) {return (lnt)ceil((dnt)x/(dnt)y);}void getans(lnt a, lnt b, lnt c, lnt d, lnt &amp;p, lnt &amp;q) { if (flr(a, b)+1 &lt;= cel(c, d)-1) p = flr(a, b)+1, q = 1; else if (!a) p = 1, q = flr(d, c)+1; else if (a &lt;= b &amp;&amp; c &lt;= d) getans(d, c, b, a, q, p); else {lnt k = a/b; getans(a-b*k, b, c-d*k, d, p, q), p += q*k;}}int main() { lnt a, b, c, d, p, q, t; while (~scanf("%lld%lld%lld%lld", &amp;a, &amp;b, &amp;c, &amp;d)) t = gcd(a, b), a /= t, b /= t, t = gcd(c, d), c /= t, d /= t, getans(a, b, c, d, p, q), printf("%lld/%lld\n", p, q); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>类欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4025 二分图]]></title>
    <url>%2FBZOJ4025%20%E4%BA%8C%E5%88%86%E5%9B%BE%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem二分图 Description神犇有一个 个节点的图。因为神犇是神犇，所以在T时间内一些边会出现后消失。神犇要求出每一时间段内这个图是否是二分图。这么简单的问题神犇当然会做了，于是他想考考你。 Input输入数据的第一行是三个整数 。第 行到第 行，每行4个整数 ，表示第 条边连接 两个点，这条边在 时刻出现，在第 时刻消失。 Output输出包含 行。在第 行中，如果第 时间段内这个图是二分图，那么输出Yes，否则输出No。 Sample Input12343 3 31 2 0 22 3 0 31 3 1 2 Sample Output123YesNoYes Explanation 时刻，出现两条边 和 。第 时间段内，这个图是二分图，输出 。 时刻，出现一条边 。第 时间段内，这个图不是二分图，输出 。 时刻， 和 两条边消失。第 时间段内，只有一条边 ，这个图是二分图，输出 。 HINT ， ， ， ， 。 标签：线段树分治 并查集 Solution事实证明，线段树不仅是一种数据结构，更是一种思想。 先考虑不带存在时间的版本，可以直接用带权并查集维护。 我们将整个时间想成一段线段，那么其中的任意时间段都是一条更短的线段，显然是可以和线段树一样分作 段。那么我们对每条边存在的时间区间做这种拆分，在这 个区间内的并查集中分别加入这条边然后判断询问。 像整体二分一样分治处理即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, T; bool ans[MAX_N+5];int fa[MAX_N+5], fc[MAX_N+5], w[MAX_N+5];struct edge {int u, v, l, r;} ;int getf(int x) {return fa[x] == x ? x : getf(fa[x]);}int getc(int x) {return fa[x] == x ? 0 : getc(fa[x])^fc[x];}void merge(int u, int v, int c, stack &lt;int&gt; &amp;sta) { if (w[u] &lt; w[v]) swap(u, v); sta.push(v), fa[v] = u, fc[v] = c, w[u] += w[v];}void restore(stack &lt;int&gt; &amp;sta) { for (int u; !sta.empty(); sta.pop()) u = sta.top(), w[fa[u]] -= w[u], fa[u] = u, fc[u] = 0;}void bi_solve(int s, int t, vector &lt;edge&gt; E) { vector &lt;edge&gt; El, Er; stack &lt;int&gt; sta; for (int i = 0; i &lt; (int)E.size(); i++) if (s &gt;= E[i].l &amp;&amp; t &lt;= E[i].r) { int u = getf(E[i].u), v = getf(E[i].v); int c = getc(E[i].u)^getc(E[i].v)^1; if (u^v) merge(u, v, c, sta); else if (c) { for (int j = s; j &lt;= t; j++) ans[j] = false; restore(sta); return; } } else { if (E[i].l &lt;= mid) El.push_back(E[i]); if (E[i].r &gt;= mid+1) Er.push_back(E[i]); } if (s &lt; t) bi_solve(s, mid, El), bi_solve(mid+1, t, Er); restore(sta);}int main() { read(n), read(m), read(T); vector &lt;edge&gt; E; for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1, u, v, l, r; i &lt;= m; i++) read(u), read(v), read(l), read(r), E.push_back((edge){u, v, l+1, r}); for (int i = 1; i &lt;= T; i++) ans[i] = true; bi_solve(1, T, E); for (int i = 1; i &lt;= T; i++) puts(ans[i] ? "Yes" : "No"); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>线段树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3551【ONTAK2010】Peaks加强版 < Kruskal重构树+DFS序+主席树 >]]></title>
    <url>%2FBZOJ3551%E3%80%90ONTAK2010%E3%80%91Peaks%E5%8A%A0%E5%BC%BA%E7%89%88%20Kruskal%E9%87%8D%E6%9E%84%E6%A0%91%2BDFS%E5%BA%8F%2B%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【ONTAK2010】Peaks加强版 Description在 有 座山峰，每座山峰有他的高度 。有些山峰之间有双向道路相连，共 条路径，每条路径有一个困难值，这个值越大表示越难走。现在有 组询问，每组询问询问从点 开始只经过困难值小于等于 的路径所能到达的山峰中第 高的山峰，如果无解输出 。 Input第一行三个数 。第二行 个数，第 个数为 。接下来 行，每行 个数 ，表示从 到 有一条困难值为 的双向路径。接下来 行，每行三个数 ，表示一组询问。 ， ， ，如果 则不变。 Output对于每组询问，输出一个整数表示答案。 Sample Input123456789101112131415161710 11 41 2 3 4 5 6 7 8 9 101 4 42 5 39 8 27 8 107 1 46 7 16 4 82 1 510 8 103 4 73 4 61 5 21 5 61 5 88 9 2 Sample Output12346109-1 HINT ， ， 标签：Kruskal重构树 DFS序 主席树 Solution这道题是BZOJ3545【ONTAK2010】Peaks的强制在线版本。无法离线，则不能只加边不删边，于是无法直接线段树合并。 这里需要引入 重 构 树 这一概念。对于一个图，我们对其构建 重 构 树 ：为每条边都设置一个点，点权为该边边权；为每个点（连同边代表的点）一起建立并查集。 找出当前没有尝试过的最小的边 ，判断其两端点 和 的连通性 若两端点尚未联通，则将 和 的祖先用并查集并到边 所代表的点 上，这时在重构树上加边 , 若当前所有原树上的点都在同一个并查集中，则退出，否则返回步骤 下图是一个 重 构 树 的例子，其四个性质在下方标注 不难发现，由于其是一个大根堆，从一个点出发，只走边权小于等于 的点所能到达的点，一定是重构树上一个边所代表的点的子树的所有叶子节点。这样我们在重构树上倍增预处理一下，即可在 的时间内找到每个询问对应的上述的这个点。对整棵重构树做树上主席树，即可在 的时间内找到第 大的点权。 综上，先跑 建立重构树，并在重构树上倍增预处理和树上值域主席树预处理。随后对每次询问，先倍增跳到权值小于等于 的层数最浅的结点，再在此结点子树的 序区间中询问第 大权值即可，时间复杂度 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define LOG 20#define MAX_N 200000#define MAX_M 500000#define INF 0x3f3f3f3f#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}vector &lt;int&gt; G[MAX_N+5];int N, M, Q, sz, h[MAX_N+5], fa[MAX_N+5];int cnt, ind, id[MAX_N+5], into[MAX_N+5], outo[MAX_N+5];int anc[MAX_N+5][LOG+1], dep[MAX_N+5], rt[MAX_N+5];int val[MAX_N+5], rev[MAX_N+5], tot; map &lt;int, int&gt; mp;struct edge {int u, v, c;} E[MAX_M+5];struct node {int ls, rs, s;} tr[MAX_N*LOG];void addedge(int u, int v) {G[u].push_back(v);}bool cmp(const edge &amp;a, const edge &amp;b) {return a.c &lt; b.c;}int getf(int x) {return fa[x] == x ? x : fa[x] = getf(fa[x]);}void Kruskal() { cnt = 1, sort(E+1, E+M+1, cmp); for (int i = 1; i &lt;= N; i++) fa[i] = i; for (int i = 1; i &lt;= M &amp;&amp; cnt &lt; N; i++) { int u = getf(E[i].u), v = getf(E[i].v); if (u^v) fa[cnt+N] = cnt+N, fa[u] = fa[v] = cnt+N, addedge(cnt+N, u), addedge(cnt+N, v), h[cnt+N] = E[i].c, cnt++; }}void DFS(int u) { into[u] = ++ind, id[ind] = u; for (int i = 1; i &lt;= LOG; i++) anc[u][i] = anc[anc[u][i-1]][i-1]; for (int i = 0, v; i &lt; (int)G[u].size(); i++) anc[v = G[u][i]][0] = u, dep[v] = dep[u]+1, DFS(v); outo[u] = ind;}void modify(int v, int o, int s, int t, int p) { tr[v] = tr[o]; if (s == t) {tr[v].s++; return;} if (p &lt;= mid) modify(tr[v].ls = ++sz, tr[o].ls, s, mid, p); if (p &gt;= mid+1) modify(tr[v].rs = ++sz, tr[o].rs, mid+1, t, p); tr[v].s = tr[tr[v].ls].s+tr[tr[v].rs].s;}int query(int v1, int v2, int s, int t, int k) { if (s == t) return s; int rsz = tr[tr[v2].rs].s-tr[tr[v1].rs].s; if (k &gt; rsz) return query(tr[v1].ls, tr[v2].ls, s, mid, k-rsz); return query(tr[v1].rs, tr[v2].rs, mid+1, t, k);}int getpos(int u, int c) { for (int i = LOG; ~i; i--) if (h[anc[u][i]] &lt;= c) u = anc[u][i]; return u;}int getans(int u, int c, int k) { u = getpos(u, c); int l = into[u]-1, r = outo[u]; if (tr[rt[r]].s-tr[rt[l]].s &lt; k) return -1; return rev[query(rt[l], rt[r], 1, N, k)];}int main() { read(N), read(M), read(Q), h[0] = INF; for (int i = 1; i &lt;= N; i++) read(h[i]); for (int i = 1; i &lt;= N; i++) val[i] = h[i]; sort(val+1, val+N+1); for (int i = 1; i &lt;= N; i++) if (i == 1 || (val[i]^val[i-1])) mp[val[i]] = ++tot, rev[tot] = val[i]; for (int i = 1; i &lt;= N; i++) h[i] = mp[h[i]]; for (int i = 1, u, v, c; i &lt;= M; i++) read(u), read(v), read(c), E[i] = (edge){u, v, c}; Kruskal(), DFS(getf(1)); for (int i = 1, p; i &lt; N+N; i++) if ((p = id[i]) &gt; N) rt[i] = rt[i-1]; else modify(rt[i] = ++sz, rt[i-1], 1, N, h[p]); for (int i = 1, lst = -1; i &lt;= Q; i++) { int u, c, k; read(u), read(c), read(k); if (~lst) u ^= lst, c ^= lst, k ^= lst; printf("%d\n", lst = getans(u, c, k)); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>ONTAK</tag>
        <tag>Kruskal重构树</tag>
        <tag>DFS序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3545【ONTAK2010】Peaks]]></title>
    <url>%2FBZOJ3545%E3%80%90ONTAK2010%E3%80%91Peaks%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[Problem【ONTAK2010】Peaks Description在 有 座山峰，每座山峰有他的高度 。有些山峰之间有双向道路相连，共 条路径，每条路径有一个困难值，这个值越大表示越难走。现在有 组询问，每组询问询问从点 开始只经过困难值小于等于 的路径所能到达的山峰中第 高的山峰，如果无解输出 。 Input第一行三个数 。第二行 个数，第 个数为 。接下来 行，每行 个数 ，表示从 到 有一条困难值为 的双向路径。接下来 行，每行三个数 ，表示一组询问。 Output对于每组询问，输出一个整数表示答案。 Sample Input123456789101112131415161710 11 41 2 3 4 5 6 7 8 9 101 4 42 5 39 8 27 8 107 1 46 7 16 4 82 1 510 8 103 4 73 4 61 5 21 5 61 5 88 9 2 Sample Output123461-18 HINT ， ， SourceBy Sbullet 标签：并查集 线段树合并 Solution离线询问，按 从小到大排序，发现是裸的线段树合并。将 条边按照边权从小到大排序，按 从小到大处理询问，每次只需要加边而不需要删边。这时就和BZOJ2733【HNOI2012】永无乡一样了。用并查集维护联通关系，每个连通块内用权值线段树维护。若某条边使得两个块不联通的块联通，则合并连个块的线段树，查询则直接在块内查询即可。 其实可以在线做，详见BZOJ3551【ONTAK2010】Peaks加强版。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define MAX_M 500000#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int N, M, Q, sz, h[MAX_N+5];int fa[MAX_N+5], rt[MAX_N+5], ans[MAX_M+5];int val[MAX_N+5], rev[MAX_N+5], tot; map &lt;int, int&gt; mp;struct edge {int u, v, c;} E[MAX_M+5];struct node {int ls, rs, s;} tr[MAX_N*50];struct quest {int id, u, c, k;} q[MAX_M+5];bool cmpe(const edge &amp;a, const edge &amp;b) {return a.c &lt; b.c;}bool cmpq(const quest &amp;a, const quest &amp;b) {return a.c &lt; b.c;}int getf(int x) {return fa[x] == x ? x : fa[x] = getf(fa[x]);}void modify(int &amp;v, int s, int t, int p) { if (!v) v = ++sz; if (s == t) {tr[v].s++; return;} if (p &lt;= mid) modify(tr[v].ls, s, mid, p); if (p &gt;= mid+1) modify(tr[v].rs, mid+1, t, p); tr[v].s = tr[tr[v].ls].s+tr[tr[v].rs].s;}int query(int v, int s, int t, int k) { if (s == t) return s; int rsz = tr[tr[v].rs].s; if (rsz &lt; k) return query(tr[v].ls, s, mid, k-rsz); return query(tr[v].rs, mid+1, t, k);}int merge(int x, int y) { if (!x) return y; if (!y) return x; tr[x].s = tr[x].s+tr[y].s; tr[x].ls = merge(tr[x].ls, tr[y].ls); tr[x].rs = merge(tr[x].rs, tr[y].rs); return x;}int main() { read(N), read(M), read(Q); for (int i = 1; i &lt;= N; i++) fa[i] = i; for (int i = 1; i &lt;= N; i++) read(h[i]); for (int i = 1; i &lt;= N; i++) val[i] = h[i]; sort(val+1, val+N+1); for (int i = 1; i &lt;= N; i++) if (i == 1 || (val[i]^val[i-1])) mp[val[i]] = ++tot, rev[tot] = val[i]; for (int i = 1; i &lt;= N; i++) h[i] = mp[h[i]]; for (int i = 1; i &lt;= N; i++) modify(rt[i], 1, N, h[i]); for (int i = 1, u, v, c; i &lt;= M; i++) read(u), read(v), read(c), E[i] = (edge){u, v, c}; for (int i = 1, u, c, k; i &lt;= Q; i++) read(u), read(c), read(k), q[i] = (quest){i, u, c, k}; sort(E+1, E+M+1, cmpe), sort(q+1, q+Q+1, cmpq); for (int i = 1, j = 1, lft = N-1; i &lt;= Q; i++) { for (int u, v; lft &amp;&amp; j &lt;= M &amp;&amp; E[j].c &lt;= q[i].c; j++) if ((u = getf(E[j].u)) ^ (v = getf(E[j].v))) fa[v] = u, rt[u] = merge(rt[u], rt[v]), lft--; int v = rt[getf(q[i].u)]; if (tr[v].s &lt; q[i].k) ans[q[i].id] = -1; else ans[q[i].id] = rev[query(v, 1, N, q[i].k)]; } for (int i = 1; i &lt;= Q; i++) printf("%d\n", ans[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>ONTAK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ300【CTSC2017】吉夫特]]></title>
    <url>%2FUOJ300%E3%80%90CTSC2017%E3%80%91%E5%90%89%E5%A4%AB%E7%89%B9%20%E5%AD%90%E9%9B%86DP%2F</url>
    <content type="text"><![CDATA[Problem【CTSC2017】吉夫特时间限制： 空间限制： 简单的题目，既是礼物，也是毒药。 君 设计了一道简单的题目，准备作为 送给大家。输入一个长度为 的数列 问有多少个长度大于等于 2 的不上升的子序列 满足 输出这个个数对 取模的结果。 输入格式第一行一个整数 。接下来 行，每行一个整数，这 行中的第 行，表示 。 输出格式一行一个整数表示答案。 样例输入输出样例一Input12345415731 Output111 样例二至样例九见样例数据下载。 限制与约定对于前 的测试点， ；对于前 的测试点， ；对于前 的测试点， ；对于前 的测试点， ；对于前 的测试点， ；对于 的测试点， 。所有的 互不相同，也就是说不存在 同时满足 和 。 下载样例数据下载 标签：子集DP Solution由 定理可以推得 当且仅当 ，于是原题转为需要使 ，即 是 的子集。显然有 ：令 表示在 后面接若干个 满足条件的序列总数，那么对于 值是当前 的子集的所有位置 ，均有 。直接做子集 即可。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;#define MAX_A 233333#define P 1000000007using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, s, f[MAX_A+5];int main() { read(n); for (int i = 1, x, t; i &lt;= n; i++) { read(x), t = (f[x]+1)%P, (s += t) %= P; for (int y = x; y; y = (y-1)&amp;x) (f[y] += t) %= P; } return printf("%d\n", s-n), 0;}]]></content>
      <tags>
        <tag>DP</tag>
        <tag>计数</tag>
        <tag>CTSC</tag>
        <tag>子集DP</tag>
        <tag>UOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3996【TJOI2015】线性代数]]></title>
    <url>%2FBZOJ3996%E3%80%90TJOI2015%E3%80%91%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%20%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[Problem【TJOI2015】线性代数 Description给出一个 的矩阵 和一个 的矩阵 。求出一个 的 矩阵 ，使得 最大，输出最大的 值。 Input第一行输入一个整数 。接下来 行输入 矩阵，第 行第 个数字代表 .接下来一行输入 个整数，代表矩阵 。矩阵 和矩阵 中每个数字都是不超过 的非负整数。 Output输出最大的 。 Sample Input1234531 2 13 1 01 2 32 3 7 Sample Output12 Hint 标签：网络流 最大权闭合子图 Solution先化简一下 ，用和式表示： 由于 是 矩阵，可以将其看作有 个物品，选择取或不去，第 给物品取有 的代价，第 个和第 个同时取会有 的贡献。要求使总贡献 最大。 对于每个物体建一个点，任意两个物体的组合建一个点。对于组合 ，连接其代表的点和第 个物体的点与第 个物体的点。对于物体的点，权值设为 ，对于组合的点，权值设为 。这样选择一个组合的点，必须将其连向的两个物体的点也选择，即变为最大权闭合子图模型。 建模： 对每个物体 建一个点 ，连接 流量 对每个组合 建一个点 ，连接 流量 对于每个组合 ，连边 流量 ，连边 流量 跑最大流求最小割，答案为 最 小 割 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define MAX_N 300000#define MAX_M 2000000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, s, t, cnt, tot;int d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5];void init() {s = 0, t = n*n+n+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}int main() { read(n), init(); for (int i = 1; i &lt;= n; i++) for (int j = 1, b; j &lt;= n; j++) read(b), tot += b, addedge(s, (i-1)*n+j, b); for (int i = 1, c; i &lt;= n; i++) read(c), addedge(n*n+i, t, c); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) addedge((i-1)*n+j, n*n+i, INF), addedge((i-1)*n+j, n*n+j, INF); return printf("%d\n", tot-Dinic()), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3747【POI2015】Kinoman]]></title>
    <url>%2FBZOJ3747%E3%80%90POI2015%E3%80%91Kinoman%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【POI2015】Kinoman Description共有 部电影，编号为 ，第 部电影的好看值为 。在 天之中（从 编号）每天会放映一部电影，第 天放映的是第 部。你可以选择 ，并观看第 天内所有的电影。如果同一部电影你观看多于一次，你会感到无聊，于是无法获得这部电影的好看值。你希望最大化观看且仅观看过一次的电影的好看值的总和。 Input第一行两个整数 。第二行包含 个整数 。第三行包含 个整数 。 Output输出观看且仅观看过一次的电影的好看值的总和的最大值。 Sample Input1239 42 3 1 1 4 1 2 4 15 3 6 6 Sample Output115 Explanation观看第 天内放映的电影，其中看且仅看过一次的电影的编号为 。 Source鸣谢Jcvb 标签：线段树 Solution暴力枚举左端点，考虑用线段树动态维护此时每个点作为右端点的答案的最大值。先对每天预处理后面最早哪一天会放同样的电影，若后面不会再放，则令其为 。这个数组称为 。每种电影最先放映的时间称为 （这是由于从后往前预处理，最先放映的在最后扫到）。开始时，以 作为左端点，对于电影 ，右端点在 时 对答案有贡献，于是区间 整体加 。此后每次将左端点向后移一天。设当前为第 天，则移到 后，区间 不会再有电影 的贡献，于是区间 整体减 。而区间 则会有电影 的贡献，于是区间 区间加 。每次移动左端点，并在线段树上修改，到下一个左端点后得到一个答案并和最大值打擂即可。时间复杂度 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000#define mid ((s+t)&gt;&gt;1)using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, f[MAX_N+5], w[MAX_N+5];int pos[MAX_N+5], nxt[MAX_N+5], cnt[MAX_N+5];lnt tr[MAX_N&lt;&lt;2], tag[MAX_N&lt;&lt;2], ans;void update(int v) {tr[v] = max(tr[v&lt;&lt;1], tr[v&lt;&lt;1|1]);}void downtag(int v) { if (!tag[v]) return; tr[v&lt;&lt;1] += tag[v], tr[v&lt;&lt;1|1] += tag[v]; tag[v&lt;&lt;1] += tag[v], tag[v&lt;&lt;1|1] += tag[v]; tag[v] = 0;}void modify(int v, int s, int t, int l, int r, lnt x) { if (s &gt;= l &amp;&amp; t &lt;= r) {tr[v] += x, tag[v] += x; return;} downtag(v); if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, x); update(v);}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(f[i]); for (int i = 1; i &lt;= m; i++) read(w[i]); for (int i = n; i; i--) nxt[i] = pos[f[i]], pos[f[i]] = i; for (int i = 1; i &lt;= m; i++) if (pos[i]) { if (!nxt[pos[i]]) modify(1, 1, n, pos[i], n, w[i]); else modify(1, 1, n, pos[i], nxt[pos[i]]-1, w[i]); } for (int i = 1; i &lt;= n; i++) { ans = max(ans, tr[1]); if (nxt[i]) { modify(1, 1, n, i, nxt[i]-1, -w[f[i]]); if (!nxt[nxt[i]]) modify(1, 1, n, nxt[i], n, w[f[i]]); else modify(1, 1, n, nxt[i], nxt[nxt[i]]-1, w[f[i]]); } else modify(1, 1, n, i, n, -w[f[i]]); } return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3231【SDOI2008】递归数列]]></title>
    <url>%2FBZOJ3231%E3%80%90SDOI2008%E3%80%91%E9%80%92%E5%BD%92%E6%95%B0%E5%88%97%20%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2008】递归数列 Description一个由自然数组成的数列按下式定义： 对于 ： 对于 ： 其中 和 是给定的自然数。写一个程序，给定自然数 , 计算 , 并输出它除以给定自然数 的余数的值。 Input输入由四行组成。第一行是一个自然数 。第二行包含 个自然数 。第三行包含 个自然数 。第四行包含三个自然数 。 Output输出一行一个正整数，表示 的值。 Sample Input123421 11 12 10 1000003 Sample Output1142 HINT对于 的测试数据： ， 标签：矩阵快速幂 Solution简单矩阵快速幂优化递推。 将答案拆成两个前缀和，即 。我们需要快速计算 的值，显然可以构造递推矩阵。 特判 暴力，其余用转移矩阵的 次方乘由 和 组成的矩阵即可得到 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MAX_N 20using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n; lnt l, r, b[MAX_N+5], c[MAX_N+5], s1, s2, P;struct Matrix { int n; lnt ele[MAX_N][MAX_N]; Matrix (int _n) {n = _n, memset(ele, 0, sizeof ele);} inline Matrix operator * (const Matrix &amp;x) const { Matrix ret(n); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; n; k++) ret.ele[i][j] = (ret.ele[i][j]+ele[i][k]*x.ele[k][j]%P)%P; return ret; }} ;Matrix Power(Matrix mat, lnt k) { Matrix ret(mat.n); for (int i = 0; i &lt; ret.n; i++) ret.ele[i][i] = 1; for (; k; k &gt;&gt;= 1, mat = mat*mat) if (k&amp;1) ret = ret*mat; return ret;}int main() { read(n); Matrix p(n+1), q(n+1); for (int i = 1; i &lt;= n; i++) read(b[i]); for (int i = 1; i &lt;= n; i++) read(c[i]); read(l), read(r), read(P), l--, p.ele[0][0] = 1; for (int i = 1; i &lt; n; i++) p.ele[i+1][i] = 1; for (int i = 1; i &lt;= n; i++) p.ele[0][i] = c[i]%P; for (int i = 1; i &lt;= n; i++) p.ele[1][i] = c[i]%P; for (int i = 1; i &lt;= n; i++) (q.ele[0][0] += b[i]) %= P; for (int i = 1; i &lt;= n; i++) (q.ele[n-i+1][0] = b[i]) %= P; if (l &lt;= n) for (int i = 1; i &lt;= l; i++) (s1 += b[i]) %= P; else s1 = (Power(p, l-n)*q).ele[0][0]; if (r &lt;= n) for (int i = 1; i &lt;= r; i++) (s2 += b[i]) %= P; else s2 = (Power(p, r-n)*q).ele[0][0]; return printf("%lld\n", (s2-s1+P)%P), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3876【JSOI2014】支线剧情]]></title>
    <url>%2FBZOJ3876%E3%80%90JSOI2014%E3%80%91%E6%94%AF%E7%BA%BF%E5%89%A7%E6%83%85%20%E5%B8%A6%E4%B8%8B%E7%95%8C%E7%9A%84%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【JSOI2014】支线剧情 Background宅男 非常喜欢玩 游戏，比如仙剑，轩辕剑等等。不过 喜欢的并不是战斗场景，而是类似电视剧一般的充满恩怨情仇的剧情。这些游戏往往都有很多的支线剧情，现在 想花费最少的时间看完所有的支线剧情。 Description 现在所玩的 游戏中，一共有 个剧情点，由 到 编号，第 个剧情点可以根据 的不同的选择，而经过不同的支线剧情，前往 种不同的新的剧情点。当然如果为 ，则说明 号剧情点是游戏的一个结局了。 观看一个支线剧情需要一定的时间。 一开始处在 号剧情点，也就是游戏的开始。显然任何一个剧情点都是从 号剧情点可达的。此外，随着游戏的进行，剧情是不可逆的。所以游戏保证从任意剧情点出发，都不能再回到这个剧情点。由于 过度使用修改器，导致游戏的“存档”和“读档”功能损坏了，所以 要想回到之前的剧情点，唯一的方法就是退出当前游戏，并开始新的游戏，也就是回到 号剧情点。 可以在任何时刻退出游戏并重新开始。不断开始新的游戏重复观看已经看过的剧情是很痛苦， 希望花费最少的时间，看完所有不同的支线剧情。 Input输入一行包含一个正整数 。接下来 行，第 行为 号剧情点的信息：第一个整数为 ，接下来 个整数对， 和 ，表示从剧情点 可以前往剧情点 ，并且观看这段支线剧情需要花费 的时间。 Output输出一行包含一个整数，表示 看完所有支线剧情所需要的最少时间。 Sample Input123456762 2 1 3 22 4 3 5 42 5 5 6 6000 Sample Output124 Explanation 需要重新开始 次游戏，加上一开始的一次游戏， 次游戏的进程是 , , 和 。 Hint 的数据满足 , , , 标签：带下界的费用流 Solution无源无汇带下界最小费用可行流。 将原图直接放入网络流，其中每条边流量下界为 ，上界为 ；每个点向 连一条流量下界为 ，上界为 ，费用为 的边。这样就转化为求此图的最小费用可行流。将原图中每条边拆一个流量为 费用不变的边出来，这样若这条边满载后，只需要流量守恒即可。对于每个点，令入度为 ，出度为 。则经过其的流量一定是 。如此拆出来的流量为 的边可以以出入度的限制的形式出现，而不必真正建出这些边使其满载。而对于入度和出度不等的边，我们新建源汇，从源点补流或分流到汇点即可。 建图： 对于原图中每条边 长度 ，连边 流量 费用 对于非 号点的点 ，连边 流量 费用 对于点 ，计算其入度 和出度 若 ，连边 流量 费用 若 ，连边 流量 费用 跑最小费用最大流即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define MAX_N 300#define MAX_M 20000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, s, t, tot, deg[MAX_N+5];int cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node {int v, c, w, nxt;} E[MAX_M+5];void init() {s = 0, t = n+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += flow*d[t]; return true;}int main() { read(n), init(); for (int u = 1, k; u &lt;= n; u++) { read(k); for (int i = 0, v, c; i &lt; k; i++) read(v), read(c), addedge(u, v, INF, c), deg[u]--, deg[v]++, tot += c; if (u^1) addedge(u, 1, INF, 0); } for (int i = 1; i &lt;= n; i++) if (deg[i] &gt; 0) addedge(s, i, deg[i], 0); else if (deg[i] &lt; 0) addedge(i, t, -deg[i], 0); while (SPFA()) ; return printf("%d\n", mic+tot), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2821 作诗]]></title>
    <url>%2FBZOJ2821%20%E4%BD%9C%E8%AF%97%20%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Problem作诗 Description神犇 虐完 之后给傻X 出了一题： 是T国的公主，平时的一大爱好是作诗。由于时间紧迫， 作完诗之后还要虐 ，于是 找来一篇长度为 的文章，阅读 次，每次只阅读其中连续的一段 ，从这一段中选出一些汉字构成诗。因为 喜欢对偶，所以 规定最后选出的每个汉字都必须在 里出现了正偶数次。而且 认为选出的汉字的种类数（两个一样的汉字称为同一种）越多越好（为了拿到更多的素材！）。于是 请 安排选法。 这种傻X当然不会了，于是向你请教……问题简述： 个数， 组询问，每次问 中有多少个数出现正偶数次。 Input输入第一行三个整数 ，表示文章字数、汉字的种类数、要选择 次。第二行有 个整数，每个数 在 间，代表一个编码为 的汉字。接下来 行每行两个整数 和 ，设上一个询问的答案为 (第一个询问时 )，令 , ，若 ，交换 和 ，则本次询问为 。 Output输出共 行，每行一个整数，第 个数表示 第 次能选出的汉字的最多种类数。 Sample Input12345675 3 51 2 2 3 10 41 22 22 33 5 Sample Output1234520001 Hint对于 的数据， SourceBy lydrainbowcat 标签：分块 Solution由于”出现次数为偶数“不好维护，需要分块。将序列分为 个块，预处理出前 块内每个数的出现次数，以及两块间的有多少个数出现偶数次。对于每个询问，将左右端点所在块中间的块有多少个数出现偶数次作为基础答案，然后暴力枚举块外的数，结合预处理出的“前 块内每个数的出现次数”判断其对答案的影响即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;const int MAGIC = 316;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, c, m, a[MAX_N+5], buk[MAX_N+5];int num[MAGIC+5][MAX_N+5], cnt[MAGIC+5][MAGIC+5];int block(int p) {return p/MAGIC+1;}int L(int num) {return max((num-1)*MAGIC, 1);}int R(int num) {return min(num*MAGIC-1, n);}int main() { read(n), read(c), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]), num[block(i)][a[i]]++; for (int i = 2; i &lt;= block(n); i++) for (int j = 1; j &lt;= c; j++) num[i][j] += num[i-1][j]; for (int i = 1, t; i &lt;= block(n); i++) { memset(buk, 0, sizeof buk), t = 0; for (int j = i; j &lt;= block(n); cnt[i][j++] = t) for (int p = L(j); p &lt;= R(j); buk[a[p++]]++) if (buk[a[p]]&amp;1) t++; else if (buk[a[p]]) t--; } memset(buk, 0, sizeof buk); for (int l, r, ans = 0; m; m--) { read(l), read(r); l = (l+ans)%n+1, r = (r+ans)%n+1; if (l &gt; r) swap(l, r); ans = 0; if (block(r)-block(l) &lt;= 1) { for (int i = l; i &lt;= r; buk[a[i++]]++) if (buk[a[i]]&amp;1) ans++; else if (buk[a[i]]) ans--; for (int i = l; i &lt;= r; i++) buk[a[i]]--; } else { ans = cnt[block(l)+1][block(r)-1]; for (int i = l; i &lt;= R(block(l)); i++) buk[a[i]]++; for (int i = r; i &gt;= L(block(r)); i--) buk[a[i]]++; for (int i = l; i &lt;= R(block(l)); buk[a[i++]] = 0) if (buk[a[i]]) { int t = num[block(r)-1][a[i]]-num[block(l)][a[i]]; if (!t) ans += ((buk[a[i]]&amp;1) == 0); else if ((t&amp;1) &amp;&amp; (buk[a[i]]&amp;1)) ans++; else if (!(t&amp;1) &amp;&amp; (buk[a[i]]&amp;1)) ans--; } for (int i = r; i &gt;= L(block(r)); buk[a[i--]] = 0) if (buk[a[i]]) { int t = num[block(r)-1][a[i]]-num[block(l)][a[i]]; if (!t) ans += ((buk[a[i]]&amp;1) == 0); else if ((t&amp;1) &amp;&amp; (buk[a[i]]&amp;1)) ans++; else if (!(t&amp;1) &amp;&amp; (buk[a[i]]&amp;1)) ans--; } } printf("%d\n", ans); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2095【POI2010】Bridges]]></title>
    <url>%2FBZOJ2095%E3%80%90POI2010%E3%80%91Bridges%20%E4%BA%8C%E5%88%86%2B%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【POI2010】Bridges Description 为了减肥，来到了瘦海。这是一个巨大的海，海中有 个小岛，小岛之间有 座桥连接，两个小岛之间不会有两座桥，并且从一个小岛可以到另外任意一个小岛。现在 想骑单车从小岛 出发，骑过每一座桥，到达每一个小岛，然后回到小岛 。霸中同学为了让 减肥成功，召唤了大风，由于是海上风变得十分大，经过每一座桥都有不可避免的风阻碍 ， 十分 ，于是用泡芙贿赂了你，希望你能帮他找出一条承受的最大风力最小的路线。 Input第一行为两个用空格隔开的整数 。接下来 行，每行为由空格隔开的 个整数 ，第 行表示第 座桥连接小岛 和 ，从 到 承受的风力为 ，从 到 承受的风力为 。 Output如果无法完成减肥计划，则输出NIE，否则第一行输出最大风力的最小值。 Sample Input123454 41 2 2 42 3 3 43 4 4 44 1 5 4 Sample Output14 Explanation HINT , 对于每座桥，保证 , , 标签：二分答案 网络流 欧拉回路 Solution二分答案+网络流判定混合图欧拉回路 二分答案，找出符合条件的边集，原问题变为判断混合图中是否存在欧拉回路。用经典的网络流判定混合图欧拉回路的建模方式： 给所有无向边随机定向，若 的无向边定向为 ，则连边 流量为 按照定向后的图计算每个点的入度 和出度 对于每个点 ，若 ，则连边 流量为 ；若 ，则连边 流量为 建图后跑一遍 ，若满载，则存在欧拉回路。 大致原理：欧拉回路的充要条件是存在一种定向使得每个点的入度等于出度。随机定向后，连接“ ”的边，这样走这条边可以使得 的出度 ， 的入度 ，达到边反向的效果。而一个点入度每 ，出度均要 ，所以分正负从 或向 连长为 的边，这样满载时这个点一定有 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MAX_M 10000#define mid ((l+r)&gt;&gt;1)#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, into[MAX_N+5], outo[MAX_N+5];int s, t, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5];struct edge {int u, v, x, y;} e[MAX_M+5];void init() {s = 0, t = n+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}bool chk(int tans) { int tot = 0; init(); for (int i = 1; i &lt;= m; i++) if (e[i].x &gt; tans) return false; memset(into, 0, sizeof into), memset(outo, 0, sizeof outo); for (int i = 1; i &lt;= m; i++) into[e[i].v]++, outo[e[i].u]++; for (int i = 1; i &lt;= m; i++) if (e[i].y &lt;= tans) addedge(e[i].v, e[i].u, 1); for (int i = 1; i &lt;= n; i++) if (into[i]%2 != outo[i]%2) return false; for (int i = 1; i &lt;= n; i++) tot += max(0, (outo[i]-into[i])&gt;&gt;1); for (int i = 1; i &lt;= n; i++) if (into[i] &gt; outo[i]) addedge(s, i, (into[i]-outo[i])&gt;&gt;1); else if (into[i] &lt; outo[i]) addedge(i, t, (outo[i]-into[i])&gt;&gt;1); return Dinic() == tot;}void bi_search(int l, int r) { int ans = 0; while (l &lt;= r) if (!chk(mid)) l = mid+1; else ans = mid, r = mid-1; if (!ans) puts("NIE"); else printf("%d\n", ans);}int main() { read(n), read(m); for (int i = 1, u, v, x, y; i &lt;= m; i++) { read(u), read(v), read(x), read(y); if (x &lt; y) e[i] = (edge){u, v, x, y}; else e[i] = (edge){v, u, y, x}; } return bi_search(1, 1000), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
        <tag>POI</tag>
        <tag>欧拉回路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3532【SDOI2014】LIS]]></title>
    <url>%2FBZOJ3532%E3%80%90SDOI2014%E3%80%91Lis%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2014】LIS Description给定序列 ，序列中的每一项 有删除代价 和附加属性 。请删除若干项，使得 的最长上升子序列长度减少至少 ，且付出的代价之和最小，并输出方案。如果有多种方案，请输出将删去项的附加属性排序之后，字典序最小的一种。 Input输入包含多组数据。输入的第一行包含整数 ，表示数据组数。接下来 行描述每组数据。每组数据的第一行包含一个整数 ，表示 的项数。接下来三行，每行 个整数 ， ， 。 Output对每组数据，输出两行。第一行包含两个整数 ，依次表示删去项的代价和与数量；接下来一行 个整数，表示删去项在 中的的位置，按升序输出。 Sample Input12345163 4 4 2 2 32 1 1 1 1 26 5 4 3 2 1 Sample Output124 32 3 6 Explanation删去 , , 等都是合法的方案，但 对应的 值的字典序最小。 HINT ， 两两不同 标签：网络流 退流 Solution最小割+网络流退流 首先做一遍 求出 数组，即每个前缀中的 长度，令最长的 长度为 。 若不考虑字典序最小的限制，只要求最小代价，则是一个最小割模型。将每个位置 拆成 和 两个点，分别代表入点和出点。连接 流量 ，割这条边代表删除 。对于所有 ，连接 流量 ，这样每个长度为 的序列都连成一条链，两位置间不能隔开，只能删除其中的某个数，即每个位置入点到出点的边。这样跑最大流得到最小割即为最小代价。 考虑字典序最小的限制。先用上面的建图跑出一个可行解，然后按 从小往大看能否用 小的数换当前可行解中 大的数，显然每次还完之后要调整当前可行解。对于当前枚举到的位置 ，若其不在当前可行解中，则以 为源点，原源点 为汇点，跑一遍网络流，再以 为源点， 为汇点跑一遍网络流。这样可以用反向边使前面的可行流“返回”，达到调整可行解的效果。然后将 这条边删除，以后的可行解中将不再会删掉这个点。这样贪心调整即可得到最终答案。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define MAX_N 1500#define MAX_M 2000000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, A[MAX_N+5], B[MAX_N+5], C[MAX_N+5];int f[MAX_N+5], ord[MAX_N+5], ans[MAX_N+5];int S, T, s, t, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];bool cmp (const int &amp;x, const int &amp;y) {return C[x] &lt; C[y];}struct node {int v, c, nxt;} E[MAX_M+5];void init() {S = 0, T = 2*n+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = S; i &lt;= T; i++) cr[i] = pr[i];}void rec() {for (int i = S; i &lt;= T; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}int main() { int CASE; read(CASE); for (; CASE; puts(""), CASE--) { read(n), init(); int mx = 0, tot = 0; for (int i = 1; i &lt;= n; i++) read(A[i]); for (int i = 1; i &lt;= n; i++) read(B[i]); for (int i = 1; i &lt;= n; i++) read(C[i]); for (int i = 1; i &lt;= n; i++) ord[i] = i; for (int i = 1; i &lt;= n; i++) f[i] = 1; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt; i; mx = max(mx, f[j++])) if (A[j] &lt; A[i]) f[i] = max(f[i], f[j]+1); for (int i = 1; i &lt;= n; i++) addedge(i, i+n, B[i]); for (int i = 1; i &lt;= n; i++) if (f[i] == 1) addedge(S, i, INF); else if (f[i] == mx) addedge(i+n, T, INF); for (int i = 1; i &lt;= n; i++) for (int j = i+1; j &lt;= n; j++) if (A[i] &lt; A[j] &amp;&amp; f[j] == f[i]+1) addedge(i+n, j, INF); s = S, t = T, printf("%d ", Dinic()); sort(ord+1, ord+n+1, cmp), s = ord[1], t = s+n; for (int i = 1; i &lt;= n; s = ord[++i], t = s+n) if (!BFS()) ans[++tot] = ord[i], s = ord[i], t = S, Dinic(), s = T, t = ord[i]+n, Dinic(), E[ord[i]*2-2].c = E[ord[i]*2-1].c = 0; sort(ans+1, ans+tot+1), printf("%d\n", tot); for (int i = 1; i &lt;= tot; i++) printf("%d ", ans[i]); } return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4657 Tower]]></title>
    <url>%2FBZOJ4657%20Tower%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[ProblemTower Description 最近在玩一款很好玩的游戏，游戏规则是这样的：有一个 的地图，地图上的每一个位置要么是空地，要么是炮塔，要么是一些 狗， 需要操纵炮塔攻击 狗们。攻击方法是：对于每个炮塔，游戏系统已经给出它可以瞄准的方向（上下左右其中一个）， 需要选择它的攻击位置，每一个炮塔只能够攻击一个位置，炮塔只能够向着它的瞄准方向上的某个位置发动攻击，当然炮塔也可以不进行攻击。炮塔威力强大，它可以且仅可以消灭目标位置上所有的 狗。出于安全考虑，游戏系统已经保证不存在一个炮塔能够瞄准另外一个炮塔，即对于任意一个炮塔，它所有可能的攻击位置上不存在另外一个炮塔。而且，如果把炮塔的起点和终点称为炮弹的运行轨迹，那么系统不允许两条轨迹相交（包括起点和终点）。现在，选定目标位置以后，每一个炮塔同时开炮，你要告诉 ，他最多可以干掉多少 狗。 Input第一行两个正整数 ，表示地图的规模。接下来礼行，每行 个整数， 表示空地， 分别表示瞄准上下左右的炮塔，若为正整数 ，则表示该位置有 个 狗。 Output一个正整数，表示 最多可以干掉几个 狗 Sample Input12343 20 9-4 30 -1 Sample Output19 HINT 每个位置的 狗数量不超过 个保证不存在任意一个炮塔能够瞄准另外一个炮塔 标签：最小割 Solution经典最小割建模之一。 网格图可以拆成两个图，即所有行组成的图和所有列组成的图。这样原图中每个点变成两个，在行图上的称为行点，在列图上的称为列点。对于点 ，不妨设其行点为 ，列点为 。 图上的向左或向右的炮将图分为若干横向的链，每个炮可以打到的区域都是一条链。在这个区域中，我们找出贡献最大的点 ，作为基础贡献，将此链上不所有同于 的点 的贡献 变为 。对于每条链，我们从左往右或从右往左串联，连边 流量为 点的新贡献，这样割掉这条边表示用这条链所对应的炮打 的位置。如此，链被分为两段，从链首到 为一段，从 到链尾为另一段，符合割的定义。对于所有向上或向下的炮也如法炮制，只不过前者在行图上连，后者在列图上连。每个点的行点和列点间连流量为 的边，代表无法割断。 重新整理一下建图：对于点 ，若 或 连边 流量为 对于其可以打到的链上的点 ，连边 流量为 ，其中 为此链上的最大 值 或 连边 流量为 对于其可以打到的链上的点 ，连边 流量为 ，其中 为此链上的最大 值 ，连边 流量为 建模后跑最大流求最小割，答案为 每 条 链 的 最 大 值 之 和 最 小 割 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#define MAX_N 5000#define MAX_M 600000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, s, t, cnt, tot, mp[55][55];int d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5];int pos(int x, int y, int id) {return n*m*(id-1)+(x-1)*m+y;}void init() {s = 0, t = n*m*2+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}int main() { read(n), read(m), init(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) read(mp[i][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1, mx = 0; j &lt;= m; j++, tot += mx, mx = 0) if (mp[i][j] == -1) { addedge(s, pos(i, j, 1), INF); for (int k = i; k &gt;= 1; k--) mx = max(mx, max(mp[k][j], 0)); for (int k = i; k &gt; 1; k--) addedge(pos(k, j, 1), pos(k-1, j, 1), mx-max(mp[k][j], 0)); } else if (mp[i][j] == -2) { addedge(s, pos(i, j, 1), INF); for (int k = i; k &lt;= n; k++) mx = max(mx, max(mp[k][j], 0)); for (int k = i; k &lt; n; k++) addedge(pos(k, j, 1), pos(k+1, j, 1), mx-max(mp[k][j], 0)); } else if (mp[i][j] == -3) { addedge(pos(i, j, 2), t, INF); for (int k = j; k &gt;= 1; k--) mx = max(mx, max(mp[i][k], 0)); for (int k = j; k &gt; 1; k--) addedge(pos(i, k-1, 2), pos(i, k, 2), mx-max(mp[i][k], 0)); } else if (mp[i][j] == -4) { addedge(pos(i, j, 2), t, INF); for (int k = j; k &lt;= m; k++) mx = max(mx, max(mp[i][k], 0)); for (int k = j; k &lt; m; k++) addedge(pos(i, k+1, 2), pos(i, k, 2), mx-max(mp[i][k], 0)); } else addedge(pos(i, j, 1), pos(i, j, 2), INF); return printf("%d\n", tot-Dinic()), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4289【PA2012】Tax]]></title>
    <url>%2FBZOJ4289%E3%80%90PA2012%E3%80%91Tax%20%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Problem【PA2012】Tax Description给出一个 个点 条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值，求从起点 到点 的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权。 Input第一行两个整数 ，表示图的点数和边数。接下来 行，每行三个整数 ，表示 间存在一条边权为 的无向边。 Output输出一行一个整数，表示从 到 的最小代价。 Sample Input1234564 51 2 51 3 22 3 12 4 43 4 8 Sample Output112 HINT ， 标签：最短路 Solution经典拆边建模。 将每条有向边作为一个点，若存在边 ， ，则连边 。跑最短路即可。但这样图太稠密，会 。 考虑像网络流一样差分建图。对于点 ，记录其入边 和出边 ，并将 按边权排序。对于每对互为反向边的边，从入边向出边连边权为原边权的边。对于排好序的 ，按顺序从小到大，每条边向其下一条边连一条长为原边权差的点。这样相当于每个点的出边集连成了一条链，选择在链的哪个部分离开即可确定在原图上走哪条出边。 保险起见用 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define MAX_N 400000#define mp make_pair#define fir first#define sec secondusing namespace std;typedef long long lnt;typedef pair&lt;lnt,int&gt; pli;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, s, t, val[MAX_N+5];vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];vector &lt;int&gt; g[MAX_N+5], r[MAX_N+5];struct node {int u, v, c;} a[MAX_N+5];bool cmp (const node &amp;p, const node &amp;q) {return p.c &lt; q.c;}void insert(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void ins(int u, int v, int c) {g[u].push_back(v), r[u].push_back(c);}lnt Dijkstra() { lnt dis[MAX_N+5]; memset(dis, 127, sizeof dis); priority_queue &lt;pli&gt; que; que.push(mp((dis[s] = 0), s)); while (!que.empty()) { int u = que.top().sec; lnt d = que.top().fir; que.pop(); if (dis[u] != -d) continue; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (dis[u]+c &gt;= dis[v]) continue; dis[v] = dis[u]+c, que.push(mp(-dis[v], v)); } } return dis[t];}int main() { read(n), read(m), s = 1, t = m*2+2; for (int i = 1, u, v, c; i &lt;= m; i++) read(u), read(v), read(c), val[i*2] = val[i*2+1] = c, ins(u, i*2, i*2+1), ins(v, i*2+1, i*2); for (int i = 2, tot = 0; i &lt; n; i++, tot = 0) { for (int j = 0; j &lt; (int)g[i].size(); j++) a[++tot] = (node){r[i][j], g[i][j], val[g[i][j]]}; sort(a+1, a+tot+1, cmp); for (int j = 1; j &lt;= tot; j++) insert(a[j].u, a[j].v, a[j].c); for (int j = 1; j &lt; tot; j++) insert(a[j].v, a[j+1].v, a[j+1].c-a[j].c); for (int j = 1; j &lt; tot; j++) insert(a[j+1].v, a[j].v, 0); } for (int i = 0; i &lt; (int)g[1].size(); i++) insert(s, g[1][i], val[g[1][i]]); for (int i = 0; i &lt; (int)g[n].size(); i++) insert(r[n][i], t, val[g[n][i]]); return printf("%lld\n", Dijkstra()), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>PA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4869【SHOI2017】相逢是问候]]></title>
    <url>%2FBZOJ4869%E3%80%90SHOI2017%E3%80%91%E7%9B%B8%E9%80%A2%E6%98%AF%E9%97%AE%E5%80%99%20%E6%89%A9%E5%B1%95%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【SHOI2017】相逢是问候 Description 君 希望以维护一个长度为 的数组，这个数组的下标为从 到 的正整数。一共有 个操作，可以分为两种： ：表示将第 个到第 个数( )中的每一个数 替换为 ，其中 是一个常数 ：求第 个到第 个数的和，即 因为这个结果可能会很大，所以你只需要输出结果 的值即可。 Input第一行有三个整数 。接下来一行 个整数，表示a数组的初始值。接下来 行，每行三个整数，其中第一个整数表示了操作的类型。如果是 ，表示这是一个修改操作，操作的参数为 。如果是 ，表示这是一个询问操作，操作的参数为 。 Output对于每个询问操作，输出一行，包括一个整数表示答案 的值。 Sample Input1234564 4 7 21 2 3 40 1 41 2 40 1 41 1 3 Sample Output1203 HINT , , , , Source黑吉辽沪冀晋六省联考鸣谢xlk授权本OJ使用权鸣谢多名网友提供正确数据，已重测！ 标签：扩展欧拉定理 线段树 Solution数论和数据结构结合。 扩展欧拉定理： 。由于 最多 次取 后变为定值 ，所以可以暴力修改，类似区间取模的线段树，需要注意每层指数模的是 取多少次 的值。因为修改时需要计算 和快速幂，总复杂度为 。预处理 可将复杂度缩小为 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;bits/stdc++.h&gt;#define MAX_N 50000#define mid ((s+t)&gt;&gt;1)using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, p, c, k;int a[MAX_N+5]; lnt phi[MAX_N+5];lnt tr[MAX_N&lt;&lt;2]; int num[MAX_N&lt;&lt;2];int getphi(int n) { int ret = n; for (int i = 2; i*i &lt;= n; i++) if (n%i == 0) { ret = ret/i*(i-1); while (n%i == 0) n /= i; } if (n^1) ret = ret/n*(n-1); return ret;}lnt pow(lnt x, lnt k, lnt MOD) { lnt ret = 1; for (; k; k &gt;&gt;= 1, x = 1LL*x*x%MOD) if (k&amp;1) ret = 1LL*x*ret%MOD; return ret;}lnt calc(lnt x, int k) { for (int i = k; i; i--) { if (x &gt;= phi[i]) x = x%phi[i]+phi[i]; x = pow(c, x, phi[i-1]), x = x ? x : phi[i-1]; } return x;}void build(int v, int s, int t) { if (s == t) {tr[v] = a[s]%p; return;} build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t); tr[v] = (tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1])%p;}void modify(int v, int s, int t, int l, int r) { if (num[v] &gt;= k) return; if (s == t) {tr[v] = calc(a[s], ++num[v]); return;} if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r); tr[v] = (tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1])%p; num[v] = min(num[v&lt;&lt;1], num[v&lt;&lt;1|1]);}lnt query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v]; lnt ret = 0; if (l &lt;= mid) (ret += query(v&lt;&lt;1, s, mid, l, r)) %= p; if (r &gt;= mid+1) (ret += query(v&lt;&lt;1|1, mid+1, t, l, r)) %= p; return ret;}void init() { phi[0] = p; for (int i = p; i^1; ) phi[++k] = i = getphi(i); phi[++k] = 1;}int main() { read(n), read(m), read(p), read(c); for (int i = 1; i &lt;= n; i++) read(a[i]); init(), build(1, 1, n); while (m--) { int opt, l, r; read(opt), read(l), read(r); if (opt == 0) modify(1, 1, n, l, r); if (opt == 1) printf("%lld\n", query(1, 1, n, l, r)); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>扩展欧拉定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5210 最大连通子块和]]></title>
    <url>%2FBZOJ5210%20%E6%9C%80%E5%A4%A7%E8%BF%9E%E9%80%9A%E5%AD%90%E5%9D%97%E5%92%8C%20%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2B%E6%A0%91%E4%B8%8ADP%2F</url>
    <content type="text"><![CDATA[Problem最大连通子块和 Description给出一棵 个点，以 为根的有根树，点有点权。要求支持如下两种操作： ：将点 的点权改为 ：求以 为根的子树的最大连通子块和 一棵子树的最大连通子块和指该子树所有子连通块的点权和中的最大值（本题中子连通块包括空连通块，点权和为 ）。 Input第一行两个整数 , ，表示树的点数以及操作的数目。第二行 个整数，第 个整数 表示第 个点的点权。接下来的 行，每行两个整数 ，表示 和 之间有一条边相连。接下来的 行，每行输入一个操作，含义如题目所述。保证操作为 或 之一。 Output对于每个 操作输出一行一个整数，表示询问子树的最大连通子块和。 Sample Input123456789105 43 -2 0 3 -11 21 34 22 5Q 1M 4 1Q 1Q 2 Sample Output123431 HINT ，任意时刻 。 SourceCQzhangyu&amp;GXZlegend原创 标签：树链剖分 树上DP Solution经典树链剖分维护树上 。以下解法源自出题人CQzhangyu的博客和GXZlegend的博客。 首先考虑暴力 ，令 表示 子树中包含 的连通块权值和最大值，那么 。维护 表示 子树中连通块权值和最大值，则 。每次修改后重新 ，可做到 。 注意到每次修改后不是所有的 都变化。用树链剖分维护树上 ，可以每次不修改所有的 值。然而直接维护 的值不方便，因为递推式中的和式在线段树上不便于计算。于是引入 ，其中 是 的轻儿子。那么重链上的转移就变为 。这其实就是最大连续子段和的 方式，可以用线段树维护带修改最大连续子段和。于是对于每次修改，向上跳重链，在线段树上每条重链的区域内维护最大连续子段和即可。注意这里“每条重链的区域”指的是链顶到链底的距离，而非括号序列。 再考虑如何维护 。注意到 每次都直接取最值，带修改后，其实是可删除堆的形式。对每个点维护可删除堆来维护轻儿子的 值最大值，对于重儿子则在线段树上维护。在线段树上修改后 时，用每个结点的 堆顶元素更新最大子段和，即可动态维护 。 查询时，直接向上跳重链，将该重链对应区间的最大子段和取出来打擂即可。 这样修改复杂度 ，查询复杂度 ，总复杂度 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define mid ((s+t)&gt;&gt;1)using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, a[MAX_N+5]; vector &lt;int&gt; G[MAX_N+5];int ind, dep[MAX_N+5], fa[MAX_N+5], son[MAX_N+5];int sz[MAX_N+5], top[MAX_N+5], into[MAX_N+5], outo[MAX_N+5];lnt f[MAX_N+5], g[MAX_N+5], mxf[MAX_N+5];struct node { lnt s, mx, lmx, rmx; node () {s = mx = lmx = rmx = 0LL;} inline friend node operator + (const node &amp;a, const node &amp;b) { node ret; ret.s = a.s+b.s, ret.mx = max(max(a.mx, b.mx), a.rmx+b.lmx); ret.lmx = max(a.lmx, a.s+b.lmx), ret.rmx = max(b.rmx, a.rmx+b.s); return ret; }} tr[MAX_N&lt;&lt;2];struct heap { priority_queue &lt;lnt&gt; i, o; inline void push(lnt x) {i.push(x);} inline void pop(lnt x) {o.push(x);} inline lnt top() { while (!o.empty() &amp;&amp; i.top() == o.top()) i.pop(), o.pop(); return i.top(); }} h[MAX_N+5];void addedge(int u, int v) {G[u].push_back(v), G[v].push_back(u);}void DFS(int u) { sz[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v == fa[u]) continue; dep[v] = dep[u]+1, fa[v] = u, DFS(v), sz[u] += sz[v]; if (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v; }}void DFS(int u, int tp) { top[u] = tp, g[into[u] = ++ind] = a[u]; if (son[u]) DFS(son[u], tp); for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (((v = G[u][i]) ^ fa[u]) &amp;&amp; (v ^ son[u])) DFS(v, v), g[into[u]] += f[v], h[into[u]].push(mxf[v]); outo[u] = son[u] ? outo[son[u]] : ind; f[u] = max(f[son[u]]+g[into[u]], 0LL); mxf[u] = max(mxf[son[u]], max(f[u], h[into[u]].top()));}void build(int v, int s, int t) { if (s == t) { tr[v].s = g[s], tr[v].mx = max(g[s], h[s].top()); tr[v].lmx = tr[v].rmx = max(g[s], 0LL); return; } build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t); tr[v] = tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1];}void modify(int v, int s, int t, int p) { if (s == t) { tr[v].s = g[s], tr[v].mx = max(g[s], h[s].top()); tr[v].lmx = tr[v].rmx = max(g[s], 0LL); return; } if (p &lt;= mid) modify(v&lt;&lt;1, s, mid, p); if (p &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, p); tr[v] = tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1];}node query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v]; node ret; if (l &lt;= mid) ret = ret+query(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) ret = ret+query(v&lt;&lt;1|1, mid+1, t, l, r); return ret;}void change(int u, int val) { node pr, cr; pr.lmx = g[into[u]]; cr.lmx = g[into[u]]-a[u]+val; for (int i = 0; u; i++, u = fa[top[u]]) { g[into[u]] += cr.lmx-pr.lmx; if (i) h[into[u]].pop(pr.mx), h[into[u]].push(cr.mx); pr = query(1, 1, n, into[top[u]], outo[u]); modify(1, 1, n, into[u]); cr = query(1, 1, n, into[top[u]], outo[u]); }}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]), h[i].push(0); for (int i = 1, u, v; i &lt; n; i++) read(u), read(v), addedge(u, v); DFS(1), DFS(1, 1), build(1, 1, n); while (m--) { char opt[2]; int x, y; scanf("%s", opt); if (opt[0] == 'M') read(x), read(y), change(x, y), a[x] = y; else read(x), printf("%lld\n", query(1, 1, n, into[x], outo[x]).mx); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>DP</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2733【HNOI2012】永无乡]]></title>
    <url>%2FBZOJ2733%E3%80%90HNOI2012%E3%80%91%E6%B0%B8%E6%97%A0%E4%B9%A1%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2012】永无乡 Description永无乡包含 座岛，编号从 到 ，每座岛都有自己的独一无二的重要度，按照重要度可以将这 座岛排名，名次用 到 来表示。某些岛之间由巨大的桥连接，通过桥可以从一个岛到达另一个岛。如果从岛 出发经过若干座（含 座）桥可以到达岛 ，则称岛 和岛 是连通的。现在有两种操作： ：表示在岛 与岛 之间修建一座新桥。 ：表示询问当前与岛 连通的所有岛中第 重要的是哪座岛，即所有与岛 连通的岛中重要度排名第 小的岛是哪座，请你输出那个岛的编号。 Input第一行是用空格隔开的两个正整数 和 ，分别表示岛的个数以及一开始存在的桥数。接下来的一行是用空格隔开的 个数，依次描述从岛 到岛 的重要度排名。随后的 行每行是用空格隔开的两个正整数 和 ，表示一开始就存在一座连接岛 和岛 的桥。后面剩下的部分描述操作。该部分的第一行是一个正整数 ，表示一共有 个操作。接下来的 行依次描述每个操作，操作的格式如上所述，以大写字母 或 开始，后面跟两个不超过 的正整数，字母与数字以及两个数字之间用空格隔开。 Output对于每个 操作都要依次输出一行，其中包含一个整数，表示所询问岛屿的编号。如果该岛屿不存在，则输出 。 Sample Input12345678910115 14 3 2 5 11 27Q 3 2Q 2 1B 2 3B 1 5Q 2 1Q 2 4Q 2 3 Sample Output12345-12512 HINT对于 的数据， 对于 的数据， 标签：并查集 线段树合并 Solution线段树合并裸题。 只建桥不拆桥，可以用并查集维护是否在同一连通块内，在每个连通块内维护一棵值域线段树，这样可以查第 小。对于建桥的操作，用并查集找出是那两个块合并到一起，将两个块内的线段树合并起来。 线段树合并只需要用函数式线段树动态开点，并像可并堆那样递归合并即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, a[MAX_N+5], b[MAX_N+5];int sz, rt[MAX_N+5], fa[MAX_N+5];struct node {int ls, rs, val;} tr[MAX_N*20];int getf(int x) {return fa[x] == x ? x : fa[x] = getf(fa[x]);}void modify(int &amp;v, int s, int t, int p) { if (!v) v = ++sz; if (s == t) {tr[v].val++; return;} if (p &lt;= mid) modify(tr[v].ls, s, mid, p); if (p &gt;= mid+1) modify(tr[v].rs, mid+1, t, p); tr[v].val = tr[tr[v].ls].val+tr[tr[v].rs].val;}int query(int v, int s, int t, int k) { if (s == t) return s; int lsz = tr[tr[v].ls].val; if (lsz &gt;= k) return query(tr[v].ls, s, mid, k); return query(tr[v].rs, mid+1, t, k-lsz);}int merge(int x, int y) { if (!x) return y; if (!y) return x; tr[x].ls = merge(tr[x].ls, tr[y].ls); tr[x].rs = merge(tr[x].rs, tr[y].rs); tr[x].val = tr[tr[x].ls].val+tr[tr[x].rs].val; return x;}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]), b[a[i]] = i, fa[i] = i; for (int i = 1, u, v; i &lt;= m; i++) read(u), read(v), u = getf(u), v = getf(v), fa[v] = u; for (int i = 1; i &lt;= n; i++) modify(rt[getf(i)], 1, n, a[i]); int T; read(T); while (T--) { char opt[2]; scanf("%s", opt); if (opt[0] == 'B') { int x, y; read(x), read(y), x = getf(x), y = getf(y); if (x^y) fa[y] = x, rt[x] = merge(rt[x], rt[y]); } else { int x, k; read(x), read(k); if (tr[rt[x = getf(x)]].val &lt; k) puts("-1"); else printf("%d\n", b[query(rt[x], 1, n, k)]); } } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2326【HNOI2011】数学作业]]></title>
    <url>%2FBZOJ2326%E3%80%90HNOI2011%E3%80%91%E6%95%B0%E5%AD%A6%E4%BD%9C%E4%B8%9A%20%E7%9F%A9%E9%98%B5%E5%BF%AB%E9%80%9F%E5%B9%82%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2011】数学作业 Description 小 数学成绩优异，于是老师给 小 留了一道非常难的数学作业题：给定正整数 和 ，要求计算 的值，其中 是将所有正整数 顺序连接起来得到的数。例如 ， 。 小 想了大半天终于意识到这是一道不可能手算出来的题目，于是他只好向你求助，希望你能编写一个程序帮他解决这个问题。 Input只有一行且为用空格隔开的两个正整数 和 。 Output仅包含一个非负整数，表示 的值。 Sample Input113 13 Sample Output14 HINT 且 。 标签：DP 矩阵快速幂 Solution显然是矩阵快速幂优化 。 设 顺次连接后模 的值为 ，所求为 。构建矩阵。由于每次都是将 乘 后加上 ，需要三个参数，即 , , 。构造 的转移矩阵： 分成若干 的区间做矩阵快速幂后乘起来即可。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}lnt n, m, f;struct Matrix { lnt ele[3][3]; Matrix () {memset(ele, 0, sizeof ele);} inline Matrix operator * (const Matrix &amp;x) const { Matrix ret; for (int i = 0; i &lt; 3; i++) for (int j = 0; j &lt; 3; j++) for (int k = 0; k &lt; 3; k++) ret.ele[i][j] = (ret.ele[i][j]+ele[i][k]*x.ele[k][j]%m)%m; return ret; }};Matrix Power(Matrix a, lnt k) { Matrix ret; for (int i = 0; i &lt; 3; i++) ret.ele[i][i] = 1; for (; k; k &gt;&gt;= 1, a = a*a) if (k&amp;1) ret = ret*a; return ret;}int main() { read(n), read(m); for (lnt i = 1; i &lt;= n; i *= 10) { Matrix a, b; a.ele[0][0] = f, a.ele[0][1] = (i-1)%m, a.ele[0][2] = 1; b.ele[0][0] = i*10%m, b.ele[0][1] = 0, b.ele[0][2] = 0; b.ele[1][0] = 1, b.ele[1][1] = 1, b.ele[1][2] = 0; b.ele[2][0] = 1, b.ele[2][1] = 1, b.ele[2][2] = 1; a = a*Power(b, min(n, i*10-1)-i+1), f = a.ele[0][0]; } return printf("%lld\n", f), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UOJ62【UR#5】怎样跑得更快]]></title>
    <url>%2FUOJ62%E3%80%90UR5%E3%80%91%E6%80%8E%E6%A0%B7%E8%B7%91%E5%BE%97%E6%9B%B4%E5%BF%AB%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[Problem【UR #5】怎样跑得更快时间限制： 空间限制： 大力水手问禅师：“大师，我觉得我光有力气是不够的。比如我吃菠菜可以让力气更大，但是却没有提升跑步的速度。请问怎样才能跑得更快？我试过吃白菜，没有效果。”禅师浅笑，答：“方法很简单，不过若想我教你，你先看看这道 的 题。”令 （ ，一个质数）。给你整数 。现在有整数 和 满足 ，且对于 满足： 其中 表示 和 除以 的余数相等。 表示 和 的最大公约数， 表示 和 的最小公倍数。有 个询问，每次给出 ，请你解出 的值。 输入格式第一行四个整数 。保证 。接下来 行，每行 个整数依次表示 。保证 。 输出格式共 行，每行对给出的 ，输出对应的 。如果有多组解输出任意一组即可。如果无解那么这一行只用输出一个整数 。 样例输入输出样例一Input1233 1 0 21 0 01 2 3 Output12499122179 998244352 499122176998244352 1 1 Explanation对于第一个询问，要满足的等式为： 样例二见样例数据下载。 限制与约定对于所有数据， ， 。 测试点编号 其他 保证有唯一解 保证有唯一解 保证有唯一解 保证有唯一解 无 后记还没听完题，大力水手就嘶吼着：“太难了我不会我不会！”，飞快地跑掉了。禅师看着大力水手消失的背影，叹了口气说：“你们这些人啊，每天就想做些大水题，一碰到难题，跑得不知道比谁都快。”后来大力水手把 的 题题面贴在了汽车的后挡风玻璃上，人类从此掌握了光速旅行的正确方式。 下载样例数据下载 标签：莫比乌斯反演 Solution先膜一发vfk的题解。 首先将题目中的式子转换一下： 设 ，那么原式化为 此时可以强行”说一句废话“来加入反演。存在数论函数 使得 ，那么 且 ，这样若知道 ，即可枚举约数求出 ，即1234for (int i = 1; i &lt;= n; i++) fr[i] = f[i];for (int i = 1; i &lt;= n; i++) for (int j = i+i; j &lt;= n; j += i) fr[j] -= fr[i]; 将 带入原式即可得到 为 的 倍 数 且 令 为 的 倍 数 且 ， ，那么 我们知道右边，要求左边，于是再次做反演，即 且 ，即1234for (int i = 1; i &lt;= n; i++) fz[i] = b[i]*Pow(g(i), P-2);for (int i = 1; i &lt;= n; i++) for (int j = i+i; j &lt;= n; j += i) fz[j] -= fz[i]; 这样就得到了 的值，即得到 的值，于是 即可算出 的值。然后再尝试用 推出 。由于 为 的 倍 数 且 ，设 ，那么 为 的 倍 数 且 。仍然是反演的形式，再次反演得到 ，即1234for (int i = 1; i &lt;= n; i++) hx[i] = z[d];for (int i = n; i &gt;= 1; i--) for (int j = i+i; j &lt;= n; j += i) hx[i] -= hx[j]; 知道了 ，即可由 求出 的值。 总结一下，分为三次反演： 预处理 的值（线性筛），反演求 读入 ，反演求 ，乘 的逆元即可得到 通过 反演求 ，乘 的逆元即可得到 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define P 998244353using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, c, d, q, b[MAX_N+5], x[MAX_N+5];lnt g[MAX_N+5], fr[MAX_N+5], fz[MAX_N+5], hx[MAX_N+5];int cnt, pri[MAX_N+5]; bool NotPri[MAX_N+5];inline lnt Pow(lnt x, int k) { lnt ret = 1; bool flag = (k &lt; 0); for (k = abs(k); k; k &gt;&gt;= 1, (x *= x) %= P) if (k&amp;1) (ret *= x) %= P; return flag ? Pow(ret, P-2) : ret;}void init() { fr[1] = g[1] = NotPri[1] = 1; for (int i = 2; i &lt;= n; i++) { if (!NotPri[i]) pri[cnt++] = i, fr[i] = Pow(i, c-d), g[i] = Pow(i, d); for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; n) break; NotPri[i*pri[j]] = true; fr[i*pri[j]] = fr[i]*fr[pri[j]]%P; g[i*pri[j]] = g[i]*g[pri[j]]%P; if (i%pri[j] == 0) break; } } for (int i = 1; i &lt;= n; i++) for (int j = i+i; j &lt;= n; j += i) (fr[j] += (P-fr[i])) %= P;}int main() { read(n), read(c), read(d), read(q), init(); for (bool flag = false; q--; flag = false) { for (int i = 1; i &lt;= n; i++) read(b[i]); for (int i = 1; i &lt;= n; i++) fz[i] = 1LL*b[i]*Pow(g[i], P-2)%P; for (int i = 1; i &lt;= n; i++) for (int j = i+i; j &lt;= n; j += i) (fz[j] += (P-fz[i])) %= P; for (int i = 1; i &lt;= n; i++) if (!fr[i] &amp;&amp; fz[i]) flag = true; if (flag) {puts("-1"); continue;} for (int i = 1; i &lt;= n; i++) hx[i] = fz[i]*Pow(fr[i], P-2)%P; for (int i = n; i &gt;= 1; i--) for (int j = i+i; j &lt;= n; j += i) (hx[i] += (P-hx[j])) %= P; for (int i = 1; i &lt;= n; i++) x[i] = (int)(hx[i]*Pow(g[i], P-2)%P); for (int i = 1; i &lt;= n; i++) printf("%d ", x[i]); puts(""); } return 0;}]]></content>
      <tags>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
        <tag>UOJ</tag>
        <tag>UOJ Round</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2141 排队]]></title>
    <url>%2FBZOJ2141%20%E6%8E%92%E9%98%9F%20%E5%88%86%E5%9D%97%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Problem排队 Description排排坐，吃果果，生果甜嗦嗦，大家笑呵呵。你一个，我一个，大的分给你，小的留给我，吃完果果唱支歌，大家乐和和。红星幼儿园的小朋友们排起了长长地队伍，准备吃果果。不过因为小朋友们的身高有所区别，排成的队伍高低错乱，极不美观。设第 个小朋友的身高为 ，我们定义一个序列的杂乱程度为满足 且 的 数量。幼儿园阿姨每次会选出两个小朋友，交换他们的位置，请你帮忙计算出每次交换后，序列的杂乱程度。为方便幼儿园阿姨统计，在未进行任何交换操作时，你也应该输出该序列的杂乱程度。 Input第一行为一个正整数 ，表示小朋友的数量。第二行包含 个由空格分隔的正整数 ，依次表示初始队列中小朋友的身高。第三行为一个正整数 ，表示交换操作的次数。以下 行每行包含两个正整数 和 ，表示交换位置 与位置 的小朋友。 Output输出文件共 行，第 行一个正整数表示交换操作 结束后，序列的杂乱程度。 Sample Input123453130 150 14022 31 3 Sample Output123103 Hint样例说明未进行任何操作时， 满足条件；操作 结束后，序列为 ，不存在满足条件的 ；操作 结束后，序列为 ，有 , , 共 对满足条件的 数据规模 ， ， ， ， 。 标签：分块 树状数组 Solution分块基础应用之带交换逆序对。 将原序列分为 个大小为 的块，每块内维护一个值域树状数组，记录每个值的个数。一开始增量计算总逆序对对数，随后对每个操作计算会增加/减少多少对逆序对。当交换 时，对于 ， 若 ，则 若 ，则 若 ，则 若 ，则 整块直接用树状数组统计，剩余部分暴力即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MAX_N 20000#define MAGIC ((int)sqrt(n))using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, cnt, tot, a[MAX_N+5], b[MAX_N+5];int BIT[150][MAX_N+5]; map &lt;int, int&gt; h;int id(int p) {return (p-1)/MAGIC+1;}void inc(int tr[], int p) {for (; p &lt;= n; p += (p&amp;-p)) tr[p]++;}void dec(int tr[], int p) {for (; p &lt;= n; p += (p&amp;-p)) tr[p]--;}int sum(int tr[], int p) {int ret = 0; for (; p; p -= (p&amp;-p)) ret += tr[p]; return ret;}int main() { read(n); for (int i = 1; i &lt;= n; i++) read(a[i]), b[i] = a[i]; sort(b+1, b+n+1); for (int i = 1; i &lt;= n; i++) if (!i || (b[i]^b[i-1])) h[b[i]] = ++cnt; for (int i = 1; i &lt;= n; i++) inc(BIT[0], a[i] = h[a[i]]), tot += i-sum(BIT[0], a[i]); for (int i = 1; i &lt;= n; i++) inc(BIT[id(i)], a[i]); printf("%d\n", tot); read(m); while (m--) { int x, y; read(x), read(y); if (x &gt; y) swap(x, y); if (id(x) &lt; id(y)) { for (int i = id(x)+1; i &lt;= id(y)-1; i++) tot -= sum(BIT[i], a[x]-1), tot += sum(BIT[i], n)-sum(BIT[i], a[x]), tot += sum(BIT[i], a[y]-1), tot -= sum(BIT[i], n)-sum(BIT[i], a[y]); for (int i = x+1; i &lt;= id(x)*MAGIC; i++) tot -= (a[i] &lt; a[x]), tot += (a[i] &gt; a[x]), tot += (a[i] &lt; a[y]), tot -= (a[i] &gt; a[y]); for (int i = y-1; i &gt;= (id(y)-1)*MAGIC+1; i--) tot -= (a[i] &lt; a[x]), tot += (a[i] &gt; a[x]), tot += (a[i] &lt; a[y]), tot -= (a[i] &gt; a[y]); } else for (int i = x+1; i &lt;= y-1; i++) tot -= (a[i] &lt; a[x]), tot += (a[i] &gt; a[x]), tot += (a[i] &lt; a[y]), tot -= (a[i] &gt; a[y]); tot += (a[x] &lt; a[y]), tot -= (a[x] &gt; a[y]); dec(BIT[id(x)], a[x]), dec(BIT[id(y)], a[y]); inc(BIT[id(x)], a[y]), inc(BIT[id(y)], a[x]); swap(a[x], a[y]), printf("%d\n", tot); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF235E Number Challenge]]></title>
    <url>%2FCF235E%20Number%20Challenge%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemNumber Challenge DescriptionLet’s denote as the number of divisors of a positive integer . You are given three integers , and . Your task is to calculate the following sum: Find the sum modulo . InputThe first line contains three space-separated integers , and . OutputPrint a single integer — the required sum modulo . ExamplesInput 112 2 2 Output 1120 Input 214 4 4 Output 21328 Input 3110 10 10 Output 3111536 NoteFor the first example. So the result is . 标签：莫比乌斯反演 Translation给出三个整数 （ ），求 。 Solution还记得BZOJ3994【SDOI2015】约束个数和吗？这是那道题的加强版本。 做那道题的时候，我们得到了一个重要结论，即 。这个结论可以推广到三维，即 具体证明见rng_68的证明。 然后就可以很笨拙地套路反演将一个 化为 的和式移到前面了。 令 ，那么 到这里就可以暴力做了。由于当且仅当 互质时才会计算 ，所以直接暴力计算是可以过 这种比较小的数据的。 据说可以做到 ，不过我不会。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAX_N 2000#define MOD 1073741824using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}bool NotPri[MAX_N+5];int cnt, pri[MAX_N+5], mu[MAX_N+5];int cache[MAX_N+5][MAX_N+5];int gcd(int a, int b) { if (cache[a][b]) return cache[a][b]; return cache[a][b] = (b ? gcd(b, a%b) : a);}void init() { mu[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) mu[i*pri[j]] = -mu[i]; else {mu[i*pri[j]] = 0; break;} } }}lnt f(int n, int x) { lnt ret = 0; for (int i = 1; i &lt;= n; i++) if (gcd(i, x) == 1) (ret += n/i) %= MOD; return ret;}int main() { int a, b, c; lnt ans = 0; read(a), read(b), read(c), init(); for (int k = 1; k &lt;= c; k++) for (int d = 1; d &lt;= min(a, b); d++) if (gcd(d, k) == 1) (ans += 1LL*(c/k)*mu[d]%MOD*f(a/d, k)%MOD*f(b/d, k)%MOD) %= MOD; return printf("%lld\n", (ans+MOD)%MOD), 0;}]]></content>
      <tags>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4930 棋盘]]></title>
    <url>%2FBZOJ4930%20%E6%A3%8B%E7%9B%98%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem棋盘 Description给定一个 的棋盘，棋盘上每个位置要么为空要么为障碍。定义棋盘上两个位置 能互相攻击当前仅当满足以下两个条件： 或 对于 与 之间的所有位置，均不是障碍。 现在有 个询问，每个询问给定 ，要求从棋盘中选出 个空位置来放棋子，问最少互相能攻击到的棋子对数是多少？ Input第一行一个整数 。接下来输入一个 的字符矩阵，一个位置若为.，则表示这是一个空位置；若为#，则为障碍。第 行输入一个整数 代表询问个数。接下来 行，每行一个整数 ，代表要放的棋子个数。 Output输出共 行，每行代表对应询问的最少的互相能攻击到的棋子对数。 Sample Input1234564..#.####..#...#.1 7 Sample Output12 HINT , , 棋 盘 中 空 位 置 数 量 标签：费用流 Solution“你见过拆点费用流吗？如果见过，那你见过拆边费用流吗？” 对于一块区域，若每个位置能互相攻击到，那么逐一放入棋子，第 个放入的棋子会产生 对新的攻击对关系。注意到本题中这样的区域只可能是横着的或竖着的，这样我们可以预处理出若干个这样的横条和竖条，易知最多有 个这样的区域。按照以往的套路，我们将横条和竖条分开，这是因为对于一个格子，它同时在一个横条和一个竖条内。对于这样的每个横条，建一个点，并从源点连接到这个点。若这个横条中最多有 个空位，那么流量最大为 。然而每个单位流量的花费是不同的，于是建 条边，第 条边的费用为 。对于每个竖条，建一个点，从这个点连到汇点，仍然建立 条边，边权如法炮制。之后对于每个点，找到其所在的横条和竖条，从横条的点连向竖条的点，流量 费用 。跑费用流的时候，每次增广一定会新选一个格子，即流量增加 。记录下每增加一个格子的最小冲突对数即最小花费，即可预处理出每个 的答案。跑完费用流后再回答询问即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define MAX_N 5000#define MAX_M 20000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, q, a, b, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;char mp[55][55]; int id[2][55][55], sz[2][MAX_N+5], ts[MAX_N+5], ans[MAX_N+5];struct node {int v, c, w, nxt;} E[MAX_M+5];void init() {s = 0, t = a+b+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]; return true;}int main() { read(n); for (int i = 1; i &lt;= n; i++) scanf("%s", mp[i]+1), mp[i][0] = mp[0][i] = '#'; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (mp[i][j] == '.') { if (mp[i][j-1] == '#') id[0][i][j] = ++a, sz[0][a]++; else id[0][i][j] = id[0][i][j-1], sz[0][a]++; } for (int j = 1; j &lt;= n; j++) for (int i = 1; i &lt;= n; i++) if (mp[i][j] == '.') { if (mp[i-1][j] == '#') id[1][i][j] = ++b, sz[1][b]++; else id[1][i][j] = id[1][i-1][j], sz[1][b]++; } init(); for (int i = 1; i &lt;= a; i++) for (int j = 1; j &lt;= sz[0][i]; j++) addedge(s, i, 1, j-1); for (int i = 1; i &lt;= b; i++) for (int j = 1; j &lt;= sz[1][i]; j++) addedge(i+a, t, 1, j-1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (mp[i][j] == '.') addedge(id[0][i][j], id[1][i][j]+a, 1, 0); read(q); while (SPFA()) ans[mxf] = mic; for (int k; q; q--) read(k), printf("%d\n", ans[k]); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1927【SDOI2010】星际竞速]]></title>
    <url>%2FBZOJ1927%E3%80%90SDOI2010%E3%80%91%E6%98%9F%E9%99%85%E7%AB%9E%E9%80%9F%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2010】星际竞速 Description十年一度的银河系赛车大赛又要开始了。作为全银河最盛大的活动之一，夺得这个项目的冠军无疑是很多人的梦想，来自杰森座 星的悠悠也是其中之一。赛车大赛的赛场由 颗行星和 条双向星际航路构成，其中每颗行星都有一个不同的引力值。大赛要求车手们从一颗与这 颗行星之间没有任何航路的天体出发，访问这 颗行星每颗恰好一次，首先完成这一目标的人获得胜利。由于赛制非常开放，很多人驾驶着千奇百怪的自制赛车来参赛。这次悠悠驾驶的赛车名为超能电驴，这是一部凝聚了全银河最尖端科技结晶的梦幻赛车。作为最高科技的产物，超能电驴有两种移动模式：高速航行模式和能力爆发模式。在高速航行模式下，超能电驴会展开反物质引擎，以数倍于光速的速度沿星际航路高速航行。在能力爆发模式下，超能电驴脱离时空的束缚，使用超能力进行空间跳跃――在经过一段时间的定位之后，它能瞬间移动到任意一个行星。天不遂人愿，在比赛的前一天，超能电驴在一场离子风暴中不幸受损，机能出现了一些障碍：在使用高速航行模式的时候，只能由每个星球飞往引力比它大的星球，否则赛车就会发生爆炸。尽管心爱的赛车出了问题，但是悠悠仍然坚信自己可以取得胜利。他找到了全银河最聪明的贤者――你，请你为他安排一条比赛的方案，使得他能够用最少的时间完成比赛。 Input第一行是两个正整数 。第二行 个数 ，其中 表示使用能力爆发模式到达行星 所需的定位时间。接下来 行，每行 个正整数 ，表示在编号为 和 的行星之间存在一条需要航行 时间的星际航路。输入数据已经按引力值排序，也就是编号小的行星引力值一定小，且不会有两颗行星引力值相同。 Output仅包含一个正整数，表示完成比赛所需的最少时间。 Sample Input123453 3 1 100 100 2 1 10 1 3 1 2 3 1 Sample Output112 HINT样例解释先使用能力爆发模式到行星 ，花费时间 。然后切换到高速航行模式，航行到行星 ，花费时间 。之后继续航行到行星 完成比赛，花费时间 。虽然看起来从行星 到行星 再到行星 更优，但我们却不能那样做，因为那会导致超能电驴爆炸。数据规模 ， 。输入数据中的任何数都不会超过 。输入数据保证任意两颗行星之间至多存在一条航道，且不会存在某颗行星到自己的航道。 Source第一轮 标签：费用流 Solution套路拆点费用流。 题目要求要遍历所有的点而不重复经过，于是不难想到将每个点拆成入点和出点，入点和源点相连，出点和汇点相连，形成二分图。对于每一条边 ，将 的入点和 的出点连接，代表遍历时从 走到 ，这样对于每条路径的每对相邻点，均可以在二分图的割上体现出来。对于瞬移，直接从源点向每个点的出点连边即可。建模： 对于每个点 ，拆成入点 和出点 ，连接 流量 费用 ，连接 流量 费用 对于每个点 ，连接 流量 费用 对于每条边 ，连接 流量 费用 跑费用流即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAX_N 2000#define MAX_M 100000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node {int v, c, w, nxt;} E[MAX_M+5];void init() {s = 0, t = n*2+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]; return true;}int main() { read(n), read(m), init(); for (int i = 1; i &lt;= n; i++) addedge(s, i, 1, 0); for (int i = 1; i &lt;= n; i++) addedge(i+n, t, 1, 0); for (int i = 1, x; i &lt;= n; i++) read(x), addedge(s, i+n, 1, x); for (int i = 1, u, v, c; i &lt;= m; i++) read(u), read(v), read(c), addedge(min(u, v), max(u, v)+n, 1, c); while (SPFA()) ; return printf("%d\n", mic), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演总结]]></title>
    <url>%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[算术函数定义定义域为正整数、函数值为复数的函数叫算术函数，即映射。例如： 算术函数间的运算 相加： 相乘： 狄利克雷卷积： 卷积的性质： 交换律： 结合律： 分配律： 单位元 ： 逆元：对于 ， 使得 莫比乌斯函数与反演定义 满 足 性质结论1： 证明： 设 为 的质因子个数， 为 的质因子个数 令 为 的所有质因子之积，即若 ，则 当 时， 当 时， 推论： ， 结论2（反演定理）： 若 ，则 若 ，则 即 证明： 莫比乌斯反演例题基本套路莫比乌斯反演题目是有转换套路的，一般只会用上述结论1，少数情况才会用结论二。 例：给定 ，求 分析： 首先需要把 化为我们熟悉的形式。我们有 ，那么考虑将 化为 ，于是 原 式 ，当且仅当 是 的倍数时才会有意义。于是又转化为 原 式 。 转化后就可以带入性质1（ ）了，将后面的部分替换，可得到 原 式 （这里 为前面 的值），接下来需要交换和号，即 原 式 ，注意到后面 是可以直接计算的，其等价于 的所有取值数对中 均为 的倍数的数对个数，所以 。 我们已经得到了 原 式 ，莫比乌斯反演已经转化完了。接下来是计算过程，需要用到数论分块。 的取值一定能分为很多块，使得每块中 和 都相同。这样的块一定不会超过 个，对于每个块，我们直接用后面乘式的积乘块大小得到贡献，然后每次用左端点取值找右端点即可。复杂度 。 总结上述基本套路： 将和式的一部分转化为 的形式，并将 带入 将含 的部分提到前面，并重新确定枚举的约数条件（易错） 观察 后面的部分，找方法将其计算出来（直接算或预处理） 进行数论分块，对于每块用直接乘每个枚举量贡献或预处理前缀和求解 预处理积性函数基本套路中， 条显然是很死板的，而 灵活一些。如果 后面的部分较为复杂，我们不能直接求值，那么如何计算呢？积性函数：若数论函数 满足对于所有 ，均有 ，则称作积性函数。完全积性函数：若数论函数 满足 ，则称作完全积性函数。我们将 后面的部分分为一个或多个积性函数，若为完全积性函数则更好。分 是否为 推导一下 的表达式，即可用线性筛线性预处理。例：BZOJ2820 YY的GCD 积式中的莫比乌斯反演有时，莫比乌斯反演会存在于积式中，作为底数或指数出现。若为底数，则可以直接反演后计算，与和式中的方法类似。若为指数，则会较为复杂。反演后将以莫比乌斯函数为指数的部分分离出来，想办法预处理其前缀积。例：BZOJ4816【SDOI2017】数字表格 题目汇总热身题BZOJ1101【POI2007】ZapBZOJ2190【SDOI2008】仪仗队BZOJ2671 Calc 常规题BZOJ2820 YY的GCDBZOJ2154 Crash的数字表格BZOJ2693 jzptabBZOJ3309 DZY Loves MathBZOJ4407 于神之怒加强版 进阶题BZOJ3994【SDOI2015】约数个数和CF235E Number ChallengeBZOJ4816【SDOI2017】数字表格BZOJ4174 tty的求助]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2194 快速傅立叶之二 < FFT >]]></title>
    <url>%2FBZOJ2194%20%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E4%B9%8B%E4%BA%8C%20FFT%2F</url>
    <content type="text"><![CDATA[Problem快速傅立叶之二 Description请计算 其中 ，并且有 。 中的元素均为小于等于 的非负整数。 Input第一行一个整数 ，接下来 行，每行两个数，依次表示 。 Output输出 行，每行一个整数，第 行输出 。 Sample Input12345653 12 41 12 41 4 Sample Output1234524121061 标签：FFT Solution 裸题。 将 的下标变为负值做 即可，变为负值可以直接将数组整体右移。 Code12345678910111213141516#include &lt;bits/stdc++.h&gt;#define MOD 9999991using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n; lnt ans = 1;int main() { read(n); for (int i = 1; i &lt;= n-2; i++) (ans *= 1LL*n) %= MOD; for (int i = 1; i &lt;= n-1; i++) (ans *= 1LL*i) %= MOD; return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3262 陌上花开 < CDQ分治 >]]></title>
    <url>%2FBZOJ3262%20%E9%99%8C%E4%B8%8A%E8%8A%B1%E5%BC%80%20CDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem陌上花开 Description有 朵花，每朵花有三个属性：花形( )、颜色( )、气味( )，用三个整数表示。现在要对每朵花评级，一朵花的级别是它拥有的美丽能超过的花的数量。定义一朵花 比另一朵花 要美丽，当且仅 。显然，两朵花可能有同样的属性。需要统计出评出每个等级的花的数量。 Input第一行为 ，分别表示花的数量和最大属性值。以下 行，每行三个整数 ，表示第 朵花的属性。 Output包含 行，分别表示评级为 的每级花的数量。 Sample Input123456789101110 33 3 32 3 32 3 13 1 13 1 21 3 11 1 21 2 21 3 21 2 1 Sample Output123456789103130101001 标签：CDQ分治 树状数组 三维偏序 Solution三维偏序， 分治裸题。 首先对 排序，记录每朵花排名。分治计算，对于区间 ，先按 值排序，再考虑该区间 中的花对 中的花产生的贡献，即若排名小于等于 ，将其 值加入树状数组；否则统计 中 值比它小的花对它的贡献，即为树状数组中 的前缀和。注意若有相同的一段花，则其答案一定是排在最后的这种花的答案。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define MAX_M 200000#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, tr[MAX_M+5], cnt[MAX_N+5];struct node {int x, y, z, p, s;} a[MAX_N+5], b[MAX_N+5];void inc(int p) {for (; p &lt;= m; p += (p&amp;-p)) tr[p]++;}void dec(int p) {for (; p &lt;= m; p += (p&amp;-p)) tr[p]--;}int sum(int p) {int ret = 0; for (; p; p -= (p&amp;-p)) ret += tr[p]; return ret;}bool cmp(const node &amp;a, const node &amp;b) {return a.x == b.x ? (a.y == b.y ? (a.z &lt; b.z) : a.y &lt; b.y) : a.x &lt; b.x;}bool operator == (node a, node b) {return a.x == b.x &amp;&amp; a.y == b.y &amp;&amp; a.z == b.z;}void CDQ(int s, int t) { if (s == t) return; CDQ(s, mid), CDQ(mid+1, t); for (int i = s, p1 = s, p2 = mid+1; i &lt;= t; i++) b[i] = (p1 &lt;= mid &amp;&amp; (p2 &gt; t || a[p1].y &lt;= a[p2].y)) ? a[p1++] : a[p2++]; for (int i = s; i &lt;= t; i++) a[i] = b[i]; for (int i = s; i &lt;= t; i++) if (a[i].p &lt;= mid) inc(a[i].z); else a[i].s += sum(a[i].z); for (int i = s; i &lt;= t; i++) if (a[i].p &lt;= mid) dec(a[i].z);}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i].x), read(a[i].y), read(a[i].z); sort(a+1, a+n+1, cmp); for (int i = n-1; i &gt;= 1; i--) if (a[i] == a[i+1]) a[i].s = a[i+1].s+1; for (int i = 1; i &lt;= n; i++) a[i].p = i; CDQ(1, n); for (int i = 1; i &lt;= n; i++) cnt[a[i].s]++; for (int i = 0; i &lt; n; i++) printf("%d\n", cnt[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3295【CQOI2011】动态逆序对 < CDQ分治 >]]></title>
    <url>%2FBZOJ3295%E3%80%90CQOI2011%E3%80%91%E5%8A%A8%E6%80%81%E9%80%86%E5%BA%8F%E5%AF%B9%20CDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem【CQOI2011】动态逆序对 Description对于序列 ，它的逆序对数定义为满足 ，且 的数对 的个数。给 到 的一个排列，按照某种顺序依次删除 个元素，你的任务是在每次删除一个元素之前统计整个序列的逆序对数。 Input输入第一行包含两个整数 和 ，即初始元素的个数和删除的元素个数。以下 行每行包含一个 到 之间的正整数，即初始排列。以下 行每行一个正整数，依次为每次删除的元素。 Output输出包含 行，依次为删除每个元素之前，逆序对的个数。 Sample Input123456789105 4153425142 Sample Output12345221 HINT 标签：CDQ分治 树状数组 三维偏序 Solution三维偏序，可上 分治。 首先将删除操作离线，倒着做变成插入，并给每个数编号 分别表示其下标、数值、插入时间。需要计算每个元素插入后会多出多少个逆序对，即对于三元组 ，有多少个 满足 或 。两个三维偏序，做两次 分治后统计即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define mid ((s+t)&gt;&gt;1)using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, pos[MAX_N+5], tr[MAX_N+5]; lnt ans[MAX_N+5];struct node {int x, y, z, p, s;} a[MAX_N+5], b[MAX_N+5];bool cmp1 (const node &amp;a, const node &amp;b) {return a.x &lt; b.x;}bool cmp2 (const node &amp;a, const node &amp;b) {return a.x &gt; b.x;}void inc(int p) {for (; p &lt;= m+2; p += (p&amp;-p)) tr[p]++;}void dec(int p) {for (; p &lt;= m+2; p += (p&amp;-p)) tr[p]--;}int sum(int p) {int ret = 0; for (; p; p -= (p&amp;-p)) ret += tr[p]; return ret;}void CDQ1(int s, int t) { if (s == t) return; CDQ1(s, mid), CDQ1(mid+1, t); for (int i = s, p1 = s, p2 = mid+1; i &lt;= t; i++) b[i] = (p1 &lt;= mid &amp;&amp; (p2 &gt; t || a[p1].y &gt; a[p2].y)) ? a[p1++] : a[p2++]; for (int i = s; i &lt;= t; i++) a[i] = b[i]; for (int i = s; i &lt;= t; i++) if (a[i].x &lt;= mid) inc(a[i].z+1); else a[i].s += sum(a[i].z+1); for (int i = s; i &lt;= t; i++) if (a[i].x &lt;= mid) dec(a[i].z+1);}void CDQ2(int s, int t) { if (s == t) return; CDQ2(s, mid), CDQ2(mid+1, t); for (int i = s, p1 = s, p2 = mid+1; i &lt;= t; i++) b[i] = (p1 &lt;= mid &amp;&amp; (p2 &gt; t || a[p1].y &lt; a[p2].y)) ? a[p1++] : a[p2++]; for (int i = s; i &lt;= t; i++) a[i] = b[i]; for (int i = s; i &lt;= t; i++) if (a[i].x &gt;= n-mid+1) inc(a[i].z+2); else a[i].s += sum(a[i].z+1); for (int i = s; i &lt;= t; i++) if (a[i].x &gt;= n-mid+1) dec(a[i].z+2);}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) a[i].x = i, read(a[i].y), pos[a[i].y] = i; for (int i = m, x; i; i--) read(x), a[pos[x]].z = i; sort(a+1, a+n+1, cmp1); CDQ1(1, n); sort(a+1, a+n+1, cmp2); CDQ2(1, n); for (int i = 1; i &lt;= n; i++) ans[a[i].z] += a[i].s; for (int i = 1; i &lt;= m; i++) ans[i] += ans[i-1]; for (int i = m; i; i--) printf("%lld\n", ans[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数据结构</tag>
        <tag>CDQ分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5087 Polycomp < bitset+分块 >]]></title>
    <url>%2FBZOJ5087%20polycomp%20bitset%2B%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[ProblemPolycomp Description你有三个系数为 的多项式 求 为方便起见，将答案多项式所有系数对 取模输出即可如果 ，则 Input一共三行，每行一个多项式，分别为 对于一个多项式 ，描述为 个整数 ，其中 为 或 ， Output用同样的格式输出答案多项式如果答案为 ，输出0 0 Sample Input1235 0 1 0 1 0 12 1 1 14 0 1 1 0 1 Sample Output11 1 1 HINT记 表示多项式最高项的次数， SourceBy clj 标签：bitset 分块 Solution陈老师神题。 直接用数组模拟乘除过程，可以做到 ，若用bitset维护，即可做到 。然而这样还是会 。 考虑类似分块的想法，将 的每十位分成一段，预处理 种情况对应的和，然后每次十位十位地加，即可做到 ，时间复杂度可以接受。根据vanilla的调参，貌似这种先预处理的方法在块大小为 时最快。 OwenOwl有更快的方法，即先不预处理出所有和，最后加的时候再根据每块情况计算，这样块大小可以更大，情况数更少，会更快。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;typedef bitset&lt;8001&gt; poly;template &lt;class T&gt; inline int read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0'); return x;}int lf, lg, lh, len, LOG[1&lt;&lt;16|1];poly f, g, h, t, ans, pw[17], s[1&lt;&lt;16|1];void init() {for (int i = 2; i &lt;= (1&lt;&lt;16); i++) LOG[i] = LOG[i&gt;&gt;1]+1;}void mod(poly &amp;p, int l) { for (int i = l; i &gt;= lh; i--) if (p[i]) p ^= (h&lt;&lt;(i-lh));}poly mul(poly a, poly b) { poly ret = 0; for (int i = 0; i &lt;= lh; i++) if (a[i]) ret ^= b&lt;&lt;i; mod(ret, 2*lh); return ret;}int getsta(int l, int r) { int ret = 0; for (int i = l; i &lt;= r; i++) ret |= f[i]&lt;&lt;(i-l); return ret;}int main() { read(lf); for (int i = 0, x; i &lt;= lf; i++) if (read(x)) f.set(i); read(lg); for (int i = 0, x; i &lt;= lg; i++) if (read(x)) g.set(i); read(lh); for (int i = 0, x; i &lt;= lh; i++) if (read(x)) h.set(i); mod(g, lg), pw[0].set(0), s[1].set(0), t.set(0), init(); for (int i = 1; i &lt;= 16; i++) pw[i] = mul(pw[i-1], g); for (int i = 2; i &lt; (1&lt;&lt;16); i++) s[i] = s[i-(1&lt;&lt;LOG[i])]^pw[LOG[i]]; for (int i = 0; i &lt;= lf; i += 16, t = mul(t, pw[16])) ans ^= mul(s[getsta(i, i+15)], t); for (len = lh; !ans[len] &amp;&amp; len; len--) ; printf("%d ", len); for (int i = 0; i &lt;= len; i++) printf("%d ", ans[i] ? 1 : 0); return puts(""), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4355 Play with sequence < SegBeats >]]></title>
    <url>%2FBZOJ4355%20Play%20with%20sequence%20SegBeats%2F</url>
    <content type="text"><![CDATA[ProblemPlay with sequence Description维护一个长度为 的序列 ，现在有三种操作： 给出参数 ，将 都赋值为 。 给出参数 ，对于区间 里的每个数 ，将 赋值为 。 给出参数 ，输出 里值为 的数字个数。 Input第一行包含两个正整数 ，分别表示序列长度和操作个数。第二行包含 个整数，其中第 个数表示 ，描述序列的初始状态。接下来 行描述 个操作，保证 ，对于操作 ， ，对于操作 ， 。 Output输出若干行，每行一个整数，依次回答每个操作 的问题。 Sample Input123455 36 4 6 6 4 2 1 5 -51 3 4 43 1 5 Sample Output12 Source2016.1.1新加数据鸣谢Claris 标签：SegBeats 线段树 Solution 参见吉老师的冬令营课件。 令二元组 表示对于区间 中的每个数先 再 ，发现这样的二元组是可以合并的。对于二元组 和 ，前者在后者的前面出现，则合并起来变成 。维护每个区间的最小值、次小值、最小值个数即可。若某区间 后最小值和次小值的大小关系未发生改变，那么不需要递归到子区间重新打擂。 维护即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define MAX_N 300000#define INF (1LL&lt;&lt;50)#define mid ((s+t)&gt;&gt;1)using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m;struct Tag {lnt x, c;} tag[MAX_N&lt;&lt;2];struct Node {lnt mi1, mi2; int cnt, tot;} tr[MAX_N&lt;&lt;2];Node operator + (Node a, Node b) { Node ret = (Node){0, 0, 0, a.tot+b.tot}; if (a.mi1 == b.mi1) ret.mi1 = a.mi1, ret.cnt = a.cnt+b.cnt, ret.mi2 = min(a.mi2, b.mi2); else if (a.mi1 &lt; b.mi1) ret.mi1 = a.mi1, ret.cnt = a.cnt, ret.mi2 = min(a.mi2, b.mi1); else ret.mi1 = b.mi1, ret.cnt = b.cnt, ret.mi2 = min(a.mi1, b.mi2); return ret;}Tag operator + (Tag a, Tag b) {return (Tag){max(a.x+b.x, -INF), max(a.c+b.x, b.c)};}void build(int v, int s, int t) { tag[v] = (Tag){0, -INF}; if (s == t) {read(tr[v].mi1), tr[v].mi2 = INF, tr[v].cnt = 1, tr[v].tot = 0; return;} build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t), tr[v] = tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1];}void maintain(int v, Tag tg) ;void downtag(int v) { tag[v&lt;&lt;1] = tag[v&lt;&lt;1]+tag[v], tag[v&lt;&lt;1|1] = tag[v&lt;&lt;1|1]+tag[v]; maintain(v&lt;&lt;1, tag[v]), maintain(v&lt;&lt;1|1, tag[v]), tag[v] = (Tag){0, -INF};}void maintain(int v, Tag tg) { lnt tmi1 = max(max(tr[v].mi1+tg.x, tg.c), 0LL); lnt tmi2 = max(max(tr[v].mi2+tg.x, tg.c), 0LL); tmi1 = min(tmi1, INF), tmi2 = min(tmi2, INF); if (tr[v].mi2 == INF) tmi2 = INF; if (tmi1 &lt; tmi2) tr[v].mi1 = tmi1, tr[v].mi2 = tmi2, tr[v].tot = tmi1 ? 0 : tr[v].cnt; else downtag(v), tr[v] = tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1];}void modify(int v, int s, int t, int l, int r, Tag tg) { if (s &gt;= l &amp;&amp; t &lt;= r) {tag[v] = tag[v]+tg, maintain(v, tg); return;} downtag(v); if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, tg); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, tg); tr[v] = tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1];}int query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].tot; int ret = 0; downtag(v); if (l &lt;= mid) ret += query(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) ret += query(v&lt;&lt;1|1, mid+1, t, l, r); tr[v] = tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1]; return ret;}int main() { read(n), read(m), build(1, 1, n); while (m--) { int opt, l, r, x; read(opt), read(l), read(r); if (opt == 1) read(x), modify(1, 1, n, l, r, (Tag){-INF, x}); if (opt == 2) read(x), modify(1, 1, n, l, r, (Tag){x, 0}); if (opt == 3) printf("%d\n", query(1, 1, n, l, r)); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF896C Willem, Chtholly and Seniorious < ODT >]]></title>
    <url>%2FCF896C%20Willem%2C%20Chtholly%20and%20Seniorious%20ODT%2F</url>
    <content type="text"><![CDATA[ProblemWillem, Chtholly and Seniorious Description— Willem…— What’s the matter?— It seems that there’s something wrong with Seniorious…— I’ll have a look… is made by linking special talismans in particular order.After over years, the carillon is now in bad condition, so Willem decides to examine it thoroughly. has pieces of talisman. Willem puts them in a line, the of which is an integer .In order to maintain it, Willem needs to perform operations.There are four types of operations: : For each such that , assign to . : For each such that , assign to . : Print the smallest number in the index range , i.e. the element at the position if all the elements such that are taken and sorted into an array of non-decreasing integers. It’s guaranteed that . : Print the sum of the power of such that , modulo , i.e. . InputThe only line contains four integers ( , , .The initial values and operations are generated using following pseudo code:1234567891011121314151617181920def rnd(): ret = seed seed = (seed * 7 + 13) mod 1000000007 return retfor i = 1 to n: a[i] = (rnd() mod vmax) + 1for i = 1 to m: op = (rnd() mod 4) + 1 l = (rnd() mod n) + 1 r = (rnd() mod n) + 1 if (l &gt; r): swap(l, r) if (op == 3): x = (rnd() mod (r - l + 1)) + 1 else: x = (rnd() mod vmax) + 1 if (op == 4): y = (rnd() mod vmax) + 1 Here is the type of the operation mentioned in the legend. OutputFor each operation of types or , output a line containing the answer. ExampleInput 1110 10 7 9 Output 112342103 Input 2110 10 9 9 Output 212341133 NoteIn the first example, the initial array is .The operations are: 标签：ODT Translation给出一个长为 级别的初始数组，要求维护四种操作： 将 中的每个数 将 中的每个数赋为 询问区间 中的第 小值 询问 Solution 裸题。 用一棵set维护若干区间，每个区间都是值相等的一段。对于操作 ，将与 有交集的所有区间都拿出来，如果是包含的区间，可以直接将区间值 ；如果是部分相交，则把区间拆成两部分（或三部分），分别赋值后删除原区间，插入新区间。对于操作 ，将所有包含区间提出并删除，分成至多三段，即 ，其中 和 是与 部分相交的两个区间的左端点和右端点。将左右两个区间赋值为原来的值，将中间的区间赋值为 。对于询问 ，将所有相交区间合起来排序再枚举判断即可。对于询问 ，将所有相交区间提出来得到每个值的个数，直接统计贡献即可。 复杂度证明见lxl的题解 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define fir first#define sec second#define MAX_N 100000#define MOD 1000000007using namespace std;typedef long long lnt;typedef pair&lt;int,int&gt; pii;typedef pair&lt;lnt,int&gt; pli;typedef map&lt;pii,lnt&gt;::iterator IT;map &lt;pii, lnt&gt; s;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, seed, vmx, a[MAX_N+5];int rnd() {int ret = seed; return seed = (int)((7LL*seed+13)%MOD), ret;}void qry(int &amp;op, int &amp;l, int &amp;r, int &amp;x, int &amp;y) { op = rnd()%4+1, l = rnd()%n+1, r = rnd()%n+1; if (l &gt; r) swap(l, r); x = rnd()%(op == 3 ? (r-l+1) : vmx)+1; y = op == 4 ? rnd()%vmx+1 : 0;}lnt pw(lnt x, lnt k, lnt p) { lnt ret = 1LL; x %= p; for (; k; k&gt;&gt;=1, (x *= x) %= p) if (k&amp;1) (ret *= x) %= p; return ret;}int main() { read(n), read(m), read(seed), read(vmx); for (int i = 1; i &lt;= n; i++) a[i] = rnd()%vmx+1; for (int i = 1; i &lt;= n; i++) s[pii(i, i)] = a[i]; for (int i = 1, op, l, r, x, y; i &lt;= m; i++) { qry(op, l, r, x, y); IT it = s.lower_bound(pii(l, l)); if (op == 1) { if (it-&gt;fir.fir != l) { it--; pii pr = pii(it-&gt;fir.fir, l-1), cur = pii(l, min(r, it-&gt;fir.sec)); if (it-&gt;fir.sec &lt;= r) s[pr] = it-&gt;sec, s[cur] = it-&gt;sec+x; else s[pr] = it-&gt;sec, s[cur] = it-&gt;sec+x, s[pii(r+1, it-&gt;fir.sec)] = it-&gt;sec; s.erase(it), it = s.lower_bound(pii(l+1, l+1)); } for (; it != s.end() &amp;&amp; it-&gt;fir.fir &lt;= r; it++) if (it-&gt;fir.sec &lt;= r) it-&gt;sec += x; else { s[pii(it-&gt;fir.fir, r)] = it-&gt;sec+x, s[pii(r+1, it-&gt;fir.sec)] = it-&gt;sec, s.erase(it); break; } } if (op == 2) { if (it-&gt;fir.fir != l) { it--; pii pr = pii(it-&gt;fir.fir, l-1); if (it-&gt;fir.sec &gt; r) s[pii(r+1, it-&gt;fir.sec)] = it-&gt;sec; s[pr] = it-&gt;sec, s.erase(it), it = s.lower_bound(pii(l+1, l+1)); } for (; it != s.end() &amp;&amp; it-&gt;fir.fir &lt;= r; s.erase(it), it = s.lower_bound(pii(l, l))) if (it-&gt;fir.sec &gt; r) s[pii(r+1, it-&gt;fir.sec)] = it-&gt;sec; s[pii(l, r)] = x; } if (op == 3) { vector &lt;pli&gt; vec; if (it-&gt;fir.fir != l) it--, vec.push_back(pli(it-&gt;sec, min(r, it-&gt;fir.sec)-l+1)), it++; for (; it != s.end() &amp;&amp; it-&gt;fir.fir &lt;= r; it++) vec.push_back(pli(it-&gt;sec, min(r, it-&gt;fir.sec)-it-&gt;fir.fir+1)); sort(vec.begin(), vec.end()); for (int j = 0; j &lt; (int)vec.size(); x -= vec[j++].sec) if (x &lt;= vec[j].sec) {printf("%lld\n", vec[j].fir); break;} } if (op == 4) { lnt ans = 0; if (it-&gt;fir.fir != l) it--, (ans += pw(it-&gt;sec, x, y)*(min(r, it-&gt;fir.sec)-l+1)%y) %= y, it++; for (; it != s.end() &amp;&amp; it-&gt;fir.fir &lt;= r; it++) (ans += pw(it-&gt;sec, x, y)*(min(r, it-&gt;fir.sec)-it-&gt;fir.fir+1)%y) %= y; printf("%lld\n", ans); } } return 0;}]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>CodeForces</tag>
        <tag>ODT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5343【CTSC2018】混合果汁]]></title>
    <url>%2FBZOJ5343%E3%80%90CTSC2018%E3%80%91%E6%B7%B7%E5%90%88%E6%9E%9C%E6%B1%81%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【CTSC2018】混合果汁 Description 小 热衷于做黑暗料理，尤其是混合果汁。商店里有 种果汁，编号为 。 号果汁的美味度是 每升价格为 。 小 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中， 号果汁最多只能添加 升。现在有 个小朋友过来找 小 要混合果汁喝，他们都希望 小 用商店里的果汁制作成一瓶混合果汁。其中，第 个小朋友希望他得到的混合果汁总价格不大于 ，体积不小于 。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。 Input输入第一行包含两个正整数 ，表示果汁的种数和小朋友的数量。接下来 行，每行三个正整数 ，表示 号果汁的美味度为 ，每升价格为 ，在一瓶果汁中的添加上限为 。接下来 行依次描述所有小朋友：每行两个数正整数 描述一个小朋友，表示他最多能支付 元钱，他想要至少 升果汁。 Output对于每个小朋友，输出一行，包含一个整数，表示他能喝到的最美味的混合果汁的美味度。如果无法满足他的需求，则输出 。 Sample Input123456783 41 3 52 1 33 2 56 35 310 1020 10 Sample Output123432-11 HINT对于所有的测试数据，保证 ， ， 。 测试点编号 其他限制 无 无 无 无 标签：整体二分 线段树 Solution整体二分常规题，考场上居然没做起签到题 考虑对每个询问二分答案，对于当前答案 ，将所有美味度大于等于 的果汁提出来，从花费小的往花费大的贪心选判断钱是否够即可。这样复杂度是 。优化方式有两种： 二分判断用主席树优化。首先将所有果汁按美味度从大到小排序并构建以 值为下标的值域线段树，存储的信息为价格在当前区间内的所有果汁的总体积以及总价格。在主席树上二分即可找到最小花费，这样 复杂度为 ，总复杂度 对所有询问进行整体二分，中间用值域线段树维护。整体二分过程需要支持动态插入一种果汁，在线段树上二分得到最小花费。总复杂度 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define mid ((s+t)&gt;&gt;1)using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, sz, val[MAX_N+5], ans[MAX_N+5];struct juice {int d, p, v;} a[MAX_N+5];struct query {int id; lnt w, v;} q[MAX_N+5], tq[MAX_N+5];struct node {lnt p, v;} tr[MAX_N&lt;&lt;2]; bool mrk[MAX_N+5];bool cmpd(const juice &amp;a, const juice &amp;b) {return a.d &gt; b.d;}bool cmpp(const juice &amp;a, const juice &amp;b) {return a.p &lt; b.p;}void update(int v) { tr[v].p = tr[v&lt;&lt;1].p+tr[v&lt;&lt;1|1].p; tr[v].v = tr[v&lt;&lt;1].v+tr[v&lt;&lt;1|1].v;}void modify(int v, int s, int t, int p, int x) { if (s == t) {tr[v].p += 1LL*p*x, tr[v].v += x; return;} if (p &lt;= mid) modify(v&lt;&lt;1, s, mid, p, x), update(v); else modify(v&lt;&lt;1|1, mid+1, t, p, x), update(v);}lnt query(int v, int s, int t, lnt x) { if (s == t) return 1LL*s*x; if (x &lt;= tr[v&lt;&lt;1].v) return query(v&lt;&lt;1, s, mid, x); return tr[v&lt;&lt;1].p+query(v&lt;&lt;1|1, mid+1, t, x-tr[v&lt;&lt;1].v);}void bi_solve(int l, int r, int s, int t) { if (s &gt; t) return; if (s == t) { for (int i = l; i &lt;= r; i++) ans[q[i].id] = a[s].d; return; } int lsz = 0; for (int i = s; i &lt;= mid; i++) modify(1, 1, MAX_N, a[i].p, a[i].v); for (int i = l; i &lt;= r; i++) if (tr[1].v &lt; q[i].v) mrk[i] = false; else { lnt tot = query(1, 1, MAX_N, q[i].v); mrk[i] = q[i].w &gt;= tot, lsz += mrk[i]; } for (int i = l, p1 = l, p2 = l+lsz; i &lt;= r; i++) if (mrk[i]) tq[p1++] = q[i]; else tq[p2++] = q[i]; for (int i = l; i &lt;= r; i++) q[i] = tq[i]; bi_solve(l+lsz, r, mid+1, t); for (int i = s; i &lt;= mid; i++) modify(1, 1, MAX_N, a[i].p, -a[i].v); bi_solve(l, l+lsz-1, s, mid);}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i].d), read(a[i].p), read(a[i].v); for (int i = 1; i &lt;= m; i++) q[i].id = i, read(q[i].w), read(q[i].v); sort(a+1, a+n+1, cmpd), a[n+1].d = -1; bi_solve(1, m, 1, n+1); for (int i = 1; i &lt;= m; i++) printf("%d\n", ans[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>整体二分</tag>
        <tag>CTSC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1064【NOI2008】假面舞会]]></title>
    <url>%2FBZOJ1064%E3%80%90NOI2008%E3%80%91%E5%81%87%E9%9D%A2%E8%88%9E%E4%BC%9A%20%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F%2F</url>
    <content type="text"><![CDATA[Problem【NOI2008】假面舞会 Description一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一 个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。为了使舞会更有神秘感，主办方把面具分为 类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 类面具的人才能看到戴第 类面具的人的编号，戴第 类面具的人能看到戴第 类面具的人的编号。参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。 栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 号面具的人看到了第 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信 息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 ，所以你必须将这条信息也考虑进去。 Input第一行包含两个整数 ，用一个空格分隔， 表示主办方总共准备了多少个面具， 表示栋栋收集了多少条信息。接下来 行，每行为两个用空格分开的整数 ，表示戴第 号面具的人看到了第 号面具的编号。相同的数对 在输入文件中可能出现多次。 Output包含两个数，第一个数为最大可能的面具类数，第二个数为最小可能的面具类数。如果无法将所有的面具分为至少 类，使得这些信息都满足，则认为栋栋收集的信息有错误，输出两个 。 SampleSample Input 11234566 51 22 33 44 13 5 Sample Output 114 4 Sample Input 212343 31 22 12 3 Sample Output 21-1 -1 HINT 的数据，满足 。 标签：连通分量 Solution图论好题，比较常规的连通分量做法，不过有几个细节容易出错。 对于给定的有向图，只会有两种情况： 存在环：所有环长度的最大公约数 为最大类数，大于 且整除 的最小数为最小类数。 不存在环：所有连通块的最长链之和为最大类数， 为最小类数。 特判一下最大类数是否大于等于 即可判断是否无解。 注意这里直接跑tarjan是无法找出所有环长的，需要 直接找。对每条边建长为 的反边，即可跑 找出环长和最长链，分情况讨论即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define MAX_M 1000000using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, mi, mx, mid, mxd, cnt, pr[MAX_N+5], d[MAX_N+5];struct edge {int v, c, nxt;} E[MAX_M&lt;&lt;1]; bool mrk[MAX_N+5], vis[MAX_M&lt;&lt;1];int gcd(int a, int b) {return b ? gcd(b, a%b) : a;}void insert(int u, int v, int c) {E[cnt] = (edge){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v) {insert(u, v, 1), insert(v, u, -1);}void DFS(int u) { mrk[u] = true; for (int i = pr[u], v; ~i; i = E[i].nxt) if (!mrk[v = E[i].v]) d[v] = d[u]+E[i].c, DFS(v); else mx = gcd(mx, abs(d[u]-d[v]+E[i].c));}void getD(int u) { mrk[u] = true, mxd = max(mxd, d[u]), mid = min(mid, d[u]); for (int i = pr[u]; ~i; i = E[i].nxt) if (!vis[i]) vis[i] = vis[i^1] = true, d[E[i].v] = d[u]+E[i].c, getD(E[i].v);}int main() { read(n), read(m), memset(pr, -1, sizeof pr); for (int i = 1, u, v; i &lt;= m; i++) read(u), read(v), addedge(u, v); for (int i = 1; i &lt;= n; i++) if (!mrk[i]) DFS(i); if (mx) { if (mx &lt; 3) {puts("-1 -1"); return 0;} for (mi = 3; mi &lt;= mx; mi++) if (!(mx%mi)) break; } else { memset(mrk, false, sizeof mrk), mi = 3; for (int i = 1; i &lt;= n; i++) if (!mrk[i]) mxd = mid = d[i] = 0, getD(i), mx += mxd-mid+1; if (mx &lt; 3) {puts("-1 -1"); return 0;} } return printf("%d %d\n", mx, mi), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>NOI</tag>
        <tag>连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1901 Dynamic Rankings]]></title>
    <url>%2FBZOJ1901%20Dynamic%20Rankings%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[ProblemDynamic Rankings Description给定一个含有 个数的序列 。对于给定的 ，请回答在 中第 小的数是多少 。在询问中会有操作改变一些 的值，改变后，需要针对改变后的 继续回答上面的问题。 Input第一行有两个正整数 。分别表示序列的长度和指令的个数。第二行有 个数，表示 ，这些数都小于 。接下来的 行描述每条指令，每行的格式是下面两种格式中的一种。 表示询问指令，询问 中第 小的数。 表示把 改变成为 。 Output对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。 Sample Input123455 33 2 1 4 7Q 1 4 3C 2 6Q 2 5 3 Sample Output1236 HINT 标签：整体二分 Solution整体二分经典题，直接上整体二分即可。 考虑将所有询问离线下来，对所有询问同时进行二分答案，二分函数有四个参数 ，表示答案在 区间内的询问为在询问序列上位置在 之间的所有询问。如果 ，则可知询问序列上位置在 间的所有询问答案均为 。否则，我们需要把 间的所有询问分为前后两部分，前一部分为答案在 间的所有询问，后一部分为答案在 间的所有询问。这个过程用一棵树状数组判断一下 间每个询问的答案在哪边即可。然而我们还需要维护修改操作。对于修改操作，我们同样将其加入整体二分。当询问函数将答案限制到 时，只有参数 在 间的修改操作才会对这个 间的询问答案产生影响。于是将每个修改拆成两个操作，即在某位置上删除一个数和加入一个数。用树状数组维护时，若删除或加入的数在 间，在树状数组上对应位置 或 。对于询问，若询问区间为 ，那么该询问的 值为树状数组上 位置上的值之和。这样一来， 统计的是每个询问区间内小于等于 的数的个数，若 ，则答案一定在 间；否则，答案一定大于 。分治处理即可。 由于整体二分会带来一个 ，枚举每个询问并用树状数组判断其答案在左边还是右边需要 ，故总复杂度为 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MAX_N 20000#define INF 0x3f3f3f3f#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int N, M, Q, cnt, val[MAX_N+5], ans[MAX_N+5];struct node {int id, tp, a, b, k, s;} p[MAX_N+5], q[MAX_N+5];int num[MAX_N+5], tr[MAX_N+5]; bool mrk[MAX_N+5];void inc(int p) {for (; p &lt;= N; p += (p&amp;-p)) tr[p]++;}void dec(int p) {for (; p &lt;= N; p += (p&amp;-p)) tr[p]--;}int sum(int p) {int ret = 0; for (; p; p -= (p&amp;-p)) ret += tr[p]; return ret;}void bi_solve(int l, int r, int s, int t) { if (l &gt; r) return; if (s == t) { for (int i = l; i &lt;= r; i++) if (p[i].tp == 3) ans[p[i].id] = s; return; } for (int i = l; i &lt;= r; i++) if (p[i].tp == 1 &amp;&amp; p[i].b &lt;= mid) inc(p[i].a); else if (p[i].tp == 2 &amp;&amp; p[i].b &lt;= mid) dec(p[i].a); else if (p[i].tp == 3) num[i] = sum(p[i].b)-sum(p[i].a-1); for (int i = l; i &lt;= r; i++) if (p[i].tp == 1 &amp;&amp; p[i].b &lt;= mid) dec(p[i].a); else if (p[i].tp == 2 &amp;&amp; p[i].b &lt;= mid) inc(p[i].a); int lsz = 0; for (int i = l; i &lt;= r; i++) if (p[i].tp == 3) { if (p[i].k &lt;= p[i].s+num[i]) lsz++, mrk[i] = false; else p[i].s += num[i], mrk[i] = true; } else lsz += (p[i].b &lt;= mid), mrk[i] = (p[i].b &gt; mid); for (int i = l, p1 = l, p2 = l+lsz; i &lt;= r; i++) if (!mrk[i]) q[p1++] = p[i]; else q[p2++] = p[i]; for (int i = l; i &lt;= r; i++) p[i] = q[i]; bi_solve(l, l+lsz-1, s, mid), bi_solve(l+lsz, r, mid+1, t);}int main() { read(N), read(M); for (int i = 1; i &lt;= N; i++) read(val[i]), p[++cnt] = (node){0, 1, i, val[i], 0, 0}; for (int i = 1, a, b, k; i &lt;= M; i++) { char opt[2]; scanf("%s", opt); if (opt[0] == 'C') read(a), read(b), p[++cnt] = (node){0, 2, a, val[a], 0, 0}, p[++cnt] = (node){0, 1, a, (val[a] = b), 0, 0}; else read(a), read(b), read(k), p[++cnt] = (node){++Q, 3, a, b, k, 0}; } bi_solve(1, cnt, 0, INF); for (int i = 1; i &lt;= Q; i++) printf("%d\n", ans[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2527【POI2011】Meteors]]></title>
    <url>%2FBZOJ2527%E3%80%90POI2011%E3%80%91Meteors%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86%2F</url>
    <content type="text"><![CDATA[Problem【POI2011】Meteors Description 有 个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为 份（第 份和第 份相邻），第 份上有第 个国家的太空站。这个星球经常会下陨石雨。 已经预测了接下来 场陨石雨的情况。 的第 个成员国希望能够收集 单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。 Input第一行输入两个数 。第二行有 个数，第 个数 表示第 段轨道上有第 个国家的太空站。第三行有 个数，第 个数 表示第 个国家希望收集的陨石数量。第四行有一个数 ，表示预测了接下来的 场陨石雨。接下来 行，每行有三个数 ，表示第 场陨石雨的发生地点在从 顺时针到 的区间中（如果 ，就是 ，否则就是 ），向区间中的每个太空站提供 单位的陨石样本。 Output输出共 行。第 行的数 表示第 个国家在第 波陨石雨之后能够收集到足够的陨石样本。如果到第 波结束后仍然收集不到，输出NIE。 Sample Input12345673 51 3 2 1 310 5 734 2 41 3 13 5 2 Sample Output1233NIE1 HINT ， ， 。 Source鸣谢Object022 标签：整体二分 Solution整体二分模板题。 将所有询问离线下来一起做二分答案。对于二分中点 ，考虑每个国家是否能在前 波流星雨之内达到收集要求。对每个国家用树状数组统计出会有多少陨石落到它的所有卫星上，即可判断每个询问的答案在 中还是 中。注意每次判的时候不要将 区间内的所有流星雨都加入树状数组修改，这样复杂度是伪的。应当对于每个答案区间在 中的询问累加前面的陨石总数，即累加前面区间对后面的贡献。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;#define MAX_N 20000#define INF 0x3f3f3f3f#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int N, M, Q, cnt, val[MAX_N+5], ans[MAX_N+5];struct node {int id, tp, a, b, k, s;} p[MAX_N+5], q[MAX_N+5];int num[MAX_N+5], tr[MAX_N+5]; bool mrk[MAX_N+5];void inc(int p) {for (; p &lt;= N; p += (p&amp;-p)) tr[p]++;}void dec(int p) {for (; p &lt;= N; p += (p&amp;-p)) tr[p]--;}int sum(int p) {int ret = 0; for (; p; p -= (p&amp;-p)) ret += tr[p]; return ret;}void bi_solve(int l, int r, int s, int t) { if (l &gt; r) return; if (s == t) { for (int i = l; i &lt;= r; i++) if (p[i].tp == 3) ans[p[i].id] = s; return; } for (int i = l; i &lt;= r; i++) if (p[i].tp == 1 &amp;&amp; p[i].b &lt;= mid) inc(p[i].a); else if (p[i].tp == 2 &amp;&amp; p[i].b &lt;= mid) dec(p[i].a); else if (p[i].tp == 3) num[i] = sum(p[i].b)-sum(p[i].a-1); for (int i = l; i &lt;= r; i++) if (p[i].tp == 1 &amp;&amp; p[i].b &lt;= mid) dec(p[i].a); else if (p[i].tp == 2 &amp;&amp; p[i].b &lt;= mid) inc(p[i].a); int lsz = 0; for (int i = l; i &lt;= r; i++) if (p[i].tp == 3) { if (p[i].k &lt;= p[i].s+num[i]) lsz++, mrk[i] = false; else p[i].s += num[i], mrk[i] = true; } else lsz += (p[i].b &lt;= mid), mrk[i] = (p[i].b &gt; mid); for (int i = l, p1 = l, p2 = l+lsz; i &lt;= r; i++) if (!mrk[i]) q[p1++] = p[i]; else q[p2++] = p[i]; for (int i = l; i &lt;= r; i++) p[i] = q[i]; bi_solve(l, l+lsz-1, s, mid), bi_solve(l+lsz, r, mid+1, t);}int main() { read(N), read(M); for (int i = 1; i &lt;= N; i++) read(val[i]), p[++cnt] = (node){0, 1, i, val[i], 0, 0}; for (int i = 1, a, b, k; i &lt;= M; i++) { char opt[2]; scanf("%s", opt); if (opt[0] == 'C') read(a), read(b), p[++cnt] = (node){0, 2, a, val[a], 0, 0}, p[++cnt] = (node){0, 1, a, (val[a] = b), 0, 0}; else read(a), read(b), read(k), p[++cnt] = (node){++Q, 3, a, b, k, 0}; } bi_solve(1, cnt, 0, INF); for (int i = 1; i &lt;= Q; i++) printf("%d\n", ans[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>POI</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4816【SDOI2017】数字表格]]></title>
    <url>%2FBZOJ4816%E3%80%90SDOI2017%E3%80%91%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2017】数字表格 Description 刚刚学习了 数列。用 表示数列的第 项，那么 用老师的超级计算机生成了一个 的表格，第 行第 列的格子中的数是 ，其中 表示 的最大公约数。 的表格中共有 个数，她想知道这些数的乘积是多少。答案对 取模。 Input有多组测试数据。第一个一个数 ，表示数据组数。接下来 行，每行两个数 。 Output输出 行，第 行的数是第 组数据的结果。 Sample Input123432 34 56 7 Sample Output12316960 HINT Source鸣谢infinityedge上传 标签：莫比乌斯反演 Solution转换题目求和的角度为枚举 ，求 对答案的贡献。那么有 将中间 单独分开，设 ，那么 ，预处理出 的前缀积后数论分块即可。 发现对于每个 ， 最多只会对 个 的值产生贡献，枚举 累加贡献的时间复杂度是调和级数。于是枚举 ，枚举 在 内的倍数 ，将 乘到 中即可处理出所有 。而 只能取 ，于是需要预处理出 和 即 在模意义下的逆元。处理出 后再处理 的前缀积即可。 时间复杂度 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000#define MOD 1000000007using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}bool NotPri[MAX_N+5]; int cnt, pri[MAX_N+5]; lnt ans, gp;lnt mu[MAX_N+5], f[MAX_N+5], g[MAX_N+5], inv[MAX_N+5];lnt Pow(lnt x, lnt k) { lnt ret = 1LL; for (; k; k &gt;&gt;= 1, (x *= x) %= MOD) if (k&amp;1) (ret *= x) %= MOD; return ret;}void init() { mu[1] = f[1] = inv[1] = 1; for (int i = 0; i &lt;= MAX_N; i++) g[i] = 1; for (int i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) mu[i*pri[j]] = -mu[i]; else {mu[i*pri[j]] = 0; break;} } } for (int i = 2; i &lt;= MAX_N; i++) f[i] = (f[i-1]+f[i-2])%MOD, inv[i] = Pow(f[i], MOD-2); for (int i = 1; i &lt;= MAX_N; i++) if (mu[i]) for (int j = i; j &lt;= MAX_N; j += i) if (mu[i] == 1) (g[j] *= f[j/i]) %= MOD; else (g[j] *= inv[j/i]) %= MOD; for (int i = 2; i &lt;= MAX_N; i++) (g[i] *= g[i-1]) %= MOD;}int main() { int T; read(T), init(); while (T--) { int n, m; read(n), read(m), ans = 1LL; for (int l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), gp = g[r]*Pow(g[l-1], MOD-2)%MOD, gp = Pow(gp, 1LL*(n/l)*(m/l)%(MOD-1)), (ans *= gp) %= MOD; printf("%lld\n", ans); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1013【JSOI2008】球形空间产生器]]></title>
    <url>%2FBZOJ1013%E3%80%90JSOI2008%E3%80%91%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8%20%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[Problem【JSOI2008】球形空间产生器 Description有一个球形空间产生器能够在 维空间中产生一个坚硬的球体。现在，你被困在了这个 维球体中，你只知道球面上 个点的坐标，你需要以最快的速度确定这个 维球体的球心坐标，以便于摧毁这个球形空间产生器。 Input第一行是一个整数 。接下来的 行，每行有 个实数，表示球面上一点的 维坐标。每一个实数精确到小数点后 位，且其绝对值都不超过 。 Output有且只有一行，依次给出球心的 维坐标（ 个实数），两个实数之间用一个空格隔开。每个实数精确到小数点后 位，数据保证有解，你的答案必须和标准输出一模一样才能够得分。 Sample Input123420.0 0.0-1.0 1.01.0 0.0 Sample Output10.500 1.500 HINT给出两个定义： 球心：到球面上任意一点距离都相等的点。 距离：设两个 维空间上的点 的坐标为 , ，则 的距离定义为： 标签：高斯消元 Solution高消裸题。 将第 个点单独分出来，将其与前 个点分别联立形成 个方程，高消即可求得球心坐标。 设球心为 ，第 个点为 。对于前 个点中的一个点 ，设 坐标为 。那么一定有 展开得 移项化简 直接高斯消元解方程组，时间复杂度 。 注意行末不要输出空格 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define EPS 1e-8using namespace std;typedef double dnt;int n; dnt p[15][15], f[15][15];dnt sqr(dnt x) {return x*x;}bool Gauss() { for (int i = 1, t; i &lt;= n; i++) { for (t = i; t &lt;= n; t++) if (fabs(f[t][i]) &gt;= EPS) break; if (t &gt; n) return false; swap(f[i], f[t]); for (int j = 1; j &lt;= n; j++) if (i^j) { dnt div = f[j][i]/f[i][i]; for (int k = 1; k &lt;= n+1; k++) f[j][k] -= f[i][k]*div; } } for (int i = 1; i &lt;= n; i++) f[i][n+1] /= f[i][i]; return true;} int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n+1; i++) for (int j = 1; j &lt;= n; j++) scanf("%lf", p[i]+j); for (int i = 1, j = n+1; i &lt;= n; i++) for (int k = 1; k &lt;= n; k++) f[i][k] = p[i][k]-p[j][k], f[i][n+1] += (sqr(p[i][k])-sqr(p[j][k]))/2; Gauss(); for (int i = 1; i &lt;= n; i++) if (i^n) printf("%.3lf ", f[i][n+1]); else printf("%.3lf", f[i][n+1]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3143【HNOI2013】游走]]></title>
    <url>%2FBZOJ3143%E3%80%90HNOI2013%E3%80%91%E6%B8%B8%E8%B5%B0%20%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2013】游走 Description一个无向连通图，顶点从 编号到 ，边从 编号到 。 小 在该图上进行随机游走，初始时 小 在 号顶点，每一步 小 以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当 小 到达 号顶点时游走结束，总分为所有获得的分数之和。现在请你对这 条边进行编号，使得 小 获得的总分的期望值最小。 Input第一行是正整数 和 ，分别表示该图的顶点数和边数。接下来 行每行是整数 ，表示顶点 与顶点 之间存在一条边。 Output仅包含一个实数，表示最小的期望值，保留 位小数。 Sample Input12343 32 31 21 3 Sample Output13.333 Explanation边 编号为 ，边 编号 ，边 编号为 。 HINT 保证图为无向简单连通图 标签：高斯消元 Solution大致思路是求出每条边的期望经过次数，然后贪心选择边权。然而对于边来说，并不好确定其期望经过次数，而点的期望经过次数则更好求。 设 为到达点 并继续向下一个点移动的期望次数。那么对于普通的点（非起点 或终点 ），其只能从与其相邻的点走过来，于是对于点 ，从 连出去的点的集合为 ，那么 ，其中 为点的度数。而对于 号点，初始时一定在 号点上，因此一定初始就有 次的经过次数，而游走过程中的情况与普通点相同，于是 。对于 号点，由于到了 后不能继续走动，即只进不出，于是一定不会经过（因为前面经过的定义是要有向下一个点移动的可能），因此 。于是有方程组 用高斯消元可以解得 。 对于一条边 ，其端点为 和 ，要经过 必定只能是从 到 或从 到 。在 时有 的概率走这条边，在 时有 的概率走这条边，于是第 条边的期望经过次数为 。求出 后从大到小排序，贪心使得期望经过次数越大的边权越小，即可得到最小的期望路径长度。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define EPS 1e-7#define MAX_N 500#define MAX_M 250000using namespace std;typedef double dnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, u[MAX_M+5], v[MAX_M+5], d[MAX_N+5];dnt f[MAX_N+5][MAX_N+5], x[MAX_N+5], y[MAX_M+5];void Gauss() { for (int i = 1, t; i &lt;= n; i++) { for (t = i; t &lt;= n; t++) if (fabs(f[i][t]) &gt;= EPS) break; if (t &gt; n) continue; swap(f[i], f[t]); for (int j = 1; j &lt;= n; j++) if (i^j) { dnt div = f[j][i]/f[i][i]; for (int k = 1; k &lt;= n+1; k++) f[j][k] -= f[i][k]*div; } } for (int i = 1; i &lt;= n; i++) x[i] = f[i][n+1]/f[i][i];}int main() { read(n), read(m); dnt ans = 0; for (int i = 1; i &lt;= m; i++) read(u[i]), read(v[i]), d[u[i]]++, d[v[i]]++; for (int i = 1; i &lt;= m; i++) f[u[i]][v[i]] -= 1.0/d[v[i]], f[v[i]][u[i]] -= 1.0/d[u[i]]; for (int i = 1; i &lt;= n; i++) f[n][i] = 0; for (int i = 1; i &lt;= n; i++) f[i][i] = 1; f[1][n+1] = 1, Gauss(); for (int i = 1; i &lt;= m; i++) y[i] = x[u[i]]/d[u[i]]+x[v[i]]/d[v[i]]; sort(y+1, y+m+1); for (int i = 1; i &lt;= m; i++) ans += y[i]*(m-i+1); return printf("%.3lf\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2565 最长双回文串 < Manacher >]]></title>
    <url>%2FBZOJ2565%20%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%20Manacher%2F</url>
    <content type="text"><![CDATA[Problem最长双回文串 Description顺序和逆序读起来完全一样的串叫做回文串。比如acbca是回文串，而abc不是（abc的顺序为abc，逆序为cba，不相同）。输入长度为 的串 ，求 的最长双回文子串 ，即可将 分为两部分 且 和 都是回文串。 Input一行由小写英文字母组成的字符串 。 Output一行一个整数，表示最长双回文子串的长度。 Sample Input1baacaabbacabb Sample Output112 Explanation从第二个字符开始的字符串aacaabbacabb可分为aacaa与bbacabb两部分，且两者都是回文串。 HINT对于 的数据， 新加数据一组 Source 国家集训队 标签：Manacher Solution 上稍加变化。 首先跑 得到以每个位置为中心的回文串最大长度。然后考虑计算出 和 ，分别表示以每个位置为终点和起点的最长回文串的中心点位置。如此枚举每个位置作为中间断点打擂得到最长双回文字串。 那么如何计算 和 呢？对于位置 ，其最长回文串半径长为 ，那么区间 中的所有位置都可以作为这个串的右端点（终点）。于是这些位置的 值一定不大于 ，这是因为 值越小，回文串越长，这样更优。所以从前往后枚举 ，如果 中的某个点的 值在前面没有确定到，那么这个点的 值一定最小为 。发现这样的点一定在一个区间中，所以可以记录每次更新 更新到的位置，即可 扫一遍得到 。反着这样扫一遍即可得到 。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define MAX_M 200000using namespace std;char s[MAX_M+5];int n, f[MAX_M+5];int L[MAX_N+5], R[MAX_N+5];void manacher() { int p = 0, r = 0; for (int i = 1; i &lt;= n; i++) { f[i] = i &lt; r ? min(f[p*2-i], r-i) : 1; while (i-f[i] &gt;= 1 &amp;&amp; i+f[i] &lt;= n) if (s[i-f[i]] == s[i+f[i]]) f[i]++; else break; if (i+f[i] &gt; r) p = i, r = i+f[i]; }}int main() { char str[MAX_N+5]; scanf("%s", str), n = (int)strlen(str); for (int i = 0; i &lt; n; i++) s[i*2+1] = '#', s[i*2+2] = str[i]; s[n = n*2+1] = '#', manacher(); int mx = 1, mi = n, ans = 0; for (int i = 1; i &lt;= n; i++) if (f[i] &gt; 1 &amp;&amp; i+f[i] &gt; mx) { for (int j = mx; j &lt; i+f[i]; j++) L[j] = i; mx = i+f[i]; } for (int i = n; i &gt;= 1; i--) if (f[i] &gt; 1 &amp;&amp; i-f[i] &lt; mi) { for (int j = mi; j &gt; i-f[i]; j--) R[j] = i; mi = i-f[i]; } for (int i = 1; i &lt;= n; i++) ans = max(ans, R[i]-L[i]); return printf("%d\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>字符串</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2006【NOI2010】超级钢琴 < ST表+堆 >]]></title>
    <url>%2FBZOJ2006%E3%80%90NOI2010%E3%80%91%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%20ST%E8%A1%A8%2B%E5%A0%86%2F</url>
    <content type="text"><![CDATA[Problem【NOI2010】超级钢琴 Description 小 是一个小有名气的钢琴家，最近 博 士 送给了 小 一架超级钢琴， 小 希望能够用这架钢琴创作出世界上最美妙的音乐。这架超级钢琴可以弹奏出 个音符，编号为 。第 个音符的美妙度为 ，其中 可正可负。一个“超级和弦“由若干个编号连续的音符组成，包含的音符个数不少于 且不多于 。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。 小 决定创作一首由 个超级和弦组成的乐曲，为了使得乐曲更加动听， 小 要求该乐曲由 个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。 小 想知道他能够创作出来的乐曲美妙度最大值是多少。 Input第一行包含四个正整数 。其中 为音符的个数， 为乐曲所包含的超级和弦个数， 和 分别是超级和弦所包含音符个数的下限和上限。接下来 行，每行包含一个整数 ，表示按编号从小到大每个音符的美妙度。 Output只有一个整数，表示乐曲美妙度的最大值。 Sample Input123454 3 2 332-68 Sample Output111 Explanation共有 种不同的超级和弦：音符 ，美妙度为 音符 ，美妙度为 音符 ，美妙度为 音符 ，美妙度为 音符 ，美妙度为 最优方案为：乐曲由和弦 ,和弦 ,和弦 组成，美妙度为 。 HINT ， ， ， 数据保证一定存在满足条件的乐曲 标签：堆 ST表 Solution经典线段树例题，不过我用的是一种精妙的ST表。 找出第 大的差值，可以用一个堆维护，每次弹出堆顶。首先将区间和处理为前缀和，这样问题变为给出一个数组 ，求第 大的 ，其中 。考虑对于一个确定的 ，使差值最大的 一定是 中的最小值，这个最小值可以在 时间内用ST表找到。这个值取完后，对于其他以 作为终点的区间可以分成两部分，一部分为起点在 间的区间，另一部分为起点在 的区间，在这两个区间中分别找最大值插入堆中。对于以每个位置为右端点的区间，我们维护四元组 ，代表右端点位置，左端点的左右界，以及在此左右界中的最大差值。一开始插入以每个位置为右端点的区间中和最大的区间，随后每次弹出最大区间，将这个四元组拆成两部分，即若当前四元组为 ，左端点取 时得到最大差值，以后不能取 ，将四元组拆为 和 ，其中 和 分别表示左端点在 和 间时的最大差值。如此即可在 的时间内找到前 大差值的和。 Code12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;#define MAX_N 500000#define LOG Log[t-s]using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, L, R, s[MAX_N+5], st[MAX_N+5][25], Log[MAX_N+5];struct node {int p, l, r, val; bool operator &lt; (const node &amp;t) const {return t.val &gt; val;}} ;priority_queue &lt;node&gt; que;int Min(int a, int b) {return s[a] &lt; s[b] ? a : b;}int query(int s, int t) {return s &gt; t ? -1 : Min(st[s][LOG], st[t-(1&lt;&lt;LOG)+1][LOG]);}int main() { read(n), read(m), read(L), read(R); lnt ans = 0; for (int i = 2; i &lt;= n; i++) Log[i] = Log[i&gt;&gt;1]+1; for (int i = 1; i &lt;= n; i++) read(s[i]), s[i] += s[i-1], st[i][0] = i; for (int j = 1; (1&lt;&lt;j) &lt;= n; j++) for (int i = 0; i &lt;= n-(1&lt;&lt;j)+1; i++) st[i][j] = Min(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]); for (int i = L; i &lt;= n; i++) que.push((node){i, max(i-R, 0), i-L, s[i]-s[query(max(i-R, 0), i-L)]}); for (int i = 1, t, p; i &lt;= m; i++) { node tp = que.top(); que.pop(), ans += tp.val, p = tp.p; int ll = tp.l, rr = tp.r, lr = query(ll, rr)-1, rl = query(ll, rr)+1; if (~(t = query(ll, lr))) que.push((node){p, ll, lr, s[p]-s[t]}); if (~(t = query(rl, rr))) que.push((node){p, rl, rr, s[p]-s[t]}); } return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>NOI</tag>
        <tag>ST表</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3784 树上的路径]]></title>
    <url>%2FBZOJ3784%20%E6%A0%91%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84%20%E7%82%B9%E5%88%86%E6%B2%BB%2BST%E8%A1%A8%2B%E5%A0%86%2F</url>
    <content type="text"><![CDATA[Problem树上的路径 Description给定一个 个结点的树，结点用正整数 编号，每条边有一个正整数权值。用 表示从结点 到结点 路边上经过边的权值，其中要求 。将这 个距离从大到小排序，输出前 个距离值。 Input第一行两个正整数 。下面 行，每行三个正整数 ，表示结点 到结点 有一条权值为 的边。 Output共 行，如题所述。 Sample Input123455 101 2 11 3 22 4 32 5 4 Sample Output123456789107765443321 Hint 标签：点分治序 ST表 堆 Solution 超 级 钢 琴 的加强版，将问题移到了树上。 对于关系到树上所有路径的问题，一般用点分治解决。此题需要用到点分治序。点分时，记录下每个分治中心，并在从分治中心向外 的过程中记录下走到结点的顺序，这样的排列叫做点分治序。其实就是点分树上的 序中插入每个点子树的 序。 对于一个分治中心 ，其在点分治序上的第 个位置出现，并且从 开始做 ，每个子树的 序分别在位置区间 ， ， ……对于 第 个子树中的一点 ，以 为起点，其路径另一端点只能落在点分治序位置区间 内，发现以每个点为一端，形成的路径的另一端在点分治序上一定对应一个区间。 这样问题又转化到了数列上，即已知对于每个数 ，其二元组 中另一个数 的范围 ，二元组 的权值为 ，求前 大的二元组权值。 这个问题可以用类似BZOJ2006的方法解决，在此不再赘述。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAX_N 50000#define MAX_M 800000#define LOG Log[t-s]using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, k, rt, tot;int sz[MAX_N+5], w[MAX_N+5], L[MAX_M+5], R[MAX_M+5];int d[MAX_M+5], st[MAX_M+5][25], Log[MAX_M+5];struct node {int p, l, r, val; bool operator &lt; (const node &amp;t) const {return t.val &gt; val;}} ;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5]; bool mrk[MAX_N+5]; priority_queue &lt;node&gt; que;void insert(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, c);}void getrt(int u, int fa) { sz[u] = 1, w[u] = 0; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v]) getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]); if ((w[u] = max(w[u], tot-sz[u])) &lt; w[rt]) rt = u;}void getdis(int u, int fa, int dis) { d[++m] = dis, L[m] = L[m-1]; if (!R[m]) R[m] = R[m-1]; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v]) getdis(v, u, dis+E[u][i]);}void DFS(int u) { d[++m] = 0, L[m] = m, R[m] = m-1, mrk[u] = true; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (!mrk[v = G[u][i]]) R[m+1] = m, getdis(v, u, E[u][i]); for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (!mrk[v = G[u][i]]) w[rt = 0] = tot = sz[v], getrt(v, u), DFS(rt);}int Max(int a, int b) {return d[a] &gt; d[b] ? a : b;}void init_ST() { for (int i = 2; i &lt;= m; i++) Log[i] = Log[i&gt;&gt;1]+1; for (int i = 1; i &lt;= m; i++) st[i][0] = i; for (int j = 1; (1&lt;&lt;j) &lt;= m; j++) for (int i = 1; i &lt;= m-(1&lt;&lt;j)+1; i++) st[i][j] = Max(st[i][j-1], st[i+(1&lt;&lt;(j-1))][j-1]);}int query(int s, int t) {return s &gt; t ? -1 : Max(st[s][LOG], st[t-(1&lt;&lt;LOG)+1][LOG]);}int main() { read(n), read(k); for (int i = 1, u, v, c; i &lt; n; i++) read(u), read(v), read(c), addedge(u, v, c); w[rt = 0] = tot = n, getrt(1, 0), DFS(rt), init_ST(); for (int i = 1; i &lt;= m; i++) if (L[i] &lt;= R[i]) que.push((node){i, L[i], R[i], d[i]+d[query(L[i], R[i])]}); for (int i = 1, t, p; i &lt;= k; i++) { node tp = que.top(); que.pop(), p = tp.p, printf("%d\n", tp.val); int ll = tp.l, rr = tp.r, lr = query(ll, rr)-1, rl = query(ll, rr)+1; if (~(t = query(ll, lr))) que.push((node){p, ll, lr, d[p]+d[t]}); if (~(t = query(rl, rr))) que.push((node){p, rl, rr, d[p]+d[t]}); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>树分治</tag>
        <tag>ST表</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3219 巡游]]></title>
    <url>%2FBZOJ3219%20%E5%B7%A1%E6%B8%B8%20%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%2B%E7%82%B9%E5%88%86%E6%B2%BB%2B%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Problem巡游 Description 国正在准备每年一次的巡游活动。国王将会在一个城市 里召集人群，沿着城市间的道路进行游览，最终在一个城市 里发表他每年一次的著名演讲。 国有 个城市，由于国家的特殊要求，每两个城市之间存在一条唯一的简单通路。国王希望借着这个机会视察 国的城市建设，因此他提出 到 的距离不能少于 条道路。同时，国王的私人医生检查了他的身体情况后，断定国王的身体不适合做长途旅行，因此他要求 到 的距离不能多于 条道路。另外，政府希望跟随国王的人民沿途不仅能看到城市风景，还能看到城市外的美丽乡村。因此每条道路定义了一个魅力值 ，一条路径的魅力值定义为这条路径的中位数。更详细的说法是这样的：将路径上所有边的魅力值排序，得到序列 。假设 ，中位数就是 。你的任务就是求出魅力值最大的路径，并输出这个魅力值。 Input第一行是三个整数 ，表示 国的城市个数、路径的最小和最大长度。接下来 行，每行 个整数 ，表示有一条连接 和 且魅力值 的道路。 Output仅一行，表示最大的魅力值。如果不存在这样的路径，输出 。 Sample Input123455 1 41 2 11 3 43 4 73 5 2 Sample Output17 HINT对于 的数据： ， ， 。 标签：点分治 二分答案 单调队列 Solution稍有码量的点分题。 首先策略是 二 分 答 案 点 分 治 验 证 ，二分答案魅力值，将所有的边权变为 和 ，分别表示大于等于魅力值和小于魅力值。这样验证问题转化为判断是否有一条长度在 间路径使得边权和大于等于 。 这个判断过程可以用点分治实现。对于每个分治中心，只考虑经过其的路径。在其点分树的不同子树中找两个点，使得其到分治中心的路径长度和在 之间，可以用两个桶，分别存已枚举的子树和当前子树中各个深度的最大路径边权和，需要用单调队列维护一下。这部分有些细节需要注意。 此题卡常，注意一些减小常数的细节： 二分答案时，将原边权记下来排序，在排好的数组上二分，这样只会二分到边权值 一开始将点分树记下来，记录所有分治中心，这样每次二分 可以不用重新找重心 点分时在当前分治中心统计答案时用 预处理点分时在当前分治中心 ，若下一个点的距离大于 则退出 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define mid ((l+r)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, L, R, rt, cnt, ind, tot, f[MAX_N+5], g[MAX_N+5];int pr[MAX_N+5], sz[MAX_N+5], w[MAX_N+5], dfn[MAX_N+5];int val[MAX_N+5], dep[MAX_N+5], d[MAX_N&lt;&lt;1], ord[MAX_N+5];bool mrk[MAX_N+5], vis[MAX_N+5]; queue &lt;int&gt; que, bin;struct edge {int v, c, w, nxt;} E[MAX_N&lt;&lt;1];bool cmp(const int &amp;x, const int &amp;y) {return d[x] &lt; d[y];}void insert(int u, int v, int c) {E[cnt] = (edge){v, c, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, c);}void getrt(int u, int fa) { sz[u] = 1, w[u] = 0; for (int i = pr[u], v; ~i; i = E[i].nxt) if (((v = E[i].v) ^ fa) &amp;&amp; !mrk[v]) getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]); if ((w[u] = max(w[u], tot-sz[u])) &lt; w[rt]) rt = u;}void init(int u) { int num = 0; dfn[++ind] = u, mrk[u] = true; for (int i = pr[u], v, mxd = 0; ~i; i = E[i].nxt, mxd = 0) if (!mrk[v = E[i].v]) { while (!que.empty()) que.pop(); memset(vis, false, sizeof vis); que.push(v), dep[v] = 1, vis[v] = true; while (!que.empty()) { int p = que.front(); que.pop(); if (dep[p] &gt;= R) continue; mxd = max(mxd, dep[p]); for (int j = pr[p], q; ~j; j = E[j].nxt) if (!mrk[q = E[j].v] &amp;&amp; !vis[q]) que.push(q), dep[q] = dep[p]+1, vis[q] = true; } d[ord[++num] = i] = mxd; } else d[ord[++num] = i] = n; sort(ord+1, ord+num+1, cmp), pr[u] = ord[1]; for (int i = 1; i &lt; num; i++) E[ord[i]].nxt = ord[i+1]; E[ord[num]].nxt = -1; for (int i = pr[u], v; ~i; i = E[i].nxt) if (sz[u] &lt; sz[v = E[i].v]) sz[v] = tot-sz[u]; for (int i = pr[u], v; ~i; i = E[i].nxt) if (!mrk[v = E[i].v] &amp;&amp; sz[v] &gt; L) w[rt = 0] = tot = sz[v], getrt(v, u), init(rt);}bool DFS(int stp) { if (stp &gt; ind) return false; int u = dfn[stp], mxd = 0; f[0] = 0, mrk[u] = true; for (int i = pr[u], v; ~i; i = E[i].nxt) if (!mrk[v = E[i].v]) { int s = 1, t = 0; while (!que.empty()) que.pop(); while (!bin.empty()) bin.pop(); memset(vis, false, sizeof vis); for (int j = mxd; j &gt;= L; d[++t] = j--) while (s &lt;= t &amp;&amp; f[d[t]] &lt;= f[j]) t--; que.push(v), dep[v] = 1, g[v] = E[i].c, vis[v] = true; while (!que.empty()) { int p = que.front(); que.pop(), bin.push(p); while (s &lt;= t &amp;&amp; d[s]+dep[p] &gt; R) s++; if (dep[p] &lt;= L) { while (s &lt;= t &amp;&amp; f[d[t]] &lt;= f[L-dep[p]]) t--; d[++t] = L-dep[p]; } if (s &lt;= t &amp;&amp; f[d[s]]+g[p] &gt;= 0) return true; if (dep[p] &gt;= R) continue; mxd = max(mxd, dep[p]); for (int j = pr[p], q; ~j; j = E[j].nxt) if (!mrk[q = E[j].v] &amp;&amp; !vis[q]) que.push(q), dep[q] = dep[p]+1, g[q] = g[p]+E[j].c, vis[q] = true; } for (int x; !bin.empty(); bin.pop()) x = bin.front(), f[dep[x]] = max(f[dep[x]], g[x]); } for (int i = 0; i &lt;= mxd; i++) f[i] = -n; return DFS(stp+1);}bool chk(int tans) { for (int i = 0; i &lt; cnt; i++) E[i].c = E[i].w &lt; tans ? -1 : 1; for (int i = 0; i &lt;= n; i++) f[i] = -n; memset(mrk, false, sizeof mrk); return DFS(1);}int bi_search(int l, int r) { int ret = -1; while (l &lt;= r) if (!chk(val[mid])) r = mid-1; else ret = val[mid], l = mid+1; return ret;}int main() { read(n), read(L), read(R), memset(pr, -1, sizeof pr); for (int i = 1, u, v, c; i &lt; n; i++) read(u), read(v), read(c), addedge(u, v, c), val[i] = c; w[rt = 0] = tot = n, getrt(1, 0), init(rt); sort(val+1, val+n), m = (int)(unique(val+1, val+n)-val-1); return printf("%d\n", bi_search(1, m)), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>二分答案</tag>
        <tag>树分治</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4974【Lydsy月赛201708】字符串大师]]></title>
    <url>%2FBZOJ4974%E3%80%90Lydsy1708%E6%9C%88%E8%B5%9B%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B8%88%20KMP%2B%E8%B4%AA%E5%BF%83%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[Problem【Lydsy1708月赛】字符串大师 Description一个串 是 的循环节，当且仅当存在正整数 ，使得 是 重复 次的前缀，比如abcd是abcdabcdab的循环节。给定一个长度为 的仅由小写字符构成的字符串 ，请对于每个 ，求出 长度为 的前缀的最短循环节的长度 。字符串大师 小 觉得这个问题过于简单，于是花了一分钟将其 了，他想检验你是否也是字符串大师。 小 告诉你 以及 ，请找到一个长度为 的小写字符串 ，使得 能对应上 。 Input第一行包含一个正整数 ，表示字符串的长度。第二行包含 个正整数 ，表示每个前缀的最短循环节长度。输入数据保证至少存在一组可行解。 Output输出一行一个长度为 的小写字符串 ，即某个满足条件的 。若有多个可行的 ，输出字典序最小的那一个。 Sample Input1251 2 2 2 5 Sample Output1ababb SourceClaris原创，本 版权所有，翻版必究 标签：KMP 贪心 构造 Solution 好题。 本文中所有数组和字符串下标从 开始。 首先有一个结论： 证明：对于字符串 ，其最短循环节为 ，除去循环节后多余的部分为 ，如图所示。 那么再在上面接一个 ，一定可以包含 ，于是可以知道 一定是 的前缀，所以有下图： 将 末尾循环节长度那么长去掉，得到 ，将 第一个循环节去掉，得到 ，发现两者是相同的（如下图）。而这显然是 的 ，所以 的末尾位置为 ，即 这样根据给出的 可以将 数组处理出来。从前往后构造，对于位置 ： ，一定有 ，可以直接赋值 ，那么在计算 的过程中，即将这个串与自己做匹配的时候，不断根据 向前跳到的位置一定不会和当前位置匹配，否则 最 先 能 匹 配 的 位 置 。于是将能向前跳到的位置上的字符存下来，找一个最小的没有跳到过的字符作为这一位置的字符 如此贪心构造即可得到最优解。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, nxt[MAX_N+5], s[MAX_N+5]; bool mrk[26];int main() { read(n); for (int i = 0; i &lt; n; i++) read(nxt[i]), nxt[i] = i-nxt[i]; for (int p = 1; p &lt; n; p++) { if (~nxt[p]) s[p] = s[nxt[p]]; else { memset(mrk, false, sizeof mrk); for (int q = nxt[p-1]; ~q; q = nxt[q]) mrk[s[q+1]] = true; for (int c = 1; c &lt; 26; c++) if (!mrk[c]) {s[p] = c; break;} } } for (int i = 0; i &lt; n; i++) printf("%c", 'a'+s[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>字符串</tag>
        <tag>构造</tag>
        <tag>KMP</tag>
        <tag>Lydsy月赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3697 采药人的路径]]></title>
    <url>%2FBZOJ3697%20%E9%87%87%E8%8D%AF%E4%BA%BA%E7%9A%84%E8%B7%AF%E5%BE%84%20%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem采药人的路径 Description采药人的药田是一个树状结构，每条路径上都种植着同种药材。采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。他想知道他一共可以选择多少种不同的路径。 Input第 行包含一个整数 。接下来 行，每行包含三个整数 ，表示 到 这条路上药材的类型为 。 Output输出符合采药人要求的路径数目。 Sample Input123456771 2 03 1 12 4 05 2 06 3 15 7 1 Sample Output11 HINT对于 的数据， 。 标签：点分治 Solution点分治基础题。 每次找重心作分治中心，同一子树内的路径数递归计算，只考虑经过当前分治中心的路径数。对于当前分治中心，处理出其余未分治到的点与其的路径上有多少阴性和阳性道路。设阴性道路边权为 ，阳性为 ，那么若两个点到分治中心的路径拼起来可以构成一条合法道路，一定需要满足两个条件： 路径总长为 在两条路径中一定有至少一条在路径上存在两个点，使得分治中心到这个两点的长度相同，并且这个长度不为 。特殊情况是两条路径的长度都为 也可。 用 表示现在枚举到的子树中，与当前分治中心距离为 的路径上有/没有两个离分治中心距离相同的点的路径条数；用 表示同样的意义，只是是在前面已枚举的子树中这样的路径条数。那么从当前子树和前面的子树各选一条路径，拼成新路径，这样对答案的贡献是 。除此之外还需要加上两条不同子树中到分治中心长为 的路径组成的路径条数，即 。 点分时每次 预处理 , 统计即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;#define MAX_N 500000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, rt, tot, cnt[(MAX_N&lt;&lt;1)+5]; lnt ans;int sz[MAX_N+5], w[MAX_N+5], dis[MAX_N+5];int f[(MAX_N&lt;&lt;1)+5][2], g[(MAX_N&lt;&lt;1)+5][2];vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5]; bool mrk[MAX_N+5];void insert(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void addedge(int u, int v, int c) {if (!c) c = -1; insert(u, v, c), insert(v, u, c);}void getrt(int u, int fa) { sz[u] = 1, w[u] = 0; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v]) getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]); if ((w[u] = max(w[u], tot-sz[u])) &lt; w[rt]) rt = u;}int getdis(int u, int fa, int dep) { int ret = dep; f[dis[u]][cnt[dis[u]]&gt;0]++, cnt[dis[u]]++; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v]) dis[v] = dis[u]+E[u][i], ret = max(ret, getdis(v, u, dep+1)); cnt[dis[u]]--; return ret;}void DFS(int u) { int r = 0; mrk[u] = true, g[n][0] = 1; for (int i = 0, v, d; i &lt; (int)G[u].size(); i++) if (!mrk[v = G[u][i]]) { dis[v] = n+E[u][i], d = getdis(v, u, 1); r = max(r, d), ans += 1LL*f[n][0]*(g[n][0]-1); for (int j = -d; j &lt;= +d; j++) ans += 1LL*f[n+j][1]*g[n-j][1], ans += 1LL*f[n+j][0]*g[n-j][1], ans += 1LL*f[n+j][1]*g[n-j][0]; for (int j = -d; j &lt;= +d; j++) g[n+j][0] += f[n+j][0], f[n+j][0] = 0, g[n+j][1] += f[n+j][1], f[n+j][1] = 0; } for (int i = -r; i &lt;= +r; i++) g[n+i][0] = g[n+i][1] = 0; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (!mrk[v = G[u][i]]) w[rt = 0] = tot = sz[v], getrt(v, u), DFS(rt);}int main() { read(n); for (int i = 1, u, v, c; i &lt; n; i++) read(u), read(v), read(c), addedge(u, v, c); w[rt = 0] = tot = n, getrt(1, 0), DFS(rt); return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4174 tty的求助]]></title>
    <url>%2FBZOJ4174%20tty%E7%9A%84%E6%B1%82%E5%8A%A9%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[Problemtty的求助 Description求 ，其中 为实数。 Input输入仅有一行。第一行仅有两个正整数 和一个实数 。 Output输出共一行，由于结果过大，所以请输出上式对 取模的结果。 Sample Input12 3 1 Sample Output17 Explanation当 时， 当 时， 当 时， 当 时， 当 时， 当 时， 所以答案是 HINT ， ， 精确到小数点后8位。 标签：莫比乌斯反演 Solution 对于最后一次求和： 先考虑前一项：设 ，那么 。于是有 ，即可知 。 对于 取遍 ， 的值依次为 。由于 与 互质，所以 一定取遍 ，因而 一定取遍 。故而有 又发现 ，故 对于后两项： 将三项和前面两个求和连起来： 对前面的和式做莫比乌斯反演： 直接枚举 数论分块即可，总时间复杂度约为 。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAX_N 500000#define MOD 998244353#define inv2 499122177using namespace std;typedef double dnt;typedef long long lnt;bool NotPri[MAX_N+5]; dnt x;int n, m, cnt, pri[MAX_N+5], mu[MAX_N+5];void init() { mu[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) mu[i*pri[j]] = -mu[i]; else {mu[i*pri[j]] = 0; break;} } } for (int i = 2; i &lt;= MAX_N; i++) mu[i] += mu[i-1];}lnt calc(int n, int m) { lnt ret = 0LL; for (int l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), (ret += 1LL*(mu[r]-mu[l-1])*(n/l)%MOD*(m/l)%MOD) %= MOD; return ret;}int main() { scanf("%d%d%lf", &amp;n, &amp;m, &amp;x), init(); lnt sn = 1LL*n*(n+1)/2%MOD, sm = 1LL*m*(m+1)/2%MOD; lnt ans = sn*sm%MOD-1LL*m*sn%MOD-1LL*n*sm%MOD; for (int d = 1; d &lt;= min(n, m); d++) (ans += (2LL*d*(lnt)(x/d)+d)%MOD*calc(n/d, m/d)%MOD) %= MOD; return printf("%lld\n", (ans*inv2%MOD+MOD)%MOD), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3994【SDOI2015】约数个数和]]></title>
    <url>%2FBZOJ3994%E3%80%90SDOI2015%E3%80%91%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2015】约数个数和 Description设 为 的约数个数，给定 ，求 Input输入文件包含多组测试数据。第一行，一个整数 ，表示测试数据的组数。接下来的 行，每行两个整数 。 Output 行，每行一个整数，表示你所求的答案。 Sample Input12327 45 6 Sample Output12110121 HINT 标签：莫比乌斯反演 Solution挺神的反演，没推出来，需要一个结论。 首先考虑如何把 变为我们更为熟悉的数学语言。对于 ，考虑 的约数，每个约数均可表示为 ，其中 。那么用 统计约数，一定会不漏地枚举到所有约数，但显然是有重复的。注意到这种重复的造成只有一种情况，即若 符合条件，那么 也符合条件，而两者所代表的最终约数是相同的，重复计数。也就是说只要 ，那么一定是重复计算的。于是不重不漏地计算只需要把 中的 加上 的限制即可。因此推出重要结论 。 接下来就可以推反演了： 如果能预处理出 的值，就可以根号分块计算答案。 考虑 的意义，即枚举一个数，统计其在 内的倍数有多少个，可以理解为枚举约数，计算它在 中是多少个数的约数，即计算其对 的贡献。于是 ，我们需要预处理出 。 由于 是积性函数，对于 是 质 数 ，我们有： ： ： ，其中 一定为 的最小质因子 为了应对情况 ，我们需要预处理最小质因子次数 ，注意到 也可以线性筛预处理： 对于质数 ， 对于正整数 和质数 ， ： ： 如此我们即可线性筛预处理出 ，计算 前缀和 ，对于询问进行数论分块统计答案，时间复杂度 。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAX_N 50000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}bool NotPri[MAX_N+5]; int pri[MAX_N+5], cnt;lnt mu[MAX_N+5], c[MAX_N+5], d[MAX_N+5], ans;void init() { mu[1] = 1, d[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1, c[i] = 1, d[i] = 2; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) mu[i*pri[j]] = -mu[i], c[i*pri[j]] = 1, d[i*pri[j]] = d[i]*d[pri[j]]; else mu[i*pri[j]] = 0, c[i*pri[j]] = c[i]+1, d[i*pri[j]] = d[i]*(c[i]+2)/(c[i]+1); if (i%pri[j] == 0) break; } } for (int i = 2; i &lt;= MAX_N; i++) mu[i] += mu[i-1], d[i] += d[i-1];}int main() { int n, m, T; read(T), init(); while (T--) { read(n), read(m), ans = 0; for (int l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), ans += (mu[r]-mu[l-1])*d[n/l]*d[m/l]; printf("%lld\n", ans); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3626【LNOI2014】LCA]]></title>
    <url>%2FBZOJ3626%E3%80%90LNOI2014%E3%80%91LCA%20%E7%A6%BB%E7%BA%BF%2B%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[Problem【LNOI2014】LCA Description给出一个 个节点的有根树（编号为 到 ，根节点为 ）。一个点的深度定义为 这 个 节 点 到 根 的 距 离 。设 表示点 的深度， 表示 与 的最近公共祖先。有 次询问，每次询问给出 ，求 。 Input第一行 个整数 。接下来 行，分别表示点 到点 的父节点编号。接下来 行，每行 个整数 。 Output输出 行，每行表示一个询问的答案。每个答案对 取模输出 Sample Input12345675 200111 4 31 4 2 Sample Output1285 HINT共 组数据， 与 的规模分别为 , , , , 。 Source数据已加强 saffah 标签：树链剖分 Solution傻逼树链剖分，练手居然还 了一发… 首先有一个这样的暴力：对于每个询问，将 到根的路径打标记，枚举 ，每次累加当前节点最近的标记节点的深度。然后发现可以反转一下：对于每个询问，枚举 ，每次将当前结点到根路径上的所有结点权值 ，统计 到根路径上的总权值即可。（权值 相当于深度累加）。这道题没有强制在线，于是可以把所有的询问都离线下来，拆成两个前缀询问 和 分别计算。如果将所有前缀询问按右端点位置排序，不难发现可以依次操作，每次将一个新的结点到根路径上的所有结点权值 ，操作完统计右端点在此结点上的所有前缀询问的答案。注意模完两个前缀答案相减后可能出现负数，需要先加上 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;bits/stdc++.h&gt;#define MOD 201314#define MAX_N 50000#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}vector &lt;int&gt; G[MAX_N+5];struct node {int t, p, id; bool f;} opt[(MAX_N&lt;&lt;1)+5];int n, m, ind, ans[MAX_N+5], tr[MAX_N&lt;&lt;2], tag[MAX_N&lt;&lt;2];int dep[MAX_N+5], fa[MAX_N+5], sz[MAX_N+5], son[MAX_N+5], top[MAX_N+5], dfn[MAX_N+5];bool cmp(const node &amp;x, const node &amp;y) {return x.t &lt;= y.t;}void DFS(int u) { sz[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v == fa[u]) continue; dep[v] = dep[u]+1, fa[v] = u, DFS(v), sz[u] += sz[v]; if (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v; }}void DFS(int u, int tp) { top[u] = tp, dfn[u] = ++ind; if (son[u]) DFS(son[u], tp); for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (((v = G[u][i])^fa[u]) &amp;&amp; (v^son[u])) DFS(v, v);}void update(int v) {tr[v] = tr[v&lt;&lt;1]+tr[v&lt;&lt;1|1];}void downtag(int v, int s, int t) { if (!tag[v]) return; int x = tag[v]; tag[v] = 0; (tr[v&lt;&lt;1] += x*(mid-s+1)%MOD) %= MOD; (tr[v&lt;&lt;1|1] += x*(t-mid)%MOD) %= MOD; (tag[v&lt;&lt;1] += x) %= MOD, (tag[v&lt;&lt;1|1] += x) %= MOD;}void modify(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) { (tr[v] += x*(t-s+1)%MOD) %= MOD; (tag[v] += x) %= MOD; return; } downtag(v, s, t); if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, x); update(v);}int query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return (tr[v]+MOD)%MOD; int ret = 0; downtag(v, s, t); if (l &lt;= mid) (ret += query(v&lt;&lt;1, s, mid, l, r)) %= MOD; if (r &gt;= mid+1) (ret += query(v&lt;&lt;1|1, mid+1, t, l, r)) %= MOD; return (ret%MOD+MOD)%MOD;}void change(int u) { for (; u; u = fa[top[u]]) modify(1, 1, n, dfn[top[u]], dfn[u], 1);}int getsum(int u) { int ret = 0; for (; u; u = fa[top[u]]) (ret += query(1, 1, n, dfn[top[u]], dfn[u])) %= MOD; return (ret += MOD) %= MOD;}int main() { read(n), read(m); for (int i = 2, x; i &lt;= n; i++) read(x), G[x+1].push_back(i); for (int i = 1, l, r, p; i &lt;= m; i++) read(l), read(r), read(p), opt[i*2-1].p = opt[i*2].p = p+1, opt[i*2-1].id = opt[i*2].id = i, opt[i*2-1].t = l, opt[i*2].t = r+1, opt[i*2-1].f = false, opt[i*2].f = true; sort(opt+1, opt+m*2+1, cmp), DFS(1), DFS(1, 1); for (int i = 1, j = 0; i &lt;= m*2; i++) { while (j &lt; opt[i].t) change(++j); if (opt[i].f) (ans[opt[i].id] += getsum(opt[i].p)) %= MOD; else (ans[opt[i].id] += MOD-getsum(opt[i].p)) %= MOD; } for (int i = 1; i &lt;= m; i++) printf("%d\n", (ans[i]%MOD+MOD)%MOD); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3438 小M的作物]]></title>
    <url>%2FBZOJ3438%20%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem小M的作物 Description 小 在 里开辟了两块巨大的耕地 和 （你可以认为容量是无穷）。现在， 小 有种 作物的种子，每种作物的种子有 个（就是可以种一棵作物）（用 编号），第 种作物种植在 中种植可以获得 的收益，在 中种植可以获得 的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益。 小 找到了规则中共有 种作物组合，第 个组合中的作物共同种在 中可以获得 的额外收益，共同总在 中可以获得 的额外收益。 小 很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？ Input第一行包括一个整数 第二行包括 个整数，表示 第三行包括 个整数，表示 第四行包括一个整数 接下来 行，第 行依次输入： 一个整数 ，表示第 个作物组合中共有 种作物 两个整数 ，表示两种收益分别是多少 个整数，表示该组合中的作物编号 Output只有一行，包括一个整数，表示最大收益 Sample Input1234534 2 12 3 212 3 2 1 2 Sample Output111 Explanation 耕地种 ， 耕地种 ，收益 HINT , ，保证所有数据及结果不超过 标签：最小割 Solution文理分科加强版，建模稍有变化。 首先容易想到将每个作物作为结点，对于作物 ，连接 容量 ，连接 容量 。割掉一条边表示不选对应的那片田，就可以以最小割的形式处理只考虑选 和选 收益，不考虑集团收益的问题。 对于每个组合，由于作物个数很多，不能像文理分科一样把失去的收益拆到 和 上。这里可以建立辅助结点，即给每个组合建立结点。由于存在两种贡献，需要拆成两个节点 和 ，连接 容量 ， 容量 。以 为例， 需要被割去当且仅当此组合中任意作物选择 而非 ，即此组合中存在作物 ， 并未被割掉。因此需要串联，即从 连边到此组合中的所有作物，容量 （从中间割断是没有意义的）。对应地， 的连法相同。 建模： 对于每个作物 ，连接 容量 ， 容量 对于每个组合 ，建立结点 ，连接 容量 ， 容量 对于每个组合 ，设其内作物为 ，那么对每个作物 ，连接 容量 ， 容量 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAX_N 4000#define MAX_M 5000000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, s, t, cnt, sum, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5];void init() {s = 0, t = 4000, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}int main() { read(n), init(); for (int i = 1, x; i &lt;= n; i++) read(x), addedge(s, i, x), sum += x; for (int i = 1, x; i &lt;= n; i++) read(x), addedge(i, t, x), sum += x; read(m); for (int i = 1, c1, c2, k; i &lt;= m; i++) { read(k), read(c1), read(c2), sum += c1+c2; addedge(s, n+i*2-1, c1), addedge(n+i*2, t, c2); for (int j = 0, x; j &lt; k; j++) read(x), addedge(n+i*2-1, x, INF), addedge(x, n+i*2, INF); } return printf("%d\n", sum-Dinic()), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2440【中山市选2011】完全平方数]]></title>
    <url>%2FBZOJ2440%E3%80%90%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892011%E3%80%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20%E4%BA%8C%E5%88%86%2B%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%AE%B9%E6%96%A5%2F</url>
    <content type="text"><![CDATA[Problem【中山市选2011】完全平方数 Description小 自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。这天是小 的生日，小 想送一个数给他作为生日礼物。当然他不能送一个小 讨厌的数。他列出了所有小 不讨厌的数，然后选取了第 个数送给了小 。小 很开心地收下了。然而现在小 却记不起送给小 的是哪个数了。你能帮他一下吗？ Input包含多组测试数据。文件第一行有一个整数 ，表示测试数据的组数。第 至第 行每行有一个整数 ，描述一组数据，含义如题目中所描述。 Output含 行，分别对每组数据作出回答。第 行输出相应的第 个不是完全平方数的正整数倍的数。 Sample Input1234541131001234567 Sample Output12341191632030745 HINT对于 的数据有 标签：二分答案 莫比乌斯容斥 Solution 没做起水题… 似乎答案不超过 ？不会证。 二分答案，对于当前尝试的答案 ，统计 以下有多少个符合条件的数。 符 合 条 件 的 数 的 个 数 完 全 平 方 数 的 倍 数 的 个 数 容易发现为了避免算重复，可以约数容斥来算。另外，如果完全平方数的底数有平方因子，一定不会产生贡献。设所有质数的集合为 ，所有由两个不同质数相乘而得数的集合为 ，…，由 个不同质数相乘而得的数的集合为 ，那么符合条件的数的个数为： 发现上面的式子可以用莫比乌斯函数简化，即 这样每次用 时间 ，总复杂度为 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 50000#define mid (l+((r-l)&gt;&gt;1))using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}bool NotPri[MAX_N+5];int pri[MAX_N+5], mu[MAX_N+5], cnt;void init() { mu[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) mu[i*pri[j]] = -mu[i]; else {mu[i*pri[j]] = 0; break;} } }}bool chk(int n, int k) { int rk = 0; for (int i = (int)sqrt(n); i; i--) rk += mu[i]*(n/i/i); return rk &gt;= k;}void sol(int k) { int l = 1, r = 2*k, ans = -1; while (l &lt;= r) if (!chk(mid, k)) l = mid+1; else ans = mid, r = mid-1; printf("%d\n", ans);}int main() { int T, k; read(T), init(); while (T--) read(k), sol(k); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
        <tag>二分</tag>
        <tag>容斥</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1061【NOI2008】志愿者招募]]></title>
    <url>%2FBZOJ1061%E3%80%90NOI2008%E3%80%91%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%BD%AC%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【NOI2008】志愿者招募 Description申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要 天才能完成，其中第 天至少需要 个人。布布通过了解得知，一共有 类志愿者可以招募。其中第 类可以从第 天工作到第 天，招募费用是每人 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。 Input第一行包含两个整数 ，表示完成项目的天数和可以招募的志愿者的种类。接下来的一行中包含 个非负整数，表示每天至少需要的志愿者人数。接下来的 行中每行包含三个整数 ，含义如上文所述。为了方便起见，我们可以认为每类志愿者的数量都是无限多的。 Output仅包含一个整数，表示你所设计的最优方案的总费用。 Sample Input123453 32 3 41 2 22 3 53 3 2 Sample Output114 HINT ， ，题目中其他所涉及的数据均不超过 。 标签：线性规划 费用流 Solution经典线性规划转网络流。 由题意可知，共会有 个限制条件，还有一个需要最小化的表达式。以样例作例子，第 种招募 人，则有 接着设三个辅助变量 ，使得 在最前面和最后面加入两个 ，差分一下，得到 发现每个变量只出现两次，并且正、负各一次。这个性质其实一定成立。因为每种志愿者只在一个区间内出现，即每个变量只会在连续的式子中出现，这样差分后就会只剩一次正和一次负。辅助变量也有这个性质是显然的。如果将每个式子看成一个结点，等式可以看作这个点的流量平衡方程。将正看成出流，负看成入流，即可构图。例如，对于 ，其在第二个式子中出现正，在第四个式子中出现负，可以想成是从二号结点流出的 流量进入四号结点。对于辅助变量也是一样。而对于每个式子中的常数项，可以看成从源点流出或流入汇点，即若移到左边后为负，则为从源点流出这么多流量；若为正，则为向汇点流这么多流量。这样一来，根据费用流一定跑出最大流（废话），跑出的流一定满足流量平衡方程（废话 2），最后跑出的方案一定能满足所有限制。如果加上边权（即所要取最小值的式子的系数），可以跑最小费用最大流解出最小值。 建模： 对于 ， 若 ，连接 ，容量 ，单位费用 若 ，连接 ，容量 ，单位费用 对于一种志愿者 ，连接 ，容量 ，单位费用 辅助变量：对于 ，连接 ，容量 ，单位费用 跑最小费用最大流即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define MAX_N 2000#define MAX_M 50000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node {int v, c, w, nxt;} E[MAX_M+5]; int a[MAX_N+5];void init() {s = 0, t = n+2, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]*flow; return true;}int main() { read(n), read(m), init(); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= n+1; i++) if (a[i] &gt;= a[i-1]) addedge(s, i, a[i]-a[i-1], 0); else addedge(i, t, a[i-1]-a[i], 0); for (int i = 1, u, v, w; i &lt;= m; i++) read(u), read(v), read(w), addedge(u, v+1, INF, w); for (int i = 2; i &lt;= n+1; i++) addedge(i, i-1, INF, 0); while (SPFA()) ; return printf("%d\n", mic), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>线性规划</tag>
        <tag>费用流</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4299 FRBSUM]]></title>
    <url>%2FBZOJ4299%20FRBSUM%20%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ProblemFRBSUM Description数集 的 定义为无法用 的某个子集（可以为空）的和表示的最小的非负整数。例如， ，则它的子集和中包含 ， ， ， ， ， ，但是它无法得到 。因此 的 为 。给定一个序列 ，你的任务是回答该数列的一些子区间所形成的数集的 是多少。 Input输入数据的第一行包含一个整数 ，表示序列的长度。接下来一行包含 个数，表示给定的序列 （从 标号）。接下来一行包含一个整数 ，表示询问的组数。接下来 行，每行一对整数，表示一组询问。 Ouput对于每组询问，输出一行表示对应的答案。 Sample Input1234567851 2 4 9 1051 11 21 31 41 5 Sample Output1234524888 Hint对于 的数据， , , 。 SourceBy yts1999 标签：主席树 Solution本题和【FJOI2016】神秘数相同，双倍经验。 首先不难发现一个结论，若某集合当前能凑出 中的所有数，加入一个数 ，可凑出的数的值域扩展当且仅当 ，并且会将值域扩展到 。如此，对于每个区间 ，从小到大逐一将每个数加入到集合中，像上面那样不断扩展值域，如果加入某个数时 ，值域无法继续扩充，那么 即为最小的不能凑成的数。这个过程可以用一棵值域主席树维护，每次将所有小于等于 的数求和，作为新的 ，若 在某次这样的操作中不变，则无法继续扩展，输出答案 。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define INF 1000000000#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, rt[MAX_N+5], cnt;struct node {int ls, rs, s;} tr[MAX_N*32];void modify(int v, int o, int s, int t, int p) { tr[v] = tr[o], tr[v].s += p; if (s == t) return; if (p &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, p); else modify(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, p);}int query(int l, int r, int s, int t, int p) { if (s == t) return tr[r].s-tr[l].s; int lsum = tr[tr[r].ls].s-tr[tr[l].ls].s; if (p &lt;= mid) return query(tr[l].ls, tr[r].ls, s, mid, p); return lsum+query(tr[l].rs, tr[r].rs, mid+1, t, p);}int main() { read(n); for (int i = 1, x; i &lt;= n; i++) read(x), modify(rt[i] = ++cnt, rt[i-1], 1, INF, x); read(m); while (m--) { int l, r; read(l), read(r); for (int mx = 0, lst = 0; ; lst = mx) { mx = query(rt[l-1], rt[r], 1, INF, mx+1); if (mx == lst) {printf("%d\n", mx+1); break;} } } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>CodeChef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4293【PA2015】Siano]]></title>
    <url>%2FBZOJ4293%E3%80%90PA2015%E3%80%91Siano%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【PA2015】Siano Description农夫 买了一片 亩的土地，他要在这上面种草。他在每一亩土地上都种植了一种独一无二的草，其中，第 亩土地的草每天会长高 厘米。 一共会进行 次收割，其中第 次收割在第 天，并把所有高度大于等于 的部分全部割去。 想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？ Input第一行包含两个正整数 ，分别表示亩数和收割次数。第二行包含 个正整数，其中第 个数为 ，依次表示每亩种植的草的生长能力。接下来 行，每行包含两个正整数 ，依次描述每次收割。 Output输出 行，每行一个整数，依次回答每次收割能得到的草的高度总和。 Sample Input1234564 41 2 4 31 12 23 04 4 Sample Output123466180 Explanation第 天，草的高度分别为 ，收割后变为 。第 天，草的高度分别为 ，收割后变为 。第 天，草的高度分别为 ，收割后变为 。第 天，草的高度分别为 ，收割后变为 。 HINT , , 数据保证 ，并且任何时刻没有任何一亩草的高度超过 。 SourceBy Claris 标签：线段树 Solution比较灵活的线段树。 观察题目可以发现一个性质，即长速快的在任意时刻都比长速慢的高度高。这是由于每次修剪都是将所有的剪到同一高度，这样长速快的在修剪后的高度一定大于等于长速慢的在修剪后的高度。 将长速从低到高排序，不会影响询问，并且每次询问剪去的部分一定是一个后缀。那么可以在线段树上分治寻找剪和不剪的分界点，同时累加答案。 对于每个区间需要维护其长速之和、高度和两个基础元素。为了方便询问，需要维护高度的最大和最小值，即该区间最右边和最左边的苗的高度。这样如果当前区间的最大高度 ，可知不用继续递归；如果当前区间最小高度 ，可知整个区间都要修剪，打区间标记后返回。而对于标记，每个区间需要维护三个元素 ，分别表示该区间中的所有高度均变为 ，这个变化发生在 时刻，上一次递归到该区间的时间是 。询问每次递归进入一个区间先计算从上次递归到该区间也就是 到现在总共长了多少，更新信息。注意 和 不能合并为一个变量，这是由于该区间上次被递归到时可能先更新了信息，但是并未打标记，即其下面的子区间没有更新信息，故 和 不同。 一棵线段树即可维护，某些细节注意一下即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define MAX_N 500000#define mid ((s+t)&gt;&gt;1)using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m; lnt a[MAX_N+5], b, d;struct node {lnt v, s, tc, td, ld, lv, rv;} tr[MAX_N&lt;&lt;2];void update(int v) { tr[v].v = tr[v&lt;&lt;1].v+tr[v&lt;&lt;1|1].v; tr[v].s = tr[v&lt;&lt;1].s+tr[v&lt;&lt;1|1].s; tr[v].lv = tr[v&lt;&lt;1].lv, tr[v].rv = tr[v&lt;&lt;1|1].rv;}void downtag(int v, int s, int t) { if (tr[v].tc == -1) return; tr[v&lt;&lt;1].s = tr[v].tc*(mid-s+1); tr[v&lt;&lt;1|1].s = tr[v].tc*(t-mid); tr[v&lt;&lt;1].lv = tr[v&lt;&lt;1].rv = tr[v].tc; tr[v&lt;&lt;1|1].lv = tr[v&lt;&lt;1|1].rv = tr[v].tc; tr[v&lt;&lt;1].tc = tr[v&lt;&lt;1|1].tc = tr[v].tc; tr[v&lt;&lt;1].td = tr[v&lt;&lt;1|1].td = tr[v].td; tr[v&lt;&lt;1].ld = tr[v&lt;&lt;1|1].ld = tr[v].td; tr[v].tc = -1;}void build(int v, int s, int t) { tr[v].tc = -1; if (s == t) {tr[v].v = a[s]; return;} build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t), update(v);}lnt query(int v, int s, int t) { lnt ret = 0LL; tr[v].s += (d-tr[v].ld)*tr[v].v; tr[v].lv += a[s]*(d-tr[v].ld), tr[v].rv += a[t]*(d-tr[v].ld); if (tr[v].lv &gt;= b) { ret = tr[v].s-b*(t-s+1), tr[v].s = b*(t-s+1); tr[v].lv = tr[v].rv = tr[v].tc = b, tr[v].td = d; } else if (tr[v].rv &gt; b) { downtag(v, s, t); ret += query(v&lt;&lt;1, s, mid); ret += query(v&lt;&lt;1|1, mid+1, t); update(v); } return tr[v].ld = d, ret;}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(a[i]); sort(a+1, a+n+1), build(1, 1, n); while (m--) read(d), read(b), printf("%lld\n", query(1, 1, n)); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>PA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1913【APIO2010】信号覆盖]]></title>
    <url>%2FBZOJ1913%E3%80%90APIO2010%E3%80%91%E4%BF%A1%E5%8F%B7%E8%A6%86%E7%9B%96%20%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F%2B%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[Problem【APIO2010】信号覆盖 Description Input输入第一行包含一个正整数 ，表示房子的总数。接下来有 行，分别表示每一个房子的位置。对于， 第 个房子的坐标用一对整数 和 来表示，中间用空格隔开。 Output输出文件包含一个实数，表示平均有多少个房子被信号所覆盖，需保证输出结果与精确值的绝对误差不超过 。 Sample Input1234540 24 40 02 0 Sample Output13.500 HINT 的数据， 的数据， 的数据， 的数据保证，对于 ，第 个房子的坐标 为整数且 。任何三个房子不在同一条直线上，任何四个房子不在同一个圆上。 标签：极角排序 双指针 Solution总体思路是求出所有三元组形成的圆能多覆盖的点的总数 ， 对于任意四点构成的四边形，考虑任选其中任意三点形成的圆能否包括另一个点。有两种情况： 凹四边形：除凹进去的点外另外三点的外接圆可以包括凹进去的点外，其余三元组构成的圆一定不能包括第四点，故贡献为 。 凸四边形：由于不存在共圆四边形，对角和一定一个大于 ，一个小于 。只有对角和大于 的两个角上三点的外接圆能包括另一点，故贡献为 。 因此 凹 四 边 形 数 凸 四 边 形 数 。 接下来考虑如何求两种四边形的个数。由于 凹 四 边 形 数 凸 四 边 形 数 ，我们只用求凹四边形个数即可。枚举每个点，考虑其作为凹四边形凹进去的那个点又多少种情况。易知 情 况 数 含 此 点 的 凸 多 边 形 数 。于是需要求含此点 的凸多边形数。即枚举凸多边形上的另一个点 ，看有多少点 使得 和 的夹角小于 。这个过程可以用极角排序后双指针扫一遍统计。这样 计算出凹多边形数后即可得到最终答案。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define Pi acos(-1)#define x first#define y second#define MAX_N 1500using namespace std;typedef double dnt;typedef long long lnt;typedef pair&lt;dnt,dnt&gt; pdd;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n; lnt c1, c2; pdd p[MAX_N+5];lnt C(int n, int m) { lnt ret = 1LL; if (n &lt; m) return 0LL; for (int i = 1; i &lt;= m; i++) ret *= 1LL*(n-i+1); for (int i = 1; i &lt;= m; i++) ret /= i; return ret;}int main() { read(n); for (int i = 1; i &lt;= n; i++) read(p[i].x), read(p[i].y); for (int i = 1, m = 0; i &lt;= n; i++, m = 0) { lnt tot = 0LL; dnt a[MAX_N*2+5]; for (int j = 1; j &lt;= n; j++) if (i^j) a[++m] = atan2(p[j].y-p[i].y, p[j].x-p[i].x); for (int j = 1; j &lt;= n; j++) if (a[j] &lt; 0) a[j] += 2*Pi; sort(a+1, a+m+1); for (int j = 1; j &lt;= m; j++) a[m+j] = a[j]+2*Pi; for (int u = 1, v = 1; u &lt;= m; tot += C(v-u, 2), u++) while (v &lt; (m&lt;&lt;1) &amp;&amp; a[v+1]-a[u] &lt; Pi) v++; c1 += C(m, 3)-tot; } c2 = C(n, 4)-c1; return printf("%.6lf\n", (dnt)(c1+c2*2)/(dnt)C(n, 3)+3), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>计算几何</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4069【APIO2015】巴厘岛的雕塑 < DP >]]></title>
    <url>%2FBZOJ4069%E3%80%90APIO2015%E3%80%91%E5%B7%B4%E5%8E%98%E5%B2%9B%E7%9A%84%E9%9B%95%E5%A1%91%20DP%2F</url>
    <content type="text"><![CDATA[Problem【APIO2015】巴厘岛的雕塑 Description印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。在这条主干道上一共有 座雕塑，为方便起见，我们把这些雕塑从 到 连续地进行标号，其中第 i 座雕塑的年龄是 年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。下面是将雕塑分组的规则：这些雕塑必须被分为恰好 组，其中 ，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。请问政府能得到的最小的最终优美度是多少? Input输入的第一行包含三个用空格分开的整数 。第二行包含 个用空格分开的整数 。 Output输出一行一个数，表示最小的最终优美度。 Sample Input126 1 38 1 2 1 5 4 Sample Output111 Explanation将这些雕塑分为 组， 和 ，它们的和是 和 ，最终优美度是 。不难验证，这也是最终优美度的最小值。 HINT 子任务编号 分值 标签：DP Solution奇葩的面向数据编程题。 由于算答案是按位或，可以考虑从高位向低位贪心，每次判断在前面的位都取到最优情况下，这一位能否取 。这个判断的过程可以 实现。 表示考虑前 个雕塑，分成 个组，能否在当前位上取 。那么 当且仅当 ，满足 ，并且 和当前答案取或的结果还是当前答案（即不会使得前面位上不为最优解），还需要 在当前位上的值为 （这样当前位才能取 ）。求出所有 后，判断是否 满足 ，如果存在则可以取 ，否则此位取 。 然而这样并不能得满分。上面的方法是 处理出所有 值，不能通过 的 。 而对于 ，发现 ，则每次使得分的组数量尽量小肯定是最优的。于是用 表示当前位考虑前 个雕塑，最少需要分成几组才能使当前位上可以取 。如果在当前位处理 后发现 ，那么必须取 ，否则可以取 。这样复杂度降成了 ，可以解决 。 综上，特判数据分两种情况分别做即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define MAX_N 2000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, A, B; lnt s[MAX_N+5], ans;bool f[MAX_N+5][MAX_N+5]; int g[MAX_N+5];void sub1() { for (int p = m, flag = 1; p; p--, flag = 1) { memset(f, false, sizeof f), f[0][0] = true; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) for (int k = j-1; k &lt; i; k++) if (f[k][j-1]) { if ((((s[i]-s[k])&gt;&gt;p)|ans)^ans) continue; if ((s[i]-s[k])&amp;(1LL&lt;&lt;(p-1))) continue; f[i][j] = true; break; } for (int i = A; i &lt;= B; i++) if (f[n][i]) {flag = 0; break;} (ans &lt;&lt;= 1) |= flag; } printf("%lld\n", ans);}void sub2() { for (int p = m; p; p--) { memset(g, 0x3f, sizeof g), g[0] = 0; for (int i = 1; i &lt;= n; i++) for (int k = 0; k &lt; i; k++) { if ((((s[i]-s[k])&gt;&gt;p)|ans)^ans) continue; if ((s[i]-s[k])&amp;(1LL&lt;&lt;(p-1))) continue; g[i] = min(g[i], g[k]+1); } (ans &lt;&lt;= 1) |= (g[n] &gt; B); } printf("%lld\n", ans);}int main() { read(n), read(A), read(B); for (int i = 1; i &lt;= n; i++) read(s[i]), s[i] += s[i-1]; for (lnt i = s[n]; i; i &gt;&gt;= 1) m++; return (A != 1 ? sub1() : sub2()), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>DP</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4070【APIO2015】雅加达的摩天楼]]></title>
    <url>%2FBZOJ4070%E3%80%90APIO2015%E3%80%91%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC%20%E5%88%86%E5%9D%97%2B%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Problem【APIO2015】雅加达的摩天楼 Description印尼首都雅加达市有 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 到 。除了这 座摩天楼外，雅加达市没有其他摩天楼。有 只叫做 的神秘生物在雅加达市居住，它们的编号依次是 到 。编号为 的 最初居住于编号为 的摩天楼。每只 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 的 的跳跃能力为 。在一次跳跃中，位于摩天楼 而跳跃能力为 的 可以跳跃到编号为 （如果 ）或 （如果 ）的摩天楼。编号为 的 是所有 的首领，它有一条紧急的消息要尽快传送给编号为 的 。任何一个收到消息的 有以下两个选择: 跳跃到其他摩天楼上 将消息传递给它当前所在的摩天楼上的其他 请帮助 们计算将消息从 号 传递到 号 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 号 。 Input输入的第一行包含两个整数 和 。接下来 行，每行包含两个整数 和 。 Output输出一行，表示所需要的最少步数。如果消息永远无法传递到 号 ，输出 。 Sample Input12345 30 21 14 1 Sample Output15 Explanation下面是一种步数为 的解决方案： 号 跳跃到 号摩天楼，再跳跃到 号摩天楼（ 步）。 号 将消息传递给 号 。 号 跳跃到 号摩天楼,接着跳跃到 号摩天楼，再跳跃到 号摩天楼（ 步）。 号 将消息传递给 号 。 HINT 标签：最短路 分块 Solution分块优化最短路建边。新姿势 。 考虑直接建边，由于可以多次跳跃，最多会形成 条边，肯定不行。 正解是给每个结点建立若干个辅助结点，像分块一样把建边数降下来。具体来说，设块大小为 ， 对于 ，连出的边数较少，可以直接连边 对于 ，连出的边数较多，需要对每个点建立 个中转节点，第 个点的第 个中转节点只会通向距离 距离恰为 的结点 的第 个中转节点。可以理解为建立的图为 层的高架桥，越高层的道路每次走的距离越大。对于点 ，连接第 层的 结点（表示 结点本身）到第 层的 结点（表示每次走的距离都是 ）。 初始化同节点层与层之间的连边，即对于 结点，连接其每个中转节点到其本身（即第 层的 结点）边权为 ，这样如果在某节点 想要停止跳过来时的步长 ，转用 结点本身的步长 ，则可以从 的第 个中转节点花费 的代价走到 结点本身，再花费 的代价走到 的第 个中转节点。 如此，边数和点数都变成了 级别，由于卡内存，可以把 调成 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define mp make_pair#define fir top().first#define sec top().second#define MAX_N 4000000#define MAX_M 15000000#define INF 0x3f3f3f3fusing namespace std;typedef pair&lt;int,int&gt; pii;typedef priority_queue&lt;pii&gt; pri_que;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, MAGIC, b[MAX_N+5], p[MAX_N+5], d[MAX_N+5], cnt;struct node {int v, c, nxt;} E[MAX_M+5]; int pr[MAX_N+5]; pri_que que;void addedge(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}int Dijkstra() { int s = b[1], t = b[2]; memset(d, 0x3f, sizeof d); d[s] = 0, que.push(mp(-d[s], s)); while (!que.empty()) { int u = que.sec, w = -que.fir; que.pop(); if (d[u]^w) continue; for (int i = pr[u], v, c; ~i; i = E[i].nxt) if (d[u]+(c=E[i].c) &lt; d[v = E[i].v]) d[v] = d[u]+c, que.push(mp(-d[v], v)); } return d[t] == INF ? -1 : d[t];}int main() { memset(pr, -1, sizeof pr); read(n), read(m), MAGIC = min((int)sqrt(n), 100); for (int i = 1; i &lt;= m; i++) read(b[i]), read(p[i]), b[i]++; for (int i = 1; i &lt;= MAGIC; i++) for (int j = 1; j &lt;= n; j++) addedge(i*n+j, j, 0); for (int i = 1; i &lt;= MAGIC; i++) for (int j = 1; j &lt;= n-i; j++) addedge(i*n+j, i*n+i+j, 1), addedge(i*n+i+j, i*n+j, 1); for (int i = 1; i &lt;= m; i++) if (p[i] &lt;= MAGIC) addedge(b[i], p[i]*n+b[i], 0); else { for (int j = b[i]+p[i]; j &lt;= n; j += p[i]) addedge(b[i], j, (j-b[i])/p[i]); for (int j = b[i]-p[i]; j &gt;= 1; j -= p[i]) addedge(b[i], j, (b[i]-j)/p[i]); } return printf("%d\n", Dijkstra()), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>APIO</tag>
        <tag>分块</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1178【APIO2009】会议中心]]></title>
    <url>%2FBZOJ1178%E3%80%90APIO2009%E3%80%91%E4%BC%9A%E8%AE%AE%E4%B8%AD%E5%BF%83%20%E8%B4%AA%E5%BF%83%2B%E5%80%8D%E5%A2%9E%2F</url>
    <content type="text"><![CDATA[Problem【APIO2009】会议中心 Description 政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。显然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有 个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。 公司 开始日期 结束日期 公 司 公 司 公 司 公 司 上例中，最多将会堂租借给两家公司。租借策略分别是租给 公 司 和 公 司 ， 或是 公 司 和 公 司 ，也可以是 公 司 和 公 司 。注意会议中心一天最多租借给 一个公司，所以 公 司 和 公 司 不能同时租借会议中心，因为他们在第九天重合 了。销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小的候选策略作为最终的策略。例中，会堂最终将被租借给 公 司 和 公 司 ： 个候选策略是 ，而在字典序中 。你的任务是帮助销售主管确定应该将会堂租借给哪些公司。 Input第一行有一个整数 ，表示发出租借会堂申请的公司的个数。第 到第 行每行有 个整数。第 行的整数表示第 家公司申请租借的起始和终止日期。对于每个公司的申请，起始日期为不小于 的整数，终止日期为不大于 的整数。 Output输出的第一行应有一个整数 ，表示最多可以租借给多少家公司。第二行应列出 个数，表示最终将会堂租借给哪些公司。 Sample Input1234544 99 1113 1910 17 Sample Output1221 3 HINT修复数据 ，并新加数据一组。 修复后数据 标签：贪心 倍增 Solution思路清奇的贪心… 如果没有“字典序最小”，直接无脑贪心即可。有输方案的要求后，就需要用另外一种贪心。 首先先做一遍贪心找到最多能有多少个会议，然后从 到 按编号枚举会议，看当前会议加入后会不会使答案变小，如果不会变小就贪心把这个会议加入到方案中。 具体地，首先以 从小到大为第一关键字，以 从大到小为第二关键字排序，去掉包含的区间。找到一种方法（一会儿说）计算 ，表示 时间段最多可以放多少个会议。对于会议 ，其时间段是 ，已经加入的会议中此会议的前驱的结束时间是 ，后继的开始时间是 （前驱和后继用set维护）。 若 或 ，那么一定不能放入。 若 ，那么放入后一定不会影响答案，输出编号后把此会议加入set即可。这个等式表示加入此会议后虽然把原区间分成了三个子区间，但最大值依旧不变。 若 ，那么不能放入。 这样一来，就可以解决输出方案的问题了。 但如何计算 呢？如果直接算，是 的，考虑把这个过程变成 。倍增预处理出 ，表示从区间 开始向后选 个连续区间，最后一个区间的编号。于是每次计算可以倍增跳累加答案。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define LOG 20#define MAX_N 200000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, L[MAX_N+5], R[MAX_N+5], nxt[MAX_N+5][LOG+1];struct node {int l, r; bool operator &lt; (const node &amp;t) const;} a[MAX_N+5], b[MAX_N+5];bool node::operator &lt; (const node &amp;t) const {return r == t.r ? l &gt; t.l : r &lt; t.r;}int calc(int l, int r) { int u = lower_bound(L+1, L+m+1, l)-L, ret = 1; if (u &gt; m || R[u] &gt; r) return 0; for (int i = LOG; ~i; i--) if (nxt[u][i] &amp;&amp; R[nxt[u][i]] &lt;= r) ret += 1&lt;&lt;i, u = nxt[u][i]; return ret;}int main() { read(n); set &lt;node&gt; s; for (int i = 1; i &lt;= n; i++) read(a[i].l), read(a[i].r), b[i] = a[i]; sort(b+1, b+n+1), m = 0; for (int i = 1; i &lt;= n; i++) if (b[i].l &gt; b[m].l) b[++m] = b[i]; for (int i = 1; i &lt;= m; i++) L[i] = b[i].l, R[i] = b[i].r; for (int i = 1, j = 1; i &lt;= m; i++) { while (j &lt;= m &amp;&amp; b[j].l &lt;= b[i].r) j++; if (j &lt;= m) nxt[i][0] = j; } for (int i = 1; i &lt;= LOG; i++) for (int j = 1; j &lt;= m; j++) nxt[j][i] = nxt[nxt[j][i-1]][i-1]; s.insert((node){-INF, -INF}), s.insert((node){INF, INF}); printf("%d\n", calc(-INF, INF)); for (int i = 1; i &lt;= n; i++) { set &lt;node&gt; :: iterator ln = s.lower_bound(a[i]), rn = ln; ln--; int l = a[i].l, r = a[i].r, lr = ln-&gt;r, rl = rn-&gt;l; if (l &lt;= lr || r &gt;= rl) continue; if (calc(lr+1, rl-1) == calc(lr+1, l-1)+calc(r+1, rl-1)+1) s.insert(a[i]), printf("%d ", i); } return puts(""), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>倍增</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【APIO2011】方格染色]]></title>
    <url>%2FBZOJ2303%E3%80%90APIO2011%E3%80%91%E6%96%B9%E6%A0%BC%E6%9F%93%E8%89%B2%20%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Problem【APIO2011】方格染色 Description 和他的妹妹 有一个包含 个方格的表格。她们想要将其的每个方格都染成红色或蓝色。出于个人喜好，他们想要表格中每个 的方形区域都包含奇数个（ 个或 个）红色方格。 可是昨天晚上，有人已经给表格中的一些方格染上了颜色！现在 和 非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格仍然满足她们的要求。如果可能的话，满足他们要求的染色方案数有多少呢？ Input输入的第一行包含三个整数 , 和 ，分别代表表格的行数、列数和已被染色的方格数目。之后的 行描述已被染色的方格。其中第 行包含三个整数 , 和 ，分别代表第 个已被染色的方格的行编号、列编号和颜色。 为 表示方格被染成红色， 为 表示方格被染成蓝色。 Output输出一个整数，表示可能的染色方案数目 模 得到的值。 Sample Input12343 4 32 2 11 2 02 3 1 Sample Output18 Hint对于所有的测试数据， , , , 。数据为国内数据+国际数据+修正版鸣谢GYZ 标签：带权并查集 异或方程组 Solution并查集解异或方程组。 令 表示第 行第 列的格子最终是否被染，对于 ，一定有 。而易得到结论：确定一行一列的情况，即可确定最后是否能正确染色。 于是我们尝试确定第一行和第一列的情况，即做一个 个变量的异或方程组。对于给定的 ，我们如果把 的所有上一段所属方程异或起来，那么相同元抵消，可知 ，如果我们知道 ，那么就能确定 的值，这时用一个带权并查集维护一下，即可得到联通块的个数。那么答案为 自 由 元 个 数 （ 所在联通块的取值是一定的）。如果我们预先不知道 的值，就可以枚举两种取值，分别计算后加起来即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define MOD 1000000000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, k, f[MAX_N+5], g[MAX_N+5];int x[MAX_N+5], y[MAX_N+5], c[MAX_N+5];int getf(int x) {return f[x] == x ? x : getf(f[x]), g[x] ^= g[f[x]], f[x] = f[f[x]];}lnt calc(int val) { lnt ret = 1; for (int i = 1; i &lt;= k; i++) if (x[i] &gt; 1 &amp;&amp; y[i] &gt; 1) c[i] ^= val; for (int i = 1; i &lt;= n+m; i++) f[i] = i, g[i] = 0; f[n+1] = 1; for (int i = 1; i &lt;= k; i++) if ((x[i]^1) || (y[i]^1)) { int u = getf(x[i]), v = getf(y[i]+n), w = g[x[i]]^g[y[i]+n]^c[i]; if (u^v) f[v] = u, g[v] = w; else if (w) return 0LL; } for (int i = 1, t = 0; i &lt;= n+m; i++) if (getf(i) == i) {if (t) (ret *= 2LL) %= MOD; else t = 1;} return ret;}int main() { read(n), read(m), read(k); bool f0 = true, f1 = true; lnt ans = 0; for (int i = 1; i &lt;= k; i++) { read(x[i]), read(y[i]), read(c[i]); if (!(x[i]%2) &amp;&amp; !(y[i]%2)) c[i] ^= 1; if (x[i] == 1 &amp;&amp; y[i] == 1) c[i] ? f0 = false : f1 = false; } if (f0) (ans += calc(0)) %= MOD; if (f1) (ans += calc(1)) %= MOD; return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5180【Baltic2016】Cities]]></title>
    <url>%2FBZOJ5180%E3%80%90Baltic2016%E3%80%91Cities%20%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【Baltic2016】Cities Description给定 个点， 条双向边的图，其中有 个点是重要的，每条边都有一定的长度。现在要你选定一些边来构成一个图，要使得 个重要的点相互连通，求边的长度和的最小值。 Input共 行第 行读入 ，表示 个点， 个重要的点， 条边第 行读入 个重要点的编号第 至第 行，每行包括 个数字 ，表示有一条从 到 长度为 的双向路径 Output共 行，即最小长度和 Sample Input123456784 3 61 3 41 2 41 3 91 4 62 3 22 4 53 4 8 Sample Output111 HINT 标签：斯坦纳树 状压DP Solution斯坦纳树裸题。 斯坦纳树的基本解法是状压 ，压缩联通状态进行 ， 表示在 点，联通状态为 的最小花费。有两种转移： 状态 可以通过两个状态组合而来，对于 的一个子集 ，有 状态 也可以在同层向邻接点扩展，即最短路中的松弛操作，对于边 ，有 ，可以跑最短路更新。 此题有点卡，注意不要用SPFA，要用堆优Dijkstra。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define fir first#define sec second#define mp make_pair#define MAX_N 100000using namespace std;typedef long long lnt;typedef pair&lt;lnt,int&gt; pli;typedef priority_queue&lt;pli&gt; pri_que;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, k; lnt f[32][MAX_N+5]; bool mrk[32][MAX_N+5];vector &lt;int&gt; G[MAX_N+5]; vector &lt;lnt&gt; E[MAX_N+5]; pri_que que;void insert(int u, int v, lnt c) {G[u].push_back(v), E[u].push_back(c);}void addedge(int u, int v, lnt c) {insert(u, v, c), insert(v, u, c);}int main() { read(n), read(k), read(m), memset(f, 0x3f, sizeof f); for (int i = 0, p; i &lt; k; i++) read(p), f[1&lt;&lt;i][p] = 0; for (int i = 1, u, v, c; i &lt;= m; i++) read(u), read(v), read(c), addedge(u, v, c); for (int s = 1; s &lt; (1&lt;&lt;k); s++) { for (int i = 1; i &lt;= n; i++) for (int t = (s-1)&amp;s; t; t = (t-1)&amp;s) f[s][i] = min(f[s][i], f[t][i]+f[s^t][i]); for (int i = 1; i &lt;= n; i++) que.push(mp(-f[s][i], i)); while (!que.empty()) { int u = que.top().sec; que.pop(); if (mrk[s][u]) continue; mrk[s][u] = true; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (f[s][v = G[u][i]] &gt; f[s][u]+E[u][i]) f[s][v] = f[s][u]+E[u][i], que.push(mp(-f[s][v], v)); } } lnt mi = 1LL&lt;&lt;62; for (int i = 1; i &lt;= n; i++) mi = min(mi, f[(1&lt;&lt;k)-1][i]); return printf("%lld\n", mi), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>斯坦纳树</tag>
        <tag>Baltic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2809【APIO2012】Dispatching]]></title>
    <url>%2FBZOJ2809%E3%80%90APIO2012%E3%80%91Dispatching%20%E5%8F%AF%E5%B9%B6%E5%A0%86%2F</url>
    <content type="text"><![CDATA[Problem【APIO2012】Dispatching Description在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。在这个帮派里，有一名忍者被称之为 。除了 以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，就不需要支付管理者的薪水。你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。写一个程序，给定每一个忍者 的上级 ，薪水 ，领导力 ，以及支付给忍者们的薪水总预算 ，输出在预算内满足上述要求时顾客满意度的最大值。 Input从标准输入读入数据。第一行包含两个整数 和 ，其中 表示忍者的个数， 表示薪水的总预算。接下来 行描述忍者们的上级、薪水以及领导力。其中的第 行包含三个整数 分别表示第 个忍者的上级，薪水以及领导力。 满足 ，并且每一个忍者的老板的编号一定小于自己的编号。 Output输出一个数，表示在预算内顾客的满意度的最大值。 Sample Input1234565 40 3 31 3 52 2 21 2 42 3 1 Sample Output16 Hint样例解释如果我们选择编号为 的忍者作为管理者并且派遣第三个和第四个忍者，薪水总和为 ，没有超过总预算 。因为派遣了 个忍者并且管理者的领导力为 ，用户的满意度为 ，是可以得到的用户满意度的最大值。数据范围 标签：可并堆 左偏树 Solution可并堆基础题。 对于每个结点作领导的情况，贪心策略肯定在其子树中从小往大选，直到选不了为止。可以每个结点用一个堆维护，但遍历子树会导致复杂度爆炸。 考虑每次用已经算出的一些结点的答案。那么可以想到一种做法：将每个结点子树中的所有点默认先选上，再从大往小去掉直到可行为止。这样在儿子结点中都没选到的点一定不会在父节点中选到。于是可以直接将每个结点最后选出的点加入到父亲的备选点集中。这样不难发现可以用可并堆维护， 时将所有儿子结点的可并堆并起来，再从大往小 点，找到可行最大 后更新答案即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}struct node {int c, d, ls, rs;} h[MAX_N+5];int n, m, b[MAX_N+5], c[MAX_N+5], l[MAX_N+5], sz[MAX_N+5];vector &lt;int&gt; G[MAX_N+5]; int fa[MAX_N+5]; lnt mx, s[MAX_N+5];int getf(int x) {return fa[x] == x ? fa[x] : getf(fa[x]);}int merge(int a, int b) { if (!a || !b) return a^b; if (h[a].c &lt; h[b].c) swap(a, b); h[a].rs = merge(h[a].rs, b), fa[h[a].rs] = a; if (h[h[a].rs].d &gt; h[h[a].ls].d) swap(h[a].ls, h[a].rs); h[a].d = h[a].rs ? h[h[a].rs].d+1 : 0; return a;}int pop(int a) { int l = h[a].ls, r = h[a].rs; h[a].ls = h[a].rs = h[a].c = 0; return fa[l] = l, fa[r] = r, merge(l, r);}int DFS(int u) { int rt = u; s[u] = c[u], sz[u] = 1; for (int i = 0, v; i &lt; (int)G[u].size(); i++) rt = merge(rt, DFS(v = G[u][i])), s[u] += s[v], sz[u] += sz[v]; while (s[u] &gt; m &amp;&amp; sz[u]) s[u] -= h[rt].c, sz[u]--, rt = pop(rt); return mx = max(mx, 1LL*sz[u]*l[u]), rt;}int main() { read(n), read(m); for (int i = 1; i &lt;= n; i++) read(b[i]), read(c[i]), read(l[i]); for (int i = 1; i &lt;= n; i++) G[b[i]].push_back(i); for (int i = 1; i &lt;= n; i++) fa[i] = i, h[i].c = c[i]; return DFS(1), printf("%lld\n", mx), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>可并堆</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ5251【2018多省省队联测】劈配]]></title>
    <url>%2FBZOJ5251%E3%80%902018%E5%A4%9A%E7%9C%81%E7%9C%81%E9%98%9F%E8%81%94%E6%B5%8B%E3%80%91%E5%8A%88%E9%85%8D%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【2018多省省队联测】劈配 Description一年一度的综艺节目《中国新代码》又开始了。 从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。轻车熟路的 顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：总共 名参赛选手（编号从 至 ）每人写出一份代码并介绍自己的梦想。接着由所有导师对这些选手进行排名。为了避免后续的麻烦，规定不存在排名并列的情况。同时，每名选手都将独立地填写一份志愿表，来对总共 位导师（编号从 至 ）作出评价。志愿表上包含了共 档志愿。对于每一档志愿，选手被允许填写最多 位导师，每位导师最多被每位选手填写一次（放弃某些导师也是被允许的）。在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。节目组对“前 名的录取结果最优”作出如下定义： 前 名的录取结果最优，当且仅当第 名被其最高非空志愿录取（特别地，如果第 名没有填写志愿表，那么该选手出局）。 前 名的录取结果最优，当且仅当在前 名的录取结果最优的情况下：第 名被其理论可能的最高志愿录取（特别地，如果第i名没有填写志愿表、或其所有志愿中的导师战队均已满员，那么该选手出局）。 如果一种方案满足“前 名的录取结果最优”，那么我们可以简称这种方案是最优的。举例而言， 位导师 老师、 老师的战队人数上限分别都是 人； 位选手 、 分列第 、 名。那么下面 种志愿表及其对应的最优录取结果如表中所示： 可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。每个人都有一个自己的理想值 ，表示第 位同学希望自己被第 或更高的志愿录取，如果没有，那么他就会非常沮丧。现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。对于每一位选手， 都想知道下面两个问题的答案： 在最优的录取方案中，他会被第几志愿录取。 在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。 作为《中国新代码》的实力派代码手， 当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。 Input每个测试点包含多组测试数据，第一行 个用空格隔开的非负整数 ，分别表示数据组数、每档志愿最多允许填写的导师数目。接下来依次描述每组数据，对于每组数据： 第 行两个用空格隔开的正整数 。 分别表示选手的数量、导师的数量。 第 行 个用空格隔开的正整数：其中第 个整数为 。 表示编号为 的导师战队人数的上限。 第 行至第 行，每行 个用空格隔开的非负整数：其中第 行左起第 个数为 表示编号为 的选手将编号为 的导师编排在了第 志愿。特别地，如果 ，则表示该选手没有将该导师填入志愿表。 在这一部分，保证每行中不存在某一个正数出现超过 次（ 可能出现超过 次），同时保证所有 。 第 行 个用空格隔开的正整数，其中第 个整数为 表示编号为 的选手的理想值。 在这一部分，保证 。 Output按顺序输出每组数据的答案。对于每组数据，输出 行： 第 行输出 个用空格隔开的正整数，其中第 个整数的意义为： 在最优的录取方案中，编号为 的选手会被该档志愿录取。 特别地，如果该选手出局，则这个数为 。 第 行输出 个用空格隔开的非负整数，其中第 个整数的意义为： 使编号为 的选手不沮丧，最少需要让他上升的排名数。 特别地，如果该选手一定会沮丧，则这个数为 。 Sample Input123456789101112131415163 52 21 12 21 21 12 21 11 21 22 12 21 10 10 12 2 Sample Output1234562 11 01 20 11 30 1 HINT样例解释三组数据分别与题目描述中的三个表格对应。对于第 组数据：由于选手 没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手 按原排名就不沮丧，因此他不需要提升排名。对于第 组和第 组数据： 号选手都不需要提升排名。而希望被第一志愿录取的 号选手都必须升到第 名才能如愿。数据范围 原题面 标签：网络流 Solution九省联考 唯一一道有区分度的题。 容易看出本质就是一个二分图匹配。只不过每条边的优先度是有差别的。第一问先将源点到每个学员流量为 的边和导师到汇点的流量为 的边连上。顺次考虑每个学员，每次将一个志愿中的所有导师的边加到图里，看能否使其找到匹配，找到就退出，标记此志愿为答案。 第二问考虑像第一问那样判断，那么就可以每次加入一个学员，判断能否达到要求，当加入一个学员后不能达到要求时， 此 时 加 入 的 学 员 数 为此人满足要求的最大名次，用其真实名次减去即可得到答案。注意特判无论如何都不能满足的情况。另外，这里还可以二分答案，不过直接暴力加入在 上已经可以过了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 100000#define INF 0x3f3f3f3fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, s, t, cnt, rk[MAX_N+5], mi[MAX_N+5];int b[MAX_N+5], d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5]; vector &lt;int&gt; a[205][205];void init() {s = 0, t = n+m+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}void build() { init(); for (int i = 1; i &lt;= n; i++) addedge(s, i, 1); for (int i = 1; i &lt;= m; i++) addedge(i+n, t, b[i]);}bool inc(int p, int l, int r) { for (int i = l; i &lt;= r; i++) for (int j = 0; j &lt; (int)a[p][i].size(); j++) addedge(p, a[p][i][j]+n, 1); return Dinic();}int main() { int T, C; read(T), read(C); while (T--) { read(n), read(m); for (int i = 1; i &lt;= m; i++) read(b[i]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) a[i][j].clear(); for (int i = 1; i &lt;= n; i++) for (int j = 1, x; j &lt;= m; j++) read(x), a[i][x].push_back(j); build(); for (int i = 1; i &lt;= n; i++) for (rk[i] = 1; rk[i] &lt;= m; rk[i]++) if (inc(i, rk[i], rk[i])) break; for (int i = 1, k; i &lt;= n; i++) { read(k), mi[i] = i, build(); if (!inc(i, 1, k)) continue; for (int j = 1; mi[i]--; j++) if (rk[j] &lt;= m) if (!inc(j, rk[j], rk[j])) break; } for (int i = 1; i &lt;= n; i++) printf("%d ", rk[i]); puts(""); for (int i = 1; i &lt;= n; i++) printf("%d ", mi[i]); puts(""); } return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3675【APIO2014】序列分割]]></title>
    <url>%2FBZOJ3675%E3%80%90APIO2014%E3%80%91%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem【APIO2014】序列分割 Description 小 最近迷上了一个分隔序列的游戏。在这个游戏里， 小 需要将一个长度为 的非负整数序列分割成 个非空的子序列。为了得到 个子序列， 小 需要重复 次以下的步骤： 小 首先选择一个长度超过 的序列（一开始 小 只有一个长度为 的序列，也就是一开始得到的整个序列） 选择一个位置，并通过这个位置将这个序列分割成连续的两个非空的新序列 每次进行上述步骤之后， 小 将会得到一定的分数。这个分数为两个新序列中元素和的乘积。 小 希望选择一种最佳的分割方式，使得 轮之后， 小 的总得分最大。 Input输入第一行包含两个整数 。第二行包含 个非负整数 ，表示一开始 小 得到的序列。 Output输出第一行包含一个整数，为 小 可以得到的最大分数。 Sample Input127 34 1 3 4 0 2 3 Sample Output1108 Hint在样例中， 小 可以通过如下3轮操作得到108分： 一开始 小 有一个序列 。 小 选择在第 个数之后的位置将序列分成两部分，并得到 分。 这一轮开始时 小 有两个序列： 。 小 选择在第3个数字之后的位置将第二个序列分成两部分，并得到 分。 这一轮开始时 小 有三个序列： 。 小 选择在第 个数字之后的位置将第三个序列分成两部分，并得到 分。 经过上述三轮操作， 小 将会得到四个子序列： 并总共得到 分。 标签：斜率优化DP Solution易得 方程： 表示玩 轮时只考虑 区间内的数的最大贡献。那么有 。简单推一推： 套上斜率优化： 注意这里不要写成斜率的形式，因为 可能等于 。按照不等式用单调栈对每层 进行维护即可，这里可以做 次一维 ，每次重新算 数组。 Code1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, l, r, que[MAX_N+5]; lnt s[MAX_N+5];lnt f[MAX_N+5], a[MAX_N+5], b[MAX_N+5];bool chk(int p, int l, int r) { lnt x = (b[p]-b[que[r]])*(a[que[r-1]]-a[que[r]]); lnt y = (b[que[r]]-b[que[r-1]])*(a[que[r]]-a[p]); return x &lt;= y;}int main() { read(n), read(m); for (int i = 1, x; i &lt;= n; i++) read(x), s[i] = s[i-1]+x; for (int i = 1; i &lt;= n; i++) a[i] = s[i], b[i] = -s[i]*s[i]; for (int k = 1; k &lt;= m; k++) { que[l = r = 0] = 0; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; s[i]*(a[que[l]]-a[que[l+1]]) &lt;= b[que[l+1]]-b[que[l]]) l++; f[i] = a[que[l]]*s[i]+b[que[l]]; while (l &lt; r &amp;&amp; chk(i, l, r)) r--; que[++r] = i; } for (int i = 1; i &lt;= n; i++) b[i] = f[i]-s[i]*s[i]; } return printf("%lld\n", f[n]), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>斜率优化</tag>
        <tag>DP</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1911【APIO2010】特别行动队]]></title>
    <url>%2FBZOJ1911%E3%80%90APIO2010%E3%80%91%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem【APIO2010】特别行动队 Description Input Output Sample Input1234-1 10 -202 2 3 4 Sample Output19 标签：斜率优化DP Solution首先易得 方程：设 为考虑前 人的最大收益，则 。那么推一推： 发现中间 是一次函数，那么对于两个位置 ，若 比 优秀，则有： 按照此斜率维护单调栈即可。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000using namespace std;typedef long long lnt;typedef double dnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, que[MAX_N+5], l, r; lnt A, B, C;lnt s[MAX_N+5], k[MAX_N+5], b[MAX_N+5], f[MAX_N+5];dnt calc(int x, int y) {return (dnt)(b[x]-b[y])/(dnt)(k[y]-k[x]);}int main() { read(n), read(A), read(B), read(C); for (int i = 1, x; i &lt;= n; i++) read(x), s[i] = s[i-1]+x; int l = 0, r = 0; que[0] = 0, b[0] = C; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; calc(que[l], que[l+1]) &lt;= s[i]) l++; f[i] = k[que[l]]*s[i]+b[que[l]]+A*s[i]*s[i]+B*s[i]; k[i] = -2*A*s[i], b[i] = A*s[i]*s[i]-B*s[i]+C+f[i]; while (l &lt; r &amp;&amp; calc(que[r], i) &lt;= calc(que[r-1], que[r])) r--; que[++r] = i; } return printf("%lld\n", f[n]), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>斜率优化</tag>
        <tag>DP</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3730 震波]]></title>
    <url>%2FBZOJ3730%20%E9%9C%87%E6%B3%A2%20%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem震波 Description在一片土地上有 个城市，通过 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 ，其中第i个城市的价值为 。不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。接下来你需要在线处理 次操作： 表示发生了一次地震，震中城市为 ，影响范围为 ，所有与 距离不超过 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。 表示第 个城市的价值变成了 。 为了体现程序的在线性，操作中的 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 。 Input第一行包含两个正整数 和 。第二行包含 个正整数，第 个数表示 。接下来 行，每行包含两个正整数 ，表示 和 之间有一条无向边。接下来 行，每行包含三个数，表示 次操作。 Output包含若干行，对于每个询问输出一行一个正整数表示答案。 Sample Input123456789108 11 10 100 1000 10000 100000 1000000 100000001 21 32 42 53 63 73 80 3 1 Sample Output111100101 Hint 标签：动态点分治 Solution终于学会动态点分辣QAQ~赶快来肝几道基础题 先不考虑时间复杂度，那么对于每个 操作显然可以暴力从震源向上爬统计答案。每次加上当前子树中距离符合题意的点，再减去其儿子（就是向上爬时此点的前驱）的子树中与其算重复的点。这样维护两个树状数组即可。但是树高可以构造比 大，这时就需要建立点分树，把树高降成 。 提取重心建立点分树，对每个分治中心维护两个树状数组，第一个是其子树中到此分治中心的每种距离的所有点的点权和，第二个是其子树中到此分治中心的上一层分治中心的每种距离的所有点的点权和。这样对于询问，每次 向上爬，爬到每个分治中心 统计；对于修改，每次 向上爬，爬到每个分治中心 更新树状数组即可。这样总复杂度是 。 不过此题有些卡常，有三种策略： 用 做 带fread大读优 将 棵树状数组建到同一个大数组上，每个 记录其起始指针和终止指针，可以避免vector的一些常数 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;bits/stdc++.h&gt;#define LOG 16#define MAX_N 100000using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, e, c[MAX_N+5], fa[MAX_N+5];int w[MAX_N+5], sz[MAX_N+5], rt, tot;int anc[MAX_N+5][LOG+1], dep[MAX_N+5];int *p0[MAX_N+5], *p1[MAX_N+5], pr[MAX_N+5];int BIT0[MAX_N*100], BIT1[MAX_N*100]; bool mrk[MAX_N+5];struct node {int v, nxt;} E[(MAX_N&lt;&lt;1)+5];void addedge(int u, int v) {E[e] = (node){v, pr[u]}, pr[u] = e++;}void inc(int *tr, int p, int x, int l) {for (p = min(p+1, l); p &lt;= l; p += (p&amp;-p)) tr[p] += x;}int sum(int *tr, int p, int l) {int ret = 0; for (p = min(p+1, l); p; p -= (p&amp;-p)) ret += tr[p]; return ret;}void init(int u) { for (int i = 1; i &lt;= LOG; i++) anc[u][i] =anc[anc[u][i-1]][i-1]; for (int i = pr[u], v; ~i; i = E[i].nxt) if ((v = E[i].v) ^ anc[u][0]) anc[v][0] = u, dep[v] = dep[u]+1, init(v);}int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = LOG; ~i; i--) if (dep[a]-(1&lt;&lt;i) &gt;= dep[b]) a = anc[a][i]; if (a == b) return a; for (int i = LOG; ~i; i--) if (anc[a][i]^anc[b][i]) a = anc[a][i], b = anc[b][i]; return anc[a][0];}int dist(int u, int v) {return dep[u]+dep[v]-2*dep[LCA(u, v)];}int getsz(int u, int f) { int ret = 1; for (int i = pr[u], v; ~i; i = E[i].nxt) if (((v = E[i].v) ^ f) &amp;&amp; !mrk[v]) ret += getsz(v, u); return ret;}void getrt(int u, int f) { sz[u] = 1, w[u] = 0; for (int i = pr[u], v; ~i; i = E[i].nxt) if (((v = E[i].v) ^ f) &amp;&amp; !mrk[v]) getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]); w[u] = max(w[u], tot-sz[u]); if (w[u] &lt; w[rt]) rt = u;}void divide(int u, int f) { rt = 0, tot = getsz(u, 0), getrt(u, 0); fa[u = rt] = f, mrk[u] = true, sz[u] = tot+1; for (int i = pr[u], v; ~i; i = E[i].nxt) if (!mrk[v = E[i].v]) divide(v, u);}void modify(int x, int y) { inc(p0[x], 0, y, sz[x]); for (int u = x; fa[u]; u = fa[u]) { int dis = dist(fa[u], x); inc(p1[u], dis, y, sz[u]); inc(p0[fa[u]], dis, y, sz[fa[u]]); }}int query(int x, int y) { int ret = sum(p0[x], y, sz[x]); for (int u = x, dis; fa[u]; u = fa[u]) if ((dis = dist(fa[u], x)) &lt;= y) ret += sum(p0[fa[u]], y-dis, sz[fa[u]])-sum(p1[u], y-dis, sz[u]); return ret;}int main() { read(n), read(m), w[0] = n; memset(pr, -1, sizeof pr); for (int i = 1; i &lt;= n; i++) read(c[i]); for (int i = 1, u, v; i &lt; n; i++) read(u), read(v), addedge(u, v), addedge(v, u); init(1), divide(1, 0); int cnt = 0, lst = 0; for (int i = 1; i &lt;= n; cnt += sz[i++]+1) p0[i] = BIT0+cnt, p1[i] = BIT1+cnt; for (int i = 1; i &lt;= n; i++) modify(i, c[i]); while (m--) { int opt, x, y; read(opt); read(x), read(y), x ^= lst, y ^= lst; if (opt) modify(x, y-c[x]), c[x] = y; else printf("%d\n", lst = query(x, y)); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SCOI2018总结]]></title>
    <url>%2FSCOI2018%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SCOI2018模拟退役记 集训Day 0到成电打校赛，中午吃饭碰到 和 ，一起骑车去考场。结果走错门了，绕了 才绕过去。 比赛 才开始，貌似是内网出了点小锅。刚刚拿到题我们三人都蒙了，看了 才找到签到题。 和 都很水， 和 各做一道，我在看 给的一道类似文理分科建模的网络流图。先过了两道签到题，接着 就看出 的贪心了。于是三道签到题就搞定了。 接着我和 开始肛 ，这时全场没人过 ，所以我们有点虚。发现和文理分科不一样的是这个模的贡献可能有负数，然后我就懵逼了… 机智地想到了把正负拆成差的方法，这样边权都是正的了。我直接套上我洛谷的网络流板，一发过样例，交了，然后…然后… … 我和 开始肉眼查错，发现我的当前弧是错的…洛谷的板题是给出 和 ，所以当前弧每次复原是循环 ，而 中建模 时 号点， 是 ，然后就 了。改了再交， ，惊奇地发现一血了。过了两分钟，柱神他们也过了 。 接下来 和 开始肛 ，傻逼主席树，不过容易写错。封榜的时候交了 ，然后我们队就 了。 话说我好像全程抱大腿… Day 1到中和中学参加省选集训，本来还期待能学些东西，结果上午全程骑车。某天津老师来讲异或方程组，先水了 高消，然后用了各种技巧避开线性基水了若干线性基裸题…只能说这老师 拖 时 间 能 力 。 下午去体验机房，在初中生高度的座位上颓颓颓。神机安了 个五笔输入法，而且开新页面会默认调成拼音输入法。什么编译器都没有，分辨率出翔… 晚上回酒店，刷水搞了几道线性基，然后颓颓颓。厕所漏水严重，水管工貌似修不好，凑合凑合。 Day 2 巨佬讲博弈论，讲得挺好。前半场很简单，开热点刷题。最后讲了尼姆积，玄学玩意儿，不过听懂了，这东西虽然精妙，但是题目并不是很常见。 下午继续刷题，居然没颓。 晚上继续刷题，十点过和 颓了一会儿炉石。 Day 3成电学生来讲数论，全程划水。讲了一些并无卵用的东西，而且就讲了一些素数论的皮毛， 难度。补觉补觉。 下午刷题，刷完颓颓颓。 晚上打了几个板子，继续颓。 Day 4上午省选模拟，抱着划水的心态边打弹球边写（中和中学机房最好的地方就是有三维弹球）。 状压 ，打了一个玄学做法，考完发现有锅，结果考试的时候并没有 ，最后两个点卡常 了。 没想到贪心，暴力滚粗。 暴力，不过评测的时候貌似 了，而且好像好几个人都 了。 下午赶到清水河，晚上打了几个板子，睡前膜一膜 和 正式考试Day 1考前听到 说不能用bits/stdc++.h，我信了。 上考场先看了看题，黑人问号 。没 ？ 动态点分？ 数据结构？（考完才发现我有多 ） 什么玄学玩意儿？ 先肛 ，并没有想出去除 影响的办法，于是打 翻译滚粗。 回去看 ，写不熟动态点分，而且貌似不好维护，再加上卡点分树空间，直接想如何骗分。 出一种暴力爬树高统计的方法，期待数据有随机点。对拍+调试花了 。 过了大样例，感觉挺稳。 最后剩 做 。好不容易把题读懂，打了暴力 ，不过貌似并没有暴力分。 考完下来预估 。 下午接到成绩，心态崩了…爆 滚粗。查分发现前两道都 了，最后一道肯定没分。电子科大神机的 版本很低，然后和 适配的时候出锅了。所以在 下编辑，用memset可以不开cstring，用sort可以不开algorithm。我的 就这样送了。 晚上开会发现 和我 写的一样的算法，他拿了 ，我：…… Day 2改用bits/stdc++.h，不要又 。 前一天 爆 整个心态都炸了。于是抱着划水的心态考 。一鼓作气，三道暴力，先花 把三道暴力写了，发现 可做，开始肛。 考试的时候有点懵，没直接用绝对值函数分开维护，而是分 种情况维护凸函数。写了 才大致理清楚。结果过了小样例，没过 的另一个小样例。赶紧对拍，然后补锅。耗了 才过 的样例。然后随手造了一个 的数据，崩溃地发现 了…弃疗扫雷（我貌似没有找到做蛋糕）。 Conclusion在退役的边缘试探]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3944 Sum]]></title>
    <url>%2FBZOJ3944%20Sum%20%E6%9D%9C%E6%95%99%E7%AD%9B%2F</url>
    <content type="text"><![CDATA[ProblemSum Description Input一共 行第 行为数据组数 第 行每行一个非负整数 ，代表一组询问 Output一共 行，每行两个用空格分隔的数 Sample Input1234567612813302333 Sample Output1234561 12 022 -258 -3278 -31655470 2 标签：杜教筛 Solution杜教筛板题。 首先推杜教筛通式。对于积性函数 ，若 ，即 ，那么可以得到 这样就可以预处理较小的 后数论分块求解。 然后对于题目中的两问分别推式子： 注意将两个答案的求解放在一起，用pair&lt;long,long&gt;返回，否则可能 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define MX 2500000#define fir first#define sec second#define mp make_pair#define pll pair&lt;lnt,lnt&gt;using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int cnt, pri[MX+5]; lnt phi[MX+5], mu[MX+5];bool NotPri[MX+5]; map &lt;lnt, lnt&gt; ex1, ex2;void init() { phi[1] = mu[1] = 1; for (int i = 2; i &lt;= MX; i++) { if (!NotPri[i]) pri[cnt++] = i, phi[i] = i-1, mu[i] = -1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; MX) break; NotPri[i*pri[j]] = true; if (i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]-1), mu[i*pri[j]] = -mu[i]; else {phi[i*pri[j]] = phi[i]*pri[j], mu[i*pri[j]] = 0; break;} } phi[i] += phi[i-1], mu[i] += mu[i-1]; }}pll sum(lnt n) { if (n &lt;= MX) return mp(phi[n], mu[n]); if (ex1[n]) return mp(ex1[n], ex2[n]); lnt ret1 = 1LL*n*(n+1)/2, ret2 = 1LL; pll t; for (lnt l = 2, r; l &lt;= n; l = r+1) r = n/(n/l), t = sum(n/l), ret1 -= 1LL*(r-l+1)*t.fir, ret2 -= 1LL*(r-l+1)*t.sec; return mp(ex1[n] = ret1, ex2[n] = ret2);}void sol(lnt n) { pll ans = sum(n); printf("%lld %lld\n", ans.fir, ans.sec);}int main() { lnt T, n; read(T), init(); while (T--) read(n), sol(n); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>杜教筛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2756【SCOI2012】奇怪的游戏]]></title>
    <url>%2FBZOJ2756%E3%80%90SCOI2012%E3%80%91%E5%A5%87%E6%80%AA%E7%9A%84%E6%B8%B8%E6%88%8F%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2012】奇怪的游戏 Description 最近喜欢上一个奇怪的游戏。这个游戏在一个 的棋盘上玩，每个格子有一个数。每次 会选择两个相邻的格子，并使这两个数都加上 。现在 想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出 。 Input输入的第一行是一个整数 ，表示输入数据有 轮游戏组成。每轮游戏的第一行有两个整数 和 ， 分别代表棋盘的行数和列数。接下来有 行，每行 个数。 Output对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出 。 Sample Input123456782 2 2 1 2 2 3 3 3 1 2 32 3 44 3 2 Sample Output122-1 HINT对于 的数据，保证 对于 的数据，保证 ，所有数为正整数且小于 标签：网络流 黑白染色 二分答案 Solution黑白染色，两色个数为 和 ，两色初始数字和为 和 。则有 当 时，可以直接解出 ，这时网络流 一下是否可能达到即可。当 时，每次操作都会使一定能在某一基础上将所有格子都 ，那么所有大于等于最小 的值都可以达到，具有二分性。那么二分 ，网络流 即可。 对于网络流 ，建图如下： 对于白格 ，连接 对于黑格 ，连接 对于每组相邻点 ，连接 再计算一个 所 有 白 格 的 值 与 的 差 之 和 若 最 大 流 ，则当前 可行。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;#define MAX_N 2000#define MAX_M 20000#define INF (1LL&lt;&lt;50)#define mid ((l+r)&gt;&gt;1)using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int nxt[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};int n, m, s, t, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, nxt; lnt c;} E[MAX_M+5];int col[50][50], c0, c1; lnt a[50][50], s0, s1, mx;int p(int x, int y) {return x*m-m+y;}void init() {s = 0, t = n*m+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, lnt c) {E[cnt] = (node){v, pr[u], c}, pr[u] = cnt++;}void addedge(int u, int v, lnt c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v; lnt c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}lnt DFS(int u, lnt flow) { if (u == t) return flow; lnt ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v; lnt c = E[i].c; if (d[u]+1 != d[v] || !c) continue; lnt tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}lnt Dinic() {lnt ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}bool chk(lnt x) { init(); lnt tot = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (col[i][j]) addedge(s, p(i, j), x-a[i][j]), tot += x-a[i][j]; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (!col[i][j]) addedge(p(i, j), t, x-a[i][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (col[i][j]) for (int k = 0; k &lt; 4; k++) { int x = i+nxt[k][0], y = j+nxt[k][1]; if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) continue; addedge(p(i, j), p(x, y), INF); } return Dinic() == tot;}lnt bi_search(lnt l, lnt r) { lnt ret = -1; while (l &lt;= r) if (!chk(mid)) l = mid+1; else ret = mid, r = mid-1; return ret;}void color() { mx = c0 = c1 = s0 = s1 = 0; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) col[i][j] = (i+j)&amp;1, (col[i][j] ? c1++ : c0++);}int main() { int T; read(T); while (T--) { read(n), read(m), color(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) read(a[i][j]), mx = max(mx, a[i][j]), (col[i][j] ? s1 += a[i][j] : s0 += a[i][j]); if (c0^c1) { if ((s0-s1)/(c0-c1) &gt;= m &amp;&amp; chk((s0-s1)/(c0-c1))) printf("%lld\n", (s0-s1)/(c0-c1)*c0-s0); else puts("-1"); } else { if (s0^s1) puts("-1"); else printf("%lld\n", bi_search(mx, INF)*c0-s0); } } return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3289 Mato的文件管理]]></title>
    <url>%2FBZOJ3289%20Mato%E7%9A%84%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%20%E8%8E%AB%E9%98%9F%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[ProblemMato的文件管理 Description 同学从各路神犇以各种方式收集了许多资料，这些资料一共有 份，每份有一个大小和一个编号。为了防止他人偷拷，这些资料都是加密过的，只能用 自己写的程序才能访问。 每天随机选一个区间 ，他今天就看编号在此区间内的这些资料。 有一个习惯，他总是从文件大小从小到大看资料。他先把要看的文件按编号顺序依次拷贝出来，再用他写的排序程序给文件大小排序。排序程序可以在 单位时间内交换 个相邻的文件（因为加密需要，不能随机访问）。 想要使文件交换次数最小，你能告诉他每天需要交换多少次吗？ Input第一行一个正整数 ，表示 的资料份数。第二行由空格隔开的 个正整数，第 个表示编号为 的资料的大小。第三行一个正整数 ，表示 会看几天资料。之后 行每行两个正整数 ，表示 这天看 区间的文件。 Output 行，每行一个正整数，表示 这天需要交换的次数。 Sample Input1234541 4 2 321 22 4 Sample Output1202 Hint样例解释第一天， 不需要交换第二天， 可以把 号交换 次移到最后。数据规模和约定 SourceBy taorunz 标签：莫队 树状数组 Solution 最 小 交 换 次 数 区 间 逆 序 对 数 因此此问题等价于求区间逆序对数，傻逼莫队水过。离线下所有询问，每次加入或删除一个数用树状数组维护，计算会增加或减少多少对逆序对，更新答案即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define MAX_N 50000using namespace std;const int MAGIC = 230;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, q, a[MAX_N+5], b[MAX_N+5], c[MAX_N+5], tr[MAX_N+5];struct query {int l, r, lb, rb, id;} Q[MAX_N+5]; int ans[MAX_N+5];bool cmpn (const int &amp;x, const int &amp;y) {return c[x] &lt; c[y];}bool cmpq (const query &amp;x, const query &amp;y) {return x.lb == y.lb ? x.rb &lt; y.rb : x.lb &lt; y.lb;}void inc(int p) {for (; p &lt;= m; p += (p&amp;-p)) tr[p]++;}void dec(int p) {for (; p &lt;= m; p += (p&amp;-p)) tr[p]--;}int sum(int p) {int s = 0; for (; p; p -= (p&amp;-p)) s += tr[p]; return s;}int get_bef(int p) {return sum(p-1);}int get_aft(int p) {return sum(m)-sum(p);}int main() { read(n); for (int i = 1; i &lt;= n; i++) read(c[i]), b[i] = i; sort(b+1, b+n+1, cmpn); for (int i = 1; i &lt;= n; a[b[i++]] = m) if (c[b[i]]^c[b[i-1]]) m++; read(q); for (int i = 1; i &lt;= q; i++) read(Q[i].l), read(Q[i].r), Q[i].id = i, Q[i].lb = Q[i].l/MAGIC, Q[i].rb = Q[i].r/MAGIC; sort(Q+1, Q+q+1, cmpq); int tot = 0; for (int i = 1, l = 1, r = 0; i &lt;= q; i++) { for (; l &gt; Q[i].l; l--) tot += get_bef(a[l-1]), inc(a[l-1]); for (; r &lt; Q[i].r; r++) tot += get_aft(a[r+1]), inc(a[r+1]); for (; l &lt; Q[i].l; l++) tot -= get_bef(a[l]), dec(a[l]); for (; r &gt; Q[i].r; r--) tot -= get_aft(a[r]), dec(a[r]); ans[Q[i].id] = tot; } for (int i = 1; i &lt;= q; i++) printf("%d\n", ans[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2938【POI2000】病毒 < AC自动机 >]]></title>
    <url>%2FBZOJ2938%E3%80%90POI2000%E3%80%91%E7%97%85%E6%AF%92%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Problem【POI2000】病毒 Description二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。示例：如果 为病毒代码段，那么一个可能的无限长安全代码就是 。如果 为病毒代码段，那么就不存在一个无限长的安全代码。任务：请写一个程序 读入病毒代码 判断是否存在一个无限长的安全代码 将结果输出 Input第一行包括一个整数 ，表示病毒代码段的数目。以下的 行每一行都包括一个非空的 字符串就是一个病毒代码段。所有病毒代码段的总长度不超过 。 Output一行输出一个单词： ：存在这样的代码 ：不存在这样的代码 Sample Input12343011100000 Sample Output1NIE 标签：AC自动机 Solution首先显然需要建 自动机。然后，在此 自动机形成的 上，一个符合题意的无限长的串一定对应一个环，并且换上没有任何一个结点有结束标记。因此直接在 上 ，暴力找解即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MAX_N 30000using namespace std;int n, rt, cnt, tr[MAX_N+5][2], fail[MAX_N+5];char s[MAX_N+5]; bool end[MAX_N+5], mrk[MAX_N+5], ins[MAX_N+5];void init() {rt = ++cnt, tr[0][0] = tr[0][1] = rt;}void insert() { int cur = rt, len = (int)strlen(s); for (int i = 0; i &lt; len; cur = tr[cur][s[i++]-'0']) if (!tr[cur][s[i]-'0']) tr[cur][s[i]-'0'] = ++cnt; end[cur] = true;}void setFail() { queue &lt;int&gt; que; que.push(rt); while (!que.empty()) { int u = que.front(); que.pop(); if (!tr[u][0]) tr[u][0] = tr[fail[u]][0]; else que.push(tr[u][0]), fail[tr[u][0]] = tr[fail[u]][0], end[tr[u][0]] |= end[tr[fail[u]][0]]; if (!tr[u][1]) tr[u][1] = tr[fail[u]][1]; else que.push(tr[u][1]), fail[tr[u][1]] = tr[fail[u]][1], end[tr[u][1]] |= end[tr[fail[u]][1]]; }}bool DFS(int u) { if (end[u]) return false; ins[u] = mrk[u] = true; if (ins[tr[u][0]]) return true; if (ins[tr[u][1]]) return true; if (!mrk[tr[u][0]] &amp;&amp; DFS(tr[u][0])) return true; if (!mrk[tr[u][1]] &amp;&amp; DFS(tr[u][1])) return true; ins[u] = false; return false;}int main() { scanf("%d", &amp;n), init(); for (int i = 1; i &lt;= n; i++) scanf("%s", s), insert(); setFail(); return puts(DFS(rt) ? "TAK" : "NIE"), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>POI</tag>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2753【SCOI2012】滑雪与时间胶囊 < MST >]]></title>
    <url>%2FBZOJ2753%E3%80%90SCOI2012%E3%80%91%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%20MST%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2012】滑雪与时间胶囊 Description 非常喜欢滑雪。他来到一座雪山，这里分布着 条供滑行的轨道和 个轨道之间的交点（同时也是景点），而且每个景点都有一编号 （ ）和一高度 。 能从景点 滑到景点 当且仅当存在一条 和 之间的边，且 的高度不小于 。 与其他滑雪爱好者不同， 喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。于是 拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是 滑行的距离）。请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在， 站在 号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？ Input输入的第一行是两个整数 ， 。接下来 行有 个整数 ，分别表示每个景点的高度。接下来 行，表示各个景点之间轨道分布的情况。每行 个整数， 。表示编号为 的景点和编号为 的景点之间有一条长度为 的轨道。 Output输出一行，表示 最多能到达多少个景点，以及此时最短的滑行距离总和。 Sample Input123453 33 2 11 2 12 3 11 3 10 Sample Output13 2 HINT对于 的数据，保证 对于 的数据，保证 , , , 。 标签：MST Solution原题的一大坨叙述就是求有向图中从一点出发能达到的点数和最小生成树边权和。 第一问直接 出解。第二问比较麻烦，还是做 ，只是排序的时候以终点高度从高到低为第一关键字，以边权从低到高为第二关键字。 原理：首先，同一高度的点间一定是双向边，于是是一个强连通分量，如果把每个高度的点缩起来，那么最后一定会形成一个 ，从 开始沿拓扑序遍历每个强连通分量，这个强连通分量中的边都是双向边，可以在这个强连通分量中跑 ，除了这些边以外还可能有从上面的点连下来的点。因此如果按终点高度为第一关键字排序，那么到一个高度时一定是此高度强连通分量内部的双向边和前面连到此强连通分量的边，符合 贪心的前提。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define MAX_M 2000000#define pb push_backusing namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, p, h[MAX_N+5], fa[MAX_N+5];vector &lt;int&gt; G[MAX_N+5]; bool mrk[MAX_N+5];struct node {int u, v, w; lnt c;} E[MAX_M+5];bool cmp (const node &amp;a, const node &amp;b) { return a.w == b.w ? a.c &lt; b.c : a.w &gt; b.w;}int getf(int x) {return fa[x] == x ? x : fa[x] = getf(fa[x]);}int BFS() { int ret = 1; mrk[1] = true; queue &lt;int&gt; que; que.push(1); while (!que.empty()) { int u = que.front(); que.pop(); for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (!mrk[v = G[u][i]]) que.push(v), mrk[v] = true, ret++; } return ret;}int main() { read(n), read(m); lnt ans = 0; for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1; i &lt;= n; i++) read(h[i]); for (int i = 0; i &lt; m; i++) { int u, v; lnt c; read(u), read(v), read(c); if (h[u] &gt;= h[v]) G[u].pb(v), E[++p] = (node){u, v, h[v], c}; if (h[u] &lt;= h[v]) G[v].pb(u), E[++p] = (node){v, u, h[u], c}; } sort(E+1, E+(m=p)+1, cmp), printf("%d ", BFS()); for (int i = 1, u, v; i &lt;= m; i++) if (mrk[E[i].u] &amp;&amp; mrk[E[i].v]) { u = getf(E[i].u), v = getf(E[i].v); if (u^v) fa[u] = v, ans += E[i].c; } return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2115【WC2011】Xor]]></title>
    <url>%2FBZOJ2115%E3%80%90WC2011%E3%80%91Xor%20%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[Problem【WC2011】Xor Description Input第一行包含两个整数 和 ，表示该无向图中点的数目与边的数目。接下来 行描述 条边，每行三个整数 ，表示 与 之间存在 一条权值为 的无向边。图中可能有重边或自环。 Output仅包含一个整数，表示最大的 和（十进制结果），注意输出后加换行回车。 Sample Input123456785 71 2 21 3 22 4 12 5 14 5 35 3 44 3 2 Sample Output16 Hint 标签：线性基 Solution线性基经典题。 对于一条非简单的路径，其异或和等于其中的简单路径异或和异或上经过的环的异或和，即选取一条简单路径和若干环，此简单路径到环的那段路径会经过两次，因而异或和消成 。因此只用选出一条从 到 的简单路径异或和，再异或上若干环的异或和使总和最大即可。于是暴力 找到简单路径异或和和所有环的异或和，对所有环的异或和求线性基，贪心选最大和即可。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define SZ 60#define MAX_N 50000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m;lnt b[SZ+5], dis[MAX_N+5]; bool mrk[MAX_N+5];vector &lt;int&gt; G[MAX_N+5]; vector &lt;lnt&gt; E[MAX_N+5];void insert(lnt x) { for (int i = SZ; ~i; i--) if (x&gt;&gt;i&amp;1) { if (b[i]) x ^= b[i]; else {b[i] = x; break;} }}void DFS(int u) { for (int i = 0, v; i &lt; (int)G[u].size(); i++) if (mrk[v = G[u][i]]) insert(dis[u]^dis[v]^E[u][i]); else dis[v] = dis[u]^E[u][i], mrk[v] = true, DFS(v);}int main() { read(n), read(m); for (int i = 0, u, v; i &lt; m; i++) { lnt c; read(u), read(v), read(c); G[u].push_back(v), E[u].push_back(c); G[v].push_back(u), E[v].push_back(c); } DFS(1); lnt mx = dis[n]; for (int i = SZ; ~i; i--) if (!(mx&gt;&gt;i&amp;1)) mx ^= b[i]; return printf("%lld\n", mx), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>线性基</tag>
        <tag>WC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4568【SCOI2016】幸运数字 < LCA+线性基 >]]></title>
    <url>%2FBZOJ4568%E3%80%90SCOI2016%E3%80%91%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%20LCA%2B%E7%BA%BF%E6%80%A7%E5%9F%BA%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2016】幸运数字 Description 国共有 座城市，这些城市由 条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览 国。旅行者计划乘飞机降落在 号城市，沿着 号城市到 号城市之间那条唯一的路径游览，最终从 城市起飞离开 国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，游览者拍了 张照片，幸运值分别是 ，那么最终保留在自己身上的幸运值就是 。有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择 和 ，可以保留的幸运值为 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。 Input第一行包含 个正整数 ，分别表示城市的数量和旅行者数量。第二行包含 个非负整数，其中第 个整数 表示 号城市的幸运值。随后 行，每行包含两个正整数 ，表示 号城市和 号城市之间有一条道路相连。随后 行，每行包含两个正整数 ，表示这名旅行者的旅行计划是从 号城市到 号城市。 Output输出需要包含 行，每行包含 个非负整数，表示这名旅行者可以保留的最大幸运值。 Sample Input12345674 211 5 7 91 21 31 42 31 4 Sample Output121411 Hint 标签：线性基 Solution最大子集异或和上树… 树上两点间路径，容易联想到倍增 ；最大子集异或和，容易联想到线性基。因此把两者结合起来，预处理出每个结点到其 祖先结点路径上的线性基，对于倍增的合并，可以暴力合并线性基，即将一个线性基中的数暴力插到另一个线性基中。求 的过程照常，只是将单个值合并换成了两个数组合并。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define SZ 60#define LOG 15#define MAX_N 20000#define vl vector&lt;lnt&gt;using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}lnt a[MAX_N+5];int n, q, fa[MAX_N+5][LOG+1], dep[MAX_N+5];vector &lt;lnt&gt; b[MAX_N+5][LOG+1]; vector &lt;int&gt; G[MAX_N+5];void addedge(int u, int v) {G[u].push_back(v), G[v].push_back(u);}lnt get_mx(vl base) { lnt ret = 0LL; for (int i = SZ; ~i; i--) if (base[i]) if ((ret^base[i]) &gt; ret) ret ^= base[i]; return ret;}vl merge(vl x, vl y) { vl ret = x; for (int i = SZ; ~i; i--) if (y[i]) for (int j = i; ~j; j--) if (y[i]&gt;&gt;j&amp;1) { if (ret[j]) y[i] ^= ret[j]; else {ret[j] = y[i]; break;} } return ret;}void DFS(int u) { b[u][0].resize(SZ+1); for (int i = SZ; ~i; i--) if (a[u]&gt;&gt;i&amp;1) {b[u][0][i] = a[u]; break;} for (int i = 1; i &lt;= LOG; i++) fa[u][i] = fa[fa[u][i-1]][i-1], b[u][i].resize(SZ+1), b[u][i] = merge(b[u][i-1], b[fa[u][i-1]][i-1]); for (int i = 0, v; i &lt; (int)G[u].size(); i++) if ((v = G[u][i]) ^ fa[u][0]) fa[v][0] = u, dep[v] = dep[u]+1, DFS(v);}lnt query(int u, int v) { vl ub, vb; ub.resize(SZ+1), vb.resize(SZ+1); if (dep[u] &lt; dep[v]) swap(u, v); for (int i = LOG; ~i; i--) if (dep[u]-dep[v] &gt;= (1&lt;&lt;i)) ub = merge(ub, b[u][i]), u = fa[u][i]; if (u == v) return get_mx(merge(ub, b[u][0])); for (int i = LOG; ~i; i--) if (fa[u][i]^fa[v][i]) ub = merge(ub, b[u][i]), u = fa[u][i], vb = merge(vb, b[v][i]), v = fa[v][i]; ub = merge(ub, b[u][0]), vb = merge(vb, b[v][0]); return get_mx(merge(merge(ub, vb), b[fa[u][0]][0]));}int main() { read(n), read(q); for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1, u, v; i &lt; n; i++) read(u), read(v), addedge(u, v); for (int i = 0; i &lt;= LOG; i++) b[0][i].resize(SZ+1); DFS(1); while (q--) { int u, v; read(u), read(v); printf("%lld\n", query(u, v)); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>数论数学</tag>
        <tag>LCA</tag>
        <tag>线性基</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2177 曼哈顿最小生成树]]></title>
    <url>%2FBZOJ2177%20%E6%9B%BC%E5%93%88%E9%A1%BF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%E5%BB%BA%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[Problem曼哈顿最小生成树 Description平面坐标系 内，给定 个顶点 。对于顶点 ， 与 之间的距离 定义为 。你的任务是求出这 个顶点的最小生成树。 Input第一行一个正整数 ，表示定点个数。接下来 行每行两个正整数 ，描述一个顶点。 Output只有一行，为最小生成树的边的距离和。 Sample Input1234541 00 10 -1-1 0 Sample Output16 HINT对于 的数据， 。 标签：树状数组 MST Solution 裸题。 对于曼哈顿最小生成树，直接建边肯定是不行的，考虑优化建边，去掉一些一定不会在 中的边。考虑一个点 ，以 为中心将整个图分为 个部分。 对于一个在右上角的点 ，一定有 且 ，若其使 最小，则所有在右上角的点的曼哈顿距离都没有 小。因此在 右上角的所有点中，只连 即可。同理在 周围的八个方向中，每个方向只需连曼哈顿距离最小的点。 对于如何寻找这样的点，拿找右上角的最近点做例子：最近的点 一定使 最小，即使 最小。同时要满足 和 ，即满足 且 。可以发现这就是以 为第一维， 为第二维做偏序，找到符合的位置中的最小值，用 排 序 树 状 数 组 维护。这样我们就可以连每个点到其右上角的最近点的边了。考虑到边可以每次都连双向，因此每个点只用枚举一半即可。这里默认向 坐标比当前点大的点连边。其实是可以把每种情况都转化为右上角的。一开始的时候，我们总共需要考虑的是下图区域 中的最近点。第一次连边将 中的最近点连边。 接下来将每个点的 坐标互换，即关于直线 对称，可以得到下图。第二次连边将 中的最近点连边。 然后将每个点的 坐标取反，即可得到下图。这时第三次连边将 中的最近点连边。 最后再次互换每个点的 坐标，得到下图。第四次连边将 中的最近点连边。 由此，我们可以不改回原值就将 个方向连边。建图后，直接跑 或 即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define INF 4020010910LLusing namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, cnt, fa[MAX_N+5];lnt tr[MAX_N+5]; int mi[MAX_N+5];struct edge {int u, v; lnt c;} E[(MAX_N&lt;&lt;2)+5];struct P {int id; lnt x, y;} p[MAX_N+5], q[MAX_N+5];bool cmpe (const edge &amp;a, const edge &amp;b) {return a.c &lt; b.c;}bool cmpp (const P &amp;a, const P &amp;b) {return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;}lnt dist(int u, int v) {return abs(q[u].x-q[v].x)+abs(q[u].y-q[v].y);}void addedge(int u, int v) {E[++cnt] = (edge){u, v, dist(u, v)};}int getf(int x) {return fa[x] == x ? x : fa[x] = getf(fa[x]);}void modify(int pos, lnt x, int id) { for (; pos; pos -= pos&amp;-pos) if (tr[pos] &gt; x) tr[pos] = x, mi[pos] = id;}int query(int pos) { int ret = -1; lnt mc = INF; for (; pos &lt;= n; pos += pos&amp;-pos) if (tr[pos] &lt; mc) mc = tr[pos], ret = mi[pos]; return ret;}void build() { int a[MAX_N+5], b[MAX_N+5], m; sort(p+1, p+n+1, cmpp); for (int i = 1; i &lt;= n; i++) a[i] = b[i] = p[i].y-p[i].x; sort(b+1, b+n+1), m = (int)(unique(b+1, b+n+1)-b-1); for (int i = 1; i &lt;= n; i++) tr[i] = INF; memset(mi, -1, sizeof mi); for (int i = n, rk, mp; i; i--) { rk = (int)(lower_bound(b+1, b+m+1, a[i])-b); mp = query(rk); if (~mp) addedge(p[i].id, mp); modify(rk, p[i].x+p[i].y, p[i].id); }}lnt MST() { sort(E+1, E+cnt+1, cmpe); lnt ret = 0; for (int i = 1; i &lt;= n; i++) fa[i] = i; for (int i = 1, u, v; i &lt;= cnt; i++) { u = getf(E[i].u), v = getf(E[i].v); if (u^v) fa[u] = v, ret += E[i].c; } return ret;}int main() { read(n); for (int i = 1; i &lt;= n; i++) p[i].id = i, read(p[i].x), read(p[i].y), q[i] = p[i]; build(); for (int i = 1; i &lt;= n; i++) swap(p[i].x, p[i].y); build(); for (int i = 1; i &lt;= n; i++) p[i].x *= -1; build(); for (int i = 1; i &lt;= n; i++) swap(p[i].x, p[i].y); build(); for (int i = 1; i &lt;= n; i++) p[i].y *= -1; return printf("%lld\n", MST()), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树状数组</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4695 最假女选手 < SegBeats >]]></title>
    <url>%2FBZOJ4695%20%E6%9C%80%E5%81%87%E5%A5%B3%E9%80%89%E6%89%8B%20SegBeats%2F</url>
    <content type="text"><![CDATA[Problem最假女选手 Description在刚刚结束的水题嘉年华的压轴节目放水大赛中， 如愿以偿的得到了最假女选手的奖项。但是作为主办人的 为了证明 确实在放水，决定出一道基础题考察 的姿势水平。给定一个长度为 序列，编号从 到 。要求支持下面几种操作： 给一个区间 加上一个数 把一个区间 里小于 的数变成 把一个区间 里大于 的数变成 求区间 的和 求区间 的最大值 求区间 的最小值 Input第一行一个整数 表示序列长度第二行 个整数 表示初始序列第三行一个整数 表示操作个数接下来 行，每行三或四个整数，第一个整数 表示操作类型，接下来 或 表述操作数 Output对于每个 类型的操作，输出一行一个整数表示答案 Sample Input1234521 222 1 2 24 1 2 Sample Output14 HINT 时, 或 时， 标签：SegBeats 线段树 Solution 参见吉老师的冬令营课件。 像课件里那样维护最大值、最大值个数、严格次大值、最小值、最小值个数、严格次小值、区间加标记、区间和，丧心病狂分类更新即可。注意只有区间和需要开 ，这样即省空间又省常数。 好久没写过上 行的代码了…强烈建议先对拍再交，否则容易卡住评测… Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;bits/stdc++.h&gt;#define ls (v&lt;&lt;1)#define rs (v&lt;&lt;1|1)#define mid ((s+t)&gt;&gt;1)#define MAX_N 500000#define INF 0x3f3f3f3fusing namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}struct node {int mx1, mx2, mxc, mi1, mi2, mic, tag; lnt s;} tr[(MAX_N&lt;&lt;2)+5];void update(int v) { tr[v].s = tr[ls].s+tr[rs].s; if (tr[ls].mx1 == tr[rs].mx1) tr[v].mx1 = tr[ls].mx1, tr[v].mxc = tr[ls].mxc+tr[rs].mxc, tr[v].mx2 = max(tr[ls].mx2, tr[rs].mx2); else if (tr[ls].mx1 &gt; tr[rs].mx1) tr[v].mx1 = tr[ls].mx1, tr[v].mxc = tr[ls].mxc, tr[v].mx2 = max(tr[ls].mx2, tr[rs].mx1); else tr[v].mx1 = tr[rs].mx1, tr[v].mxc = tr[rs].mxc, tr[v].mx2 = max(tr[ls].mx1, tr[rs].mx2); if (tr[ls].mi1 == tr[rs].mi1) tr[v].mi1 = tr[ls].mi1, tr[v].mic = tr[ls].mic+tr[rs].mic, tr[v].mi2 = min(tr[ls].mi2, tr[rs].mi2); else if (tr[ls].mi1 &lt; tr[rs].mi1) tr[v].mi1 = tr[ls].mi1, tr[v].mic = tr[ls].mic, tr[v].mi2 = min(tr[ls].mi2, tr[rs].mi1); else tr[v].mi1 = tr[rs].mi1, tr[v].mic = tr[rs].mic, tr[v].mi2 = min(tr[ls].mi1, tr[rs].mi2);}void updmx(int v, int s, int t, int x) { tr[v].s -= 1LL*tr[v].mxc*(tr[v].mx1-x); tr[v].mx1 = x, tr[v].mi1 = min(x, tr[v].mi1); if (tr[v].mx1^tr[v].mi1) tr[v].mi2 = min(x, tr[v].mi2); else tr[v].mx2 = -INF, tr[v].mi2 = INF, tr[v].s = 1LL*(t-s+1)*x, tr[v].mxc = tr[v].mic = t-s+1;}void updmi(int v, int s, int t, int x) { tr[v].s += 1LL*tr[v].mic*(x-tr[v].mi1); tr[v].mi1 = x, tr[v].mx1 = max(x, tr[v].mx1); if (tr[v].mx1^tr[v].mi1) tr[v].mx2 = max(x, tr[v].mx2); else tr[v].mx2 = -INF, tr[v].mi2 = INF, tr[v].s = 1LL*(t-s+1)*x, tr[v].mxc = tr[v].mic = t-s+1;}void downtag(int v, int s, int t) { int x = tr[v].tag; tr[v].tag = 0; if (x) tr[ls].mx1 += x, tr[ls].mx2 += x, tr[ls].mi1 += x, tr[ls].mi2 += x, tr[ls].s += 1LL*(mid-s+1)*x, tr[ls].tag += x, tr[rs].mx1 += x, tr[rs].mx2 += x, tr[rs].mi1 += x, tr[rs].mi2 += x, tr[rs].s += 1LL*(t-mid)*x, tr[rs].tag += x; if (tr[v].mx1 &lt; tr[ls].mx1 &amp;&amp; tr[v].mx1 &gt; tr[ls].mx2) updmx(ls, s, mid, tr[v].mx1); if (tr[v].mi1 &gt; tr[ls].mi1 &amp;&amp; tr[v].mi1 &lt; tr[ls].mi2) updmi(ls, s, mid, tr[v].mi1); if (tr[v].mx1 &lt; tr[rs].mx1 &amp;&amp; tr[v].mx1 &gt; tr[rs].mx2) updmx(rs, mid+1, t, tr[v].mx1); if (tr[v].mi1 &gt; tr[rs].mi1 &amp;&amp; tr[v].mi1 &lt; tr[rs].mi2) updmi(rs, mid+1, t, tr[v].mi1);}void build(int v, int s, int t) { if (s == t) { int x; read(x); tr[v].mx1 = tr[v].mi1 = x, tr[v].mxc = tr[v].mic = 1; tr[v].mx2 = -INF, tr[v].mi2 = INF, tr[v].s = x; return; } build(ls, s, mid), build(rs, mid+1, t), update(v);}void modify(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) { tr[v].mx1 += x, tr[v].mx2 += x; tr[v].mi1 += x, tr[v].mi2 += x; tr[v].s += 1LL*(t-s+1)*x; tr[v].tag += x; return; } downtag(v, s, t); if (l &lt;= mid) modify(ls, s, mid, l, r, x); if (r &gt;= mid+1) modify(rs, mid+1, t, l, r, x); update(v);}void optmx(int v, int s, int t, int l, int r, int x) { if (tr[v].mi1 &gt;= x) return; if (s &gt;= l &amp;&amp; t &lt;= r &amp;&amp; x &lt; tr[v].mi2) {updmi(v, s, t, x); return;} downtag(v, s, t); if (l &lt;= mid) optmx(ls, s, mid, l, r, x); if (r &gt;= mid+1) optmx(rs, mid+1, t, l, r, x); update(v);}void optmi(int v, int s, int t, int l, int r, int x) { if (tr[v].mx1 &lt;= x) return; if (s &gt;= l &amp;&amp; t &lt;= r &amp;&amp; x &gt; tr[v].mx2) {updmx(v, s, t, x); return;} downtag(v, s, t); if (l &lt;= mid) optmi(ls, s, mid, l, r, x); if (r &gt;= mid+1) optmi(rs, mid+1, t, l, r, x); update(v);}lnt query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].s; downtag(v, s, t); lnt ret = 0LL; if (l &lt;= mid) ret += query(ls, s, mid, l, r); if (r &gt;= mid+1) ret += query(rs, mid+1, t, l, r); update(v); return ret;}int getmx(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].mx1; downtag(v, s, t); int ret = -INF; if (l &lt;= mid) ret = max(ret, getmx(ls, s, mid, l, r)); if (r &gt;= mid+1) ret = max(ret, getmx(rs, mid+1, t, l, r)); update(v); return ret;}int getmi(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].mi1; downtag(v, s, t); int ret = INF; if (l &lt;= mid) ret = min(ret, getmi(ls, s, mid, l, r)); if (r &gt;= mid+1) ret = min(ret, getmi(rs, mid+1, t, l, r)); update(v); return ret;}int main() { int n, T; read(n), build(1, 1, n), read(T); while (T--) { int opt, l, r, x; read(opt); if (opt == 1) read(l), read(r), read(x), modify(1, 1, n, l, r, x); if (opt == 2) read(l), read(r), read(x), optmx(1, 1, n, l, r, x); if (opt == 3) read(l), read(r), read(x), optmi(1, 1, n, l, r, x); if (opt == 4) read(l), read(r), printf("%lld\n", query(1, 1, n, l, r)); if (opt == 5) read(l), read(r), printf("%d\n", getmx(1, 1, n, l, r)); if (opt == 6) read(l), read(r), printf("%d\n", getmi(1, 1, n, l, r)); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1071【SCOI2007】组队]]></title>
    <url>%2FBZOJ1071%E3%80%90SCOI2007%E3%80%91%E7%BB%84%E9%98%9F%20%E5%8F%8C%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2007】组队 Description 每年都有球员选秀环节。通常用速度和身高两项数据来衡量一个篮球运动员的基本素质。假如一支球队里速度最慢的球员速度为 ，身高最矮的球员高度为 ，那么这支球队的所有队员都应该满足： 。其中 和 为给定的经验值。这个式子很容易理解，如果一个球队的球员速度和身高差距太大，会造成配合的不协调。 请问作为球队管理层的你，在 名选秀球员中，最多能有多少名符合条件的候选球员。 Input第一行四个数 。下接 行每行两个数描述一个球员的 和 。 Output最多候选球员数目。 Sample Input123454 1 2 105 13 22 32 1 Sample Output14 HINT ， 和 不大于 。 在长整型以内。 数据加强， 程序未重测。 标签：双指针 Solution挺神的题，两个序列上双指针的操作挺奇葩。 对于每个队员，令 ，将队员数组 同时复制到 中，分别排序。 按照 从小到大排序， 按照 从小到大排序。首先按任意顺序枚举 的最小值大小，不妨直接再 中枚举。这时定义左指针和右指针 和 ，只是与普通双指针不同的是， 指向的是 中的元素， 指向的是 中的元素，可以理解为 中的右指针是不动的， 中的左指针是不动的。这样精妙设计是考虑到 中递增的 值如果不满足要求，即小于枚举到的 值，小于的部分一定是从前面开始的；同样地， 中递增的 值如果不满足要求，即大于 ，大于的部分一定是从后面开始的。这样对每个数组跑“单指针”即可得到可行最大子段，更新答案即可。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define MAX_N 5000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n; lnt A, B, C, miv, mxv;struct node {lnt h, v, s;} p[MAX_N+5], q[MAX_N+5];bool cmph(const node &amp;a, const node &amp;b) {return a.h &lt;= b.h;}bool cmps(const node &amp;a, const node &amp;b) {return a.s &lt;= b.s;}int main() { read(n), read(A), read(B), read(C); int ans = 0; for (int i = 1; i &lt;= n; i++) read(p[i].h), read(p[i].v); for (int i = 1; i &lt;= n; i++) p[i].s = A*p[i].h+B*p[i].v, q[i] = p[i]; sort(p+1, p+n+1, cmph), sort(q+1, q+n+1, cmps); for (int i = 1, l, r, cnt; i &lt;= n; i++) { l = r = cnt = 0, miv = p[i].v, mxv = miv+C/B; for (int j = 1; j &lt;= n; j++, ans = max(ans, cnt)) { while (r &lt; n &amp;&amp; q[r+1].s &lt;= A*p[j].h+B*p[i].v+C) r++, cnt += q[r].v &gt;= miv &amp;&amp; q[r].v &lt;= mxv; while (l &lt; n &amp;&amp; p[l+1].h &lt; p[j].h) l++, cnt -= p[l].v &gt;= miv &amp;&amp; p[l].v &lt;= mxv; } } return printf("%d\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数据结构</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1006【HNOI2008】神奇的国度]]></title>
    <url>%2FBZOJ1006%E3%80%90HNOI2008%E3%80%91%E7%A5%9E%E5%A5%87%E7%9A%84%E5%9B%BD%E5%BA%A6%20%E5%BC%A6%E5%9B%BE%2BMCS%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2008】神奇的国度 Description 国是一个热衷三角形的国度，连人的交往也只喜欢三角原则。他们认为三角关系：即 相互认识， 相互认识， 相互认识，是简洁高效的。为了巩固三角关系， 国禁止四边关系，五边关系等等的存在。所谓 边关系，是指 个人 之间仅存在 对认识关系： ，而没有其它认识关系。比如四边关系指 四个人 ， ， ， 相互认识，而 ， 不认识。全民比赛时，为了防止做弊，规定任意一对相互认识的人不得在一队。国王想知道，最少可以分多少支队。 Input第一行两个整数 。表示有 个人， 对认识关系。接下来 行每行输入一对朋友。 Output输出一个整数，最少可以分多少队。 Sample Input1234564 51 21 42 42 33 4 Sample Output13 HINT 标签：弦图 MCS Solution弦图与 算法参见 讲义。 结论：按照任意完美消除序列倒叙染色，每次贪心染能染的最小颜色，可以使颜色数最少。 套上 然后模拟染色即可，复杂度 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MAX_N 10000using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, d[MAX_N+5], c[MAX_N+5], seq[MAX_N+5];vector &lt;int&gt; G[MAX_N+5]; list &lt;int&gt; buk[MAX_N+5]; bool mrk[MAX_N+5];void addedge(int u, int v) {G[u].push_back(v), G[v].push_back(u);}void MCS() { memset(mrk, false, sizeof mrk); for (int i = 1; i &lt;= n; i++) buk[0].push_back(i); for (int i = 0, mx = 0, u; i &lt; n; seq[++i] = u, mrk[u] = true) { while (!buk[mx+1].empty()) mx++; for (u = -1; u == -1; mx--) { while (!buk[mx].empty() &amp;&amp; mrk[buk[mx].front()]) buk[mx].pop_front(); if (!buk[mx].empty()) u = buk[mx].front(); } for (int j = 0, v; j &lt; (int)G[u].size(); j++) if (!mrk[G[u][j]]) d[v = G[u][j]]++, buk[d[v]].push_back(v); }}int Color() { int ret = 0; memset(mrk, false, sizeof mrk); for (int i = 1, u = seq[1]; i &lt;= n; u = seq[++i]) { for (int j = 0; j &lt; (int)G[u].size(); j++) mrk[c[G[u][j]]] = true; for (int j = 1; !c[u]; j++) if (!mrk[j]) c[u] = j; for (int j = 0; j &lt; (int)G[u].size(); j++) mrk[c[G[u][j]]] = false; ret = max(ret, c[u]); } return ret;}int main() { read(n), read(m); for (int i = 1, u, v; i &lt;= m; i++) read(u), read(v), addedge(u, v); return MCS(), printf("%d\n", Color()), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>弦图</tag>
        <tag>MCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1078【SCOI2008】斜堆]]></title>
    <url>%2FBZOJ1078%E3%80%90SCOI2008%E3%80%91%E6%96%9C%E5%A0%86%20%E5%8F%AF%E5%B9%B6%E5%A0%86%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2008】斜堆 Description斜堆 是一种常用的数据结构。它也是二叉树，且满足与二叉堆相同的堆性质：每个非根结点的值都比它父亲大。因此在整棵斜堆中，根的值最小。但斜堆不必是平衡的，每个结点的左右儿子的大小关系也没有任何规定。在本题中，斜堆中各个元素的值均不相同。在斜堆 中插入新元素 的过程是递归进行的： 当 为空或者 小于 的根结点时X变为新的树根，而原来的树根（如果有的话）变为 的左儿子。 当 大于 的根结点时， 根结点的两棵子树交换，而 （递归）插入到交换后的左子树中。 给出一棵斜堆，包含值为 的结点各一次。求一个结点序列，使得该斜堆可以通过在空树中依次插入这些结点得到。如果答案不惟一，输出字典序最小的解。输入保证有解。 Input第一行包含一个整数 。第二行包含 个整数 ， 表示 是 的左儿子， 表示 是 的右儿子。显然 总是根，所以输入中不含 。 Output仅一行，包含 整数，即字典序最小的插入序列。 Sample Input126100 0 101 102 1 2 Sample Output10 1 2 3 4 5 标签：可并堆 斜堆 Solution探究斜堆性质的好题，可以围观 的题解。 考虑每次找到最后插入的结点，删除并维护到插入前的状态。那么我们需要探究一些斜堆的性质。 最后插入的结点一定是一个极左结点，即从根到它的路径都是向左走，因为最后插入后没有再交换过子树。 最后插入的结点一定没有右子树。易发现所有右子树都是因为插入结点而从左结点交换而来，而最后插入的结点的子树中一定不会插入新的结点，故一定不会有右子树。 最后插入结点时，其到根的结点一定会交换左右子树，因此这个结点到根的路径上的所有结点一定都有左右子树。 综上，最后插入的结点一定是从根结点一直向左走遇到的第一个无右子树的结点。特别地，如果此结点的左子结点是叶子，那么两者均可选，这时应该先选叶子结点以使字典序最小。模拟 次即可 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define MAX_N 50using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, rt, l[MAX_N+5], r[MAX_N+5];int f[MAX_N+5]; stack &lt;int&gt; sta;void find() { int u = rt; while (~r[u]) u = l[u]; if (~l[u] &amp;&amp; l[l[u]] == r[l[u]]) u = l[u]; sta.push(u); if (u == rt) rt = l[rt]; if (~f[u]) l[f[u]] = l[u], f[l[u]] = f[u]; for (int v = f[u]; ~v; v = f[v]) swap(l[v], r[v]);}int main() { read(n), f[0] = -1; memset(l, -1, sizeof l), memset(r, -1, sizeof r); for (int i = 1, d; i &lt;= n; i++) read(d), (d &lt; 100 ? l[d] = i : r[d-100] = i), f[i] = d &lt; 100 ? d : d-100; for (int i = 0; i &lt;= n; i++) find(); while (!sta.empty()) printf("%d ", sta.top()), sta.pop(); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数据结构</tag>
        <tag>可并堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2820 YY的GCD]]></title>
    <url>%2FBZOJ2820%20YY%E7%9A%84GCD%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemYY的GCD Description神犇 虐完数论后给 傻 叉 出了一题：给定 ，求 且 为质数的 有多少对 这种 傻 叉 必然不会了，于是向你来请教。多组输入。 Input第一行一个整数 表述数据组数。接下来 行，每行两个正整数，表示 。 Output 行，每行一个整数表示第 组数据的结果。 Sample Input123210 10100 100 Sample Output12302791 HINT 标签：莫比乌斯反演 Solution套路反演+积性函数预处理。 先套路推一波反演式： 那么我们需要用线筛预处理出所有 值。对于当前预处理到的数 和枚举到的质数 ，有 下面的式子的一部分可以化为上面的式子，剩余部分直接加上去。分类讨论： 若 ，则下式中 时， 的分解式中 的指数一定大于 ，于是只有 时会对答案产生 的贡献，所以 。 若 ，则下式中对于任意 ，其贡献都为上式中对应项的贡献乘 ，即 的贡献为 。当 时，只存在 ，此时贡献为 。因此 。 由此，可以线筛预处理出所有 值，然后根号分块计算答案即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int pri[MAX_N+5], mu[MAX_N+5], fac[MAX_N+5], cnt; bool NotPri[MAX_N+5];void PriS() { mu[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0, x; j &lt; cnt; j++) { if ((x = i*pri[j]) &gt; MAX_N) break; NotPri[x] = true; if (i%pri[j]) mu[x] = -mu[i]; else {mu[x] = 0; break;} } }}int main() { int n; read(n), PriS(); lnt ans = 0LL; for (lnt i = 1, l, r; i &lt; sqrt(n); i++) { cnt = 0; for (int j = 1; j &lt;= sqrt(i); j++) if (i%j == 0) fac[cnt++] = j; for (l = 1; l &lt; i; l = r+1) { lnt val = n/(i*(i+l)); if (!val) break; r = min(n/val/i-i, i-1); for (lnt k = 0, j; k &lt; cnt; k++) { j = fac[k], ans += mu[j]*(r/j-(l-1)/j)*val; lnt t = i/j; if (i%t == 0 &amp;&amp; (j^t)) ans += mu[t]*(r/t-(l-1)/t)*val; } } } return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1052【HAOI2007】覆盖问题]]></title>
    <url>%2FBZOJ1052%E3%80%90HAOI2007%E3%80%91%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%20%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[Problem【HAOI2007】覆盖问题 Description某人在山上种了 棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定用 个 的正方形塑料薄膜将小树遮起来。我们不妨将山建立一个平面直角坐标系，设第 棵小树的坐标为 ， 个 的正方形的边要求平行与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。 Input第一行有一个正整数 ，表示有多少棵树。接下来有 行，第 行有 个整数 ，表示第 棵树的坐标，保证不会有 个树的坐标相同。 Output一行，输出最小的 值。 Sample Input1234540 10 -11 0-1 0 Sample Output11 HINT 的数据， 标签：二分答案 Solution二分水题。 考虑到当 大于等于答案时，一定能全部覆盖。因此可以二分答案。对于当前二分到的答案 ，贪心选取前两个正方形，然后判断剩下的点能否被一个正方形包住。贪心选取即每个正方形一定覆盖剩余点中左上、左下、右上、右下四个最远点中至少一个，因而枚举 种情况后判断即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define x first#define y second#define mp make_pair#define pii pair&lt;int,int&gt;#define MAX_N 20000#define INF 0x3f3f3f#define mid ((l+r)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n; pii p[MAX_N+5]; bool mrk[MAX_N+5];bool chk(int r) { int x1 = INF, y1 = INF, x2 = -INF, y2 = -INF; for (int i = 1; i &lt;= n; i++) if (!mrk[i]) x1 = min(x1, p[i].x), y1 = min(y1, p[i].y), x2 = max(x2, p[i].x), y2 = max(y2, p[i].y); return x2-x1 &lt;= r &amp;&amp; y2-y1 &lt;= r;}int del(int sx, int sy, int r) { int ret = 0; for (int i = 1; i &lt;= n; i++) if (!mrk[i]) if (p[i].x &gt;= sx &amp;&amp; p[i].x &lt;= sx+r) if (p[i].y &gt;= sy &amp;&amp; p[i].y &lt;= sy+r) mrk[i] = true, ret++; return ret;}bool DFS(int stp, int lft, int r) { if (!lft) return true; if (stp &gt; 2) return chk(r); int x1 = INF, y1 = INF, x2 = -INF, y2 = -INF; for (int i = 1; i &lt;= n; i++) if (!mrk[i]) x1 = min(x1, p[i].x), y1 = min(y1, p[i].y), x2 = max(x2, p[i].x), y2 = max(y2, p[i].y); bool bk[MAX_N+5]; memcpy(bk, mrk, sizeof mrk); if (DFS(stp+1, lft-del(x1, y1, r), r)) return true; memcpy(mrk, bk, sizeof bk); if (DFS(stp+1, lft-del(x1, y2-r, r), r)) return true; memcpy(mrk, bk, sizeof bk); if (DFS(stp+1, lft-del(x2-r, y1, r), r)) return true; memcpy(mrk, bk, sizeof bk); if (DFS(stp+1, lft-del(x2-r, y2-r, r), r)) return true; memcpy(mrk, bk, sizeof bk); return false;}int bi_search(int l, int r) { int ret = -1; while (l &lt;= r) { memset(mrk, false, sizeof mrk); if (!DFS(1, n, mid)) l = mid+1; else ret = mid, r = mid-1; } return ret;}int main() { read(n); for (int i = 1; i &lt;= n; i++) read(p[i].x), read(p[i].y); return printf("%d\n", bi_search(1, INF)), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1430 小猴打架 < Prufer序列+组合数学 >]]></title>
    <url>%2FBZOJ1430%20%E5%B0%8F%E7%8C%B4%E6%89%93%E6%9E%B6%20Prufer%E5%BA%8F%E5%88%97%2B%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[Problem小猴打架 Description一开始森林里面有 只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过 次打架之后，整个森林的小猴都会成为好朋友。 现在的问题是，总共有多少种不同的打架过程。 比如当 时，就有 六种不同的打架过程。 Input一个整数 ， Output一行，方案数 。 Sample Input14 Sample Output196 标签：Prufer序列 组合数学 Solution由 序 列 可知，一棵有 个点的树与一个长为 的序列一一对应。那么确定出这样的序列的方案数即可确定最后形成的树的形态。易知这样的序列共有 个。再考虑构建树的顺序，即为 个元素的全排列数，总数为 。故答案为 。 Code12345678910111213141516#include &lt;bits/stdc++.h&gt;#define MOD 9999991using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n; lnt ans = 1;int main() { read(n); for (int i = 1; i &lt;= n-2; i++) (ans *= 1LL*n) %= MOD; for (int i = 1; i &lt;= n-1; i++) (ans *= 1LL*i) %= MOD; return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>组合数学</tag>
        <tag>数论数学</tag>
        <tag>Prufer序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1027【JSOI2007】合金]]></title>
    <url>%2FBZOJ1027%E3%80%90JSOI2007%E3%80%91%E5%90%88%E9%87%91%20%E5%87%B8%E5%8C%85%2BFloyed%2F</url>
    <content type="text"><![CDATA[Problem【JSOI2007】合金 Description某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。 Input第一行两个整数 和 ，分别表示原材料种数和用户需要的合金种数。第 到 行，每行三个实数 且 ，分别表示铁铝锡在一种原材料中所占的比重。第 到 行，每行三个实数 且 ，分别表示铁铝锡在一种用户需要的合金中所占的比重。 Output一个整数，表示最少需要的原材料种数。若无解，则输出 。 Sample Input12345678910111213141516171819202110 100.1 0.2 0.70.2 0.3 0.50.3 0.4 0.30.4 0.5 0.10.5 0.1 0.40.6 0.2 0.20.7 0.3 00.8 0.1 0.10.9 0.1 01 0 00.1 0.2 0.70.2 0.3 0.50.3 0.4 0.30.4 0.5 0.10.5 0.1 0.40.6 0.2 0.20.7 0.3 00.8 0.1 0.10.9 0.1 01 0 0 Sample Output15 标签：凸包 Floyed Solution首先，给出的三个参数确定两个就能确定第三个，因此可以把参数缩减为两个。考虑两种金属是否能造出第三种金属，若能造成，则第三种金属的两个参数必和这两种金属的参数成比例关系。推广到用 种金属制造一种合金，若将这 种金属的两个参数作为横纵坐标描成点，那么合金所代表的点只要在这 个点形成的凸包内即可制造。由此，题目转化为选出尽量少的点使得目标点都在选出点所构成的凸包内。 对于一个条有向线段，它能被选出到凸包上当且仅当所有目标点都在它的左侧。那么处理出所有这样的边后，我们就在点与点间连出了若干条边。我们需要尽量选尽量少的点，即选尽量少的边，使其构成凸包。这样直接跑 后枚举起始点即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define EPS 1e-8#define INF 0x3f3f3f3f#define x first#define y second#define mp make_pair#define pdd pair&lt;dnt,dnt&gt;using namespace std;typedef double dnt;bool G[MAX_N+5][MAX_N+5];pdd p[MAX_N+5], c[MAX_N+5];int n, m, f[MAX_N+5][MAX_N+5];pdd vec(pdd s, pdd t) {return mp(t.x-s.x, t.y-s.y);}dnt dot(pdd a, pdd b) {return a.x*b.x+a.y*b.y;}dnt cross(pdd a, pdd b) {return a.x*b.y-a.y*b.x;}bool chk(pdd s, pdd t, pdd a) { dnt mul = cross(vec(a, s), vec(a, t)); if (fabs(mul) &lt;= EPS &amp;&amp; dot(vec(a, s), vec(a, t)) &lt;= EPS) return true; if (mul &lt; -EPS) return true; return false;}bool spj() { for (int i = 1; i &lt;= n; i++) if (fabs(p[i].x-p[1].x) &gt; EPS || fabs(p[i].y-p[1].y) &gt; EPS) return false; for (int i = 1; i &lt;= m; i++) if (fabs(c[i].x-p[1].x) &gt; EPS || fabs(c[i].y-p[1].y) &gt; EPS) return false; return true;}int Floyed() { int ret = INF; memset(f, INF, sizeof f); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (G[i][j] &amp;&amp; i^j) f[i][j] = 1; for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) f[i][j] = min(f[i][j], f[i][k]+f[k][j]); for (int i = 1; i &lt;= n; i++) ret = min(ret, f[i][i]); return spj() ? 1 : (ret == INF ? -1 : ret);}int main() { scanf("%d%d", &amp;n, &amp;m), memset(G, true, sizeof G); dnt t; for (int i = 1; i &lt;= n; i++) scanf("%lf%lf%lf", &amp;p[i].x, &amp;p[i].y, &amp;t); for (int i = 1; i &lt;= m; i++) scanf("%lf%lf%lf", &amp;c[i].x, &amp;c[i].y, &amp;t); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (i^j) for (int k = 1; k &lt;= m &amp;&amp; G[i][j]; k++) G[i][j] &amp;= chk(p[i], p[j], c[k]); return printf("%d\n", Floyed()), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>Floyed</tag>
        <tag>凸包</tag>
        <tag>计算机和</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1095【ZJOI2007】Hide捉迷藏]]></title>
    <url>%2FBZOJ1095%E3%80%90ZJOI2007%E3%80%91Hide%E6%8D%89%E8%BF%B7%E8%97%8F%20%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97%2B%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【ZJOI2007】Hide捉迷藏 Description捉迷藏 和 是一对恩爱的夫妻，并且他们有很多孩子。某天， 、 和孩子们决定在家里玩捉迷藏游戏。他们的家很大且构造很奇特，由 个屋子和 条双向走廊组成，这 条走廊的分布使得任意两个屋子都互相可达。游戏是这样进行的，孩子们负责躲藏， 负责找，而 负责操纵这 个屋子的灯。在起初的时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性， 希望知道可能的最远的两个孩子的距离（即最远的两个关灯房间的距离）。我们将以如下形式定义每一种操作： ：改变第 个房间的照明状态，若原来打开，则关闭；若原来关闭，则打开。 ：开始一次游戏，查询最远的两个关灯房间的距离。 Input第一行包含一个整数 ，表示房间的个数，房间将被编号为 的整数。接下来 行每行两个整数 ，表示房间 与房间 之间有一条走廊相连。接下来一行包含一个整数 ，表示操作次数。接着 行，每行一个操作，如上文所示。 Output对于每一个操作 ，输出一个非负整数，表示最远的两个关灯房间的距离。若只有一个房间是关着灯的，输出 ；若所有房间的灯都开着，输出 。 Sample Input1234567891011121314151681 22 33 43 53 66 76 87GC 1GC 2GC 1G Sample Output12344334 Hint对于 的数据， 。 标签：括号序列 线段树 Solution不会写动态点分，受小岛姐的启发写了线段树，虽然有 个标记，但推出公式还是比较好写的。 括号序列对于一棵树，我们可以将其 序稍加优化，得到一个能记录每个点的子树结构的序列，即括号序列。用左括号 表示进入某点的子树，用右括号 表示走出某点的子树。 对于此树，括号序列为 ，可以看出括号序列有一个有用的性质，即仍两点之间的序列可以表示从前面的点走到后面的点的走法。例如对于点 和 ，其中间的序列为 ，如果去掉中间匹配的括号则变为 ，将 定义为向上走，将 定义为向下走，那么可以看出 向上走两步，再向下走两步即可到 。那么如果维护此题中的树的括号序列，那么只需要知道任意两个黑点间的括号序列消除配对后的长度的最大值后即可得到答案。 线段树维护对于一个序列的区间，可以用二元组 表示其消去配对后的序列，即有 个右括号和 个左括号。对于区间 和 ，它们合并起来的区间是 ，那么 当 时， 的左括号和 的右括号消去后一定会剩下 个左括号，因此 ， 当 时， 的左括号和 的右括号消去后一定会剩下 个右括号，因此 ， 那么易得到几个推论： 我们需要维护每个区间中两黑点间括号序列长度的最大值，那么我们还需要维护另外几个信息（有点像区间最大字段和）： 是 的 一 个 前 缀 ， 且 一 个 黑 点 接 在 之 后 是 的 一 个 前 缀 ， 且 一 个 黑 点 接 在 之 后 是 的 一 个 后 缀 ， 且 接 在 一 个 黑 点 后 是 的 一 个 后 缀 ， 且 接 在 一 个 黑 点 后 对于一个区间 ，其两个子区间 的七个值分别为 和 ，那么该区间的 一定是以下四个值的最大值： 而对于维护的 个信息，观察发现可以这样计算： 这样以后我们就可以用线段树维护这七个标记了。除了 有点长以外，其他都和裸线段树一样。 以后找时间把动态点分学一学吧。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define INF 0x3f3f3f3f#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}vector &lt;int&gt; G[MAX_N+5];int n, cnt, col[MAX_N+5]; int ind, seq[(MAX_N&lt;&lt;2)+5], dfn[MAX_N+5];struct node {int a, b, lp, lm, rp, rm, dis;} tr[(MAX_N&lt;&lt;4)+5];void addedge(int u, int v) {G[u].push_back(v), G[v].push_back(u);}void DFS(int u, int f) { seq[++ind] = -1, seq[++ind] = u, dfn[u] = ind; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if ((v = G[u][i]) ^ f) DFS(v, u); seq[++ind] = -2;}void init(int v, int p) { tr[v].a = tr[v].b = 0, tr[v].dis = -INF; if (seq[p] == -1) tr[v].b = 1; if (seq[p] == -2) tr[v].a = 1; if (seq[p] &gt; 0 &amp;&amp; col[seq[p]]) tr[v].lp = tr[v].lm = tr[v].rp = tr[v].rm = 0; else tr[v].lp = tr[v].lm = tr[v].rp = tr[v].rm = -INF;}void update(int v, int s, int t) { int a = tr[v&lt;&lt;1].a, b = tr[v&lt;&lt;1].b; int c = tr[v&lt;&lt;1|1].a, d = tr[v&lt;&lt;1|1].b; tr[v].a = b &lt; c ? a-b+c : a; tr[v].b = b &lt; c ? d : b-c+d; tr[v].lp = tr[v&lt;&lt;1].lp, tr[v].rp = tr[v&lt;&lt;1|1].rp; tr[v].lm = tr[v&lt;&lt;1].lm, tr[v].rm = tr[v&lt;&lt;1|1].rm; tr[v].lp = max(tr[v].lp, tr[v&lt;&lt;1|1].lp+a-b); tr[v].lp = max(tr[v].lp, tr[v&lt;&lt;1|1].lm+a+b); tr[v].lm = max(tr[v].lm, tr[v&lt;&lt;1|1].lm-a+b); tr[v].rp = max(tr[v].rp, tr[v&lt;&lt;1].rp-c+d); tr[v].rp = max(tr[v].rp, tr[v&lt;&lt;1].rm+c+d); tr[v].rm = max(tr[v].rm, tr[v&lt;&lt;1].rm+c-d); tr[v].dis = max(tr[v&lt;&lt;1].dis, tr[v&lt;&lt;1|1].dis); tr[v].dis = max(tr[v].dis, tr[v&lt;&lt;1|1].lm+tr[v&lt;&lt;1].rp); tr[v].dis = max(tr[v].dis, tr[v&lt;&lt;1|1].lp+tr[v&lt;&lt;1].rm);}void build(int v, int s, int t) { if (s == t) {init(v, s); return;} build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t); update(v, s, t);}void modify(int v, int s, int t, int p) { if (s == t) {init(v, s); return;} if (p &lt;= mid) modify(v&lt;&lt;1, s, mid, p); else modify(v&lt;&lt;1|1, mid+1, t, p); update(v, s, t);}int main() { read(n), cnt = n; for (int i = 1; i &lt;= n; i++) col[i] = 1; for (int i = 1, u, v; i &lt; n; i++) read(u), read(v), addedge(u, v); int T; read(T), DFS(1, 0), build(1, 1, ind); while (T--) { char opt[2]; scanf("%s", opt); if (opt[0] == 'C') { int x; read(x); cnt += col[x] ? -1 : 1, col[x] ^= 1; modify(1, 1, ind, dfn[x]); } if (opt[0] == 'G') { if (!cnt) puts("-1"); else if (cnt == 1) puts("0"); else printf("%d\n", tr[1].dis); } } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>括号序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1857【SCOI2010】传送带]]></title>
    <url>%2FBZOJ1857%E3%80%90SCOI2010%E3%80%91%E4%BC%A0%E9%80%81%E5%B8%A6%20%E4%B8%89%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2010】传送带 Description在一个 维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段 和线段 。 在 上的移动速度为 ，在 上的移动速度为 ，在平面上的移动速度 。现在 想从 点走到 点，他想知道最少需要走多长时间。 Input输入数据第一行是 个整数，表示 和 的坐标，分别为 。第二行是 个整数，表示 和 的坐标，分别为 。第三行是 个整数，分别是 。 Output输出数据为一行，表示 从 点走到 点的最短时间，保留到小数点后 位。 Sample Input1230 0 0 100100 0 100 1002 2 1 Sample Output1136.60 Hint对于 的数据， ， 。 标签：三分法 Solution三分套三分，据说有大学物理结论可以 做…首先一定是从 走到 上的一点 ，然后走平面到 上的一点 ，最后从 沿 走到 。考虑确定 上的 点，那么若将 点的所有位置都计算答案并画成函数图像，一定是一个单峰函数。那么确定 后可以三分法找到最佳 位置。同样地，对于每个 位置的最佳答案，也会呈一个单峰函数。因此可以先对 在 上进行三分，每次三分到的两个端点需要再对 在 上进行三分找到最小时间。这样一来，可以先在 上三分 ，每次三分找端点最值的时候再在 上三分 ，三分套三分即可找到答案。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define EPS 1e-4#define xx first#define yy second#define mp make_pair#define pdd pair&lt;dnt,dnt&gt;using namespace std;typedef double dnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}pdd A, B, C, D; dnt P, Q, R;dnt sqr(dnt x) {return x*x;}dnt dis(pdd x, pdd y) {return sqrt(sqr(x.xx-y.xx)+sqr(x.yy-y.yy));}dnt tri_search_T(pdd l, pdd r, pdd S) { dnt ret = dis(A, S)/dis(l, D)/Q+dis(S, l)/R; pdd llr, lrr; while (fabs(l.xx-r.xx) &gt; EPS || fabs(l.yy-r.yy) &gt; EPS) { llr = mp(l.xx+(r.xx-l.xx)/3, l.yy+(r.yy-l.yy)/3); lrr = mp(r.xx-(r.xx-l.xx)/3, r.yy-(r.yy-l.yy)/3); dnt tllr = dis(A, S)/P+dis(llr, D)/Q+dis(S, llr)/R; dnt tlrr = dis(A, S)/P+dis(lrr, D)/Q+dis(S, lrr)/R; if (tllr &lt; tlrr) r = lrr; else l = llr; ret = min(tllr, tlrr); } return ret;}dnt tri_search_S(pdd l, pdd r) { dnt ret = tri_search_T(C, D, l); pdd llr, lrr; while (fabs(l.xx-r.xx) &gt; EPS || fabs(l.yy-r.yy) &gt; EPS) { llr = mp(l.xx+(r.xx-l.xx)/3, l.yy+(r.yy-l.yy)/3); lrr = mp(r.xx-(r.xx-l.xx)/3, r.yy-(r.yy-l.yy)/3); dnt tllr = tri_search_T(C, D, llr); dnt tlrr = tri_search_T(C, D, lrr); if (tllr &lt; tlrr) r = lrr; else l = lrr; ret = min(tllr, tlrr); } return ret;}int main() { read(A.xx), read(A.yy), read(B.xx), read(B.yy); read(C.xx), read(C.yy), read(D.xx), read(D.yy); read(P), read(Q), read(R); return printf("%.2lf\n", tri_search_S(A, B)), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>三分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1068【SCOI2007】压缩]]></title>
    <url>%2FBZOJ1068%E3%80%90SCOI2007%E3%80%91%E5%8E%8B%E7%BC%A9%20%E5%8C%BA%E9%97%B4DP%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2007】压缩 Description给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母 与 ，其中 标记重复串的开始， 重复从上一个 （如果当前位置左边没有 ，则从串的开始算起）开始的解压结果（称为缓冲串）。 可以压缩为 ，下面是解压缩的过程： 另一个例子是 可以被压缩为 。 Input输入仅一行，包含待压缩字符串，仅包含小写字母，长度为 。 Output输出仅一行，即压缩后字符串的最短长度。 Sample InputInput #11aaaaaaa Input #21bcdcdcdcdxcdcdcdcd Sample OutputOutput #115 Output #2112 HINT样例解释在第一个样例中，解为 ，在第二个例子中，解为 。数据规模 的数据满足 标签：区间DP Solution每次压缩的是连续的一段，考虑区间 。 设 表示压缩字符串 的字串 的最短长度，其中压缩后的串串首自带一个 于是就会有两种转移： 若 ，则 但这样是有锅的…压缩后串中间的 会影响到后面的 。例如 ，显然 为一种压缩，但其复制一遍形成的 表示的不是原串。这是因为中间的 会使后面的 少复制一截。 于是我们调整状态定义，定义 表示压缩后除了串首不再含有任何一个 ， 表示压缩后除了串首还含有其他 ，这样前者是可以整体复制的，而后者不行。那么首先有边界条件 。转移有三种： ，表示直接把后缀接上去 ，其中 ，表示把前一半复制一遍 ，表示分成两半随便拼，只不过拼了以后不能复制，因为中间有 直接记忆化即可，注意第三种情况要判左右边界。 Code1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define MAX_N 50#define INF 0x3f3f3f3f#define mid ((l+r)&gt;&gt;1)using namespace std;int n, f[MAX_N+5][MAX_N+5][2]; char s[MAX_N+5];int DP(int l, int r, bool x) { int &amp;ret = f[l][r][x]; if (ret^INF) return ret; if (l == r &amp;&amp; !x) return ret = 2; if (x) { for (int i = l; i &lt; r; i++) { ret = min(ret, DP(l, i, 0)+DP(i+1, r, 0)); if (l &lt; i) ret = min(ret, DP(l, i, 0)+DP(i+1, r, 1)); if (i+1 &lt; r) ret = min(ret, DP(l, i, 1)+DP(i+1, r, 0)); if (l &lt; i &amp;&amp; i+1 &lt; r) ret = min(ret, DP(l, i, 1)+DP(i+1, r, 1)); } } else { for (int i = l; i &lt; r; i++) ret = min(ret, DP(l, i, 0)+r-i); bool flag = (r-l)%2 == 1; for (int i = l, j = mid+1; i &lt;= mid; i++, j++) if (s[i]^s[j]) flag = false; if (flag) ret = min(ret, DP(l, mid, 0)+1); } return ret;}int main() { scanf("%s", s+1), n = (int)strlen(s+1); memset(f, INF, sizeof f), DP(1, n, 0), DP(1, n, 1); return printf("%d", min(f[1][n][0], f[1][n][1])-1), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>区间DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3597【SCOI2014】方伯伯运椰子]]></title>
    <url>%2FBZOJ3597%E3%80%90SCOI2014%E3%80%91%E6%96%B9%E4%BC%AF%E4%BC%AF%E8%BF%90%E6%A4%B0%E5%AD%90%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2014】方伯伯运椰子 Description Input第一行包含二个整数 , 。接下来 行代表 条边，表示这个交通网络。每行六个整数，表示 。接下来一行包含一条边，表示连接起点的边。 Output一个浮点数，保留二位小数。表示答案，数据保证答案大于 。 Sample Input12345678910115 101 5 13 13 0 4122 5 30 18 396 1481 5 33 31 0 394 5 22 4 0 7864 5 13 32 0 5614 5 3 48 0 4602 5 32 47 604 2585 7 44 37 75 1645 7 34 50 925 4416 2 26 38 1000 22 Sample Output1103.00 HINT ， ， ， ， ， 。 标签：费用流 Solution妙不可言的费用流。 首先肯定需要二分答案，设当前答案是 ，那么第 条边压缩 流量花费 ，扩容 流量花费 。 对于二分后的 ，发现修改的同时维护流量守恒比较麻烦，不妨考虑先将所有流量都退掉，随后再逐一把不用退的流量增广回来，这样每次增广都可以保证流量守恒。那么初始费用为 。 建模：对于原图的第 条边： ，流量 ，费用 若 ，则 ，流量 ，费用 这样跑最小费用最大流后判断 初 始 费 用 最 小 增 广 费 用 是否成立即可判断是否有 。 正确性：由于跑费用流，会优先增广费用小的边，而 ，因此第一类边比第二类边小，一定会先走第一类边补到原先流量后再继续走第二类边扩容。 本文参考 的题解。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define MAX_M 100000#define EPS 1e-5#define INF 0x3f3f3f3f#define mid ((l+r)/2)using namespace std;typedef double dnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}struct node {int v, c, nxt; dnt w;} E[MAX_M+5];struct edge {int u, v, a, b, c, d;} e[MAX_M+5];int n, m, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5]; dnt mic, tot;void init() {s = n+1, t = n+2, cnt = 0, mic = tot = 0.0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, dnt w) {E[cnt] = (node){v, c, pr[u], w}, pr[u] = cnt++;}void addedge(int u, int v, int c, dnt w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; memset(inq, false, sizeof inq); dnt d[MAX_N+5]; int cr[MAX_N+5]; for (int i = 1; i &lt;= t; i++) d[i] = INF; d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; dnt w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (fabs(d[t]-INF) &lt;= EPS) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mic += 1.0*flow*d[t]; return true;}bool chk(dnt tans) { init(); for (int i = 1; i &lt;= m; i++) addedge(e[i].u, e[i].v, e[i].c, e[i].d-e[i].a-tans); for (int i = 1; i &lt;= m; i++) if (e[i].u^s) addedge(e[i].u, e[i].v, INF, e[i].b+e[i].d+tans); for (int i = 1; i &lt;= m; i++) tot += (e[i].a-e[i].d+tans)*e[i].c; while (SPFA()) ; return tot+mic &lt;= -EPS;}dnt bi_search(dnt l, dnt r) { dnt ret = -1.0; while (r-l &gt;= EPS) if (!chk(mid)) r = mid; else ret = mid, l = mid; return ret;}int main() { read(n), read(m); for (int i = 1; i &lt;= m; i++) read(e[i].u), read(e[i].v), read(e[i].a), read(e[i].b), read(e[i].c), read(e[i].d); return printf("%.2lf", bi_search(0.0, 30000.0)), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4443【SCOI2015】小凸玩矩阵]]></title>
    <url>%2FBZOJ4443%E3%80%90SCOI2015%E3%80%91%E5%B0%8F%E5%87%B8%E7%8E%A9%E7%9F%A9%E9%98%B5%20%E4%BA%8C%E5%88%86%2B%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2015】小凸玩矩阵 Description小凸和小方是好朋友，小方给小凸一个 的矩阵 ,要求小秃从其中选出 个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的 个数中第 大的数字的最小值是多少。 Input第一行给出三个整数 接下来 行，每行 个数字，用来描述这个矩阵 Output输出一个整数，表示第 大数字的最小值 Sample Input12343 4 21 5 6 6 8 3 4 36 8 6 3 Sample Output13 HINT 矩 阵 元 素 标签：二分答案 网络流 Solution套路 二 分 网 络 流 匹 配 验 证 。 二分第 大数的值，将所有 的位置加入网络流图中 。建模：给每行每列设一个点，初始 行 流量 ， 列 流量 。如果 ，则连边 行 列 ，流量 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MAX_M 100000#define INF 0x7f7f7f7f#define mid ((l+r)&gt;&gt;1)using namespace std;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, k, mx, s, t, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5]; int mat[255][255];void init() {cnt = 0, s = 0, t = n+m+1, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}bool chk(int tans) { init(); for (int i = 1; i &lt;= n; i++) addedge(s, i, 1); for (int i = 1; i &lt;= m; i++) addedge(i+n, t, 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (mat[i][j] &lt;= tans) addedge(i, j+n, 1); return Dinic() &gt;= n-k+1;}int bi_search(int l, int r) { int ret = -1; while (l &lt;= r) if (!chk(mid)) l = mid+1; else ret = mid, r = mid-1; return ret;}int main() { read(n), read(m), read(k); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) read(mat[i][j]), mx = max(mat[i][j], mx); return printf("%d\n", bi_search(0, mx)), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3594【SCOI2014】方伯伯的玉米田]]></title>
    <url>%2FBZOJ3594%E3%80%90SCOI2014%E3%80%91%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84%E7%8E%89%E7%B1%B3%E7%94%B0%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96DP%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2014】方伯伯的玉米田 Description方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。这排玉米一共有 株，它们的高度参差不齐。方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。方伯伯可以选择一个区间，把这个区间的玉米全部拔高 单位高度，他可以进行最多 次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。问能最多剩多少株玉米，来构成一排美丽的玉米。 Input第 行包含 个整数 ，分别表示这排玉米的数目以及最多可进行多少次操作。第 行包含 个整数，第 个数表示这排玉米，从左到右第 株玉米的高度 。 Output输出 个整数，最多剩下的玉米数。 Sample Input123 12 1 3 Sample Output13 Hint 标签：DP 树状数组 Solution首先，显然每次拔高时，不管从哪里开始拔，区间右边界总是 肯定不会使答案变小。有此贪心后，考虑到第 株时前面拔高 次，那么第 株一定也已拔高 次。 令 表示考虑前 株，共拔高了 次，最多可以剩下多少。那么有 对于 值 ，将其坐标设为 ，那么 到 时，需要找的是坐标在 范围内的最小值，可以二维树状数组维护。 注意 时第二层循环要倒着循环，以排除后效性，由于二维树状数组的坐标范围不能到 ，可以把所有坐标的横纵值强行加 。 Code123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define MAX_N 10000#define MAX_A 5500#define MAX_M 500using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, a[MAX_N+5], tr[MAX_M+5][MAX_A+5];void modify(int p, int q, int c) { for (int i = p; i &lt;= MAX_M+1; i += (i&amp;-i)) for (int j = q; j &lt;= MAX_A; j += (j&amp;-j)) tr[i][j] = max(tr[i][j], c);}int query(int p, int q) { int ret = 0; for (int i = p; i; i -= (i&amp;-i)) for (int j = q; j; j -= (j&amp;-j)) ret = max(ret, tr[i][j]); return ret;}int main() { read(n), read(m); int f, ans = 0; for (int i = 1; i &lt;= n; i++) read(a[i]); for (int i = 1; i &lt;= n; i++) for (int j = m; ~j; j--) ans = max(ans, f = query(j+1, a[i]+j)+1), modify(j+1, a[i]+j, f); return printf("%d\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4516【SHOI2016】生成魔咒]]></title>
    <url>%2FBZOJ4516%E3%80%90SHOI2016%E3%80%91%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%20%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Problem【SHOI2016】生成魔咒 Description魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 , 拼凑起来形成一个魔咒串 。一个魔咒串 的非空字串被称为魔咒串 的生成魔咒。例如 时，它的生成魔咒有 , , , , 五种。 时，它的生成魔咒有 , , 三种。最初 为空串。共进行 次操作，每次操作是在 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 共有多少种生成魔咒。 Input第一行一个整数 。第二行 个数，第 个数表示第 次操作加入的魔咒字符 ，用来表示魔咒字符的数字 满足 Output输出 行，每行一个数。第 行的数表示第 次操作后 的生成魔咒数量 Sample Input1271 2 3 3 3 1 2 Sample Output12345671369121722 Source鸣谢Menci上传 标签：后缀自动机 Solution后缀自动机的模板题。 按题意增量构建后缀自动机，考虑每次新增的一位能构成多少新串，贡献计入答案。 对于每次新增的结点 ，若其在 树上的父亲为 ，那么前面有若干条路走到 从而得到的字符串与其走到 得到的字符串相同。由于走到 的字符串个数是 ，走到 的字符串个数是 。因此新增字符串个数是 。维护即可。 Code123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define mii map&lt;int,int&gt;using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, rt, sz, lst; lnt ans;struct node {mii ch; int len, par;} SAM[(MAX_N&lt;&lt;1)+5];int newnode(int _len) {SAM[++sz].len = _len; return sz;}void init() {sz = 0, rt = lst = newnode(0);}void insert(int c) { int p = lst, np = newnode(SAM[p].len+1); lst = np; for (; p &amp;&amp; !SAM[p].ch[c]; p = SAM[p].par) SAM[p].ch[c] = np; if (!p) {SAM[np].par = rt; return;} int q = SAM[p].ch[c]; if (SAM[q].len == SAM[p].len+1) {SAM[np].par = q; return;} int nq = newnode(SAM[p].len+1); SAM[nq].ch = SAM[q].ch; SAM[nq].par = SAM[q].par, SAM[q].par = SAM[np].par = nq; for (; p &amp;&amp; SAM[p].ch[c] == q; p = SAM[p].par) SAM[p].ch[c] = nq;}void upd() {ans += SAM[lst].len-SAM[SAM[lst].par].len;}int main() { read(n), init(); for (int i = 0, x; i &lt; n; i++) read(x), insert(x), upd(), printf("%lld\n", ans); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3998【TJOI2015】弦论]]></title>
    <url>%2FBZOJ3998%E3%80%90TJOI2015%E3%80%91%E5%BC%A6%E8%AE%BA%20%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[Problem【TJOI2015】弦论 Description对于一个给定长度为 的字符串，求它的第 小子串是什么。 Input第一行是一个仅由小写英文字母构成的字符串 。第二行为两个整数 和 ， 为 则表示不同位置的相同子串算作一个， 则表示不同位置的相同子串算作多个。 的意义如题所述。 Output输出仅一行，为一个数字串，为第 小的子串。如果子串数目不足 个，则输出 。 Sample Input12aabc0 3 Sample Output1aab 标签：后缀自动机 Solution后缀自动机的模板题。 对于两个询问的找到第 大，预处理出从每个状态节点向后有多少种符合规则的字符串，然后每次选择走哪个字符即可。 关于预处理： 对于 ，即计算后缀自动机所形成的 上有多少条从初始状态出发路径，将每一个状态节点初值赋为 后按拓扑序在 上 即可。 对于 ，类似上面，也是按拓扑序在 上作 ，只是此时只有表示原字符串每个前缀结束状态的节点的初值为 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 500000using namespace std;char s[MAX_N+5]; int l, T, K, tot[MAX_N+5];int rt, sz, lst, val[(MAX_N&lt;&lt;1)+5], sum[(MAX_N&lt;&lt;1)+5];struct node {int ch[26], len, par;} SAM[(MAX_N&lt;&lt;1)+5];int newnode(int _len) {SAM[++sz].len = _len; return sz;}void init() {sz = 0, rt = lst = newnode(0);}void insert(int c) { int p = lst, np = newnode(SAM[p].len+1); lst = np, val[np] = 1; for (; p &amp;&amp; !SAM[p].ch[c]; p = SAM[p].par) SAM[p].ch[c] = np; if (!p) {SAM[np].par = rt; return;} int q = SAM[p].ch[c]; if (SAM[q].len == SAM[p].len+1) {SAM[np].par = q; return;} int nq = newnode(SAM[p].len+1); memcpy(SAM[nq].ch, SAM[q].ch, sizeof SAM[q].ch); SAM[nq].par = SAM[q].par, SAM[q].par = SAM[np].par = nq; for (; p &amp;&amp; SAM[p].ch[c] == q; p = SAM[p].par) SAM[p].ch[c] = nq;}int prt(int c, int k) { if (k &lt;= val[c]) return 1; k -= val[c]; for (int i = 0; i &lt; 26 &amp;&amp; k &gt; 0; k -= sum[SAM[c].ch[i++]]) if (SAM[c].ch[i] &amp;&amp; k &lt;= sum[SAM[c].ch[i]]) putchar('a'+i), prt(SAM[c].ch[i], k); return 1;}int main() { int que[(MAX_N&lt;&lt;1)+5]; init(); scanf("%s%d%d", s, &amp;T, &amp;K), l = (int)strlen(s); for (int i = 0; i &lt; l; i++) insert(s[i]-'a'); for (int i = 1; i &lt;= sz; i++) tot[SAM[i].len]++; for (int i = 1; i &lt;= l; i++) tot[i] += tot[i-1]; for (int i = sz; i; i--) que[tot[SAM[i].len]--] = i; for (int i = sz; i; i--) if (!T) val[que[i]] = 1; else val[SAM[que[i]].par] += val[que[i]]; val[1] = 0; for (int i = 1; i &lt;= sz; i++) sum[i] = val[i]; for (int i = sz; i; i--) for (int j = 0; j &lt; 26; j++) sum[que[i]] += sum[SAM[que[i]].ch[j]]; return (K &gt; sum[rt] ? puts("-1") : prt(rt, K)), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>字符串</tag>
        <tag>后缀自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4569【SCOI2016】萌萌哒]]></title>
    <url>%2FBZOJ4569%E3%80%90SCOI2016%E3%80%91%E8%90%8C%E8%90%8C%E5%93%92%20%E5%B9%B6%E6%9F%A5%E9%9B%86%2BST%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2016】萌萌哒 Description一个长度为 的大数，用 表示，其中 表示数的第 位， 是数的最高位，告诉你一些限制条件，每个条件表示为四个数， ， ， ， ，即两个长度相同的区间，表示子串 与 完全相同。比如 时，某限制条件 ， ， ， ，那么 ， 均满足条件，但是 ， 不满足条件，前者数的长度不为 ，后者第二位与第五位不同。问满足以上所有条件的数有多少个。 Input第一行两个数 和 ，分别表示大数的长度，以及限制条件的个数。接下来 行，对于第 行，有 个数 ， ， ， ，分别表示该限制条件对应的两个区间。 ， ， ；并且保证 。 Output一个数，表示满足所有条件且长度为 的大数的个数，答案可能很大，因此输出答案模 的结果即可。 Sample Input1234 21 2 3 4 3 3 3 3 Sample Output190 标签：并查集 ST表 Solution好题，把基础数据结构玩出了新花样。 首先朴素思想是用并查集维护每位的相同关系，每次暴力合并，最后统计有几个集合就有几个自由元。若有 个集合，那么答案为 。 发现我们花费了很多时间再合并上，考虑用带 数据结构优化合并。这里需要用到 表。考虑存 组并查集，第 组并查集的第 个元素维护的是区间 与其他长度为 的区间是否相同。这样对于关系 ，令 ，等同于 和 ，那么合并第 组并查集中的 和 、第 组并查集中的 和 即可。随后像 表一样自大区间向小区间合并信息，可得出最后的集合个数，计算答案即可。 Code1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define LOG 20#define MAX_N 100000#define MOD 1000000007using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, cnt, LOG2[MAX_N+5], fa[LOG][MAX_N+5]; lnt ans = 9LL;int getf(int d, int x) {return fa[d][x] == x ? x : fa[d][x] = getf(d, fa[d][x]);}int main() { read(n), read(m); for (int i = 2; i &lt;= n; i++) LOG2[i] = LOG2[i&gt;&gt;1]+1; for (int i = 0; i &lt; LOG; i++) for (int j = 1; j &lt;= n; j++) fa[i][j] = j; for (int i = 0, l1, l2, e1, e2, l, d; i &lt; m; i++) { read(l1), read(e1), read(l2), read(e2), l = e1-l1+1, d = LOG2[l]; if (getf(d, l1)^getf(d, l2)) fa[d][fa[d][l1]] = fa[d][l2]; if (getf(d, l1+l-(1&lt;&lt;d))^getf(d, l2+l-(1&lt;&lt;d))) fa[d][fa[d][l1+l-(1&lt;&lt;d)]] = fa[d][l2+l-(1&lt;&lt;d)]; } for (int i = LOG2[n]; i; i--) for (int j = 1; j &lt;= n-(1&lt;&lt;i)+1; j++) { if (getf(i-1, j)^getf(i-1, getf(i, j))) fa[i-1][fa[i-1][j]] = fa[i-1][fa[i][j]]; if (getf(i-1, j+(1&lt;&lt;(i-1)))^getf(i-1, getf(i,j)+(1&lt;&lt;(i-1)))) fa[i-1][fa[i-1][j+(1&lt;&lt;(i-1))]] = fa[i-1][fa[i][j]+(1&lt;&lt;(i-1))]; } for (int i = 1; i &lt;= n; i++) if (getf(0, i) == i) cnt++; for (int i = 1; i &lt; cnt; i++) (ans *= 10LL) %= MOD; return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4407 于神之怒加强版]]></title>
    <url>%2FBZOJ4407%20%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[Problem于神之怒加强版 Description给下 ，计算 的值。 Input输入有多组数据，输入数据的第一行两个正整数 ，代表有 组数据， 的意义如上所示，下面第 行到第 行，每行为两个正整数 ，其意义如上式所示。 Output对于每一个询问，输出一行一个数作为回答。 Sample Input121 23 3 Sample Output120 HINT 官方题解 标签：莫比乌斯反演 Solution先套路转换出 ： 那么每次询问对于前半部分可以根号分块，随后需要 计算后半部分的值，因而需要线筛预处理后半部分的值。 令 ， 由于 和 均为积性函数，因而 也为积性函数。那么就有 易知当 时，均有 ，因此有 接下来考虑在线筛中如何处理。首先，对于所有质数，均有 。而对于合数，假设当前筛到的数是 ，对于一个比它小的素数 ，有两种情况： 若 ，设 在 分解质因数中的次数为 ，那么 相比于 而言，在含 的约数中 的次数都增加了 ，否则 无贡献。因此 增加了 ，这样总共扩大了 倍，故 ； 若 ，由积性函数可知 。 这样就可以 筛出 的函数值，每次询问 根号分块，总复杂度 。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define MAX_N 5000000#define MOD 1000000007using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}lnt k, cnt, ans, f[MAX_N+5], p[MAX_N+5], pri[MAX_N+5]; bool NotPri[MAX_N+5];lnt PM(lnt x, lnt y) {if (!y) return 1LL; lnt ret = PM(x, y&gt;&gt;1); return (y&amp;1) ? ret*ret%MOD*x%MOD : ret*ret%MOD;}void init() { NotPri[1] = true, f[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, p[i] = PM(i, k), f[i] = p[i]-1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) f[i*pri[j]] = f[i]*f[pri[j]]%MOD; else {f[i*pri[j]] = f[i]*p[pri[j]]%MOD; break;} } } for (int i = 2; i &lt;= MAX_N; i++) (f[i] += f[i-1]) %= MOD;}int main() { int T; read(T), read(k), init(); while (T--) { lnt n, m; read(n), read(m), ans = 0; for (lnt l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), (ans += (n/l)*(m/l)%MOD*(f[r]-f[l-1]+MOD)%MOD) %= MOD; printf("%lld\n", ans); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3309 DZY Loves Math]]></title>
    <url>%2FBZOJ3309%20DZY%20Loves%20Math%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemDZY Loves MathTime Limit: Memory Limit: Description对于正整数 ，定义 为 所含质因子的最大幂指数。例如 , , 。给定正整数 ，求 。 Input第一行一个数 ，表示询问数。接下来 行，每行两个数 ，表示一个询问。 Output对于每一个询问，输出一行一个非负整数作为回答。 Sample Input1234547558588 96531146514903 44512117425644 11894426335198 4957 Sample Output12343579345393990114225956593420433283884584615400094813 HINT 标签：莫比乌斯反演 Solution好题， 线筛新姿势。 首先套路转化出莫比乌斯函数： 这时会发现前面用根号分块很好处理，而后面的部分需要 计算，所以需要线性筛预处理。 令 ，考虑通过 与 的性质找到其积性关系。 设 ， ， 那么一定有 ，否则 ，不计入总贡献。 若 对于 的情况，只有一种，即 。而 。故贡献为 ； 对于 的情况，根据组合原理，有 ，而又由二项式基本定理知 ，因而贡献为 。 故此情况 。 若 使得 不论 还是 ，都存在至少一个质因数 使得 不论取 还是 对 的取值都没有影响。然而 取 或 会使得 取到 或 ，此处的贡献为 ，一定全部被抵消。 故此情况 。 综上，线性筛预处理 需要知道每个数最小的质因数的次数 和最小质因数的幂指数次幂 ，这样看是否有 即可知 的最小与次小质因数的次数是否相等，由此可判断是情况 还是情况 。这样先线性筛预处理后，对每次询问 进行根号分块，即可达到 的复杂度。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define MAX_N 10000000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int g[MAX_N+5], sp[MAX_N+5], num[MAX_N+5];int pri[MAX_N+5], cnt; lnt ans;bool NotPri[MAX_N+5];void init(int n) { NotPri[0] = NotPri[1] = true; for (int i = 2; i &lt;= n; i++) { if (!NotPri[i]) pri[cnt++] = sp[i] = i, g[i] = num[i] = 1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; n) break; NotPri[i*pri[j]] = true; if (i%pri[j]) sp[i*pri[j]] = pri[j], num[i*pri[j]] = 1, g[i*pri[j]] = num[i] == 1 ? -g[i] : 0; else sp[i*pri[j]] = sp[i]*pri[j], num[i*pri[j]] = num[i]+1, g[i*pri[j]] = sp[i] == i ? 1 : (num[i/sp[i]] == num[i*pri[j]] ? -g[i/sp[i]] : 0); if (i%pri[j] == 0) break; } } for (int i = 1; i &lt;= n; i++) g[i] += g[i-1];}int main() { int T; read(T), init(MAX_N); while (T--) { int a, b; read(a), read(b), ans = 0; for (int l = 1, r; l &lt;= min(a,b); l = r+1) r = min(a/(a/l), b/(b/l)), ans += 1LL*(a/l)*(b/l)*(g[r]-g[l-1]); printf("%lld\n", ans); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2693 jzptab]]></title>
    <url>%2FBZOJ2693%20jzptab%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[Problemjzptab Description求 ，答案模 输出。多组询问。 Input一个正整数 表示数据组数。接下来 行，每行两个正整数 表示 。 Output 行，每行一个整数，表示第 组数据的结果。 Sample Input1214 5 Sample Output1122 HINT Sourse版权所有者：倪泽堃 标签：莫比乌斯反演 Solution此题和 所求相同，只是又多组询问，如果每次都像 那样 做为 。故需要改变求和方式。这里将使用 的最终推导结果来继续恒等变形。前面的推导见：BZOJ2154。 综上， 的前缀和可用线性筛预处理，对于每次询问对 根号分块，即可做到 的复杂度。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAX_N 10000000#define MOD 100000009using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}lnt n, m, cnt, ans, s[MAX_N+5], pri[MAX_N+5]; bool NotPri[MAX_N+5];void init() { NotPri[1] = true, s[1] = 1; for (lnt i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, s[i] = (i-i*i%MOD)%MOD; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) s[i*pri[j]] = s[i]*s[pri[j]]%MOD; else {s[i*pri[j]] = s[i]*pri[j]; break;} } } for (int i = 1; i &lt;= MAX_N; i++) (s[i] += s[i-1]) %= MOD;}int main() { int T; read(T), init(); while (T--) { lnt n, m; read(n), read(m), ans = 0; for (lnt l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), (ans += (n/l*(n/l+1)/2%MOD)*(m/l*(m/l+1)/2%MOD)%MOD*(s[r]-s[l-1])%MOD) %= MOD; printf("%lld\n", (ans+MOD)%MOD); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2154 Crash的数字表格]]></title>
    <url>%2FBZOJ2154%20Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemCrash的数字表格 Description今天的数学课上， 小朋友学习了最小公倍数 。对于两个正整数 和 ， 表示能同时被 和 整除的最小正整数。例如， 。回到家后， 还在想着课上学的东西，为了研究最小公倍数，他画了一张 的表格。每个格子里写了一个数字，其中第 行第 列的那个格子里写着数为 。看着这个表格， 想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当 和 很大时， 就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大， 只想知道表格里所有数的和 的值。 Input输入的第一行包含两个正整数，分别表示 和 。 Output输出一个正整数，表示表格中所有数的和 的值。 Sample Input14 5 Sample Output1122 HINT 的数据满足 。 标签：莫比乌斯反演 Solution 由以上推导，可见 和 是可以根号分块的，在外层对 进行分块，在每个值相同的块中，对 进行分块以求出 带回外层算贡献。 综上，外层复杂度为 ，内层复杂度为 ，总时间复杂度为 。 其实可以做得更快，详见加强版BZOJ2693。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define MAX_N 10000000#define MOD 20101009using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}lnt n, m, ans, s[MAX_N+5];int cnt, pri[MAX_N+5], mu[MAX_N+5];bool NotPri[MAX_N+5];void getMu() { NotPri[1] = true, mu[1] = 1; for (int i = 2; i &lt;= min(n,m); i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; min(n,m)) break; NotPri[i*pri[j]] = true; if (i%pri[j]) mu[i*pri[j]] = -mu[i]; else {mu[i*pri[j]] = 0; break;} } } for (int i = 1; i &lt;= min(n,m); i++) s[i] = (s[i-1]+1LL*mu[i]*i*i%MOD)%MOD;}lnt f(lnt p, lnt q) { lnt ret = 0; for (lnt l = 1, r; l &lt;= min(p, q); l = r+1) r = min(p/(p/l), q/(q/l)), (ret += (p/l*(p/l+1)/2%MOD)*(q/l*(q/l+1)/2%MOD)%MOD*(s[r]-s[l-1])%MOD) %= MOD; return ret;}int main() { read(n), read(m), getMu(); for (lnt l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), (ans += (l+r)*(r-l+1)/2%MOD*f(n/l, m/l)%MOD) %= MOD; return printf("%lld", (ans+MOD)%MOD), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1010【HNOI2008】玩具装箱toy]]></title>
    <url>%2FBZOJ1010%E3%80%90HNOI2008%E3%80%91%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1toy%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2008】玩具装箱toy Description 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。 教授有编号为 的 件玩具，第 件玩具经过压缩后变成一维长度为 .为了方便整理， 教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第 件玩具到第 个玩具放到一个容器中，那么容器的长度将为 制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 ,其制作费用为 .其中 是一个常量。 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 。但他希望费用最小. Input第一行输入两个整数 .接下来 行输入 . Output输出最小费用. Sample Input1234565 434214 Sample Output11 标签：斜率优化DP Solution令 ，有如下 方程： 。 预处理 。对于当前 到的位置 ，必然存在 ，使得 按照此斜率维护单调栈即可。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define MAX_N 50000using namespace std;typedef double dnt;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, l, sta[MAX_N+5], s, t; lnt f[MAX_N+5], w[MAX_N+5];dnt calc(int p, int q) {return (f[p]-f[q]+(w[p]+l)*(w[p]+l)-(w[q]+l)*(w[q]+l))/(2.0*(w[p]-w[q]));}int main() { read(n), read(l), l++; for (int i = 1; i &lt;= n; i++) read(w[i]), w[i] += w[i-1]; for (int i = 1; i &lt;= n; i++) w[i] += i; for (int i = 1; i &lt;= n; i++) { while (s &lt; t &amp;&amp; calc(sta[s+1], sta[s]) &lt;= w[i]) s++; f[i] = f[sta[s]]+(w[i]-w[sta[s]]-l)*(w[i]-w[sta[s]]-l); while (s &lt; t &amp;&amp; calc(sta[t], sta[t-1]) &gt; calc(i, sta[t])) t--; sta[++t] = i; } return printf("%lld", f[n]), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>斜率优化</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1096【ZJOI2007】仓库建设]]></title>
    <url>%2FBZOJ1096%E3%80%90ZJOI2007%E3%80%91%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem【ZJOI2007】仓库建设 Description 公司有 个工厂，由高到底分布在一座山上。如图所示，工厂 在山顶，工厂 在山脚。由于这座山处于高原内陆地区（干燥少雨）， 公司一般把产品直接堆放在露天，以节省费用。突然有一天， 公司的总裁 先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是 先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第 个工厂目前已有成品 件，在第 个工厂位置建立仓库的费用是 。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于 公司产品的对外销售处设置在山脚的工厂 ，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送 个单位距离的费用是 。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据： 工厂 距离工厂 的距离 （其中 ） 工厂 目前已有成品数量 在工厂 建立仓库的费用 请你帮助 公司寻找一个仓库建设的方案，使得总的费用（ 建 造 费 用 运 输 费 用 ）最小。 Input第一行包含一个整数 ，表示工厂的个数。接下来 行每行包含两个整数 , 意义如题中所述。 Output仅包含一个整数，为可以找到最优方案的费用。 Sample Input123430 5 105 3 1009 6 10 Sample Output132 标签：斜率优化DP Solution由题意，易得到 方程： 那么对于当前 到的位置 ，一定存在 使得 按照此斜率维护单调栈即可。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000using namespace std;typedef double dnt;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, c[MAX_N+5], x[MAX_N+5], m[MAX_N+5];lnt s1[MAX_N+5], s2[MAX_N+5], f[MAX_N+5]; int l, r, sta[MAX_N+5];dnt calc(int p, int q) {return (dnt)(f[p]-f[q]+s1[p]-s1[q])/(dnt)(s2[p]-s2[q]);}int main() { read(n); for (int i = 1; i &lt;= n; i++) read(x[i]), read(m[i]), read(c[i]); for (int i = 1; i &lt;= n; i++) s1[i] = s1[i-1]+1LL*m[i]*x[i], s2[i] = s2[i-1]+m[i]; for (int i = 1; i &lt;= n; i++) { while (l &lt; r &amp;&amp; calc(sta[l+1], sta[l]) &lt;= x[i]) l++; f[i] = f[sta[l]]+1LL*x[i]*(s2[i]-s2[sta[l]])-s1[i]+s1[sta[l]]+c[i]; while (l &lt; r &amp;&amp; calc(sta[r], sta[r-1]) &gt; calc(i, sta[r])) r--; sta[++r] = i; } return printf("%lld", f[n]), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>斜率优化</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4560 我是歌手]]></title>
    <url>%2FHDU4560%20%E6%88%91%E6%98%AF%E6%AD%8C%E6%89%8B%20%E4%BA%8C%E5%88%86%2B%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem我是歌手 Description 年一开始，一档音乐节目“我是歌手”就惊艳了大家一回。闲话少说，现在，你成为了这档节目的总导演，你的任务很简单，安排每一期节目的内容。现在有 个歌手， 种歌曲流派（ ， 之类），每个歌手都有自己擅长的流派领域，这些资料都已整理。你的工作是，安排尽可能多场的演唱比赛。每一场比赛所有歌手都必须上场，为了提高收视率，每个人演唱的歌曲类型不能相同，即便一些歌手要被迫选择一些他们不擅长的。同时，为了展现全面性，在不同的演唱比赛上，每个歌手都会安排不同的歌曲流派。但是问题是，对于任何一个歌曲流派的歌迷，如果超过 个不擅长的歌手演唱了这种歌曲，他们就会表示不满，比如，发一些宣泄不满的帖子微博，为了表示观点挑起事端等等。你当然不希望这些事情与你的节目有关，在这个前提下，你可以任意安排尽可能多的比赛场次。 Input输入第一行为 ，表示有 组测试数据。每组数据以四个数字 ， ， ， 开始。 表示有 组擅长关系，接下来的 行，每一行有两个数字 ， ，表示歌手 擅长 类型的歌曲。 Output对每组数据，先输出为第几组数据，然后输出最多比赛场次。 Sample Input1234567891031 1 1 01 11 3 0 13 3 5 11 11 22 22 33 1 Sample Output123Case 1: 1Case 2: 3Case 3: 2 Explanation123对第三组样例，可以如此安排：第一场三位歌手分别演唱(2,3,1)类型的歌曲，第二场分别演唱(1,2,3)。这样只有类型3被不擅长的歌手演唱过1次，挑剔的歌迷观众还可以接受。 Hint 相同关系不会重复出现 标签：带修主席树 Solution挺好的一道 二 分 网 络 流 套路建模题。 二分最多能安排的场次，得到当前答案进行判定。 首先，如果保证每个人唱每种流派最多仅一次，并且 个流派均会被唱至少 次，那么一定能找到一组解。这样就可以用最大流判定。由于有“每个流派仅能有 个不擅长的选手唱”，我们需要把每个流派又擅长的选手唱和不擅长的选手唱分开，而限制不擅长的选手的数量。可将每个流派拆成两个点，即第 个流派 拆成 和 。从 向擅长的选手连边，从 向不擅长的选手连边，而由于从源点向 连有 的边，因而所有可用流量都在 中， 的流量需要限制，故要在 和 间连 的边来限制不擅长选手的数量。 建模总述： 建模后跑最大流，看是否有 即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MAX_M 2000000#define mid ((l+r)&gt;&gt;1)#define INF 0x7f7f7f7fusing namespace std;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, k, f, s, t, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5]; bool G[MAX_N+5][MAX_N+5];void init() {cnt = s = 0, t = 3*m+1, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}bool chk(int tans) { init(); for (int i = 1; i &lt;= n; i++) addedge(i+2*m, t, tans); for (int i = 1; i &lt;= m; i++) addedge(s, i, tans), addedge(i, i+m, k); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) addedge(G[i][j] ? i : i+m, j+2*m, 1); return Dinic() == n*tans;}int bi_search(int l, int r) { int ret = 0; while (l &lt;= r) if (!chk(mid)) r = mid-1; else ret = mid, l = mid+1; return ret;}int main() { int T; read(T); for (int C = 1; C &lt;= T; C++) { read(n), read(m), read(f), read(k), memset(G, false, sizeof G); for (int i = 0, x, y; i &lt; f; i++) read(x), read(y), G[y][x] = true; printf("Case %d: %d\n", C, bi_search(1, m)); } return 0;}]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF446C DZY Loves Fibonacci Numbers]]></title>
    <url>%2FCF446C%20DZY%20Loves%20Fibonacci%20Numbers%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ProblemDZY Loves Fibonacci Numbers DescriptionIn mathematical terms, the sequence of is defined by the recurrence relation . loves Fibonacci numbers very much. Today gives you an array consisting of integers: . Moreover, there are queries, each query has one of the two types: Format of the query “ ”. In reply to the query, you need to add to each element , where . Format of the query “ ”. In reply to the query you should output the value of modulo . Help reply to all the queries. InputThe first line of the input contains two integers and . The second line contains n integers — initial array .Then, lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality holds. OutputFor each query of the second type, print the value of the sum on a single line. ExampleInput1234564 41 2 3 41 1 42 1 41 2 42 1 3 Output121712 NoteAfter the first query, .For the second query, .After the third query, .For the fourth query, . 标签：线段树 Translation给出一个长为 级别的初始数组，要求维护两种操作： 将 中的每个数对应加上从 的斐波那契数，即使 加上 询问 模 的值 Solution不难想到此题需要用线段树维护。不过难点在于如何合并标记。 初步想法是每次打标记时记录下此区间是从斐波那契数列的多少项开始一一对应地加进去，不过这样是无法合并标记的，每个结点只能有一个标记，可以被卡成 。 考虑把标记换一种存法。对于一个数列 ，我们将其称为一个“伪斐波那契数列”，不难发现其等于几个斐波那契数列的子序列之和，即在原题中，不管如何加，每个区间最后加的数列都是一个伪斐波那契数列。而此序列可以仅通过最前面的两项 和 推出后面的任意项以及前若干项之和，即 用这两个公式我们可以 计算任意项及前任意项的和。每个标记为一个数对 ，那么合并标记的时候将两个标记的 和 分别相加，得到 即可。总时间复杂度 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000#define mid ((s+t)&gt;&gt;1)#define MOD 1000000009using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m; lnt fib[MAX_N+5] = {0LL, 1LL};struct node {lnt c, f1, f2;} tr[(MAX_N&lt;&lt;2)+5];lnt fn(lnt f1, lnt f2, int len) {return len == 1 ? f1 : (len == 2 ? f2 : (f1*fib[len-2]%MOD+f2*fib[len-1]%MOD)%MOD);}lnt sum(lnt f1, lnt f2, int len) {return len == 1 ? f1 : (len == 2 ? (f1+f2)%MOD : (fn(f1, f2, len+2)-f2+MOD)%MOD);}void updata(int v) {tr[v].c = (tr[v&lt;&lt;1].c+tr[v&lt;&lt;1|1].c)%MOD;}void downtag(int v, int s, int t) { if (!tr[v].f1) return; lnt lf1 = tr[v].f1, lf2 = tr[v].f2, rf1 = fn(lf1, lf2, mid-s+2), rf2 = fn(lf1, lf2, mid-s+3); (tr[v&lt;&lt;1].f1 += lf1) %= MOD, (tr[v&lt;&lt;1].f2 += lf2) %= MOD, (tr[v&lt;&lt;1].c += sum(lf1, lf2, mid-s+1)) %= MOD; (tr[v&lt;&lt;1|1].f1 += rf1) %= MOD, (tr[v&lt;&lt;1|1].f2 += rf2) %= MOD, (tr[v&lt;&lt;1|1].c += sum(rf1, rf2, t-mid)) %= MOD; tr[v].f1 = tr[v].f2 = 0;}void build(int v, int s, int t) { if (s == t) {read(tr[v].c); return;} build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t); updata(v);}void modify(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) { (tr[v].f1 += fib[s-l+1]) %= MOD, (tr[v].f2 += fib[s-l+2]) %= MOD; (tr[v].c += sum(fib[s-l+1], fib[s-l+2], t-s+1)) %= MOD; return; } downtag(v, s, t); if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r); updata(v);}lnt query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].c; lnt ret = 0; downtag(v, s, t); if (l &lt;= mid) (ret += query(v&lt;&lt;1, s, mid, l, r)) %= MOD; if (r &gt;= mid+1) (ret += query(v&lt;&lt;1|1, mid+1, t, l, r)) %= MOD; updata(v); return ret;}void init() {for (int i = 2; i &lt;= MAX_N; i++) fib[i] = (fib[i-2]+fib[i-1])%MOD;}int main() { read(n), read(m), init(), build(1, 1, n); while (m--) { int opt, l, r; read(opt), read(l), read(r); if (opt == 1) modify(1, 1, n, l, r); else printf("%I64d\n", query(1, 1, n, l, r)); } return 0;}]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2671 Calc]]></title>
    <url>%2FBZOJ2671%20Calc%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemCalc Description给出 ，统计满足下面条件的数对 的个数： Input一行一个数 。 Output一行一个数表示答案。 Sample Input115 Sample Output14 HINT 测试点编号 数据规模 测试点编号 数据规模 标签：莫比乌斯反演 Solution一道稍有变形的莫比乌斯反演， 有 的算法，但我只会小常数的 算法，不过可以过 数据。 问题即求 的值。设 , , ，易知 。那么 。不妨设 ，那么 , 。有 原 式 显然 只有 级别种取值，可以根号分块来算，即枚举 ，每次找到 相等的一段 ，统计 间满足 的 的个数，可以套用基础莫比乌斯反演公式，即 。 此算法先枚举 的取值，再枚举 的取值，最后枚举 的约数 计算反演。其中 有 级别种取值， 所对应的 都在 之间，即共有 级别种取值，而最后的 又有 级别种取值，故总时间复杂度应为 。但是由于 的取值总数通常到不了 级别，且 的取值总数通常也到不了 级别，因此常数非常小，跑得贼快，可以过此题 级别的数据。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int pri[MAX_N+5], mu[MAX_N+5], fac[MAX_N+5], cnt; bool NotPri[MAX_N+5];void PriS() { mu[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0, x; j &lt; cnt; j++) { if ((x = i*pri[j]) &gt; MAX_N) break; NotPri[x] = true; if (i%pri[j]) mu[x] = -mu[i]; else {mu[x] = 0; break;} } }}int main() { int n; read(n), PriS(); lnt ans = 0LL; for (lnt i = 1, l, r; i &lt; sqrt(n); i++) { cnt = 0; for (int j = 1; j &lt;= sqrt(i); j++) if (i%j == 0) fac[cnt++] = j; for (l = 1; l &lt; i; l = r+1) { lnt val = n/(i*(i+l)); if (!val) break; r = min(n/val/i-i, i-1); for (lnt k = 0, j; k &lt; cnt; k++) { j = fac[k], ans += mu[j]*(r/j-(l-1)/j)*val; lnt t = i/j; if (i%t == 0 &amp;&amp; (j^t)) ans += mu[t]*(r/t-(l-1)/t)*val; } } } return printf("%lld\n", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2339【HNOI2011】卡农]]></title>
    <url>%2FBZOJ2339%E3%80%90HNOI2011%E3%80%91%E5%8D%A1%E5%86%9C%20%E8%AE%A1%E6%95%B0DP%2B%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2011】卡农 Description Input Output Sample 标签：计数DP Solution考试时没想出来，不过听了觉得挺简单的。 首先把每个片段看成一个数，每个音阶看成该数的一位，则每位为 或 ，题意可以转化为求在 中选 个数使其异或和为 的方案数。我们先不考虑无序性，求出所有排列后除 即为答案。 设 为选 个数的方案数，考虑先选 个数，最后一个数即为前面的数的异或和，这样才能使总异或和位 。那么如果不考虑限制，直接选则有 种选法。 只可能有两种不合法的情况，即最后一个数位 或最后一个数在前面 个数种出现过。对于第一种情况，不合法方案数为选 个数的合法方案数，即为 。而对于第二种情况，去掉相同的数后，其他数异或和为 ，这样就有 中方案，而去掉的数的位置有 种选法，去掉的数的值有 种选法，故共会去掉 种不合法方案。 于是， 方程为 Code1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000#define MOD 100000007using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m; lnt p, q, c, f[MAX_N+5], g[MAX_N+5], inv[MAX_N+5] = {1LL, 1LL};void init(int n) {for (int i = 2; i &lt;= n; i++) inv[i] = (MOD-MOD/i*inv[MOD%i]%MOD)%MOD;}int main() { read(m), read(n), init(n), p = f[0] = c = 1LL, f[1] = 0LL, g[1] = 1LL; for (int i = 1; i &lt;= m; i++) (p *= 2) %= MOD; (p += MOD-1) %= MOD, q = p; for (int i = 2; i &lt;= n; i++, (q += MOD-1) %= MOD) g[i] = g[i-1]*q%MOD; for (int i = 2; i &lt;= n; i++) f[i] = (g[i]-(f[i-1]+1LL*(i-1)*(p-i+2)%MOD*f[i-2]%MOD)%MOD+MOD)%MOD; for (int i = 1; i &lt;= n; i++) (c *= inv[i]) %= MOD; return printf("%lld", f[n]*c%MOD), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>组合数学</tag>
        <tag>DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4334【JSOI2012】铁拳]]></title>
    <url>%2FBZOJ4334%E3%80%90JSOI2012%E3%80%91%E9%93%81%E6%8B%B3%20%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【JSOI2012】铁拳 Description经过了可怕的第三次世界大战后，国家政府崩溃，各大财团趁机夺取掌控世界。长年战争后，八大财团幸存并割据一方，其中最强的当属掌控北美的铁拳。在铁拳财团所维护的文明区域中，有一项最为光荣、重要的赛事—— ，也就是铁拳大赛。 中云集了世界各地各财团鼎力资助的世外高手，只为了赢得 ，得到无上的荣耀，当然还有随之而来的权力。本来一切秩序井然，但一个来自贫民窟的少年风间仁意外地在海选中赢了 正式选手，获得了决赛资格，从此格局被打乱……为了应对这突如其来的变数， 管理层决定先对联盟中所有的选手进行评估，以更好地掌握大局。知最近 届比赛出现过的 位选手，背后都有着各自财团的资助，并且签下了合同。由于这是各财团的高度机密，合同的具体细节无从得知，但铁拳财团的间谍们通过各种渠道得知了每个选手的薪金范围（显然薪金是非负数）。对于最近 届的 比赛（从 开始编号），每一届联盟都会进行清算，通过国际金融手段准确计算出这一届联盟选手身价总和的变化。每一届中，会有一些新选手加入，也会有部分选手在比赛中丧失了战斗能力，而被踢出联盟，流放到贫民窟。现在给出联盟中 位选手的身价范围，以及他们 进入联盟的届数（ 表示在 届以前就已经是联盟选手） 和 离开联盟的届数（ 表示是现役选手）。同时给出最近 届中，每一届联盟选手身价总和减去上一届的值。请你根据现有信息，尽可能准确地给出每个选手可能的薪金范围。各选手之间的薪金范围可以不同时成立，但对于一位选手的范围中的每一个数，都必须至少存在一种合法方案使该选手能得到相应薪金，而且这个范围跨度要尽可能大。如果输入信息有误，请输出 ，表示无解。 Input第一行一个正整数 ，意义见上（下同）。第二行包含 个整数，第 个表示第 届中 选手身价总和 的变化情况。第三行一个正整数 。接下来n行，每行包含四个整数，分别表示 身价下限 、 身价上限 、 出道届数 、 退役届数，细节请参照上文。保证出道时间严格比退役时间小（ 除外）。 Output一行，输出最小的答案。 Sample Input12345625 -131 4 1 02 3 1 01 5 1 2 Sample Output1231.00 2.002.00 3.001.00 1.00 HINT样例解释第二届只有 号离开了，可以锁定 号的薪金是 。如此一来， 号和 号薪金之和为 ，那么 号最少能拿 ，最多能拿 ； 号最少能拿到 ，最多能拿到 。数据规模对于 的数据， ， ，给定薪金范围不超过 。应上传者要求，此题不公开，如有异议，请提出. 标签：线性规划 上下界网络流 Solution线性规划转上下界网络流。挺麻烦的。 首先这些条件可以看作 个等式，故可转化为线性规划。而解线性规划只有网络流和单纯形两种，不会单纯形，所以用了网络流。 将每个等式作为一个点，每个变量作为一条边，不难发现一个变量只会进入等式一次，出等式一次。若此变量从 等式进，从 等式出，范围为 ，则连边 ，容量为 。对于 的变量，则连边 ；对于 的变量，则连边 。接下来处理每个等式的差值。可以发现等式 与 的差值可以用边 或 表示，即为从源点补进来多少流量或从汇点分出去多少流量。因而可以连边：设等式 与 的差值为 ，若 ，则连边 ，容量为 ；若 ，则连边 ，容量为 。这样就可以构建出一个上下界网络流的模型。 建模后，可以在一开始就跑一遍可行流，判断是否有解。 之后有两种做法： 法 ：对每条边的取值进行二分，分别去找最大值和最小值，每次 的时候把重设当前边的范围，跑可行流验证。 法 ：对于每条边，找到先前求可行流时它的流量，考虑它最多可以再少承担多少流量或多承担多少流量。那么可以在残量网络上断掉当前边，以起点为源，终点为汇，跑最大流得到它最多可以减少多少流量；再以终点为汇，起点为源，跑最大流得到它最多可以增加多少流量。设最多可以减少 ，最多可以增加 ，此边的下限为 ，上限为 ，可行流中此边的流量为 ，则答案为 和 。这里需要注意两个答案都需要在 之间，即最终答案应该为 和 。 建议使用法 ，同时 巨 佬 提供优质法 。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MAX_M 2000#define INF 0x7f7f7f7fusing namespace std;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}struct node {int v, c, nxt;} E[MAX_M+5], cpy[MAX_M+5];int n, m, s, t, ss, tt, cnt, d[MAX_N+5], pr[MAX_N+5], mat[MAX_N+5];int gap[MAX_N+5], range[MAX_N+5][2], zone[MAX_N+5][2]; bool mrk[MAX_N+5];void init() {ss = m+1, tt = m+2, s = 0, t = m+3, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}int addedge(int u, int v, int c) {return insert(u, v, c), insert(v, u, 0), cnt-2;}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c || mrk[i]) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c || mrk[i]) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() {int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}bool get_ava() { int into = 0, outo = 0; init(), memset(d, 0, sizeof d); addedge(tt, ss, INF); for (int i = 1; i &lt;= m; i++) { if (gap[i] &gt; 0) d[ss] += gap[i], d[i] -= gap[i]; if (gap[i] &lt; 0) d[i] -= gap[i], d[tt] += gap[i]; } for (int i = 1; i &lt;= n; i++) { int u = zone[i][0] == 0 ? ss : zone[i][0]; int v = zone[i][1] == 0 ? tt : zone[i][1]; mat[i] = addedge(u, v, range[i][1]-range[i][0]); d[u] += range[i][0], d[v] -= range[i][0]; } for (int i = s+1; i &lt;= t-1; i++) { if (d[i] &lt; 0) addedge(s, i, -d[i]), into -= d[i]; if (d[i] &gt; 0) addedge(i, t, d[i]), outo += d[i]; } return into == outo &amp;&amp; Dinic() == into;}void rec() {for (int i = 0; i &lt; cnt; i++) E[i] = cpy[i];}int main() { read(m); for (int i = 1; i &lt;= m; i++) read(gap[i]); read(n); for (int i = 1; i &lt;= n; i++) read(range[i][0]), read(range[i][1]), read(zone[i][0]), read(zone[i][1]); if (!get_ava()) {puts("-1"); return 0;} for (int i = 0; i &lt; cnt; i++) cpy[i] = E[i]; for (int i = 1; i &lt;= n; i++) { int eid = mat[i], base = E[eid^1].c, ori = E[eid].c+base; mrk[eid] = mrk[eid^1] = true; s = E[eid^1].v, t = E[eid].v, printf("%d.00 ", range[i][0]+max(base-Dinic(), 0)), rec(); s = E[eid].v, t = E[eid^1].v, printf("%d.00\n", range[i][0]+min(base+Dinic(), ori)), rec(); mrk[eid] = mrk[eid^1] = false; } return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>线性规划</tag>
        <tag>上下界网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1069【SCOI2007】最大土地面积]]></title>
    <url>%2FBZOJ1069%E3%80%90SCOI2007%E3%80%91%E6%9C%80%E5%A4%A7%E5%9C%9F%E5%9C%B0%E9%9D%A2%E7%A7%AF%20%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2007】最大土地面积 Description在某块平面土地上有 个点，你可以选择其中的任意四个点，使得这四个点围成的土地面积最大。 Input第 行一个正整数 ，接下来 行，每行 个数 ，表示该点的横坐标和纵坐标。 Output最大的多边形面积，答案精确到小数点后 位。 Sample Input12345650 01 01 10 10.5 0.5 Sample Output11.000 HINT数据范围: ， 标签：旋转卡壳 Solution基础旋转卡壳。 首先这四个点一定在凸包上，先求凸包。 考虑枚举每条对角线，找出其两边最远的点，即可找到该对角线对应的最大四边形。这样就是一个 的暴力。 枚举对角线的一段，移动另一端，发现两边最远的点都是单调移动的，于是可以带上旋转卡壳，这样内层循环的总复杂度时 ，就有了一个 的优质算法。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define MAX_N 2000using namespace std;typedef double dnt;int n, m;struct pnt { dnt x, y; dnt operator * (const pnt &amp;t) const {return x*t.y-y*t.x;} pnt operator - (const pnt &amp;t) const {return (pnt){x-t.x, y-t.y};} bool operator &lt; (const pnt &amp;t) const {return x == t.x ? y &lt; t.y : x &lt; t.x;}} p[MAX_N+5], c[MAX_N*2+5], mat[MAX_N*2+5][2];dnt S(pnt a, pnt b, pnt c, pnt d) {return (a*b+b*c+c*d+d*a)/2;}void ConvexHull() { sort(p+1, p+n+1), c[++m] = p[1], c[++m] = p[2]; for (int i = 3; i &lt;= n; c[++m] = p[i++]) while (m &gt; 1 &amp;&amp; (p[i]-c[m-1])*(c[m]-c[m-1]) &gt;= 0) m--; int t = m; c[++m] = p[n-1]; for (int i = n-2; i; c[++m] = p[i--]) while (m &gt; t &amp;&amp; (p[i]-c[m-1])*(c[m]-c[m-1]) &gt;= 0) m--; m--; for (int i = 1; i &lt;= m; i++) c[i+m] = c[i];}dnt RotatingCalipers() { dnt ret = 0; if (m == 3) return (c[1]*c[2]+c[2]*c[3]+c[3]*c[1])/2; for (int i = 1; i &lt;= m; i++) { for (int j = i+2, t = j-1; j &lt;= i+m-2; j++) {while (t &lt; j &amp;&amp; (c[t+1]-c[t])*(c[j]-c[i]) &gt;= 0) t++; mat[j][0] = c[t];} for (int j = i+m-2, t = j+1; j &gt;= i+2; j--) {while (t &gt; j &amp;&amp; (c[t-1]-c[t])*(c[j]-c[i]) &lt;= 0) t--; mat[j][1] = c[t];} for (int j = i+2; j &lt;= i+m-2; j++) ret = max(ret, S(c[i], mat[j][0], c[j], mat[j][1])); } return ret;}int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); return ConvexHull(), printf("%.3lf", RotatingCalipers()), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>旋转卡壳</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2406 矩阵]]></title>
    <url>%2FBZOJ2406%20%E7%9F%A9%E9%98%B5%20%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem矩阵Time Limit: Memory Limit: Description Input第一行两个数 、 ，表示矩阵的大小。接下来 行，每行 列，描述矩阵 。最后一行两个数 ， 。 Output一行，输出最小的答案。 Sample Input12342 20 12 10 1 Sample Output11 HINT , , 标签：线性规划，上下界网络流 Solution线性规划转上下界网络流。看到所求为最大值中的最小，可想到二分答案。对于当前答案 ，验证是否能构造矩阵B使得： 对于 ， 对于 ， 对于 ， 而 又只有200，不难想到跑网络流验证。 将每行每列设为点（共 个），建图: 容量 容量 容量 赫然是个上下界网络流。建虚拟源虚拟汇跑最大流看是否等于补流即可。建图， 为上下界网络流的原源和原汇， 为虚拟源和汇， 记录补流： 容量 容量 ， 容量 ， 容量 ， 随后将此图和虚拟源汇接上：对于 若 ，连接 容量 ， 补 若 ，连接 容量 ， 分 最后判断 补 分 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define MAX_N 500000#define MAX_M 500000#define INF 0x3f3f3f3f#define mid ((p+q)&gt;&gt;1)using namespace std;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int r, c, x[205], y[205], P, Q;int n, s, t, ss, tt, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5];void init() {cnt = 0, s = 0, t = r+c+1, ss = t+1, tt = t+2, memset(pr, -1, sizeof pr), memset(d, 0, sizeof d);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() {int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}bool check(int tans) { int into = 0, outo = 0; init(), n = r+c+2, addedge(tt, ss, INF); for (int i = 1; i &lt;= r; i++) for (int j = 1; j &lt;= c; j++) addedge(i, j+r, Q-P), d[i] += P, d[j+r] -= P; for (int i = 1; i &lt;= r; i++) addedge(ss, i, 2*tans), d[ss] += x[i]-tans, d[i] -= x[i]-tans; for (int i = 1; i &lt;= c; i++) addedge(i+r, tt, 2*tans), d[i+r] += y[i]-tans, d[tt] -= y[i]-tans; for (int i = 1; i &lt;= tt; i++) if (i^t) { if (d[i] &lt; 0) addedge(s, i, -d[i]), into -= d[i]; if (d[i] &gt; 0) addedge(i, t, d[i]), outo += d[i]; } return into == outo &amp;&amp; Dinic() == into;}int bi_search(int p, int q) {int ret = -1; while (p &lt;= q) if (check(mid)) ret = mid, q = mid-1; else p = mid+1; return ret;}int main() { read(r), read(c); for (int i = 1; i &lt;= r; i++) for (int j = 1, val; j &lt;= c; j++) read(val), x[i] += val, y[j] += val; return read(P), read(Q), printf("%d", bi_search(0, 200000)), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>线性规划</tag>
        <tag>上下界网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3676【APIO2014】回文串]]></title>
    <url>%2FBZOJ3676%E3%80%90APIO2014%E3%80%91%E5%9B%9E%E6%96%87%E4%B8%B2%20%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[ProblemBZOJ3676【APIO2014】回文串Time Limit: Memory Limit: Description给你一个由小写拉丁字母组成的字符串 。我们定义 的一个子串的存在值为这个子串在 中出现的次数乘以这个子串的长度。对于给你的这个字符串 ，求所有回文子串中的最大存在值。 Input输入只有一行，为一个只包含小写字母 的非空字符串 。 Output输出一个整数，表示所有回文子串中的最大存在值。 Sample InputInput 1abacaba Input 1www Sample OutputOutput 17 Output 14 HINT一个串是回文的，当且仅当它从左到右读和从右到左读完全一样。在第一个样例中，回文子串有 个： ， ， ， ， ， ， ，其中： a出现 次，其出现值为 ： b出现 次，其出现值为 ： c出现 次，其出现值为 ： aba出现 次，其出现值为 ： aca出现 次，其出现值为 ： bacab出现 次，其出现值为 ： abacaba出现 次，其出现值为 ： 故最大回文子串出现值为 。数据规模与评分数据满足 字 符 串 长 度 。 标签：回文自动机 Solution回文自动机建出来直接统计答案。具体回文自动机讲解参见 的博客。 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;#define DICNUM 26#define MAX_N 300000using namespace std;typedef long long lnt;char s[MAX_N+5]; int cnt, trie[MAX_N+5][DICNUM], fail[MAX_N+5], end[MAX_N+5], len[MAX_N+5];int newnode(int l) {len[++cnt] = l; return cnt;}void init() {fail[0] = newnode(-1), s[0] = '$';}int getf(int x, int l) {while (s[l-len[x]-1]^s[l]) x = fail[x]; return x;}int main() { scanf("%s", s+1), init(); int n = (int)strlen(s+1); for (int i=1, x=s[1]-'a', pre=0, cur=getf(pre,1); i&lt;=n; end[pre=trie[cur][x]]++, x=s[++i]-'a', cur=getf(pre,i)) if (!trie[cur][x]) newnode(len[cur]+2), fail[cnt] = trie[getf(fail[cur], i)][x], trie[cur][x] = cnt; for (int i = cnt; i; i--) end[fail[i]] += end[i]; lnt ans = 0; for (int i = 1; i &lt;= cnt; i++) ans = max(ans, 1LL*len[i]*end[i]); return printf("%lld", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>APIO</tag>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3676【NOI2015】品酒大会]]></title>
    <url>%2FBZOJ4199%E3%80%90NOI2015%E3%80%91%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A%20%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[ProblemBZOJ3676【NOI2015】品酒大会Time Limit: Memory Limit: Description一年一度的“幻影阁夏日品酒大会”隆重开幕了。大会包含品尝和趣味挑战两个环节，分别向优胜者颁发“首席品酒家”和“首席猎手”两个奖项，吸引了众多品酒师参加。在大会的晚餐上，调酒师 调制了 杯鸡尾酒。这 杯鸡尾酒排成一行，其中第 杯酒 被贴上了一个标签 ，每个标签都是 个小写英文字母之一。设 表示第 杯酒到第 杯酒的 个标签顺次连接构成的字符串。若 ，其中 ， ， ， ，则称第 杯酒与第 杯酒是“ 相似”的。当然两杯“ 相似” 的酒同时也是“ 相似”、“ 相似”、……、“ 相似”的。特别地，对于任意的 ，第 杯酒和第 杯酒都是“ 相似”的。在品尝环节上，品酒师 轻松地评定了每一杯酒的美味度，凭借其专业的水准和经验成功夺取了“首席品酒家”的称号，其中第 杯酒 的美味度为 。现在 公布了挑战环节的问题：本次大会调制的鸡尾酒有一个特点，如果把第 杯酒与第 杯酒调兑在一起，将得到一杯美味度为 的酒。现在请各位品酒师分别对于 ，统计出有多少种方法可以选出 杯“ 相似”的酒，并回答选择 杯“ 相似”的酒调兑可以得到的美味度的最大值。 Input第 行包含 个正整数 ，表示鸡尾酒的杯数。第 行包含一个长度为 的字符串 ，其中第 i 个字符表示第 杯酒的标签。第 行包含 个整数，相邻整数之间用单个空格隔开，其中第 个整数表示第 杯酒的美味度 。 Output输出文件包括 行。第 行输出 个整数，中间用单个空格隔开。第 个整数表示选出两杯“ 相似”的酒的方案数，第 个整数表示选出两杯“ 相似”的酒调兑可以得到的最大美味度。若不存在两杯“ 相似”的酒，这两个数均为 。 SampleSample 1Input12310ponoiiipoi2 1 4 7 4 8 3 6 4 7 Output1234567891045 5610 563 320 00 00 00 00 00 00 0 Explanation二元组 表示第 杯酒与第 杯酒。 相似：所有 对二元组都是 相似的，美味度最大的是 。 相似： ， 最 大 的 是 。 相似： ， 最 大 的 是 4\times 8=32 。 没 有 3,4,5,\cdots ,9 相 似 的 两 杯 酒 ， 故 均 输 出 0$。 Sample 2Input12312abaabaabaaba1 -2 3 -4 5 -6 7 -8 9 -10 11 -12 Output12345678910111266 12034 12015 5512 409 277 165 73 -42 -41 -40 00 0 HINT对于 的数据， 。有 的数据，不存在“ 相似”的酒。有 的数据，所有 的值都相等。对于 的数据， 。 标签：后缀数组 并查集 Solution建后缀数组后统计每种 的后缀对有哪些，发现当从高向低枚举相似度 时，只会有越来越多的字符串满足，则每次合并新加进来的后缀对，用并查集维护。即若后缀 和 最高为 相似，则从 倒叙枚举到 时把 和 所在的集合合并。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define MAX_N 300000using namespace std;typedef long long lnt;int n, a[MAX_N+5]; char s[MAX_N+5];int sa[MAX_N+5], rk[MAX_N+5], height[MAX_N+5], tsa[MAX_N+5], cntA[MAX_N+5], cntB[MAX_N+5], A[MAX_N+5], B[MAX_N+5];lnt ans[MAX_N+5][2]; vector &lt;int&gt; m[MAX_N+5]; int fa[MAX_N+5], mina[MAX_N+5], maxa[MAX_N+5], size[MAX_N+5];int getf(int x) {return x == fa[x] ? x : fa[x] = getf(fa[x]);}void CalcSA() { for (int i = 1; i &lt;= 26; i++) cntA[i] = 0; for (int i = 1; i &lt;= n; i++) cntA[s[i]-'a'+1]++; for (int i = 1; i &lt;= 26; i++) cntA[i] += cntA[i-1]; for (int i = n; i &gt;= 1; i--) sa[cntA[s[i]-'a'+1]--] = i; rk[sa[1]] = 1; for (int i = 2; i &lt;= n; i++) {rk[sa[i]] = rk[sa[i-1]]; if (s[sa[i]] != s[sa[i-1]]) rk[sa[i]]++;} for (int l = 1; l &lt; n; l &lt;&lt;= 1) { for (int i = 1; i &lt;= n; i++) cntA[i] = 0; for (int i = 1; i &lt;= n; i++) cntB[i] = 0; for (int i = 1; i &lt;= n; i++) cntA[A[i] = rk[i]]++, cntB[B[i] = (i+l &lt;= n) ? rk[i+l] : 0]++; for (int i = 1; i &lt;= n; i++) cntB[i] += cntB[i-1]; for (int i = n; i &gt;= 1; i--) tsa[cntB[B[i]]--] = i; for (int i = 1; i &lt;= n; i++) cntA[i] += cntA[i-1]; for (int i = n; i &gt;= 1; i--) sa[cntA[A[tsa[i]]]--] = tsa[i]; rk[sa[1]] = 1; for (int i = 2; i &lt;= n; i++) { rk[sa[i]] = rk[sa[i-1]]; if (A[sa[i]] != A[sa[i-1]] || B[sa[i]] != B[sa[i-1]]) rk[sa[i]]++; } } for (int i = 1, j = 0; i &lt;= n; i++) { if (j) j--; while (s[i+j] == s[sa[rk[i]-1]+j]) j++; height[rk[i]] = j; }}int main() { scanf("%d", &amp;n), scanf("%s", s+1); lnt tot = 0, pro = 0; for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); CalcSA(); for (int i = 2; i &lt;= n; i++) m[height[i]].push_back(i); for (int i = 1; i &lt;= n; i++) fa[i] = i, size[i] = 1, mina[i] = maxa[i] = a[sa[i]]; for (int i = n-1; ~i; i--) { for (int j = 0; j &lt; (int)m[i].size(); j++) { int u = getf(m[i][j]), v = getf(m[i][j]-1); if (u == v) continue; if (!tot) pro = max(1LL*mina[u]*mina[v], 1LL*maxa[u]*maxa[v]); else pro = max(pro, max(1LL*mina[u]*mina[v], 1LL*maxa[u]*maxa[v])); tot += 1LL*size[u]*size[v], fa[v] = u, size[u] += size[v]; mina[u] = min(mina[u], mina[v]), maxa[u] = max(maxa[u], maxa[v]); } ans[i][0] = tot, ans[i][1] = pro; } for (int i = 0; i &lt; n; i++) printf("%lld %lld\n", ans[i][0], ans[i][1]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>NOI</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3282 Tree < LCT >]]></title>
    <url>%2FBZOJ3282%20Tree%20LCT%2F</url>
    <content type="text"><![CDATA[ProblemTreeTime Limit: Memory Limit: Description给定 个点以及每个点的权值，要你处理接下来的 个操作。操作有 种。操作从 到 编号。点从 到 编号。 .后接两个整数 ，代表询问从 到 的路径上的点的权值的 和。保证 到 是联通的。 .后接两个整数 ，代表连接 到 ，若x到y已经联通则无需连接。 .后接两个整数 ，代表删除边 ，不保证边 存在。 .后接两个整数 ，代表将点 上的权值变成 。 Input第 行两个整数，分别为 和 ，代表点数和操作数。第 行到第 行，每行一个整数，整数在 内，代表每个点的权值。第 行到第 行，每行三个整数，分别代表操作类型和操作所需的量。 Output对于每一个 号操作，你须输出 到 的路径上点权的 和。 Sample Input12345673 3 1231 1 20 1 2 0 1 1 Sample Output1231 Hint 标签：LCT Solution 板子题人生中的第一道 用了没带保护指针的 ，有几个细节挺坑 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define MAX_N 300000#define INF 0x7f7f7f7f#define flag (!tar(cur-&gt;fa-&gt;fa)&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;struct SplayNode { SplayNode *s[2], *fa; int val, sum; bool rev; void updata() {sum = val^(s[0]?s[0]-&gt;sum:0)^(s[1]?s[1]-&gt;sum:0);} void downtag() { if (fa &amp;&amp; (fa-&gt;s[0] == this || fa-&gt;s[1] == this)) fa-&gt;downtag(); if (rev &amp;&amp; s[0]) swap(s[0]-&gt;s[0], s[0]-&gt;s[1]), s[0]-&gt;rev ^= 1; if (rev &amp;&amp; s[1]) swap(s[1]-&gt;s[0], s[1]-&gt;s[1]), s[1]-&gt;rev ^= 1; rev = false; }} *tr[MAX_N+5];struct LinkCutTree { SplayNode* newnode(int _val) { SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = v-&gt;sum = _val, v-&gt;rev = 0; return v; } SplayNode* get_rt(SplayNode* v) {for (; v-&gt;fa; v = v-&gt;fa) ; return v;} bool tar(SplayNode* v) {return (v&amp;&amp;v-&gt;fa==NULL)||(v&amp;&amp;v-&gt;fa-&gt;s[0]!=v&amp;&amp;v-&gt;fa-&gt;s[1]!=v);} LinkCutTree(int n) {for (int i=1,_val;i&lt;=n;i++) scanf("%d", &amp;_val), tr[i]=newnode(_val);} void rotate(SplayNode* v, bool sn) { SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa &amp;&amp; !tar(f)) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); } void splay(SplayNode* cur) { cur-&gt;downtag(); while (!tar(cur) &amp;&amp; !tar(cur-&gt;fa)) { bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); } if (!tar(cur) &amp;&amp; tar(cur-&gt;fa)) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); cur-&gt;updata(); } void access(SplayNode* cur) { for (SplayNode* cpy = NULL; cur; cpy = cur, cur = cur-&gt;fa) splay(cur), cur-&gt;s[1] = cpy, cur-&gt;updata(); } void mroot(SplayNode* v) { access(v), splay(v); swap(v-&gt;s[0], v-&gt;s[1]), v-&gt;rev ^= 1; } void link(SplayNode* u, SplayNode* v) { if (get_rt(u) == get_rt(v)) return; mroot(u), u-&gt;fa = v; } void cut(SplayNode* u, SplayNode* v) { if (u == v || get_rt(u) != get_rt(v)) return; mroot(u), access(v), splay(v); if (v-&gt;s[0] == u) u-&gt;fa = v-&gt;s[0] = NULL, v-&gt;updata(); } void modify(SplayNode* v, int _val) { splay(v), v-&gt;val = _val, v-&gt;updata(); } int query(SplayNode* u, SplayNode* v) { mroot(u), access(v), splay(v); return v-&gt;sum; }};int main() { int n, m; scanf("%d%d", &amp;n, &amp;m); LinkCutTree LCT(n); while (m--) { int opt, x, y; scanf("%d%d%d", &amp;opt, &amp;x, &amp;y); if (opt == 0) printf("%d\n", LCT.query(tr[x], tr[y])); if (opt == 1) LCT.link(tr[x], tr[y]); if (opt == 2) LCT.cut(tr[x], tr[y]); if (opt == 3) LCT.modify(tr[x], y); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201701219-30总结]]></title>
    <url>%2F20171219-30%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[高新2017联训划水记 Day1 看到数论题就想放水…惊讶地发现貌似可以 。不过状态定义出来推不出转移，就交了暴力…题解是个矩乘，我的状态没构造对。不过 貌似因为前置 出锅了。 怎么又是数论…不过化一化发现貌似底数和指数可以合到一起，就是 的板子了。这时候发现了一个大问题… 怎么写啊！ 怎么写啊！！ 怎么写啊！！！作为一个 板都没写过的老年选手，我仍不会写 。写了个随机化骗分，不过和暴力分一样。 好熟悉啊， 上出现三次的题呢，貌似叫什么重组病毒病毒重组之类的玩意。应该是个 吧。不过自己 板子都不熟， 就别说了，弃坑搞暴力。水了三道低保， 。 Day2 没看到数据随机…打了一个 的暴力，一直在想怎么搞到 …结果是按长度排序后枚举且及时 …唯一的水题就这样甩了… 先想了想字典树，但是是没法搞的。又去推了推线性基，结果没推出了。打暴力弃坑。标解高消按两个关键字贪心。 由于 的错误方向想太久已经没时间了，所幸交了暴力，水了 。标解线段树维护区间左右端黑白段长，需要线段树合并。 Day3 数论，还好是水题。可知 一定是 的约数， 是固定的。因此枚举 即可。我和 稳 特判 写挂了，数据挺强，卡成 。 正解就别说了，连暴力都不好写。索性弃坑做 。标解行列式，有点像矩阵树。 乱搞了一个 和一个 ，写完发现公用变量名了…调出*。按水 分写，最后因为常数得了 。 Day4 二合一。后面 的 会做，水 部分分， 的暴力打错了…标解前半段是平衡树维护做到 ，不过我下来看 发现可以值域线段树水过，反正是删排名为 的数。这样比平衡树快而且好写。 小学奥数。我没有推公式，直接打了一个 的表就把规律看出来了。水过。 看起来像是北京讲的群论。不过貌似不太会推。索性打暴力水 。 Day5 的题目顺序 题。滚粗勒。 没推出公式…暴力滚粗 没思路…暴力滚粗 不会维护…暴力滚粗 正解数论错位相减推通项然后逆元搞搞 变成 走一步 走两步后最短路乱搞 维护 的区间。用 单 调 栈 线 段 树 搞搞即可 Day6唯一一次考好。 主席树套路题。有点卡常，不过把传参移到外面以后就瞬间快了 倍。 合并石子。不会做 ，但是会四边形优化的 和升序的贪心。水 。正解一个叫g什么的鬼畜算法，证明不详，平衡树维护一种贪心操作。 网络流，发现直接最小割是有锅的，写了分层 暴 力 错 解 最 小 割 。正解把每条边建 反边后跑最小割。 Day8 推半天没推出来。用基本公式打暴力水 。正解通项是 。杜教筛可过。 点分。不会合并信息，没做QAQ。 网络流二合一。第二个写了，没写出第一个。贪心打第一个结果出锅了。 Day9 没想到记忆化（我傻逼）打 暴力。正解记忆化，复杂度可证是玄学的 。 是 讲过的原题，树上背包，维护两个 。我把两个 打到一起了，互相更新答案，出锅QAQ。 丧心病狂 网络流，不会建图没写。 Day10 貌似可以 但是没推出来。用单调栈写 部分分，结果定义了全局变量和局部变量 ，以至于传进函数的 是 ，然后就没输出…正解 分治。 应该是 ，但是没推出来，按题目模拟水低保。正解 ， 有 的做法，学了学发现很精妙，不过很难想，细节也比较多。 想到是 ，但是细节太多，而且补集转换的全集不会求。标解 ，细节很多，转移方程一大堆。 Day11 看出来是基环树森林里贪心，不过没调出来，交了 暴力，水 。正解和我想的一样。 水题没做起QAQ。暴力打错了，滚粗。 通讯题会前两个 ，不会只染两种颜色。正解很精妙，用若干个四位二进制数表示倍增跑多少格，保证能识别三位就认出整个数， 当行位杂色行，上下方位交替杂色行和纯色行。 Conclusion本次集训收获还是蛮大的。见识了一些比较新奇的玩意儿。不过考试也暴露出一些水题我想不出的情况，而且有时暴力还打错。另外，我貌似做套路题很上手，但是做一些灵活的题则很被动。需要多训练思维。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2187 Beauty Contest]]></title>
    <url>%2FPOJ2187%20Beauty%20Contest%20%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[ProblemBeauty ContestDescription贝茜在牛的选美比赛中赢得了冠军”牛世界小姐”。因此,贝西会参观 ( )个农场来传播善意。世界将被表示成一个二维平面,每个农场位于一对整数坐标 ( )。没有两个农场共享相同的一对坐标。尽管贝西沿直线前往下一个农场，但牧场之间的距离可能很大,所以她需要一个手提箱保证在每一段旅程中她有足够吃的食物。她想确定她可能需要旅行的最大可能距离,她要知道她必须带的手提箱的大小。帮助贝西计算农场的最大距离。 Input第 行一个整数 ，第 行两个整数 表示 个农场中第 个的坐标 Output一行，最远距离的平方 Sample Input1234540 00 11 11 0 Sample Output12 标签：旋转卡壳 Solution平面最远点对。旋转卡壳模板。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 50000using namespace std;template &lt;class T&gt;inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m;struct pnt { int x, y; int operator * (const pnt &amp;t) const {return x*t.y-y*t.x;} pnt operator - (const pnt &amp;t) const {return (pnt){x-t.x, y-t.y};} bool operator &lt; (const pnt &amp;t) const {return x == t.x ? y &lt; t.y : x &lt; t.x;}} p[MAX_N+5], c[MAX_N+5];int sqr(int x) {return x*x;}int dis(pnt a, pnt b) {return sqr(a.x-b.x)+sqr(a.y-b.y);}void ConvexHull() { sort(p+1, p+n+1), c[++m] = p[1], c[++m] = p[2]; for (int i = 3; i &lt;= n; c[++m] = p[i++]) while (m &gt; 1 &amp;&amp; (p[i]-c[m-1])*(c[m]-c[m-1]) &gt;= 0) m--; int t = m; c[++m] = p[n-1]; for (int i = n-2; i; c[++m] = p[i--]) while (m &gt; t &amp;&amp; (p[i]-c[m-1])*(c[m]-c[m-1]) &gt;= 0) m--; m--;}int RotatingCalipers() { if (m == 2) return dis(c[1], c[2]); int a = 1, b = 1; for (int i = 1; i &lt;= m; i++) if (c[i] &lt; c[a]) a = i; for (int i = 1; i &lt;= m; i++) if (c[b] &lt; c[i]) b = i; int ret = dis(c[a], c[b]); for (int sa = a, sb = b; a^sb || b^sa; ret = max(ret, dis(c[a], c[b]))) (c[a%m+1]-c[a])*(c[b%m+1]-c[b]) &lt;= 0 ? a = a%m+1 : b = b%m+1; return ret;}int main() { read(n); for (int i = 1; i &lt;= n; i++) read(p[i].x), read(p[i].y); return ConvexHull(), printf("%d", RotatingCalipers()), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>旋转卡壳</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1930【SHOI2003】Pacman 吃豆豆]]></title>
    <url>%2FBZOJ1930%E3%80%90SHOI2003%E3%80%91Pacman%20%E5%90%83%E8%B1%86%E8%B1%86%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SHOI2003】Pacman 吃豆豆 Description两个 吃豆豆。一开始的时候， 都在坐标原点的左下方，豆豆都在右上方。 走到豆豆处就会吃掉它。 行走的路线很奇怪，只能向右走或者向上走，他们行走的路线不可以相交。 请你帮这两个 计算一下，他们俩加起来最多能吃掉多少豆豆。 Input第一行为一个整数 ，表示豆豆的数目。 接下来 行，每行一对正整数，表示第 个豆豆的坐标。任意两个豆豆的坐标都不会重合。 Output仅有一行包含一个整数，即两个 加起来最多能吃掉的豆豆数量 Sample Input12345678988 11 55 72 27 84 63 36 4 Sample Output17 HINT 样例解释 标签：费用流 Solution貌似是可以用 肝的。费用流建模细节挺多。首先可以发现不相交时废话。若穿过则互换名字即可。由于点数很多，所以不能两两连边，发现只需要把按 和 排序后相邻两点连边即可。首先需要限制每个点的流量，需要将每个点拆成两个点，连边限流。这里由于两条线可以经过同一个点，但贡献只算一个，则需要连两条边，流量均为 ，而费用则是一条为 另一条为 。注意源点也需要限制 的流量，即需要把源点拆成两个点，中间连流量 费用 的边。相邻两点间连流量为 费用为 的边。总结建图： 源点拆成两个点 和 流量 费用 把每个点拆成 和 流量 费用 流量 费用 流量 费用 流量 费用 可连边的相邻两点 和 间有 流量 费用 最后跑大费流即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define MAX_N 5000#define MAX_M 500000#define INF 0x7f7f7f7fusing namespace std;struct P {int x, y;} p[MAX_N+5];int n, s, ss, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mxc;struct node {int v, c, w, nxt;} E[MAX_M+5];void init() {s = 0, ss = n*2+1, t = n*2+2, memset(pr, -1, sizeof pr);}bool cmp (const P &amp;a, const P &amp;b) {return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(cr, -1, sizeof cr); memset(d, -1, sizeof d); d[s] = 0, que.push(s), inq[s] = true; while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &gt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] &lt;= 0) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mxc += d[t]; return true;}int main() { scanf("%d", &amp;n); init(), addedge(s, ss, 2, 0); for (int i = 1; i &lt;= n; i++) addedge(ss, i, 2, 0), addedge(i+n, t, 2, 0); for (int i = 1; i &lt;= n; i++) addedge(i, i+n, 1, 1), addedge(i, i+n, 1, 0); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;p[i].x, &amp;p[i].y); sort(p+1, p+n+1, cmp); for (int i = 1, mi = INF; i &lt;= n; i++, mi = INF) for (int j = i+1; j &lt;= n; j++) if (p[i].y &lt;= p[j].y &amp;&amp; p[j].y &lt;= mi) addedge(i+n, j, 2, 0), mi = p[j].y; while (SPFA()) ; return printf("%d", mxc), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3442 学习小组]]></title>
    <url>%2FBZOJ3442%20%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%84%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem学习小组Time Limit: Memory Limit: Description坑校准备鼓励学生参加学习小组。共有 个学生， 个学习小组，每个学生有一定的喜好，只愿意参加其中的一些学习小组，但是校领导为学生考虑，规定一个学生最多参加 个学习小组。财务处的大叔就没那么好了，他想尽量多收钱，因为每个学生参加学习小组都要交一定的手续费，不同的学习小组有不同的手续费。然而，事与愿违，校领导又决定对学习小组组织者进行奖励，若有 个学生参加第i个学习小组，那么给这个学习小组组织者奖励 元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱（若为负数，则输出负数）（ 支 出 总 奖 励 费 总 手 续 费 ）。 Input输入有若干行，第一行有三个用空格隔开的正整数 、 、 。接下来的一行有 个正整数，表示每个 。第三行有 个正整数，表示参加每个学习小组需要交的手续费 。再接下来有一个 行 列的矩阵，表若第 行 列的数字是 ，则表示第 个学生愿意参加第 个学习小组，若为 ，则为不愿意。 Output输出只有一个整数，为最小的支出。 Sample Input1234563 3 11 2 33 2 1111111111 Sample Output1-2 Hint样例解释参与学生最多为 ，每个学生参加一个学习小组，若有两个学生参加第一个学习小组，一个学生参加第二个学习小组（一定要有人参加第二个学习小组），支出为 ，可以证明没有更优的方案了。数据范围与约定 的数据， ＜ ， ＜ ， ＜ ， ＜ ， ＜ 。 标签：费用流 Solution常规费用流建模。建图：每个学生为一个点，每个小组为一个点，共 个点。对每个学生 ， 流量 费用 （限制最多选 个组） 流量 费用 （限制至少选一个组）对每个组 ， 流量 费用 其中 即当前若有 个人，再多一个人会带来 的收益学生和组之间则连边 流量 费用 跑小费流即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 50000#define INF 0x7f7f7f7fusing namespace std;int n, m, k, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node {int v, c, w, nxt;} E[MAX_M+5]; int f[MAX_N+5];void init() {s = 0, t = n+m+1, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]; return true;}int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;k), init(); for (int i = 1; i &lt;= n; i++) addedge(s, i, k, 0); for (int i = 1; i &lt;= n; i++) addedge(i, t, k-1, 0); for (int i = 1; i &lt;= m; i++) { int c; scanf("%d", &amp;c); for (int j = 1; j &lt;= n; j++) addedge(i+n, t, 1, c*(2*j-1)); } for (int i = 1; i &lt;= m; i++) scanf("%d", f+i); for (int i = 1; i &lt;= n; i++) { char s[MAX_N]; scanf("%s", s+1); for (int j = 1; j &lt;= m; j++) if (s[j] == '1') addedge(i, j+n, 1, -f[j]); } while (SPFA()) ; return printf("%d", mic), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1283 序列]]></title>
    <url>%2FBZOJ1283%20%E5%BA%8F%E5%88%97%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem序列 Description给出一个长度为 的正整数序列 ，求一个子序列，使得原序列中任意长度为 的子串中被选出的元素不超过 个，并且选出的元素之和最大。 Input第 行三个数 。 接下来 行 个正整数表示 。 Output最大和。 Sample Input1210 5 34 4 4 6 6 6 6 6 4 4 Sample Output130 HINT 的数据: 。 的数据： ， 。 。 SourceBy YM 标签：费用流 Solution常规费用流建模。转化题意为：选 次，每次选一个子序列，每一次连续 个里面只能选一个。对于第 个数 ， 如果不选： 流量 费用 如果选，则下一个数在 之后： 若 ： 流量 费用 若 ： 流量 费用 特别地，有 流量 费用 ； 流量 费用 。跑大费流即可。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define MAX_N 2000#define MAX_M 100000#define INF 0x7f7f7f7fusing namespace std;int n, m, k, a[MAX_N+5];int s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node {int v, c, w, nxt;} E[MAX_M+5];void init() {s = 0, t = n+1, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]; return true;}int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;k), init(); addedge(s, 1, k, 0), addedge(n, t, k, 0); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int i = 1; i &lt; n; i++) addedge(i, i+1, k, 0); for (int i = 1; i &lt;= n-m; i++) addedge(i, i+m, 1, -a[i]); for (int i = n-m+1; i &lt;= n; i++) addedge(i, t, 1, -a[i]); while (SPFA()) ; return printf("%d", -mic), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1221【HNOI2001】软件开发]]></title>
    <url>%2FBZOJ1221%E3%80%90HNOI2001%E3%80%91%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%20%E6%8B%86%E7%82%B9%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2001】软件开发Time Limit: Memory Limit: Description某软件公司正在规划一项 天的软件开发计划，根据开发计划第 天需要 个软件开发人员，为了提高软件开发人员的效率，公司给软件人员提供了很多的服务，其中一项服务就是要为每个开发人员每天提供一块消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。消毒方式有两种， 种方式的消毒需要 天时间， 种方式的消毒需要 天（ ）， 种消毒方式的费用为每块毛巾 , 种消毒方式的费用为每块毛巾 ，而买一块新毛巾的费用为 （新毛巾是已消毒的，当天可以使用）；而且 。公司经理正在规划在这 天中，每天买多少块新毛巾、每天送多少块毛巾进行 种消毒和每天送多少块毛巾进行 种消毒。当然，公司经理希望费用最低。你的任务就是：为该软件公司计划每天买多少块毛巾、每天多少块毛巾进行 种消毒和多少毛巾进行 种消毒，使公司在这项 天的软件开发中，提供毛巾服务的总费用最低。 Input第 行为 . 第 行为 . （注： ） Output最少费用 Sample Input124 1 2 3 2 18 2 1 6 Sample Output138 标签：拆点费用流 Solution拆点费用流套路题把每天拆成两个点 ，表示用过的毛巾和新洗好的毛巾。建图： 容量 费用 容量 费用 容量 费用 容量 费用 容量 费用 容量 费用 跑小费流即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 2000#define MAX_M 100000#define INF 0x7f7f7f7fusing namespace std;int n, a, b, f, fa, fb, w[MAX_N+5];int s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node {int v, c, w, nxt;} E[MAX_M+5];void init() {s = 0, t = n*2+1, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]*flow; return true;}int main() { scanf("%d%d%d%d%d%d", &amp;n, &amp;a, &amp;b, &amp;f, &amp;fa, &amp;fb), init(); for (int i = 1; i &lt;= n; i++) scanf("%d", w+i); for (int i = 1; i &lt;= n; i++) addedge(s, i, w[i], 0); for (int i = 1; i &lt; n; i++) addedge(i, i+1, INF, 0); for (int i = 1; i &lt;= n; i++) addedge(s, i+n, INF, f); for (int i = 1; i &lt;= n; i++) addedge(i+n, t, w[i], 0); for (int i = 1; i &lt; n-a; i++) addedge(i, i+a+n+1, INF, fa); for (int i = 1; i &lt; n-b; i++) addedge(i, i+b+n+1, INF, fb); while (SPFA()) ; return printf("%d", mic), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3691 游行]]></title>
    <url>%2FBZOJ3691%20%E6%B8%B8%E8%A1%8C%20%E4%BA%8C%E5%88%86%2B%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem游行Time Limit: Memory Limit: Description每年春季，在某岛屿上都会举行游行活动。在这个岛屿上有 个城市， 条连接着城市的有向道路。你要安排英雄们的巡游。英雄从城市 出发，经过若干个城市，到城市 结束，需要特别注意的是，每个英雄的巡游的 可以和 相同，但是必须至少途径2个城市。每次游行你的花费将由 部分构成： 每个英雄游行经过的距离之和，需要特别注意的是，假如一条边被途径了 次，那么它对答案的贡献是 ， 表示这条边的边权。 如果一个英雄的巡游的 不等于 ，那么会额外增加 的费用。因为英雄要打的回到起点。 如果一个城市没有任何一个英雄途经，那么这个城市会很不高兴，需要 费用的补偿。 你有无数个的英雄。你要合理安排游行方案，使得费用最小。由于每年， 值都是不一样的。所以你要回答 个询问，每个询问都是，当 为当前输入数值的时候的答案。 Input第一行正整数 。接下来的 行，每行 ，表示有一条从 到 ，边权为 的有向道路。保证不会有自环，但不保证没有重边。接下来 行，每行一个 ，表示询问当每次费用为 时的最小答案。 Output 行，每行代表一个询问的答案。 Sample Input1234567896 5 31 3 22 3 23 4 24 5 24 6 21510 Sample Output12362132 HINT样例说明第一年的时候， 只有 。我们比较懒所以就不安排英雄出游了，需要支付 的费用。第二年的时候，我们可以这么安排：一个英雄 ，需要付 的费用，同时还要花5费用打的回家。再花 的费用来补偿 号城市和 号城市。第三年略。数据范围对于 的数据， , , , , 。 标签：二分 费用流 Solution比较难想但很奇妙的费用流建模。题目可以转化为：选择若干条带权路径，选择指覆盖终点，所有没被覆盖的点都要付出 的代价，每次给定 求最小代价。首先用 算出多源最短路把每个点拆成入点和出点，建图： 容量 费用 容量 费用 容量 费用 每次增广均会有前面未覆盖的点被覆盖，即用增广一次的代价来代替 。若增广前代价为 ，则增广后为 。记录每次增广增加的费用，可知这个费用是单增的，推得当 时，可增广使答案变小，而当 时，继续增广会使答案变大。因此对每个询问二分出 的分界点计算答案即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 100000#define mid ((l+r)&gt;&gt;1)#define INF 0x3f3f3f3fusing namespace std;int n, m, q, x, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], f[MAX_N+5], g[MAX_N+5];struct node {int v, c, w, nxt;} E[MAX_M+5]; int G[MAX_N+5][MAX_N+5], tot, cost;void init() {s = 0, t = n*2+1, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; cost = d[t]; return true;}int bi_search(int l, int r) {while (l &lt;= r) f[mid] &lt; x ? l = mid+1 : r = mid-1; return g[l-1]+(n-l+1)*x;}int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;q), init(); memset(G, INF, sizeof G); for (int i = 1; i &lt;= n; i++) addedge(s, i, 1, 0), addedge(i+n, t, 1, 0), G[i][i] = 0; for (int i = 0, u, v, c; i &lt; m; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), G[u][v] = min(G[u][v], c); for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) G[i][j] = min(G[i][j], G[i][k]+G[k][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (G[i][j]^INF &amp;&amp; (i^j)) addedge(i, j+n, 1, G[i][j]); while (SPFA()) f[++tot] = cost, g[tot] = f[tot]+g[tot-1]; while (q--) scanf("%d", &amp;x), printf("%d\n", bi_search(0, tot)); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4205【FJ2015集训】卡牌配对]]></title>
    <url>%2FBZOJ4205%E3%80%90FJ2015%E9%9B%86%E8%AE%AD%E3%80%91%E5%8D%A1%E7%89%8C%E9%85%8D%E5%AF%B9%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【FJ2015集训】卡牌配对Time Limit: Memory Limit: Description现在有一种卡牌游戏，每张卡牌上有三个属性值： 。把卡牌分为 两类，分别有 张。两张卡牌能够配对，当且仅当，存在至多一项属性值使得两张卡牌该项属性值互质，且两张卡牌类别不同。比如一张 类卡牌属性值分别是 ，一张 类卡牌属性值分别为 。那么这两张牌是可以配对的，因为只有 和 一组属性互质。游戏的目的是最大化匹配上的卡牌组数，当然每张卡牌只能用一次。 Input数据第一行两个数 ， ，空格分割。接下来 行，每行 个数，依次表示每张 类卡牌的 项属性值。接下来 行，每行 个数，依次表示每张 类卡牌的 项属性值。 Output输出一个整数：最多能够匹配的数目。 Sample Input123452 22 2 22 5 52 2 55 5 5 Sample Output12 HINT样例中第一张 类卡牌和第一张 类卡牌能配对，第二张 类卡牌和两张 类卡牌都能配对。所以最佳方案是第一张 和第一张 配对，第二张 和第二张 配对。对于 的数据， ，属性值为不超过 的正整数请大胆使用渐进复杂度较高的算法！ 标签：网络流 Solution非常巧妙的一道二分图建模首先考虑暴力建边，显然边数是 级别的，会同时 和 注意到值域只有 ，可以预处理出所有质数，并且可以发现可匹配的情况只有三种，即 不互质, 不互质, 不互质（这里不互质只两张卡的两种同样属性不互质）。这样总共的不互质即可以匹配的情况共有 种（ 内共 个质数）对于一张 类卡牌 ，如果一个点 ， 是 的质因子， 是 的质因子，那么就连一条由卡牌出发到那个点的流量为 的边。其他类的类似。 类卡牌的话就连一条点到卡牌的边。源点向每个 牌连一条流量为 的边，每个 牌向汇点连一条流量为 的边。构图后跑最大流即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define MAX_M 5000000#define INF 0x7f7f7f7fusing namespace std;int tot = 46, pri[46] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199};int n, m, s, t, cnt, x[MAX_N+5], y[MAX_N+5], z[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5], d[MAX_N+5];struct node {int v, c, nxt;} E[MAX_M+5]; vector &lt;int&gt; p[205];void init() {s = 0, t = n+m+tot*tot*3+1, cnt = 0, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = s; i &lt;= t; i++) cr[i] = pr[i];}void rec() {for (int i = s; i &lt;= t; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}int trans(int i, int j) {return i*tot+j+1;}void build(int u) { int a = x[u], b = y[u], c = z[u]; for (int i = 0; i &lt; (int)p[a].size(); i++) for (int j = 0; j &lt; (int)p[b].size(); j++) if (u &lt;= n) addedge(u, n+m+trans(p[a][i], p[b][j]), 1); else addedge(n+m+trans(p[a][i], p[b][j]), u, 1); for (int i = 0; i &lt; (int)p[a].size(); i++) for (int j = 0; j &lt; (int)p[c].size(); j++) if (u &lt;= n) addedge(u, n+m+trans(p[a][i], p[c][j])+tot*tot, 1); else addedge(n+m+trans(p[a][i], p[c][j])+tot*tot, u, 1); for (int i = 0; i &lt; (int)p[b].size(); i++) for (int j = 0; j &lt; (int)p[c].size(); j++) if (u &lt;= n) addedge(u, n+m+trans(p[b][i], p[c][j])+tot*tot*2, 1); else addedge(n+m+trans(p[b][i], p[c][j])+tot*tot*2, u, 1);}int main() { scanf("%d%d", &amp;n, &amp;m), init(); for (int i = 1; i &lt;= 200; i++) for (int j = 0; j &lt; tot; j++) if (i%pri[j] == 0) p[i].push_back(j); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d", x+i, y+i, z+i), addedge(s, i, 1), build(i); for (int i = n+1; i &lt;= n+m; i++) scanf("%d%d%d", x+i, y+i, z+i), addedge(i, t, 1), build(i); return printf("%d", Dinic()), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4514【SDOI2016】数字配对]]></title>
    <url>%2FBZOJ4514%E3%80%90SDOI2016%E3%80%91%E6%95%B0%E5%AD%97%E9%85%8D%E5%AF%B9%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2016】数字配对 Description有 种数字，第 种数字是 、有 个，权值是 。若两个数字 满足， 是 的倍数，且 是一个质数，那么这两个数字可以配对，并获得 的价值。一个数字只能参与一次配对，可以不参与配对。在获得的价值总和不小于 的前提下，求最多进行多少次配对。 Input第一行一个整数 。第二行 个整数 。第三行 个整数 。第四行 个整数 。 Output一行一个数，最多进行多少次配对 Sample Input123432 4 82 200 7-1 -2 1 Sample Output14 HINT ， ， ， 标签：费用流 Solution比较难想的二分图建模。记 为 分解质因数后的项数（ 算两项）， 为质数的充要条件为 且 。可知 奇偶性相同的一定不能配对，所以可建二分图， 为奇在一边， 为偶在另一边。两边间连边则看是否有整除条件，流量为 ，费用为 。把每个点拆成左右两个点，左边与源点相连，右边与汇点相连，容量为 ，费用为零。跑费用流每增广一次就判一下是否费用小于 ，注意最后退出的时候不要把新加入的流全退完，退一部分至刚好大于等于 即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define MAX_N 300#define MAX_M 50000#define INF 1e16using namespace std;typedef long long lnt;int n, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5]; lnt mxf, cur;int a[MAX_N+5], f[MAX_N+5]; lnt b[MAX_N+5], c[MAX_N+5];struct node {int v, nxt; lnt c, w;} E[MAX_M+5];void init() {s = 0, t = n+1, memset(pr, -1, sizeof pr);}void insert(int u, int v, lnt c, lnt w) {E[cnt] = (node){v, pr[u], c, w}, pr[u] = cnt++;}void addedge(int u, int v, lnt c, lnt w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5], mrk[MAX_N+5]; lnt d[MAX_N+5]; int cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(cr, -1, sizeof cr), memset(d, 0, sizeof d); memset(mrk, false, sizeof mrk), d[s] = 0, que.push(s), inq[s] = true, mrk[s] = true; while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v; lnt c = E[i].c, w = E[i].w; if (c &amp;&amp; (!mrk[v] || d[u]+w &gt; d[v])) { mrk[v] = true, d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (!mrk[t]) return false; lnt flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, cur += d[t]*flow; if (cur &lt; 0) {mxf -= cur%d[t] == 0 ? cur/d[t] : cur/d[t]+1; return false;} return true;}int calc(int x) { int ret = 0; for (int i = 2; i &lt;= x; i++) while (!(x%i)) x /= i, ret++; if (x^1) ret++; return ret;}int main() { scanf("%d", &amp;n), init(); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i), f[i] = calc(a[i]); for (int i = 1; i &lt;= n; i++) scanf("%lld", b+i); for (int i = 1; i &lt;= n; i++) scanf("%lld", c+i); for (int i = 1; i &lt;= n; i++) if (f[i]&amp;1) addedge(s, i, b[i], 0); else addedge(i, t, b[i], 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if ((f[i]&amp;1) &amp;&amp; ((f[i] == f[j]+1 &amp;&amp; a[i]%a[j] == 0) || (f[i]+1 == f[j] &amp;&amp; a[j]%a[i] == 0))) addedge(i, j, INF, c[i]*c[j]); while (SPFA()) ; return printf("%lld", mxf), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1190【HNOI2007】梦幻岛宝珠]]></title>
    <url>%2FBZOJ1190%E3%80%90HNOI2007%E3%80%91%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0%20%E5%88%86%E5%B1%82DP%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2007】梦幻岛宝珠 Description给你N颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过W，且总价值最大，输出最大的总价值。数据范围： ， ，且保证每颗宝石的重量可以表示为 的形式（其中 ） Input输入文件中包含多组数据。每组数据的格式如下：第一行是两个正整数 和 ， ，分别表示宝石的数目和最多能带走的宝石重量。接下来的 行，每行有两个正整数 和 ， ，分别表示第i颗宝石的重量和价值，且保证 能写成 的形式。同一行的两个正整数之间用空格隔开。最后一组数据的后面有两个 ，表示文件的结束。这两个 并不代表一组数据，你不需对这组数据输出结果。并且输入文件中数据的组数不超过 。 Output对于输入的每组数据，输出一个整数 ，表示小P最多能带走的宝石的总价值。每个结果整数 单独占一行，且保证 不会超过 。 Sample Input123456789101112131415161718192021222324252627284 108 95 84 62 54 138 95 84 62 516 75594681393216 55332 7732768 46729360128 407840112 6824576 372768 6033554432 46609916384 31833554432 4660902048 11124576 3509216 21612582912 17476816384 2951024 76-1 -1 Sample Output12314191050650 标签：分层DP Solution 很大，不能直接搞。而保证 因而可以按 分层后背包。分层后先层内DP出 表示 层级内容量为 的最大价值。然后层间DP求最大值： 详见代码。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define LOG 30#define MAX_N 100using namespace std;int n, m, l, w[MAX_N+5][LOG+5], c[MAX_N+5][LOG], f[LOG+5][MAX_N+5], cnt[LOG+5], s[LOG+5];int main() { while (scanf("%d%d", &amp;n, &amp;m) &amp;&amp; ~n &amp;&amp; ~m) { memset(cnt, 0, sizeof cnt), memset(s, 0, sizeof s), memset(f, 0, sizeof f), l = 0; while (n--) { int x; scanf("%d", &amp;x); int t = 0; while (!(x&amp;1)) t++, x &gt;&gt;= 1; w[t][++cnt[t]] = x, s[t] += x; l = max(l, t), scanf("%d", &amp;c[t][cnt[t]]); } for (int i = 0; i &lt;= l; i++) for (int j = 1; j &lt;= cnt[i]; j++) for (int k = s[i]; k &gt;= w[i][j]; k--) f[i][k] = max(f[i][k], f[i][k-w[i][j]]+c[i][j]); while (m &gt;&gt; l) l++; l--; for (int i = 1; i &lt;= l; i++) { s[i] += (s[i-1]+1)&gt;&gt;1; for (int j = s[i]; ~j; j--) for (int k = 0; k &lt;= j; k++) f[i][j] = max(f[i][j], f[i][j-k]+f[i-1][min(s[i-1], (k&lt;&lt;1)|((m&gt;&gt;(i-1))&amp;1))]); } printf("%d\n", f[l][1]); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>分层DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1877【SDOI2009】晨跑]]></title>
    <url>%2FBZOJ1877%E3%80%90SDOI2009%E3%80%91%E6%99%A8%E8%B7%91%20%E6%8B%86%E7%82%B9%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2009】晨跑 Description 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等 等，不过到目前为止，他坚持下来的只有晨跑。 现在给出一张学校附近的地图，这张地图中包含 个十字路口和 条街道， 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。 每天从寝室出发 跑到学校，保证寝室编号为 ，学校编号为 。 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。 除了练空手道， 其他时间都花在了学习和找 上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。 Input第一行：两个数 。表示十字路口数和街道数。接下来 行，每行 个数 ，表示路口 和路口 之间有条长度为 的街道（单向）。 Output两个数，第一个数为最长周期的天数，第二个数为满足最长天数的条件下最短的路程长度。 Sample Input12345678910117 101 2 11 3 12 4 13 4 14 5 14 6 12 5 53 6 65 7 16 7 1 Sample Output12 11 Hint 。 标签：拆点费用流 Solution拆点费用流套路题。首先要同时考虑天数最长和路程最短两个权，可知要用费用流。看到每个点只经过一次可知要把每个点拆成入点和出点，中间连流量为 费用为 的边。套路建图后跑费用流即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 50000#define INF 0x7f7f7f7fusing namespace std;int n, m, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node {int v, c, w, nxt;} E[MAX_M+5];void init() {s = 1, t = n+n, memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d), memset(cr, -1, sizeof cr); d[s] = 0, que.push(s), inq[s] = true; while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]; return true;}int main() { scanf("%d%d", &amp;n, &amp;m), init(); addedge(1, 1+n, INF, 0), addedge(n, n+n, INF, 0); for (int i = 2; i &lt; n; i++) addedge(i, i+n, 1, 0); for (int i = 0, u, v, w; i &lt; m; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;w), addedge(u+n, v, 1, w); while (SPFA()) ; return printf("%d %d", mxf, mic), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2321【BJ2011集训】星器]]></title>
    <url>%2FBZOJ2321%E3%80%90BJ2011%E9%9B%86%E8%AE%AD%E3%80%91%E6%98%9F%E5%99%A8%20%E7%89%A9%E7%90%86%2F</url>
    <content type="text"><![CDATA[Problem【BJ2011集训】星器 Description 上的时间又过了若干世纪……现在，人们谈论着一个传说：从前，他们的祖先来到了一个位于东方的岛屿，那里简直就是另外一个世界。善于分析与构造的 上的人们总是不明白那里的人们是如何不借助精确的实验与计算驱动和操纵魔法。偶然地，一个魔法使（ ）来到了 ，在临走的时候留下了一个神奇的盒子，叫做星器（ ）。虽然不知道这个盒子是做什么的，但是经过了大量的实验和计算后，人们已经清楚它的一些事实： 星器之中有 个区域，可看作分成 行和 列的格子，每个区域之中有若干单位的称为“星”的对象，这个对象的最小单位已经被确定，所以，这个数量总是整数。 魔法使可以驱动星器中位于同一行或同一列的不相邻（有公共边的区域称为相邻的）两个区域中各1单位的“星”，使得它们分别向中心移动1格。 每一次使用2中的方法驱动“星”，将会产生魔力，魔法使会得到这一部分魔力。魔力的量等于这个两个区域之间所间隔的区域数。这样，我们可以用一个 的数表来表示星器的状态，比如 ， 时： 当星器为左图的状态时，通过操纵第一行的第 和 个区域中的“星”（加粗的数字对应的区域），变为右图所示的状态，同时，将产生 单位的魔力（因为这两个区域之间恰好隔了 个区域）。在经过了进一步的研究之后，人们知道了这个星器最初的状态（ ）以及最终被他们得到时的状态（ ）。你希望知道，星器最多帮助它的拥有者提供了多少的魔力。即：经过一系列上述操作由初态（ ）变为终态（ ），至多产生多少魔力。需要注意的是，显然操作过程中每个区域内“星”的数量不能是负的，即：如果那个区域已经没有“星”了，当然就不能继续操作了。 Input第一行包含两个正整数 、 表示星器的大小。接下来的 行，每行包含 个自然数： ，描绘了初态（ ）。在一个空行后的 行，每行包含 个自然数： ，描绘了终态（ ）。 Output输出一个正整数，表示至多产生的魔力。 Sample InputSample Input #112345678910115 51 0 0 0 10 0 0 0 00 0 0 0 00 1 0 1 11 0 0 0 00 0 0 0 00 0 0 0 12 0 0 0 10 0 2 0 00 0 0 0 0 Sample Input #21231 410 20 30 400 0 100 0 Sample OutputSample Output #117 Explanation唯一的一种操作方法是：对第 列的两个“星”进行一次操作，产生魔力 ；对第 列的两个“星”进行两次操作，产生魔力 ；对第 行的两个“星”进行一次操作，产生魔力 ；一共产生 单位的魔力。Sample Output #2150 HINT数据规模和约定 的数据中 ，如样例 ； 的数据中 ， ， 。所有数据保证了至少存在一个操作方法使得星器由初态变为终态，同时保证了初态与终态不是完全相同的。 标签：物理 势能 Solution玄学物理题乱搞发现答案和移动方案无关，且行列独立一个星星的势能为它到左上角格子的距离的平方，使用一次魔法释放的魔力为在 两 个 星 星 势 能 和 改 变 量 。计算 初 末 状 态 星 星 势 能 改 变 量 之 和 即可。 ##Code12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long lnt;int n, m; lnt s1, s2;int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) for (int j = 1, x; j &lt;= m; j++) scanf("%d", &amp;x), s1 += 1LL*(i*i+j*j)*x; for (int i = 1; i &lt;= n; i++) for (int j = 1, x; j &lt;= m; j++) scanf("%d", &amp;x), s2 += 1LL*(i*i+j*j)*x; printf("%lld", (s1-s2)/2); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1565【NOI2009】植物大战僵尸]]></title>
    <url>%2FBZOJ1565%E3%80%90NOI2009%E3%80%91%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%20%E6%9C%80%E5%A4%A7%E6%9D%83%E9%97%AD%E5%90%88%E5%AD%90%E5%9B%BE%2B%E6%8B%93%E6%89%91%2F</url>
    <content type="text"><![CDATA[Problem【NOI2009】植物大战僵尸Time Limit: Memory Limit: Description Input Output仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为 。 Sample Input12345673 210 020 0-10 0-5 1 0 0100 1 2 1100 0 Sample Output125 HINT在样例中, 植物 可以攻击位置 , 可以攻击位置 。一个方案为，首先进攻 ，此时可以攻击 。共得到能源收益为 。注意, 位置 被植物 保护，所以无法攻击第 行中的任何植物。数据规模 的数据满足 ； 的数据满足 ； 的数据满足 ， ， 。 标签：最大权闭合子图 网络流 拓扑 Solution可以发现，如果一个植物能被吃，则要先吃掉它右边的植物和所有攻击范围有它的植物。这样可以形成一个有向图。所得到的最大收入为最大权闭合子图。发现此有向图是可以有环的，而环上的植物一定是不能被吃的。因而先拓扑一遍，标记掉环上的点，然后跑最小割即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MAX_M 1000000#define INF 0x7f7f7f7fusing namespace std;struct node {int v, c, nxt;} E[MAX_M+5]; vector &lt;int&gt; G[MAX_N+5]; bool mrk[MAX_N+5];int n, m, s, t, cnt, sum, c[MAX_N+5], d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5], into[MAX_N+5];void init() {s = 0, t = n*m+1, cnt = 0; memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0); G[u].push_back(v), into[v]++;}void topo() { queue &lt;int&gt; que; mrk[s] = mrk[t] = true; for (int i = s; i &lt;= t; i++) if (!into[i]) que.push(i), mrk[i] = true; while (!que.empty()) { int u = que.front(); que.pop(); if (c[u] &gt; 0) sum += c[u]; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (mrk[v]) continue; if (!--into[v]) que.push(v), mrk[v] = true; } }}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || ~d[v] || !mrk[v]) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1 || !mrk[v]) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() { int ret = 0; for (int i = s; i &lt;= t; i++) cr[i] = pr[i]; while (BFS()) { ret += DFS(s, INF); for (int i = s; i &lt;= t; i++) pr[i] = cr[i]; } return ret;}int trans(int x, int y) {return x*m+y+1;}int main() { scanf("%d%d", &amp;n, &amp;m), init(); for (int i = 0; i &lt; n; i++) { for (int j = 1; j &lt; m; j++) addedge(trans(i, j), trans(i, j-1), INF); for (int j = 0, a, w, x, y; j &lt; m; j++) { scanf("%d%d", &amp;a, &amp;w), c[trans(i, j)] = a; if (a &gt; 0) addedge(trans(i, j), t, a); else addedge(s, trans(i, j), -a); while (w--) scanf("%d%d", &amp;x, &amp;y), addedge(trans(i, j), trans(x, y), INF); } } return topo(), printf("%d", sum-Dinic()), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>NOI</tag>
        <tag>最大权闭合子图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF453B Little Pony and Harmony Chest]]></title>
    <url>%2FCF453B%20Little%20Pony%20and%20Harmony%20Chest%20%E7%8A%B6%E5%8E%8BDP%2F</url>
    <content type="text"><![CDATA[ProblemLittle Pony and Harmony ChestTime limit: Memory limit: DescriptionPrincess Twilight went to Celestia and Luna’s old castle to research the chest from the Elements of Harmony. A sequence of positive integers is harmony if and only if for every two elements of the sequence their greatest common divisor equals . According to an ancient book, the key of the chest is a harmony sequence bi which minimizes the following expression: You are given sequence , help Princess Twilight to find the key. InputThe first line contains an integer — the number of elements of the sequences and . The next line contains integers . OutputOutput the key — sequence bi that minimizes the sum described above. If there are multiple optimal sequences, you can output any of them. ExampleInput #11251 1 1 1 1 Output #1 11 1 1 1 1 Input #21251 6 4 2 8 Output #211 5 3 1 8 标签：状压DP Translation题目大意：给出一个 个元素的序列 ，要求找一个 个元素的序列 ，使得 中的数两两互质，且要最小化 之和。 Solution对于互质的条件，发现其相当于每个质因子只能用一次（ 可以用无限次）。发现 的范围只有 ，而如果 ，则取 会更优。因此质因子只可能在 之间，只有 个，可以状压。预处理 中所有数占用的质因子状态，存在数组 中。 表示当前选到第 个数，质因子的选择状态为 的最大答案。对于一个数 ，若 ，则不能选。否则有 对于输出方案，存下转移到 的状态 和选的数 ，递归输出即可。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define SZ 17#define MX 60#define MAX_N 100#define INF 0x3f3f3f3fusing namespace std;int pri[SZ] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59};int n, a[MAX_N+5], f[MAX_N+5][1&lt;&lt;SZ], g[MAX_N+5][1&lt;&lt;SZ], h[MAX_N+5][1&lt;&lt;SZ], sta[MX];void init() { for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt; (1&lt;&lt;SZ); j++) f[i][j] = INF, g[i][j] = h[i][j] = 0; f[0][0] = 0; memset(sta, 0, sizeof sta);}void prt(int i, int j) {if (!i) return; prt(i-1, g[i][j]), printf("%d ", h[i][j]);}int main() { while (~scanf("%d", &amp;n)) { init(); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int i = 2; i &lt; MX; i++) for (int j = 0; j &lt; SZ; j++) if (i%pri[j] == 0) sta[i] |= (1&lt;&lt;j); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; (1&lt;&lt;SZ); j++) { if (f[i][j] == INF) continue; for (int k = 1; k &lt; MX; k++) { if (j&amp;sta[k]) continue; if (f[i+1][j|sta[k]] &gt; f[i][j]+abs(a[i+1]-k)) f[i+1][j|sta[k]] = f[i][j]+abs(a[i+1]-k), g[i+1][j|sta[k]] = j, h[i+1][j|sta[k]] = k; } } int pos = -1, ans = INF; for (int i = 0; i &lt; (1&lt;&lt;SZ); i++) if (f[n][i] &lt; ans) pos = i, ans = f[n][i]; prt(n, pos), puts(""); } return 0;}]]></content>
      <tags>
        <tag>DP</tag>
        <tag>CodeForces</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1822【JSOI2010】Frozen Nova 冷冻波]]></title>
    <url>%2FBZOJ1822%E3%80%90JSOI2010%E3%80%91Frozen%20Nove%20%E5%86%B7%E5%86%BB%E6%B3%A2%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【JSOI2010】Frozen Nova 冷冻波Time Limit: Memory Limit: Description 喜欢“魔兽争霸”这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能 每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。 当巫妖和小精灵之间的直线距离不超过 ，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。 在森林里有 个巫妖，每个巫妖释放 之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。 现在巫妖的头目想知道，若从 时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？ Input输入文件第一行包含三个整数 ，分别代表巫妖的数量、小精灵的数量和树木的数量。 接下来 行，每行包含四个整数 ，分别代表了每个巫妖的坐标、攻击范围和施法间隔（单位为秒）。 再接下来 行，每行两个整数 ，分别代表了每个小精灵的坐标。 再接下来K行，每行三个整数 ，分别代表了每个树木的坐标。 输入数据中所有坐标范围绝对值不超过 ，半径和施法间隔不超过 。 Output输出一行，为消灭所有小精灵的最短时间（以秒计算）。如果永远无法消灭所有的小精灵，则输出 。 Sample Input12345672 3 1-100 0 100 3100 0 100 5-100 -10100 10110 115 5 10 Sample Output15 标签：二分 最大流 Solution这种 二 分 答 案 最 大 流 是常见套路。类似 。二分时间，对于每个时间，判断是否足够消灭所有敌人。建模：对于每个巫妖 ，建边 权值为 攻 击 间 隔 对于每个精灵 ，建边 权值为 对于每组两个能攻击到的巫妖 和精灵 ，建边 权值为 在次图上跑最大流，判断最大流是否等于m，即是否所有小精灵都有匹配的巫妖。预处理每个巫妖和每个小精灵之间是否能看到，即用点到直线距离判断树木 所在的圆是否与巫妖所在点和小精灵所在点两点连成线段有交点，有则不能看到。具体见代码。 Code(我预处理的计算几何部分较为复杂，可以参考hzwer的代码，要简洁一些。)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#define MAX_N 200#define MAX_M 500000#define INF 0x7f7f7f7fusing namespace std;typedef double dnt;int n, m, k, s, t, mx, cnt, pr[MAX_N*2+5];struct WIZ {int x, y, r, t;} wiz[MAX_N+5];struct ELF {int x, y;} elf[MAX_N+5];struct TRE {int x, y, r;} tre[MAX_N+5];struct EDG {int u, v, c, nxt;} E[MAX_M+5];int d[MAX_N*2+5], cr[MAX_N*2+5];bool mrk[MAX_N+5][MAX_N+5];//---------- Geometry Section ----------//WIZ operator - (WIZ a, TRE b) {WIZ t; t.x = a.x-b.x, t.y = a.y-b.y; return t;}WIZ operator - (TRE a, WIZ b) {WIZ t; t.x = a.x-b.x, t.y = a.y-b.y; return t;}ELF operator - (ELF a, TRE b) {ELF t; t.x = a.x-b.x, t.y = a.y-b.y; return t;}ELF operator - (ELF a, WIZ b) {ELF t; t.x = a.x-b.x, t.y = a.y-b.y; return t;}dnt dot(WIZ a, ELF b) {return a.x*b.x+a.y*b.y;}dnt cross(WIZ a, ELF b) {return a.x*b.y-a.y*b.x;}dnt dis(WIZ a, ELF b) {return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}dnt dis(WIZ a, TRE b) {return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}dnt dis(ELF a, TRE b) {return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));}dnt dis(WIZ a, ELF b, TRE p) { if (dot(a-p, b-p) &gt; 0) return min(dis(a, p), dis(b, p)); return abs(cross(p-a, b-a)/dis(a, b));}bool jud(int x, int y) { if (dis(wiz[x], elf[y]) &gt; wiz[x].r) return false; for (int i = 1; i &lt;= k; i++) if (dis(wiz[x], elf[y], tre[i]) &lt; tre[i].r) return false; return true;}//---------- Network Flow Section ----------//void init() {s = 0, t = n+m+1, cnt = 0; memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() { int ret = 0; for (int i = s; i &lt;= t; i++) cr[i] = pr[i]; while (BFS()) { ret += DFS(s, INF); for (int i = s; i &lt;= t; i++) pr[i] = cr[i]; } return ret;}//---------- Binary Search Section ----------//bool chk(int tans) { init(); for (int i = 1; i &lt;= n; i++) addedge(s, i, tans/wiz[i].t+1); for (int i = 1; i &lt;= m; i++) addedge(i+n, t, 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (mrk[i][j]) addedge(i, j+n, 1); return Dinic() == m;}int bi_search(int l, int r) { int ret = -1; while (l &lt;= r) { int mid = (l+r)&gt;&gt;1; if (chk(mid)) r = mid-1, ret = mid; else l = mid+1; } return ret;}int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d%d", &amp;wiz[i].x, &amp;wiz[i].y, &amp;wiz[i].r, &amp;wiz[i].t), mx = max(wiz[i].t, mx); for (int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;elf[i].x, &amp;elf[i].y); for (int i = 1; i &lt;= k; i++) scanf("%d%d%d", &amp;tre[i].x, &amp;tre[i].y, &amp;tre[i].r); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) mrk[i][j] = jud(i, j); return printf("%d", bi_search(0, m*mx)), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF291D Choosing Capital for Treeland]]></title>
    <url>%2FCF291D%20Choosing%20Capital%20for%20Treeland%20%E6%A0%91%E5%BD%A2DP%2F</url>
    <content type="text"><![CDATA[ProblemChoosing Capital for Treeland DescriptionThe country Treeland consists of n cities, some pairs of them are connected with unidirectional roads. Overall there are roads in the country. We know that if we don’t take the direction of the roads into consideration, we can get from any city to any other one.The council of the elders has recently decided to choose the capital of Treeland. Of course it should be a city of this country. The council is supposed to meet in the capital and regularly move from the capital to other cities (at this stage nobody is thinking about getting back to the capital from these cities). For that reason if city a is chosen a capital, then all roads must be oriented so that if we move along them, we can get from city a to any other city. For that some roads may have to be inversed.Help the elders to choose the capital so that they have to inverse the minimum number of roads in the country. InputThe first input line contains integer — the number of cities in Treeland. Next lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers — the numbers of cities, connected by that road. The road is oriented from city to city . You can consider cities in Treeland indexed from to . OutputIn the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital — a sequence of indexes of cities in the increasing order. ExampleInput #112332 12 3 Output #11202 Input #2123441 42 43 4 Output #21221 2 3 标签：树形DP Translation给出一棵由有向边组成的树，要求选一个点使得最小化从它到其余所有点的路径中反向边的条数之和。 Solution首先转化问题为：给出一棵由无向边组成的树，边有权值 或 ( 为正向， 为反向)，要求找一个点使得最小化其到所有点的路径的权值和。特别地，计算某个点时，此点到其父结点的边的边权要异或 。第一次 ，定下每边权值，并 出每个点的子树的总权值。第二次 ，按 序计算答案。对于每个点， ，其中 为其父结点， 为其到父结点的边的边权。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define MAX_N 200000using namespace std;int n, f[MAX_N+5], ans = 1; vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];void addedge(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void DFS1(int u, int fa) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (v == fa) continue; DFS1(v, u), f[u] += f[v]+c; }}void DFS2(int u, int fa) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (v == fa) continue; f[v] = f[u]+(c ? -1 : 1), DFS2(v, u); if (f[u] &lt; f[ans] || (f[u] == f[ans] &amp;&amp; u &lt; ans)) ans = u; }}int main() { scanf("%d", &amp;n); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), addedge(u, v, 0), addedge(v, u, 1); DFS1(1, 0), DFS2(1, 0); printf("%d\n", f[ans]); for (int i = 1; i &lt;= n; i++) if (f[i] == f[ans]) printf("%d ", i); return 0;}]]></content>
      <tags>
        <tag>DP</tag>
        <tag>CodeForces</tag>
        <tag>树形DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3158 千钧一发]]></title>
    <url>%2FBZOJ3158%20%E5%8D%83%E9%92%A7%E4%B8%80%E5%8F%91%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem千钧一发 Description Input第一行一个正整数 。第二行共包括 个正整数，第 个正整数表示 。第三行共包括 个正整数，第 个正整数表示 。 Output共一行，包括一个正整数，表示在合法的选择条件下，可以获得的能量值总和的最大值。 Sample Input12343 4 5 129 8 30 9 Sample Output139 HINT 标签：黑白染色 最小割 Solution和 差不多两条性质： 奇 奇 偶 偶 奇与奇共存，偶与偶共存建模： 奇 ， 偶 ， 奇 偶 总 权 值 最 小 割 注意判断是否能组成勾股数时平方要开 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define INF 2147483647using namespace std;int n, s, t, sum, cnt, a[MAX_N+5], b[MAX_N+5], d[MAX_N+5], pr[MAX_N+5];struct node {int u, v, c, nxt;} E[MAX_N*1000];int gcd(int x, int y) {return y ? gcd(y, x%y) : x;}void init() {s = 0, t = n+1; memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() {int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}bool chk(int i, int j) {return gcd(a[i], a[j]) == 1 &amp;&amp; sqrt(1LL*a[i]*a[i]+1LL*a[j]*a[j]) == floor(sqrt(1LL*a[i]*a[i]+1LL*a[j]*a[j]));}int main() { scanf("%d", &amp;n), init(); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int i = 1; i &lt;= n; i++) scanf("%d", b+i), sum += b[i]; for (int i = 1; i &lt;= n; i++) if (a[i]%2) addedge(s, i, b[i]); else addedge(i, t, b[i]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i]%2 == 1 &amp;&amp; a[j]%2 == 0 &amp;&amp; chk(i, j)) addedge(i, j, INF); return printf("%d", sum-Dinic()), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1475 方格取数]]></title>
    <url>%2FBZOJ1475%20%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem方格取数Time Limit: Memory Limit: Description在一个 的方格里，每个格子里都有一个正整数。从中取出若干数，使得任意两个取出的数所在格子没有公共边，且取出的数的总和尽量大。 Input第一行一个数 （ ），接下来 行每行 个数描述一个方阵 Output仅一个数，即最大和 Sample Input12321 23 5 Sample Output16 标签：黑白染色 最小割 Solution将网格图黑白染色，同色格子间不会冲突。建模： 黑 格 容 量 ， 白 格 容 量 ， 黑 格 白 格 容 量 总 权 值 最 小 割 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define INF 0x7f7f7f7fusing namespace std;int nxt[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}}, sum;int n, m, s, t, cnt, id[35][35], a[MAX_N+5], d[MAX_N+5], pr[MAX_N+5];struct node {int u, v, c, nxt;} E[MAX_N*MAX_N*2];void init() {s = 0, t = m+1; memset(pr, -1, sizeof pr);}void getID() {for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) id[i][j] = (i-1)*n+j;}void insert(int u, int v, int c) {E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() {int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}int main() { scanf("%d", &amp;n), m = n*n, getID(), init(); for (int i = 1; i &lt;= m; i++) scanf("%d", a+i), sum += a[i]; for (int i = 1; i &lt;= m; i++) if ((i-1)%n%2 == (i-1)/n%2) addedge(s, i, a[i]); else addedge(i, t, a[i]); for (int i = 1; i &lt;= m; i++) if ((i-1)%n%2 == (i-1)/n%2){ int x = (i-1)/n+1, y = (i-1)%n+1; for (int j = 0; j &lt; 4; j++) { int nx = x+nxt[j][0], ny = y+nxt[j][1]; if (nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; n) continue; addedge(id[x][y], id[nx][ny], INF); } } printf("%d", sum-Dinic()); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2521【SHOI2010】最小生成树]]></title>
    <url>%2FBZOJ2521%E3%80%90SHOI2010%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem【SHOI2010】最小生成树Time Limit: Memory Limit: Description 最近对最小生成树问题特别感兴趣。他已经知道如果要去求出一个 个点、 条边的无向图的最小生成树有一个 算法和另一个 的算法。另外，他还知道，某一个图可能有多种不同的最小生成树。例如，下面图 中所示的都是图 中的无向图的最小生成树： 当然啦，这些都不是今天需要你解决的问题。 想知道对于某一条无向图中的边 ，至少需要多少代价可以保证 边在这个无向图的最小生成树中。为了使得 边一定在最小生成树中，你可以对这个无向图进行操作，一次单独的操作是指：先选择一条图中的边 ，再把图中除了这条边以外的边，每一条的权值都减少 。如图 所示就是一次这样的操作： Input输入文件的第一行有 个正整数 、 、 分别表示无向图中的点数、边数、必须要在最小生成树中出现的 边的标号。接下来 行依次描述标号为 的无向边，每行描述一条边。每个描述包含 个整数 、 、 ，表示这条边连接着标号为 、 的点，且这条边的权值为 。输入文件保证 , ,且输入数据保证这个无向图一定是一个连通图。 Output输出文件只有一行，这行只有一个整数，即，使得标号为 边一定出现最小生成树中的最少操作次数。 Sample Input12345674 6 11 2 21 3 21 4 32 3 22 4 43 4 5 Sample Output11 HINT样例就是问题描述中的例子。1\le n\le 500, 1\le M\le 800,1\le D&lt;10^6$ 标签：最小割 Solution 除 边 外 其 他 边 权 值 边 权 值 设 边连接 ，以 为源， 为汇，断开 边，形成一个网络流图。对于此图中的任意一个割，若此割上的所有边边权均大于 边边权，则 边必在 中。于是把每条边边权变为“改变到使此边边权大于 边边权的代价”，即 ，然后跑最小割即可。 Code?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 800#define INF 0x7f7f7f7fusing namespace std;int n, m, id, s, t, tc, cnt, pr[MAX_N+5], d[MAX_N+5];struct node {int u, v, c, nxt;} E[MAX_M*10];struct edge {int u, v, c, id;} e[MAX_M+5];bool cmp(const edge &amp;a, const edge &amp;b) {return a.c &lt; b.c;}void init() {s = e[id].u, t = e[id].v, tc = e[id].c; memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() {int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;id); for (int i = 1; i &lt;= m; i++) scanf("%d%d%d", &amp;e[i].u, &amp;e[i].v, &amp;e[i].c), e[i].id = i; init(), sort(e+1, e+m+1, cmp); for (int i = 1; i &lt;= m; i++) if (e[i].id^id) { if (e[i].c &gt; tc) break; addedge(e[i].u, e[i].v, tc-e[i].c+1); addedge(e[i].v, e[i].u, tc-e[i].c+1); } printf("%d", Dinic()); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3275 Number]]></title>
    <url>%2FBZOJ3275%20Number%20%E9%BB%91%E7%99%BD%E6%9F%93%E8%89%B2%2B%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[ProblemNumber Description有 个正整数，需要从中选出一些数，使这些数的和最大。若两个数 同时满足以下条件，则 不能同时被选 存在正整数 ，使 Input第一行一个正整数 ，表示数的个数。第二行 个正整数 。 Output最大的和。 Sample Input1253 4 5 6 7 Sample Output122 HINT 。 标签：黑白染色 最小割 Solution两条性质：·奇 +奇 · 偶,偶 ∴奇与奇共存，偶与偶共存建模： 奇 ，偶 ，奇 偶 总权值 最小割 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define MAX_N 3000#define INF 2147483647using namespace std;int n, s, t, sum, cnt, a[MAX_N+5], d[MAX_N+5], pr[MAX_N+5];struct node {int u, v, c, nxt;} E[MAX_N*100];int gcd(int x, int y) {return y ? gcd(y, x%y) : x;}void init() {s = 0, t = n+1; memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() {int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}bool chk(int i, int j) {return gcd(a[i], a[j]) == 1 &amp;&amp; sqrt(a[i]*a[i]+a[j]*a[j]) == floor(sqrt(a[i]*a[i]+a[j]*a[j]));}int main() { scanf("%d", &amp;n), init(); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i), sum += a[i]; for (int i = 1; i &lt;= n; i++) if (a[i]%2) addedge(s, i, a[i]); else addedge(i, t, a[i]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i]%2 == 1 &amp;&amp; a[j]%2 == 0 &amp;&amp; chk(i, j)) addedge(i, j, INF); return printf("%d", sum-Dinic()), 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2599【IOI2011】Race]]></title>
    <url>%2FBZOJ2599%E3%80%90IOI2011%E3%80%91Race%20%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem【IOI2011】Race Description给一棵树,每条边有权.求一条简单路径,权值和等于 ,且边的数量最小. , Input第一行 两个整数 第二至 行 每行三个整数，表示一条无向边的两端和权值 (注意点的编号从 开始) Output一个整数 表示最小边数量，如果不存在这样的路径，输出 Sample Input12344 30 1 11 2 21 3 4 Sample Output12 标签：点分治 Solution 生涯的第一道 题（虽然是水题）挺有意思的一道点分治题，把模板稍加变化即可。 用 记录每种距离的路径长度的最小值，即 记录距离为 的路径的长度的最小值。对于每个点，枚举其所有子结点。当枚举到子结点 时，将 的深度加上 中子结点的深度来更新 数组。计算答案并和 打擂。注意在每个点计算答案时 值需要重新计算，但此题常数较大，最好不要memset，可以再 一次撤销。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define MAX_L 1000000using namespace std;int n, k, tot, rt, ans;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int s[MAX_N+5], h[MAX_N+5], dis[MAX_N+5], dep[MAX_N+5], mi[MAX_L+5];bool mrk[MAX_N+5];void addedge(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void getrt(int u, int fa) { s[u] = 1, h[u] = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v == fa || mrk[v]) continue; getrt(v, u); s[u] += s[v], h[u] = max(h[u], s[v]); } h[u] = max(h[u], tot-s[u]); if (h[u] &lt; h[rt]) rt = u;}void calc(int u, int fa) { if (dis[u] &lt;= k) ans = min(ans, dep[u]+mi[k-dis[u]]); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (v == fa || mrk[v]) continue; dep[v] = dep[u]+1, dis[v] = dis[u]+c, calc(v, u); }}void upd(int u, int fa) { if (dis[u] &lt;= k) mi[dis[u]] = min(mi[dis[u]], dep[u]); for (int i = 0; i &lt; (int)G[u].size(); i++) if (G[u][i] != fa &amp;&amp; !mrk[G[u][i]]) upd(G[u][i], u);}void clr(int u, int fa) { if (dis[u] &lt;= k) mi[dis[u]] = n; for (int i = 0; i &lt; (int)G[u].size(); i++) if (G[u][i] != fa &amp;&amp; !mrk[G[u][i]]) clr(G[u][i], u);}void DFS(int u) { mi[0] = 0, mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (mrk[v]) continue; dep[v] = 1, dis[v] = c, calc(v, 0), upd(v, 0); } for (int i = 0; i &lt; (int)G[u].size(); i++) if (!mrk[G[u][i]]) clr(G[u][i], 0); for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (mrk[v]) continue; rt = 0, tot = s[v], getrt(v, 0), DFS(rt); }}int main() { scanf("%d%d", &amp;n, &amp;k); for (int i = 1, u, v, c; i &lt; n; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), u++, v++, addedge(u, v, c), addedge(v, u, c); for (int i = 1; i &lt;= k; i++) mi[i] = n; ans = tot = h[0] = n, getrt(1, 0), DFS(rt); printf("%d", ans == n ? -1 : ans); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2152 聪聪可可]]></title>
    <url>%2FBZOJ2152%20%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%20%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem聪聪可可 Description聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画 个“点”，并用 条“边”把这 个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是 的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 Input输入的第 行包含 个正整数 。后面 行，每行 个整数 、 、 ，表示 号点和 号点之间有一条边，上面的数是 。 Output以即约分数形式输出这个概率（即“ ”的形式，其中 和 必须互质。如果概率为 ，输出“ ”）。 Sample Input1234551 2 11 3 21 4 12 5 3 Sample Output113/25 Hint样例说明共 组点对分别是 。数据规模对于 的数据， 。 标签：点分治 Solution经典点分治例题。对于每个点，只考虑经过它的符合条件的路径，统计后递归分治左右子树。这样我们只需要计算经过指定点长度为 的倍数的路径即可。不难发现我们只需分别统计模 余 的一段在指定点的路径条数即可。统计后，设三种余数的条数为 , , ，则答案为 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 200000using namespace std;int n, rt, tot, ans; vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int s[MAX_N+5], h[MAX_N+5], dep[MAX_N+5], cnt[3]; bool mrk[MAX_N+5];void addedge(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c%3);}int gcd(int a, int b) {return b ? gcd(b, a%b) : a;}int frac(int a, int b) {return a/gcd(a, b);}void getrt(int u, int fa) { s[u] = 1, h[u] = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v == fa || mrk[v]) continue; getrt(v, u); s[u] += s[v], h[u] = max(h[u], s[v]); } h[u] = max(h[u], tot-s[u]); if (h[u] &lt; h[rt]) rt = u;}void getdep(int u, int fa) { cnt[dep[u]]++; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (v == fa || mrk[v]) continue; dep[v] = (dep[u]+c)%3, getdep(v, u); }}int calc(int u, int init) { cnt[0] = cnt[1] = cnt[2] = 0; dep[u] = init, getdep(u, 0); return cnt[0]*cnt[0]+cnt[1]*cnt[2]*2;}void DFS(int u) { ans += calc(u, 0), mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (mrk[v]) continue; ans -= calc(v, c), rt = 0, tot = s[v], getrt(v, 0), DFS(rt); }}int main() { scanf("%d", &amp;n); for (int i = 1, u, v, c; i &lt; n; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), addedge(u, v, c), addedge(v, u, c); tot = h[0] = n, getrt(1, 0), DFS(rt); printf("%d/%d", frac(ans, n*n), frac(n*n, ans)); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4237【JOI2013】稻草人 < CDQ分治+单调栈 >]]></title>
    <url>%2FBZOJ4237%E3%80%90JOI2013%E3%80%91%E7%A8%BB%E8%8D%89%E4%BA%BA%20CDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem【JOI2013】稻草人 Description 村有一片荒地，上面竖着 个稻草人，村民们每年多次在稻草人们的周围举行祭典。有一次， 村的村长听到了稻草人们的启示，计划在荒地中开垦一片田地。和启示中的一样，田地需要满足以下条件： 田地的形状是边平行于坐标轴的长方形 左下角和右上角各有一个稻草人 田地的内部（不包括边界）没有稻草人 给出每个稻草人的坐标，请你求出有多少遵从启示的田地的个数。 Input第一行一个正整数 ，代表稻草人的个数。接下来 行，第 行 包含 个由空格分隔的整数 和 ，表示第 个稻草人的坐标。 Output输出一行一个正整数，代表遵从启示的田地的个数。 Sample Input1234540 02 23 44 3 Sample Output13 HINT所有满足要求的田地由下图所示： 互不相同。 互不相同。 标签：CDQ分治 单调栈 Solution暑假听 讲过这道题，当时用的是线段树上维护单调栈。发现 分治也可以用相同复杂度过掉此题，而且还更好写。 首先 分治降维，把两维降成一维，即把 的限制去掉。先离散化，再按 值排序，随后开始分治。对于每次分治，把区间分为两个部分 和 ，把 值在两个区间内的分开。然后逐个加入 值大于 的点，并维护单调栈，再把所有 值小于它且 值小于等于 的点加入另一个单调栈，再单调栈上二分找到分界点，统计以此点作为右上角可组成的方形个数。 Code1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define lb lower_boundusing namespace std;typedef long long lnt;int n, mp[2][MAX_N+5]; lnt ans;struct node {int x, y;} p[MAX_N+5], q[MAX_N+5], sta[2][MAX_N+5];bool cmp(const node &amp;a, const node &amp;b) {return a.x &lt; b.x;}void solve(int l, int r) { if (l == r) return; int mid = l+r&gt;&gt;1; int m0 = l, m1 = mid+1, tp0 = 0, tp1 = 0; for (int i = l; i &lt;= r; i++) if (p[i].y &lt;= mid) q[m0++] = p[i]; else q[m1++] = p[i]; memcpy(p+l, q+l, sizeof(node)*(r-l+1)); for (int p0 = l, p1 = mid+1; p1 &lt;= r; ) { while (p0 &lt;= mid &amp;&amp; p[p0].x &lt; p[p1].x) { while (tp0 &amp;&amp; sta[0][tp0].y &lt; p[p0].y) tp0--; sta[0][++tp0] = p[p0], p0++; } while (tp1 &amp;&amp; sta[1][tp1].y &gt; p[p1].y) tp1--; sta[1][++tp1] = p[p1], p1++; ans += tp0-(lb(sta[0]+1, sta[0]+tp0+1, sta[1][tp1-1], cmp)-sta[0])+1; } solve(l, mid), solve(mid+1, r);}int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;p[i].x, &amp;p[i].y), mp[0][i-1] = p[i].x, mp[1][i-1] = p[i].y; sort(mp[0], mp[0]+n), sort(mp[1], mp[1]+n); int m0 = unique(mp[0], mp[0]+n)-mp[0], m1 = unique(mp[1], mp[1]+n)-mp[1]; for (int i = 1; i &lt;= n; i++) p[i].x = lb(mp[0], mp[0]+m0, p[i].x)-mp[0]+1, p[i].y = lb(mp[1], mp[1]+m1, p[i].y)-mp[1]+1; sort(p+1, p+n+1, cmp), solve(1, n); return printf("%lld", ans), 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>CDQ分治</tag>
        <tag>单调栈</tag>
        <tag>JOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4151【AMPPZ2014】The Cave]]></title>
    <url>%2FBZOJ4151%E3%80%90AMPPZ2014%E3%80%91The%20Cave%20%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Problem【AMPPZ2014】The CaveTime Limit: Memory Limit: Description给定一棵有 个节点的树，相邻两点之间的距离为 。请找到一个点 ，使其满足所有 条限制 ，其中第 条限制为 Input第一行包含一个正整数 ( )，表示数据组数。对于每组数据，第一行包含两个正整数 ( )，表示点数、限制数。接下来 行，每行两个正整数 ( )，表示树上的一条边。接下来 行，每行三个正整数 ( , )，描述一条限制。输入数据保证所有 之和不超过 ，所有 之和也不超过 。 Output输出 行。第 行输出第 组数据的答案，如果无解输出 ，否则输出 ，然后输出 ，如有多组解，输出任意一组。 Sample Input123456789101112131425 31 22 32 43 51 4 25 5 53 2 13 21 22 31 1 23 3 1 Sample Output12TAK 2NIE 标签：树相关 Solution好题，完全没想到正解。设 号节点为根节点。对于每个限制，所求点离 这条路径的距离一定不大于某个数，在根节点确定的情况下，第 个限制可转化成所求点到根的距离最大为 以内，其中 表示该点到根节点的距离。这就可以转化成类似一堆已知某个端点的线段求某个交点的问题。于是先取限制距离最大的线段上的点，即离根节点最远的点，然后一路往上跑直到某个点刚好满足限制，对于这个点再判断一下是否满足所有情况即可，总复杂度 。可参考另一篇写得很清楚的博客：小米狐的博客 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define MAX_N 300000using namespace std;int n, m, a[MAX_N+5], b[MAX_N+5], d[MAX_N+5], pa[MAX_N+5], dep[MAX_N+5];vector &lt;int&gt; G[MAX_N+5];void DFS(int u, int fa) { for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v == fa) continue; pa[v] = u, dep[v] = dep[u]+1, DFS(v, u); }}int main() { int T; scanf("%d", &amp;T); while (T--) { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) G[i].clear(); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); dep[1] = 0, DFS(1, 0); int p = 1, mx = 0; for (int i = 1; i &lt;= m; i++) { scanf("%d%d%d", a+i, b+i, d+i); if ((dep[a[i]]+dep[b[i]]-d[i]+1)/2 &gt; mx) p = a[i], mx = (dep[a[i]]+dep[b[i]]-d[i]+1)/2; } for (; dep[p] &gt; mx; p = pa[p]) ; dep[p] = 0, DFS(p, 0); bool flag = true; for (int i = 1; i &lt;= m; i++) if (dep[a[i]]+dep[b[i]] &gt; d[i]) {flag = false; break;} if (flag) printf("TAK %d\n", p); else puts("NIE"); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树相关</tag>
        <tag>AMPPZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1999【NOIp2007】Core树网的核]]></title>
    <url>%2FBZOJ1999%E3%80%90NOIp2007%E3%80%91Core%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8%20%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Problem【NOIp2007】Core树网的核Time Limit: Memory Limit: Description设 是一个无圈且连通的无向图（也称为无根树），每条边带有正整数的权，我们称 为树网（ ），其中 分别表示结点与边的集合， 表示各边长度的集合，并设 有 个结点。 路径：树网中任何两结点 都存在唯一的一条简单路径，用 表示以 为端点的路径的长度，它是该路径上各边长度之和。我们称 为 两结点间的距离。 一点 到一条路径 的距离为该点与 上的最近的结点的距离： ， 在 上 ， 。 树网的直径：树网中最长的路径称为树网的直径。对于给定的树网 ，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。 偏心距 ：树网 中距路径 最远的结点到路径 的距离，即 。 任务：对于给定的树网 和非负整数 ，求一个路径 ，它是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 （可以等于 ），使偏心距 最小。我们称这个路径为树网 的核（ ）。必要时， 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。 下面的图给出了树网的一个实例。图中， 与 是两条直径，长度均为 。点 是树网的中心， 边的长度为 。如果指定 ，则树网的核为路径 （也可以取为路径 ），偏心距为 。如果指定 （或 、 ），则树网的核为结点 ，偏心距为 。 Input包含 行： 第 行，两个正整数 和 ，中间用一个空格隔开。其中 为树网结点的个数， 为树网的核的长度的上界。设结点编号依次为 。 从第 行到第 行，每行给出 个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，“ ”表示连接结点 与 的边的长度为 。 所给的数据都是正确的，不必检验。 Output只有一个非负整数，为指定意义下的最小偏心距。 Sample Input123455 21 2 52 3 22 4 42 5 3 Sample Output15 HINT对于 的数据， 对于 的数据， , , 所 有 权 值 似乎 上加强版的数据… 标签：树相关 Solution 上加强了数据。原题跑 再枚举可过。首先肯定需要两次 求直径，求法略。显然，在长度不超过 的前提下，链越长越好（这样偏心距小）。在直径两端 到 上维护尽可能长的链，找到左右端点到直径做右端点的较大值的最小值。然后由链上各个点出发，找到不经过直径上的点抵达的其他点的最大深度。这个最大深度和之前的最小值中较大的就是答案。 Code12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 500000#define INF 0x3f3f3f3fusing namespace std;int n, s, l, r;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int d[MAX_N+5], f[MAX_N+5]; bool mrk[MAX_N+5];void add(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void init() {scanf("%d%d", &amp;n, &amp;s); for (int i = 1, u, v, c; i &lt; n; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), add(u, v, c), add(v, u, c);}void DFS(int u) { for (int i = 0; i &lt; (int)G[u].size(); i++) if (G[u][i]^f[u] &amp;&amp; !mrk[G[u][i]]) d[G[u][i]] = d[u]+E[u][i], f[G[u][i]] = u, DFS(G[u][i]);}void getD() { f[1] = d[1] = 0, DFS(1); for (int i = 1; i &lt;= n; i++) if (!r || d[i] &gt; d[r]) r = i; f[r] = d[r] = 0, DFS(r); for (int i = 1; i &lt;= n; i++) if (!l || d[i] &gt; d[l]) l = i; for (int i = l; i; i = f[i]) mrk[i] = true;}void sol() { int ans = INF; for (int i = l, j = l; i; i = f[i]) { while (f[j] &amp;&amp; d[i]-d[f[j]] &lt;= s) j = f[j]; ans = min(ans, max(d[l]-d[i], d[j])); } for (int i = l; i; i = f[i]) d[i] = 0, DFS(i); for (int i = 1; i &lt;= n; i++) ans = max(ans, d[i]); printf("%d", ans);}int main() {init(), getD(), sol(); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树相关</tag>
        <tag>NOIp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4145【AMPPZ2014】The Prices]]></title>
    <url>%2FBZOJ4145%E3%80%90AMPPZ2014%E3%80%91The%20Prices%20%E7%8A%B6%E5%8E%8BDP%2F</url>
    <content type="text"><![CDATA[Problem【AMPPZ2014】The PricesTime Limit: Memory Limit: Description你要购买 种物品各一件，一共有 家商店，你到第 家商店的路费为 ，在第 家商店购买第 种物品的费用为 ，求最小总费用。 Input第一行包含两个正整数 ( , )，表示商店数和物品数。接下来 行，每行第一个正整数 ( )表示到第 家商店的路费，接下来 个正整数，依次表示 ( )。 Output一个正整数，即最小总费用。 Sample Input12343 45 7 3 7 92 1 20 3 28 1 20 1 1 Sample Output116 HINT在第一家店买 号物品，在第二家店买剩下的物品。 标签：状压DP Solution ，显然是一道状压 。用 表示考虑 家商店，购买状态为 的方案数。套路状压转移即可。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;#define MAX_N 100#define MAX_M 16using namespace std;typedef long long lnt;int n, m, d[MAX_N+5], c[MAX_N+5][MAX_M+5], f[MAX_N+5][(1&lt;&lt;MAX_M)+5];int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) {scanf("%d", d+i); for (int j = 1; j &lt;= m; j++) scanf("%d", c[i]+j);} memset(f, 0x3f, sizeof f); f[0][0] = 0; for (int i = 1; i &lt;= n; i++) { for (int j = 0; j &lt; (1&lt;&lt;m); j++) f[i][j] = f[i-1][j]+d[i]; for (int k = 1; k &lt;= m; k++) for (int j = 0; j &lt; (1&lt;&lt;m); j++) if ((j&amp;(1&lt;&lt;k-1)) == 0) f[i][j|(1&lt;&lt;k-1)] = min(f[i][j]+c[i][k], f[i][j|(1&lt;&lt;k-1)]); for (int j = 0; j &lt; (1&lt;&lt;m); j++) f[i][j] = min(f[i][j], f[i-1][j]); } printf("%d", f[n][(1&lt;&lt;m)-1]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>AMPPZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1468 Tree]]></title>
    <url>%2FBZOJ1468%20Tree%20%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[ProblemTree Description给你一棵树以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于 Input （ ） 接下来 行边描述管道，按照题目中写的输入 接下来是 Output一行，有多少对点之间的距离小于等于 Sample Input1234567871 6 13 6 3 9 3 5 7 4 1 3 2 4 20 4 7 2 10 Sample Output15 标签：点分治 Solution点分治板题。对于每个点，我们计算穿过它的路径的条数。这个值等于它的子树中所有深度之和小于 的点对数，可以双指针搞一搞。但这样两个在同一儿子内的点对会算重，所以需要减去它的每个儿子的子树中深度之和小于 的点对数，其中 为它到此儿子的距离。这也可以双指针搞一搞。对于每次分治，我们都要找到当前子树的重心，以保证复杂度为 。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define MAX_N 40000using namespace std;int n, k, rt, s[MAX_N+5], h[MAX_N+5], d[MAX_N+5], tot, ans;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5], dep; bool mrk[MAX_N+5];void addedge(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void getrt(int u, int fa) { s[u] = 1, h[u] = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; if (v == fa || mrk[v]) continue; getrt(v, u), s[u] += s[v], h[u] = max(h[u], s[v]); } h[u] = max(h[u], tot-s[u]); if (h[u] &lt; h[rt]) rt = u;}void getdep(int u, int fa) { dep.push_back(d[u]), s[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (v == fa || mrk[v]) continue; d[v] = d[u]+c, getdep(v, u), s[u] += s[v]; }}int calc(int u, int init) { dep.clear(), d[u] = init, getdep(u, 0), sort(dep.begin(), dep.end()); int ret = 0; for (int l = 0, r = (int)dep.size()-1; l &lt; r; ) dep[l]+dep[r] &lt;= k ? ret += r-l++ : r--; return ret;}void DFS(int u) { ans += calc(u, 0), mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (mrk[v]) continue; ans -= calc(v, c), h[0] = tot = s[v], getrt(v, rt = 0), DFS(rt); }}int main() { scanf("%d", &amp;n); for (int i = 1, u, v, c; i &lt; n; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), addedge(u, v, c), addedge(v, u, c); scanf("%d", &amp;k); h[0] = tot = n, getrt(1, 0); DFS(rt); printf("%d", ans); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4144【AMPPZ2014】Petrol < 最短路+MST >]]></title>
    <url>%2FBZOJ4144%E3%80%90AMPPZ2014%E3%80%91Petrol%20MST%2F</url>
    <content type="text"><![CDATA[Problem【AMPPZ2014】Petrol Description给定一个 个点、 条边的带权无向图，其中有 个点是加油站。每辆车都有一个油量上限 ，即每次行走距离不能超过 ，但在加油站可以补满。 次询问，每次给出 ，表示出发点是 ，终点是 ，油量上限为 ，且保证 点和 点都是加油站，请回答能否从 走到 。 Input第一行包含三个正整数 ( , )，表示点数、加油站数和边数。第二行包含 个互不相同的正整数 ，表示每个加油站。接下来 行，每行三个正整数 , , ( , , )，表示 和 之间有一条长度为 的双向边。接下来一行包含一个正整数 ( )，表示询问数。接下来 行，每行包含三个正整数 ( , , )，表示一个询问。 Output输出 行。第 行输出第 个询问的答案，如果可行，则输出 ，否则输出 。 Sample Input1234567891011126 4 51 5 2 61 3 12 3 23 4 34 5 56 4 541 2 42 6 91 5 96 5 8 Sample Output1234TAKTAKTAKNIE 标签：最短路 MST Solution一道精妙的 题。首先考虑走到一个点，先去离它最近的加油站，回来后再去下一个点肯定比直接去要优。于是用多源最短路预处理出每个点到它最近的加油站的距离，随后给每一条边分别加上它的起点和终点离它们最近加油站的距离。对于询问，先离线下来按 值排序，按照边权加入边，用并查集维护。对于每个询问，先将比它的 值小的所有边都加入，再询问起点和终点是否联通即可。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define fir first#define sec second#define mp make_pair#define pii pair&lt;int,int&gt;#define MAX_N 200000using namespace std;int n, m, s, c[MAX_N+5], fa[MAX_N+5], dis[MAX_N+5]; vector &lt;pii&gt; G[MAX_N+5];struct edge {int u, v, c; bool operator &lt; (const edge &amp;t) const {return c &lt; t.c;}} E[MAX_N+5];struct query {int id, u, v, c; bool operator &lt; (const query &amp;t) const {return c &lt; t.c;}} Q[MAX_N+5];int getf(int x) {return fa[x] == x ? x : fa[x] = getf(fa[x]);}void Dijkstra() { priority_queue &lt;pii&gt; que; bool mrk[MAX_N+5]; memset(dis, 0x7f, sizeof dis), memset(mrk, false, sizeof mrk); for (int i = 1; i &lt;= s; i++) dis[c[i]] = 0, que.push(mp(-dis[c[i]], c[i])); while (!que.empty()) { int u = que.top().sec; que.pop(); if (mrk[u]) continue; mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i].fir, w = G[u][i].sec; if (dis[u]+w &lt; dis[v]) dis[v] = dis[u]+w, que.push(mp(-dis[v], v)); } }}int main() { scanf("%d%d%d", &amp;n, &amp;s, &amp;m); for (int i = 1; i &lt;= s; i++) scanf("%d", c+i); for (int i = 1; i &lt;= m; i++) scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].c), G[E[i].u].push_back(mp(E[i].v, E[i].c)), G[E[i].v].push_back(mp(E[i].u, E[i].c)); Dijkstra(); for (int i = 1; i &lt;= m; i++) E[i].c += dis[E[i].u]+dis[E[i].v]; int q; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) Q[i].id = i, scanf("%d%d%d", &amp;Q[i].u, &amp;Q[i].v, &amp;Q[i].c); sort(E+1, E+m+1), sort(Q+1, Q+q+1); for (int i = 1; i &lt;= n; i++) fa[i] = i; bool ans[MAX_N+5]; for (int i = 1, j = 1; i &lt;= q; i++) { for (int u, v; j &lt;= m &amp;&amp; E[j].c &lt;= Q[i].c; j++) if ((u = getf(E[j].u)) != (v = getf(E[j].v))) fa[u] = v; ans[Q[i].id] = getf(Q[i].u) == getf(Q[i].v); } for (int i = 1; i &lt;= q; i++) puts(ans[i] ? "TAK" : "NIE"); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>最短路</tag>
        <tag>AMPPZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3632 外太空旅行]]></title>
    <url>%2FBZOJ3632%20%E5%A4%96%E5%A4%AA%E7%A9%BA%E6%97%85%E8%A1%8C%20%E9%9A%8F%E6%9C%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem外太空旅行Time Limit: Memory Limit: Description在人类的触角伸向银河系的边缘之际，普通人上太空旅行已经变得稀松平常了。某理科试验班有 个人，现在班主任要从中选出尽量多的人去参加一次太空旅行活动。可是 名同学并不是和平相处的。有的人，比如小 和小 整天狼狈为奸，是好朋友；但还有的人，比如杜鲁门和赫鲁晓夫就水火不相容。这 名同学，由于是理科生，都非常的理性，所以“朋友的朋友就是朋友”和“敌人的朋友就是敌人”这两句话对这些同学无效。换句话说，有可能小 和小 是朋友，小 和小 是朋友，但是小 和小 两人势如水火。任意两个人之间要不就是敌人，要不就是朋友。因为在太空船上发生人员斗殴事件是很恶劣也很危险的，因此选出来参加旅行活动的同学必须互相之间都是朋友。你的任务就是确定最多可以选多少人参加旅行。 Input第一行一个整数 ( )。所有的同学按照 编号。接下来若干行，每行两个用空格隔开的整数 ( )，表示 和 是朋友。注意：如果一个数对 或者 没有在文件中出现，那么编号为 和 的两个同学就是敌人。 Output仅仅一个数，即最多可以选多少人参加活动。 Sample Input1234541 22 33 11 4 Sample Output13 说明：选编号为 的同学参加，他们互相都是朋友。 标签：最大团 随机化 Solution一道随机化最大团的裸题。每次随机出一个 的乱序排列，按照排列顺序贪心，这样随机 次取最大值即可。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define MAX_N 50#define BOUND 100000using namespace std;int n, seq[MAX_N+5], ans;bool G[MAX_N+5][MAX_N+5], mrk[MAX_N+5];int calc() { memset(mrk, false, sizeof mrk); int ret = 0; for (int i = 1; i &lt;= n; i++) if (!mrk[seq[i]]) { ret++, mrk[seq[i]] = true; for (int j = i+1; j &lt;= n; j++) if (!G[seq[i]][seq[j]]) mrk[seq[j]] = true; } return ret;}int main() { scanf("%d", &amp;n); int u, v; while (~scanf("%d%d", &amp;u, &amp;v)) G[u][v] = G[v][u] = true; for (int i = 1; i &lt;= n; i++) seq[i] = i; for (int i = 0; i &lt; BOUND; i++) random_shuffle(seq+1, seq+n+1), ans = max(ans, calc()); printf("%d", ans); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>随机化</tag>
        <tag>最大团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4148【AMPPZ2014】Pillars]]></title>
    <url>%2FBZOJ4148%E3%80%90AMPPZ2014%E3%80%91Pillars%20%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[Problem【AMPPZ2014】PillarsTime Limit: Memory Limit: Description给定一个 的矩形，其中有f个 的障碍物，其中任意两个障碍物中心之间的欧几里得距离至少为 ，且每个障碍物的中心到边缘的距离至少为 。请找到一条从左下角 出发经过所有没有障碍物的点各一次的且最后回到左下角的回路。 Input第一行包含三个整数 ( 且 都为偶数)。接下来 行，每行两个整数 ( , )，表示该障碍物左下角的坐标。 Output如果无解，输出 ，否则第一行输出 ，第二行输出方案。方案包含 个字符，第 个字符表示第 步的移动方向，用 表示上， 表示下， 表示左， 表示右。 Sample Input12312 6 23 39 3 Sample Output12TAKPPPPPPPPPPPGGGLDDLLLLLGPPGLLLDDLLLGGGPPPPPPPPPPGLLLLLLLLLLLDDDDD Hint 标签：构造 Solution一道很适合构造入门的题。我看了 的题解才想出来。首先不考虑障碍，构造出一个走过全部格子的走法。由于 和 均为偶数，一定有解。然后考虑障碍，对障碍四周的格子的方向进行修改。由于两个障碍间距离至少为 ，故任两个障碍不会影响，只会有两大类。具体构造方法参见代码。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define MAX_N 1000using namespace std;int n, m, f; char s[MAX_N+5][MAX_N+5];int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;f); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) s[i][j] = i&amp;1 ? 'D' : 'G'; for (int i = 1; i &lt;= n; i++) { if (i^n) s[i][1] = 'P'; if ((i^1) &amp;&amp; (i&amp;1)) s[i][2] = 'L'; if (!(i&amp;1)) s[i][m] = 'L'; } for (int i = 0; i &lt; f; i++) { int x, y; scanf("%d%d", &amp;x, &amp;y); if (x&amp;1) s[x][y+2] = 'P', s[x+1][y-1] = 'L', s[x+1][y+2] = 'P', s[x+2][y+3] = 'L'; else if (y^3) s[x][y-1] = 'P', s[x+1][y-1] = 'P', s[x+1][y+2] = 'L', s[x+2][y-2] = 'L'; else s[x][1] = 'G', s[x][2] = 'P', s[x+1][2] = 'D', s[x+1][5] = 'L'; } puts("TAK"); for (int x = 1, y = 1, lft = n*m-4*f; lft; lft--) { putchar(s[x][y]); if (s[x][y] == 'P') x++; else if (s[x][y] == 'L') x--; else if (s[x][y] == 'G') y++; else y--; } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>AMPPZ</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2396 神奇的矩阵]]></title>
    <url>%2FBZOJ2396%20%E7%A5%9E%E5%A5%87%E7%9A%84%E7%9F%A9%E9%98%B5%20%E9%9A%8F%E6%9C%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem神奇的矩阵Time Limit: Memory Limit: Description给出三个行数和列数均为 的矩阵 、 、 ，判断 是否成立。 Input题目可能包含若干组数据。对于每组数据，第一行一个数 ，接下来给出三个 的矩阵，依次为 、 、 三个矩阵。 Output对于每组数据，若 成立，则输出 ，否则 。每个答案占一行。 Sample Input1234122100 Sample Output1No HINT对于 的数据， 不超过 ；对于 的数据， 不超过 ，矩阵中的数字大于等于 小于 ，数据组数不超过 组。 标签：矩阵乘法 随机化 Solution挺巧妙的一道随机化题。首先考虑直接乘，由于 ，而矩乘是 ，肯定会 。我们发现矩阵太大了，那么我们就要压缩矩阵，把这样一个正方形的矩阵压缩为一个行矩阵或列矩阵。我们先随机出一个 的列矩阵 ，这样 ，将结果与 比较。这样乘法的复杂度就降为 ，比较复杂度为 ，总复杂度为 。如果觉得随机一次不保险，还可以多随机几次，不过只随一次也很容易过。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MOD 1000000007using namespace std;int n;struct Matrix { int r, c; long long ele[MAX_N][MAX_N]; inline Matrix operator * (const Matrix &amp;x) const { Matrix ret; memset(ret.ele, 0, sizeof(ret.ele)); for (int i = 0; i &lt; (ret.r = r); i++) for (int j = 0; j &lt; (ret.c = x.c); j++) for (int k = 0; k &lt; c; k++) ret.ele[i][j] = (ret.ele[i][j]+ele[i][k]*x.ele[k][j])%MOD; return ret; }} A, B, C, R;int main() { while (scanf("%d", &amp;n)) { A.r = A.c = n; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%lld", &amp;A.ele[i][j]); B.r = B.c = n; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%lld", &amp;B.ele[i][j]); C.r = C.c = n; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%lld", &amp;C.ele[i][j]); srand(19260817); R.r = n, R.c = 1; for (int i = 0; i &lt; n; i++) R.ele[i][0] = rand()*rand()%MOD; A = A*(B*R), C = C*R; bool flag = true; for (int i = 0; i &lt; n; i++) flag &amp;= (A.ele[i][0] == C.ele[i][0]); puts(flag ? "Yes" : "No"); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4152【AMPPZ2014】The Captain]]></title>
    <url>%2FBZOJ4152%E3%80%90AMPPZ2014%E3%80%91The%20Captain%20%E6%9C%80%E7%9F%AD%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Problem【AMPPZ2014】The Captain Description给定平面上的 个点，定义 到 的费用为 ，求从 号点走到 号点的最小费用。 Input第一行包含一个正整数 ( )，表示点数。接下来 行，每行包含两个整数 , ( )，依次表示每个点的坐标。 Output一个整数，即最小费用。 Sample Input12345652 21 14 57 16 7 Sample Output12 标签：最短路 Solution一道比较基础的最短路变形。不难发现，在一个凸壳上，如果走任意一条弦，显然没有直接沿着凸壳走优。所以分别按 和 排两次序，相邻点连边，可得到一个图。在此图上跑最短路即可。注意，此题卡 （大佬：不错啊，卡错误算法天经地义~） Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define fir first#define sec second#define mp make_pair#define pli pair&lt;lnt,int&gt;using namespace std;typedef long long lnt;int n; lnt dis[MAX_N+5];vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];struct node {int id, x, y;} p[MAX_N+5];bool cmpx(const node &amp;a, const node &amp;b) {return a.x &lt; b.x;}bool cmpy(const node &amp;a, const node &amp;b) {return a.y &lt; b.y;}void addedgex(int u, int v, int a, int b) {G[u].push_back(v), E[u].push_back(p[b].x-p[a].x);}void addedgey(int u, int v, int a, int b) {G[u].push_back(v), E[u].push_back(p[b].y-p[a].y);}void Dijkstra() { memset(dis, 0x7f, sizeof dis), dis[1] = 0; priority_queue &lt;pli&gt; que; que.push(mp(0LL, 1)); bool mrk[MAX_N+5]; memset(mrk, false, sizeof mrk); while (!que.empty()) { int u = que.top().sec; que.pop(); if (mrk[u]) continue; mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i]; lnt c = E[u][i]; if (mrk[v] || dis[u]+c &gt; dis[v]) continue; dis[v] = dis[u]+c, que.push(mp(-dis[v], v)); } }}int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) p[i].id = i, scanf("%d%d", &amp;p[i].x, &amp;p[i].y); sort(p+1, p+n+1, cmpx); for (int i = 1; i &lt; n; i++) addedgex(p[i].id, p[i+1].id, i, i+1), addedgex(p[i+1].id, p[i].id, i, i+1); sort(p+1, p+n+1, cmpy); for (int i = 1; i &lt; n; i++) addedgey(p[i].id, p[i+1].id, i, i+1), addedgey(p[i+1].id, p[i].id, i, i+1); Dijkstra(); printf("%lld", dis[n]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>AMPPZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2017总结]]></title>
    <url>%2FNOIp2017%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[NOIp2017滚粗记 Day 0周五上午，想到下午就要去考场了，就不刷题了吧。毕竟前一周我已把历年 真题刷完了（个别太早的题没做）。于是就打了打板。当时觉得没什么可复习的了，于是就只打了树剖、线筛和 的板。接着颓了一会儿纸牌和扫雷。 此时正在写一道点双连通分量的题解，突然意识到我几种无向图连通分量（割点和桥）还没复习。赶快去看了看博客。一个上午就没了。下午到考场。吃饭前简略看了看树分治。晚上开会的时候又想到欧拉图还没复习，好多年没考过了，赶快看看，免得真考到了。 Day 1刚上场就被 搞得一脸懵逼。蛤？数论题放 ？或者说结论题？推了半小时 ，果断弃坑。由于先前没读 （ 题面太长太烦不想读），气氛挺紧张。还好这时我先看了 而没跳到 ，读完 发现好简单，索性栈模拟。码到一半发现貌似栈上东西挺多，突然意识到可以递归模拟，肯定好写得多。不过没管，都码了 了，索性码完。水完 倒回来看 ，打了一个 的表，把不互质的情况去掉，发现规律很显然，不就是 吗？赶快水掉。 看到后觉得难度不算太大。发现可以 最 短 路 预 处 理 做。这时还没想到拆点，只想到一个带 大常数的容斥。考场上思维没那么开阔，打了容斥 ，调了半小时才过样例。大样例貌似 了，跑了 秒看没出结果我就没管了。回去看 ，总觉得 会出锅，多出了几组自测小数据，好像没锅。（？）考完后发现 的容斥有些问题，遇到正环会死循环（因为我采用的是类似 的 顺序，而容斥的时候没及时清零）。成绩出来后才发现 只有 分。崩溃地发现把字符串转数字码错了… 12for (int i = 0; i &lt; strlen(s); i++) ret = ret*10+s[i]-'0'; //正确代码for (int i = 0; i &lt; strlen(s); i++) ret = ret*10+i-'0'; //我考试时写的，脑抽无极限... 最后只好 滚粗 Day 2拿到题目，担心 简单 会很难，结果看到 就打消了顾虑。 是难得的大水题啊，直接并查集水过。 看到数据范围 就想到了状压 ，但想得不够深，始终在想如何存存下一棵子树的形态。后来又想到了哈夫曼树的贪心，没注意到此题的顺序和贪心顺序是反的，打了一个错误的贪心，花了一个半小时，还自己把自己卡死了。水了 的树 部分分。 显然是数据结构题，看到就有种 的感觉。但是我 板都打不熟，而 又是省选内容，再加上时间不太够，就没打 。先水了 分的裸暴力，又用 二 分 写了 分的 的情况…结果二分的时候更新打错了。最后 滚粗 Conclusion两天合起来是 分。尴尬而耻辱的分数段，毕竟我当场估分时 ，因为三道题打错而挂了 分。其实也是自己的锅。十连测阶段我光顾着改题，代码能力有所下滑。这在冬令营之前一定要补起来，虽然我今年大概是进不了冬令营的了。此耻明年必报。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LG1155【NOIp2008】双栈排序]]></title>
    <url>%2FLG1155%E3%80%90NOIp2008%E3%80%91%E5%8F%8C%E6%A0%88%E6%8E%92%E5%BA%8F%20%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Problem【NOIp2008】双栈排序题目描述 最近在研究一个有趣的排序问题。如图所示，通过 个栈 和 ， 希望借助以下 种操作实现将输入序列升序排序。操作 : 如果输入序列不为空，将第一个元素压入栈 操作 : 如果栈 不为空，将 栈顶元素弹出至输出序列操作 : 如果输入序列不为空，将第一个元素压入栈 操作 : 如果栈 不为空，将 栈顶元素弹出至输出序列如果一个 的排列 可以通过一系列操作使得输出序列为 ， 就称 是一个“可双栈排序排列”。例如 就是一个“可双栈排序序列”，而 不是。下图描述了一个将 排序的操作序列： 当然，这样的操作序列有可能有几个，对于上例 ， 是另外一个可行的操作序列。 希望知道其中字典序最小的操作序列是什么。 输入输出格式输入格式：输入文件 的第一行是一个整数 。第二行有 个用空格隔开的正整数，构成一个 的排列。输出格式：输出文件 共一行，如果输入的排列不是“可双栈排序排列”，输出数字 ；否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。 输入输出样例输入样例#11241 3 2 4 输出样例#11a b a a b b a b 输入样例#21242 3 4 1 输出样例#210 输入样例#31232 3 1 输出样例#31a c a b b d 说明 的数据满足： 的数据满足： 的数据满足： 标签：二分图染色 Solution一道很有意思的联赛题。对于任意两数 ，若有 ，为了使 最先出栈，那么 和 一定在 之后出栈，若顺次放进同一个栈，那么 必然在 之前出栈，不满足题意。因此遇到这种情况 和 一定分别放入两个栈中。据此，只要存在 ，有 ，那么 和 一定在不同栈中。这样就构成了一个二分图。扫描一遍，确定那些数对不能在同一栈中，确定互斥关系。若不能构成二分图，那么就不可排序。否则在判断过程中染色，确定不同数在哪个栈中，模拟排序过程，每次等到当前排到的数进栈后把能出栈的都出栈。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define MAX_N 1000using namespace std;vector &lt;int&gt; G[MAX_N+5];int n, a[MAX_N+5], mi[MAX_N+5], col[MAX_N+5];void DFS(int u) { for (auto v : G[u]) { if (!col[v]) col[v] = -col[u], DFS(v); if (col[u] == col[v]) {puts("0"); exit(0);} }}void prt() { int cur = 1; stack &lt;int&gt; sa, sb; for (int i = 1; i &lt;= n; i++) { if (col[i] == 1) putchar('a'), putchar(' '), sa.push(a[i]); else putchar('c'), putchar(' '), sb.push(a[i]); for (; !sa.empty() &amp;&amp; sa.top() == cur; sa.pop(), cur++) putchar('b'), putchar(' '); for (; !sb.empty() &amp;&amp; sb.top() == cur; sb.pop(), cur++) putchar('d'), putchar(' '); for (; !sa.empty() &amp;&amp; sa.top() == cur; sa.pop(), cur++) putchar('b'), putchar(' '); }}int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); mi[n+1] = 0x3f3f3f3f; for (int i = n; i; i--) mi[i] = min(a[i], mi[i+1]); for (int i = 1; i &lt;= n; i++) for (int j = i+1; j &lt;= n; j++) if (a[i] &lt; a[j] &amp;&amp; mi[j+1] &lt; a[i]) G[i].push_back(j), G[j].push_back(i); for (int i = 1; i &lt;= n; i++) if (!col[i]) col[i] = 1, DFS(i); prt(); return 0;}]]></content>
      <tags>
        <tag>图论</tag>
        <tag>NOIp</tag>
        <tag>二分图</tag>
        <tag>LG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LG1967【NOIp2013】货车运输 < MST+LCA >]]></title>
    <url>%2FLG1967%E3%80%90NOIp2013%E3%80%91%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%20LCA%2F</url>
    <content type="text"><![CDATA[Problem货车运输题目描述 国有 座城市，编号从 到 ，城市之间有 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入输出格式输入格式：输入文件名为 。输入文件第一行有两个用一个空格隔开的整数 , ，表示 国有 座城市和 条道路。 接下来 行每行 个整数 、 、 ，每两个整数之间用一个空格隔开，表示从 号城市到 号城市有一条限重为 的道路。注意： 不等于 ，两座城市之间可能有多条道路 。接下来一行有一个整数 ，表示有 辆货车需要运货。接下来 行，每行两个整数 、 ，之间用一个空格隔开，表示一辆货车需要从 城市运输货物到 城市，注意： 不等于 。输出格式：输出文件名为 。输出共有 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出 。 输入输出样例输入样例：123456784 31 2 42 3 33 1 131 31 41 3 输出样例：1233-13 说明对于 的数据， ， ， ；对于 的数据， ， ， ；对于 的数据， ， ， ， 。 标签：MST LCA Solution 经典例题。为了使得货车走过的路径上最小权最大，又要使其能到任意两点，那么该图可以缩减成一棵树，为了保证最优解，该树采用原图的最大生成树。对于一次询问，在最大生成树上跑两点的 ，倍增统计路径最小值即可。不错的板题 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAX_N 10000#define MAX_M 50000#define INF 2147483647using namespace std;int n, m, q, cnt;int first[MAX_N+5], d[MAX_N+5], p[MAX_N+5][15], f[MAX_N+5][15];int father[MAX_N+5];bool vis[MAX_N+5];struct Edge { int from, to, c, next;};Edge G[MAX_M], edge[MAX_M+5];inline int read() { int ret = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret*10+ch-'0', ch = getchar(); return ret;}bool cmp (const Edge &amp;a, const Edge &amp;b) { return a.c &gt; b.c;}void Add(int u, int v, int x) { cnt++; edge[cnt].to = v; edge[cnt].c = x; edge[cnt].next = first[u]; first[u] = cnt;}int get_father(int cur) { if (father[cur] != cur) father[cur] = get_father(father[cur]); return father[cur];}void Kruskal() { sort(G, G+m, cmp); for (int i = 1; i &lt;= n; i++) father[i] = i; for (int i = 0; i &lt; m; i++) { int u = get_father(G[i].from), v = get_father(G[i].to); if (u != v) { father[u] = v; Add(G[i].from, G[i].to, G[i].c); Add(G[i].to, G[i].from, G[i].c); } }}void DFS(int u) { vis[u] = true; for (int i = 1; (1&lt;&lt;i) &lt;= d[u]; i++) { p[u][i] = p[p[u][i-1]][i-1]; f[u][i] = min(f[u][i-1], f[p[u][i-1]][i-1]); } for (int i = first[u]; i; i = edge[i].next) { int v = edge[i].to; if (!vis[v]) { d[v] = d[u]+1; p[v][0] = u; f[v][0] = edge[i].c; DFS(v); } }}int LCA(int a, int b) { int ret = INF, i, j; if (d[a] &lt; d[b]) swap(a, b); for (i = 0; (1&lt;&lt;i) &lt;= d[a]; i++) {} i--; for (j = i; j &gt;= 0; j--) { if (d[a]-(1&lt;&lt;j) &gt;= d[b]) { ret = min(ret, f[a][j]); a = p[a][j]; } } if (a == b) return ret; for (j = i; j &gt;= 0; j--) { if (p[a][j] != p[b][j]) { ret = min(ret, min(f[a][j], f[b][j])); a = p[a][j]; b = p[b][j]; } } return min(ret, min(f[a][0], f[b][0]));}int main() { memset(f, 127, sizeof(f)); n = read(), m = read(); for (int i = 0; i &lt; m; i++) { G[i].from = read(), G[i].to = read(), G[i].c = read(); } Kruskal(); for (int i = 1; i &lt;= n; i++) { if (!vis[i] &amp;&amp; father[i] == i) { DFS(i); } } q = read(); for (int i = 0; i &lt; q; i++) { int a, b; a = read(), b = read(); if (get_father(a) != get_father(b)) { printf("-1\n"); } else { printf("%d\n", LCA(a, b)); } } return 0;}]]></content>
      <tags>
        <tag>图论</tag>
        <tag>LCA</tag>
        <tag>MST</tag>
        <tag>NOIp</tag>
        <tag>LG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4565【HAOI2016】字符合并]]></title>
    <url>%2FBZOJ4565%E3%80%90HAOI2016%E3%80%91%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6%20%E7%8A%B6%E5%8E%8BDP%2F</url>
    <content type="text"><![CDATA[Problem【HAOI2016】字符合并Time Limit: Memory Limit: Description有一个长度为 的 串，你可以每次将相邻的 个字符合并，得到一个新的字符并获得一定分数。得到的新字符和分数由这 个字符确定。你需要求出你能获得的最大分数。 Input第一行两个整数 ， 。接下来一行长度为 的 串，表示初始串。接下来 行，每行一个字符 和一个整数 ， 表示长度为 的 串连成二进制后按从小到大顺序得到的第 种合并方案得到的新字符， 表示对应的第 种方案对应获得的分数。 , , , Output输出一个整数表示答案 Sample Input1234563 21011 101 100 201 30 Sample Output140 标签：状压DP Solution这显然是一道状压 （ ）考虑用 表示将字符序列 表示为状态 的最大分数。初始状态为 ( )转移则将 斩成两半 和 ， ， 。特别需要注意的是，当 时（ 为题目中的 ），会刚好变为一个字符，因此不能像上面那样递推，应为 ( 且 可为 )， ( 且 可为 )。 Code12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_K 8#define MAX_N 300using namespace std;typedef long long lnt;char str[MAX_N+5];int n, m, s[MAX_N+5], c[1&lt;&lt;MAX_K];lnt w[1&lt;&lt;MAX_K], f[MAX_N+5][MAX_N+5][1&lt;&lt;MAX_K];void upd(lnt &amp;a, lnt b) {if (a &lt; b) a = b;}int main() { scanf("%d%d%s", &amp;n, &amp;m, str), memset(f, -1, sizeof(f)); for (int i = 0; i &lt; (1&lt;&lt;m); i++) scanf("%d%lld", c+i, w+i); for (int i = 1; i &lt;= n; i++) s[i] = str[i-1]-'0', f[i][i][s[i]] = 0; for (int l = 2; l &lt;= n; l++) for (int s = 1, t = s+l-1; t &lt;= n; t = ++s+l-1) { int tar = l-1; while (tar &gt;= m) tar -= m-1; for (int mid = t-1; mid &gt;= s; mid -= m-1) for (int sta = 0; sta &lt; (1&lt;&lt;tar); sta++) { if (~f[s][mid][sta] &amp;&amp; ~f[mid+1][t][0]) upd(f[s][t][sta&lt;&lt;1], f[s][mid][sta]+f[mid+1][t][0]); if (~f[s][mid][sta] &amp;&amp; ~f[mid+1][t][1]) upd(f[s][t][sta&lt;&lt;1|1], f[s][mid][sta]+f[mid+1][t][1]); } if (tar == m-1) { lnt g[2]; g[0] = g[1] = -1; for (int sta = 0; sta &lt; (1&lt;&lt;m); sta++) if (~f[s][t][sta]) upd(g[c[sta]], f[s][t][sta]+w[sta]); f[s][t][0] = g[0], f[s][t][1] = g[1]; } } lnt ans = 0; for (int i = 0; i &lt; (1&lt;&lt;m); i++) ans = max(ans, f[1][n][i]); printf("%lld", ans); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4491 我也不知道题目名字是什么]]></title>
    <url>%2FBZOJ4491%20%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E9%A2%98%E7%9B%AE%E5%90%8D%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem我也不知道题目名字是什么 Description给定一个序列 ，每次询问 ，求 内最长子串，使得该子串为不上升子串或不下降子串 Input第一行 ，表示 数组有多少元素接下来一行为 个整数 接下来一个整数 ，表示询问数量接下来 行，每行 个整数 Output对于每个询问，求 内最长子串，使得该子串为不上升子串或不下降子串 Sample Input1234567891 2 3 4 5 6 5 4 351 61 72 71 95 9 Sample Output1234566564 样例解释五个询问分别对应 HINT Source 一个读错题的沙茶 标签：线段树 Solution稍有变形的基础线段树。对于每个区间，维护其从左端开始的最长上升升下降序列、从右端开始的最长上升或下降序列、左端点键值、右端点键值、区间中最长序列长度、区间中最长上升序列长度、区间中最长下降序列长度，共 个值。然后 和 注意写法即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define MAX_N 50000using namespace std;int n, m; struct node {int lup, rup, ldn, rdn, lc, rc, l, mxup, mxdn;} tr[(MAX_N&lt;&lt;2)+5];node update(node a, node b) { node ret; ret.l = a.l+b.l, ret.lc = a.lc, ret.rc = b.rc; ret.lup = a.lup; if (a.lup == a.l &amp;&amp; a.rc &lt;= b.lc) ret.lup = a.l+b.lup; ret.ldn = a.ldn; if (a.ldn == a.l &amp;&amp; a.rc &gt;= b.lc) ret.ldn = a.l+b.ldn; ret.rup = b.rup; if (b.rup == b.l &amp;&amp; a.rc &lt;= b.lc) ret.rup = a.rup+b.l; ret.rdn = b.rdn; if (b.rdn == b.l &amp;&amp; a.rc &gt;= b.lc) ret.rdn = a.rdn+b.l; ret.mxup = max(a.mxup, b.mxup), ret.mxdn = max(a.mxdn, b.mxdn); if (a.rc &lt;= b.lc) ret.mxup = max(ret.mxup, a.rup+b.lup); if (a.rc &gt;= b.lc) ret.mxdn = max(ret.mxdn, a.rdn+b.ldn); return ret;}void build(int v, int s, int t) { if (s == t) { scanf("%d", &amp;tr[v].lc), tr[v].rc = tr[v].lc; tr[v].lup = tr[v].rup = tr[v].ldn = tr[v].rdn = tr[v].l = tr[v].mxup = tr[v].mxdn = 1; return; } int mid = s+t&gt;&gt;1; build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t); tr[v] = update(tr[v&lt;&lt;1], tr[v&lt;&lt;1|1]);}node query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v]; int mid = s+t&gt;&gt;1; node ls, rs; bool fl = false, fr = false; if (l &lt;= mid) ls = query(v&lt;&lt;1, s, mid, l, r), fl = true; if (r &gt;= mid+1) rs = query(v&lt;&lt;1|1, mid+1, t, l, r), fr = true; return fl ? (fr ? update(ls, rs) : ls) : rs;}int main() { scanf("%d", &amp;n), build(1, 1, n); scanf("%d", &amp;m); while (m--) { int l, r; scanf("%d%d", &amp;l, &amp;r); node ans = query(1, 1, n, l, r); printf("%d\n", max(ans.mxup, ans.mxdn)); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1087【SCOI2005】互不侵犯King]]></title>
    <url>%2FBZOJ1087%E3%80%90SCOI2005%E3%80%91%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AFKing%20%E7%8A%B6%E5%8E%8BDP%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2005】互不侵犯King Description在 的棋盘里面放 个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共 个格子。 Input只有一行，包含两个数 , ( , ) Output方案数。 Sample Input13 2 Sample Output116 标签：状压DP Solution状压 的基础题。对于每个国王，不难发现它放与不放只与当行和前一行有关，而它放完后的影响只作用于当行和后一行。而 于是考虑状压 ， 表示当前考虑到第 行，共用了 个国王，第 行状态为 的方案数。那么 和前一行的状态 是否冲突可以用 、 、 与 取 得到。时间复杂度 。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long lnt;int n, k, cnt[100], sta[1000], tot;lnt f[10][1000][1000], ans; bool mrk[1000];void init() { for (int i = 0; i &lt; (1&lt;&lt;n); i++) { if (i&amp;(i&lt;&lt;1)) continue; mrk[i] = true, sta[tot++] = i; for (int j = i; j; j &gt;&gt;= 1) cnt[i] += (j&amp;1); f[1][cnt[i]][i] = 1; }}int main() { scanf("%d%d", &amp;n, &amp;k), init(); for (int i = 2; i &lt;= n; i++) for (int j = 0; j &lt;= k; j++) for (int p = 0; p &lt; tot; p++) { int cur = sta[p]; if (cnt[cur] &gt; j) continue; for (int q = 0; q &lt; tot; q++) { int lst = sta[q]; if ((cur&amp;lst) || ((cur&lt;&lt;1)&amp;lst) || ((cur&gt;&gt;1)&amp;lst)) continue; f[i][j][cur] += f[i-1][j-cnt[cur]][lst]; } } for (int i = 0; i &lt; tot; i++) ans += f[n][k][sta[i]]; printf("%lld", ans); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1046【HAOI2007】上升序列 < DP >]]></title>
    <url>%2FBZOJ1046%E3%80%90HAOI2007%E3%80%91%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97%20DP%2F</url>
    <content type="text"><![CDATA[Problem【HAOI2007】上升序列 Description对于一个给定的 ,若有 ,满足( )且( )。那么就称 为 的一个上升序列。如果有多个 满足条件，那么我们想求字典序最小的那个。任务给出 序列，给出若干询问。对于第 个询问，求出长度为 的上升序列，如有多个，求出字典序最小的那个（即首先 最小，如果不唯一，再看 最小……），如果不存在长度为 的上升序列，则输出 . Input第一行一个 ，表示序列一共有 个元素第二行 个数，为 第三行一个 ，表示询问次数。下面接 行每行一个数 ，表示要询问长度为 的上升序列。 ， Output对于每个询问，如果对应的序列存在，则输出，否则输出 . Sample Input12345663 4 1 2 3 63645 Sample Output123Impossible1 2 3 6Impossible 标签：DP Solution一道 的变形。显然需要先预处理出每个数向后能组成的 的最大长度。对于每次询问，从前往后取，一旦某数字的 最大长度比 大，则此数可加入答案。顺序构造即可。 Code12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 10000using namespace std;int n, m, k, a[MAX_N+5], f[MAX_N+5];void print() { for (int i = 1, pre = 0; i &lt;= n; i++) if (f[i] &gt;= k &amp;&amp; a[i] &gt; pre) { printf("%d", a[i]), pre = a[i]; if (--k) printf(" "); else break; } if (k) printf("Impossible"); printf("\n");}int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), f[i] = 1; for (int i = n; i &gt;= 1; i--) for (int j = i+1; j &lt;= n; j++) if (a[i] &lt; a[j]) f[i] = max(f[i], f[j]+1); scanf("%d", &amp;m); while (m--) scanf("%d", &amp;k), print(); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4720【NOIp2016】换教室]]></title>
    <url>%2FBZOJ4720%E3%80%90NOIp2016%E3%80%91%E6%8D%A2%E6%95%99%E5%AE%A4%20%E6%9C%9F%E6%9C%9BDP%2F</url>
    <content type="text"><![CDATA[Problem【NOIp2016】换教室题目描述对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中，有 节课程安排在 个时间段上。在第 （ ）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 上课，而另一节课程在教室 进行。在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 节安排好的课程。如果学生想更换第 节课程的教室，则需要提出申请。若申请通过，学生就可以在第 个时间段去教室 上课，否则仍然在教室 上课。由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 节课程的教室时，申请被通过的概率是一个已知的实数 ，并且对于不同课程的申请，被通过的概率是互相独立的。学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的 门课程，也可以不用完这 个申请的机会，甚至可以一门课程都不申请。因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。牛牛所在的大学有 个教室，有 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。 当第 （ ）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 输入输出格式输入格式第一行四个整数 。 表示这个学期内的时间段的数量； 表示牛牛最多可以申请更换多少节课程的教室； 表示牛牛学校里教室的数量； 表示牛牛的学校里道路的数量。第二行 个正整数，第 （ ） 个正整数表示 ，即第 个时间段牛牛被安排上课的教室；保证 。第三行 个正整数，第 （ ） 个正整数表示 ，即第 个时间段另一间上同样课程的教室；保证 。第四行 个实数，第 （ ） 个实数表示 ，即牛牛申请在第 个时间段更换教室获得通过的概率。保证 。接下来 行，每行三个正整数 , , ，表示有一条双向道路连接教室 , ，通过这条道路需要耗费的体力值是 ；保证 ， 。保证 ， ， ， 。保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。保证输入的实数最多包含 位小数。输出格式输出一行，包含一个实数，四舍五入精确到小数点后恰好 位，表示答案。你的输出必须和标准输出完全一样才算正确。测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于 。（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理） 输入输出样例输入样例#112345673 2 3 32 1 21 2 10.8 0.2 0.5 1 2 51 3 32 3 1 输出样例#112.80 提示 道路中可能会有多条双向道路连接相同的两间教室。 也有可能有道路两端连接的是同一间教室。 请注意区分n,m,v,e的意义, n不是教室的数量, m不是道路的数量。 标签：期望DP Solution期望题，有点超纲。考虑 。 表示选到第 个时间段，换了 节课，这节课是否换的期望。那么可以枚举是否换成功的情况进行转移。具体见代码。 方程挺长，但还是比较好想的。 Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_V 300#define MAX_N 2000#define INF 0x3f3f3f3fusing namespace std;typedef double dnt;int n, m, v, e;int c[MAX_N+5], d[MAX_N+5]; dnt k[MAX_N+5];int dis[MAX_V+5][MAX_V+5]; dnt f[MAX_N+5][MAX_N+5][2];void Floyed() { for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) dis[i][j] = i == j ? 0 : INF; for (int i = 0, x, y, z; i &lt; e; i++) scanf("%d%d%d", &amp;x, &amp;y, &amp;z), dis[x][y] = dis[y][x] = min(dis[x][y], z); for (int k = 1; k &lt;= v; k++) for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);}void DP() { for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) for (int k = 0; k &lt;= 1; k++) f[i][j][k] = INF; f[1][0][0] = f[1][1][1] = 0; for (int i = 2; i &lt;= n; i++) for (int j = 0; j &lt;= min(m, i); j++) { f[i][j][0] = min(f[i-1][j][0]+dis[c[i-1]][c[i]], f[i-1][j][1]+dis[d[i-1]][c[i]]*k[i-1]+dis[c[i-1]][c[i]]*(1-k[i-1])); if (j) f[i][j][1] = min(f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1-k[i]), f[i-1][j-1][1]+dis[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i])+dis[c[i-1]][d[i]]*(1-k[i-1])*k[i]+dis[d[i-1]][c[i]]*k[i-1]*(1-k[i])+dis[d[i-1]][d[i]]*k[i-1]*k[i]); }}dnt MIN() {dnt ret = INF; for (int j = 0; j &lt;= m; j++) for (int k = 0; k &lt; 2; k++) ret = min(ret, f[n][j][k]); return ret;}int main() { scanf("%d%d%d%d", &amp;n, &amp;m, &amp;v, &amp;e); for (int i = 1; i &lt;= n; i++) scanf("%d", c+i); for (int i = 1; i &lt;= n; i++) scanf("%d", d+i); for (int i = 1; i &lt;= n; i++) scanf("%lf", k+i); Floyed(), DP(), printf("%.2lf", MIN()); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>NOIp</tag>
        <tag>期望DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4034【HAOI2015】树上操作]]></title>
    <url>%2FBZOJ4034%E3%80%90HAOI2015%E3%80%91%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C%20%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[Problem【HAOI2015】树上操作 Description有一棵点数为 的树，以点 为根，且树点有边权。然后有 个操作，分为三种：操作 ：把某个节点 的点权增加 。操作 ：把某个节点 为根的子树中所有点的点权都增加 。操作 ：询问某个节点 到根的路径中所有点的点权和。 Input第一行包含两个整数 。表示点数和操作数。接下来一行 个整数，表示树中节点的初始权值。接下来 行每行三个正整数 ， 表示该树中存在一条边 。再接下来 行，每行分别表示一次操作。其中第一个数表示该操作的种类 ，之后接这个操作的参数 或 者 。 Output对于每个询问操作，输出该询问的答案。答案之间用换行隔开。 Sample Input12345678910115 51 2 3 4 51 21 42 32 53 31 2 13 52 1 23 3 Sample Output1236913 HINT对于 的数据， ，且所有输入数据的绝对值都不会超过 。 标签：树链剖分 Solution这是一道 序的裸题。可以 序 树状数组区间修改单点查询(差分)搞定。但为了写板我码了个树剖。反正是裸题。不多说。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;typedef long long lnt;vector &lt;int&gt; G[MAX_N+5];int n, m, rt, c[MAX_N+5], sz[MAX_N+5];int dep[MAX_N+5], fa[MAX_N+5], son[MAX_N+5];int into[MAX_N+5], outo[MAX_N+5], top[MAX_N+5], ind;lnt seg[(MAX_N&lt;&lt;2)+5], tag[(MAX_N&lt;&lt;2)+5];void DFS(int u) { sz[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == fa[u]) continue; dep[v] = dep[u]+1, fa[v] = u, DFS(v), sz[u] += sz[v]; if (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v; }}void DFS(int u, int tp) { top[u] = tp, into[u] = ++ind; if (son[u]) DFS(son[u], tp); for (int i = 0, v; i &lt; G[u].size(); i++) {v = G[u][i]; if ((v^fa[u]) &amp;&amp; (v^son[u])) DFS(v, v);} outo[u] = ind;}void updata(int v) {seg[v] = seg[v&lt;&lt;1]+seg[v&lt;&lt;1|1];}void downtag(int v, int s, int t) { if (!tag[v]) return; int mid = s+t&gt;&gt;1; seg[v&lt;&lt;1] += tag[v]*(mid-s+1), seg[v&lt;&lt;1|1] += tag[v]*(t-mid); tag[v&lt;&lt;1] += tag[v], tag[v&lt;&lt;1|1] += tag[v], tag[v] = 0;}void modify(int v, int s, int t, int l, int r, lnt x) { if (s &gt;= l &amp;&amp; t &lt;= r) {seg[v] += x*(t-s+1), tag[v] += x; return;} int mid = s+t&gt;&gt;1; downtag(v, s, t); if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, x); updata(v); return;}lnt query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return seg[v]; int mid = s+t&gt;&gt;1; lnt ret = 0; downtag(v, s, t); if (l &lt;= mid) ret += query(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) ret += query(v&lt;&lt;1|1, mid+1, t, l, r); updata(v); return ret;}void solve1(int p, lnt x) {modify(1, 1, n, into[p], into[p], x);}void solve2(int p, lnt x) {modify(1, 1, n, into[p], outo[p], x);}void solve3(int p) { lnt ans = 0; while (top[p] != rt) ans += query(1, 1, n, into[top[p]], into[p]), p = fa[top[p]]; ans += query(1, 1, n, into[rt], into[p]); printf("%lld\n", ans);}int main() { scanf("%d%d", &amp;n, &amp;m), rt = 1; for (int i = 1; i &lt;= n; i++) scanf("%d", c+i); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); DFS(rt), DFS(rt, rt); for (int i = 1; i &lt;= n; i++) modify(1, 1, n, into[i], into[i], c[i]); while (m--) { int opt; scanf("%d", &amp;opt); if (opt == 1) {int p; lnt x; scanf("%d%lld", &amp;p, &amp;x), solve1(p, x);} if (opt == 2) {int p; lnt x; scanf("%d%lld", &amp;p, &amp;x), solve2(p, x);} if (opt == 3) {int p; scanf("%d", &amp;p), solve3(p);} } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4721【NOIp2016】蚯蚓]]></title>
    <url>%2FBZOJ4721%E3%80%90NOIp2016%E3%80%91%E8%9A%AF%E8%9A%93%20%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Problem【NOIp2016】蚯蚓题目描述本题中，我们将用符号 表示对 向下取整，例如： 。蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。蛐蛐国里现在共有 只蚯蚓（ 为正整数)。每只蚯蚓拥有长度，我们设第 只蚯蚓的长度为 ，并保证所有的长度都是非负整数（即:可能存在长度为 的蚯蚓）。每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数 (是满足 的有理数)决定，设这只蚯蚓长度为 ，神刀手会将其切成两只长度分别为 和 的蚯蚓。特殊地，如果这两个数的其中一个等于 ，则这个长度为 的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加 (是一个非负整常数)。蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要 秒才能到来……( 为非负整数）蛐蛐国王希望知道这 秒内的战况。具体来说，他希望知道： 秒内，每一秒被切断的蚯蚓被切断前的长度（有 个数） 秒后，所有蚯蚓的长度（有 个数)。蛐蛐国王当然知道怎么做啦！但是他想考考你……输入输出格式输入格式第一行包含六个整数 ，其中： 的意义见【问题描述】； 均为正整数；你需要自己计算 (保证 )； 是输出参数，其含义将会在【输出格式】中解释。第二行包含 个非负整数，为 ，即初始时 只蚯蚓的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。保证 ， ， ， ， ， 。输出格式：第一行输出 个整数，按时间顺序，依次输出第 秒，第 秒，第 秒……被切断蚯蚓（在被切断前）的长度。第二行输出 个整数，输出 秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第 ，第 ，第 ……的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要 输出，你也应输出一个空行。请阅读样例来更好地理解这个格式。 输入输出样例输入样例#1：123 7 1 1 3 13 3 2 输出样例#1123 4 4 4 5 5 66 6 6 5 5 4 4 3 2 2 输入样例#2123 7 1 1 3 23 3 2 输出样例#2124 4 56 5 4 3 2 输入样例#3123 7 1 1 3 93 3 2 输出样例#312//空行2 说明【样例解释1】在神刀手到来前： 只蚯蚓的长度为 。 秒后：一只长度为 的蚯蚓被切成了两只长度分别为 和 的蚯蚓，其余蚯蚓的长度增加了 。最终 只蚯蚓的长度分别为 。括号表示这个位置刚刚有一只蚯蚓被切断 秒后：一只长度为 的蚯蚓被切成了 和 。 只蚯蚓的长度分别为： 。 秒后：一只长度为 的蚯蚓被切断。 只蚯蚓的长度分别为： 。 秒后：一只长度为 的蚯蚓被切断。 只蚯蚓的长度分别为： 。 秒后：一只长度为 的蚯蚓被切断。 只蚯蚓的长度分别为： 。 秒后：一只长度为 的蚯蚓被切断。 只蚯蚓的长度分别为： 。 秒后：一只长度为 的蚯蚓被切断。 只蚯蚓的长度分别为： 。所以， 秒内被切断的蚯蚓的长度依次为 。 秒后，所有蚯蚓长度从大到小排序为 。【样例解释2】这个数据中只有 与上个数据不同。只需在每行都改为每两个数输出一个数即可。虽然第一行最后有一个 没有被输出，但是第二行仍然要重新从第二个数再开始输出。【样例解释3】这个数据中只有 与上个数据不同。注意第一行没有数要输出，但也要输出一个空行。 标签：队列 Solution本题很巧妙，把基础数据结构玩出了新花样。观察发现每次选最长的一只进行操作，那么可以直接用一个大根堆维护，每次取出最大数，把它按要求操作后变成两个，并放回堆中。但每次操作会使数量增大 ，而 最大为 ，那么最后取出时会 。其实，大根堆的 是可以去掉的。考虑每次取出最大数后进行的操作，易知产生的两个数一定比最大数小。令 ，则第 轮取出的最大数显然大于第j轮取出的最大数，那么新切出的较长的蚯蚓一定比以前切出的所有较长蚯蚓要短，较短蚯蚓也是一样，这样如果把原蚯蚓、切出的较长蚯蚓、切出的较短蚯蚓分开存放，那么先存进去的蚯蚓一定比后存进去的蚯蚓长，这就是一个天然的优先队列。那么用三个队列维护，每次取三个队首中的最大值进行操作，得到的两个数分别存到对应的两个队列中即可。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 100000#define INF 2147483647using namespace std;typedef long long lnt;int n, m, q, t; lnt u, v;int la, lb, lc, ra, rb, rc;lnt qa[MAX_N+5], qb[MAX_N*100+5], qc[MAX_N*100+5];bool cmp(const lnt &amp;a, const lnt &amp;b) {return a &gt; b;}lnt choose() { lnt l1 = -INF, l2 = -INF, l3 = -INF; if (la &lt;= ra) l1 = qa[la]; if (lb &lt;= rb) l2 = qb[lb]; if (lc &lt;= rc) l3 = qc[lc]; lnt ret = max(l1, max(l2, l3)); if (ret == l1) la++; else if (ret == l2) lb++; else lc++; return ret;}int main() { scanf("%d%d%d%lld%lld%d", &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t); for (int i = 1; i &lt;= n; i++) scanf("%lld", qa+i); sort(qa+1, qa+n+1, cmp); la = 1, ra = n, lb = 1, rb = 0, lc = 1, rc = 0; for (int i = 1; i &lt;= m; i++) { lnt cur = choose()+(i-1)*q; if (!(i%t)) printf("%lld ", cur); lnt l1 = cur*u/v, l2 = cur-l1; if (l1 &gt; l2) swap(l1, l2); qb[++rb] = l1-(lnt)i*q, qc[++rc] = l2-(lnt)i*q; } printf("\n"); for (int i = 1; i &lt;= n+m; i++) {lnt cur = choose()+m*q; if (!(i%t)) printf("%lld ", cur);} return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>NOIp</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1833【ZJOI2010】count数字计数]]></title>
    <url>%2FBZOJ1833%E3%80%90ZJOI2010%E3%80%91count%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%20%E6%95%B0%E4%BD%8DDP%2F</url>
    <content type="text"><![CDATA[Problem【ZJOI2010】count 数字计数Time Limit: Memory Limit: Description给定两个正整数 和 ，求在 中的所有整数中，每个数码 各出现了多少次。 Input输入文件中仅包含一行两个整数 、 ，含义如上所述。 Output输出文件中包含一行 个整数，分别表示 在 中出现了多少次。 Sample Input11 99 Sample Output19 20 20 20 20 20 20 20 20 20 HINT 的数据中， 的数据中， 标签：数位DP Solution 上最简单的数位 ，比 数还水。预处理数组 ，其中 表示第i位为 的数共多少个。对于每次查询，找 和 中 出现的次数，按位在 数组上查，相减即可。可以用结构体重载运算符，这样一个算式不用写十遍。 Code12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long lnt;lnt a, b, pow[20];struct node {lnt c[10];} f[20][10];node operator + (node a, node b) {node ret; for (int i = 0; i &lt; 10; i++) ret.c[i] = a.c[i]+b.c[i]; return ret;}void init() {pow[1] = 1; for (int i = 2; i &lt;= 15; i++) pow[i] = pow[i-1]*10;}node calc(lnt x) { node ret; for (int i = 0; i &lt; 10; i++) ret.c[i] = 0; if (!x) {ret.c[0] = 1; return ret;} int len = 15; while (x &lt; pow[len]) len--; for (int i = 1; i &lt; len; i++) for (int j = 1; j &lt; 10; j++) ret = ret+f[i][j]; ret.c[0]++; int cur = x/pow[len]; for (int i = 1; i &lt; cur; i++) ret = ret+f[len][i]; x %= pow[len], ret.c[cur] += x+1; for (int i = len-1; i; i--) { cur = x/pow[i]; for (int j = 0; j &lt; cur; j++) ret = ret+f[i][j]; x %= pow[i], ret.c[cur] += x+1; } return ret;}int main() { init(), scanf("%lld%lld", &amp;a, &amp;b); for (int i = 0; i &lt; 10; i++) f[1][i].c[i] = 1; for (int i = 2; i &lt;= 12; i++) for (int j = 0; j &lt; 10; j++) for (int k = 0; k &lt; 10; k++) f[i][k] = f[i][k]+f[i-1][j], f[i][k].c[k] += pow[i-1]; node ansa = calc(a-1), ansb = calc(b); for (int i = 0; i &lt; 10; i++) {printf("%lld", ansb.c[i]-ansa.c[i]); if (i != 9) printf(" ");} return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1026【SCOI2009】Windy数]]></title>
    <url>%2FBZOJ1026%E3%80%90SCOI2009%E3%80%91Windy%E6%95%B0%20%E6%95%B0%E4%BD%8DDP%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2009】windy数 Description 定义了一种 数。不含前导零且相邻两个数字之差至少为 的正整数被称为 数。 想知道，在 和 之间，包括 和 ，总共有多少个 数？ Input包含两个整数， 。 Output一个整数 Sample Input输入样例一11 10 输入样例二125 50 Sample Output输出样例一19 输出样例二120 HINT数据规模和约定 的数据，满足 。 标签：数位DP Solution非常经典的一道数位 题。也是多少 数位 入门的第一题啊… 先预处理出 数组，其中 从左往右第 位为 的 数的个数。对于询问，分别计算 和 中的 数的个数，即在预处理的表中按位查询，统计答案后相减即可。 Code1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int f[15][15];int abs(int x) {return x &gt;= 0 ? x : -x;}int calc(int x) { int len = 0, n[15], t = x, ret = 0; while (t) n[++len] = t%10, t /= 10; for (int i = 1; i &lt; len; i++) for (int j = 1; j &lt;= 9; j++) ret += f[i][j]; for (int i = len; i; i--) { for (int j = (i == len ? 1 : 0); j &lt; n[i]; j++) if (i == len || abs(j-n[i+1]) &gt;= 2) ret += f[i][j]; if (i &lt; len &amp;&amp; abs(n[i+1]-n[i]) &lt; 2) break; } return ret;}int main() { for (int i = 0; i &lt;= 9; i++) f[1][i] = 1; for (int i = 1; i &lt;= 10; i++) for (int j = 0; j &lt;= 9; j++) { for (int k = 0; k &lt;= j-2; k++) f[i+1][k] += f[i][j]; for (int k = j+2; k &lt;= 9; k++) f[i+1][k] += f[i][j]; } int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%d", calc(r+1)-calc(l)); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1860【ZJOI2006】Mahjong麻将 < DP >]]></title>
    <url>%2FBZOJ1860%E3%80%90ZJOI2006%E3%80%91Mahjong%E9%BA%BB%E5%B0%86%20DP%2F</url>
    <content type="text"><![CDATA[Problem【ZJOI2006】Mahjong麻将 Description很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：普通麻将有砣、索、万三种类型的牌，每种牌有 个数字，其中相同的牌每个有四张，例如 砣 砣 ， 索 索 ， 万 万 各 张，所以共 张牌。胡牌时每人有 张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是 而每种数字的牌各有 张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！刺激归刺激，但是拿多了怎么胡牌呢？超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。 Input第一行一个整数 （ ），表示玩了 次超级麻将。 接下来 行，每行 个数 ，描述每次玩牌手中各种牌的数量。 表示数字为 的牌有 张。（ ） Output输出 行，若胡了则输出 ，否则输出 ，注意区分 、 的大小写！ Sample Input123432 4 0 0 0 0 0 …… 0（一共98个0）2 4 2 0 0 0 0 …… 0（一共97个0）2 3 2 0 0 0 0 …… 0（一共97个0） Sample Output123YesYesNo 标签：DP Solution一道比较常规的 。记得另外一道省选麻将题可以贪心做，但此题不行，没有贪心策略。考虑动态规划。发现一个数的牌数只可能影响它前后三个连续数的牌数（毕竟顺子只能三个连续），设 表示把前 中数字取完，取完之前数字为 的共 张，为 的共 张， 表示是否取了对子，能否有取法。那么根据不同情况，可以从取二对子、三对子、四对子、顺子的情况转移过来。除了方程特判有点多，还是挺好写的。 Code1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int a[105]; bool f[105][105][105][2];int main() { int T; scanf("%d", &amp;T); while (T--) { memset(f, false, sizeof f), f[0][0][0][0] = true; for (int i = 1; i &lt;= 100; i++) scanf("%d", a+i); for (int i = 1; i &lt;= 100; i++) for (int j = 0; j &lt;= a[i-1]; j++) for (int k = 0; k &lt;= a[i]; k++) { if (k &gt;= 2) f[i][j][k][1] |= f[i][j][k-2][0]; if (k &gt;= 3) f[i][j][k][0] |= f[i][j][k-3][0]; if (k &gt;= 3) f[i][j][k][1] |= f[i][j][k-3][1]; if (k &gt;= 4) f[i][j][k][0] |= f[i][j][k-4][0]; if (k &gt;= 4) f[i][j][k][1] |= f[i][j][k-4][1]; if (j &gt;= k &amp;&amp; a[i-2] &gt;= k) f[i][j][k][0] |= f[i-1][(i &gt;= 2 ? a[i-2] : 0)-k][j-k][0]; if (j &gt;= k &amp;&amp; a[i-2] &gt;= k) f[i][j][k][1] |= f[i-1][(i &gt;= 2 ? a[i-2] : 0)-k][j-k][1]; } printf("%s\n", f[100][a[99]][a[100]][1] ? "Yes" : "No"); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1033【ZJOI2007】杀蚂蚁]]></title>
    <url>%2FBZOJ1033%E3%80%90ZJOI2007%E3%80%91%E6%9D%80%E8%9A%82%E8%9A%81%20%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[Problem【ZJOI2008】杀蚂蚁Description最近，佳佳迷上了一款好玩的小游戏： 。游戏规则非常简单：在一张地图上，左上角是蚂蚁窝，右下角是蛋糕，蚂蚁会源源不断地从窝里爬出来，试图把蛋糕搬回蚂蚁窝。而你的任务，就是用原始资金以及杀蚂蚁获得的奖金造防御塔，杀掉这些试图跟你抢蛋糕的蚂蚁~下附一张游戏截图： 为了拿到尽可能高的分数，佳佳设计了很多种造塔的方案，但在尝试了其中的一小部分后，佳佳发现，这个游戏实在是太费时间了。为了节省时间，佳佳决定写个程序，对于每一种方案，模拟游戏进程，根据效果来判断方案的优劣。根据自己在游戏中积累的一些经验，以及上网搜到的一些参数，佳佳猜了蚂蚁爬行的算法，并且假设游戏中的蚂蚁也是按这个规则选择路线： 1. 每一秒钟开始的时候，蚂蚁都在平面中的某个整点上。如果蚂蚁没有扛着蛋糕，它会在该点留下 2 单位的信息素，否则它会留下 5 单位的信息素。然后蚂蚁会在正北、正南、正东、正西四个方向中选择一个爬过去。 2. 选择方向的规则是：首先，爬完一个单位长度后到达的那个点上，不能有其他蚂蚁或是防御塔，并且那个点不能是蚂蚁上一秒所在的点（除非上一个时刻蚂蚁就被卡住，且这个时刻它仍无法动），当然，蚂蚁也不会爬出地图的边界（我们定义这些点为不可达点）。如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去。 3. 如果此时仍有多种选择，蚂蚁先面向正东，如果正东不是可选择的某个方向，它会顺时针转90°，再次判断，如果还不是，再转 90°...直到找到可以去的方向。 4. 如果将每只蚂蚁在洞口出现的时间作为它的活动时间的第 1 秒，那么每当这只蚂蚁的活动时间秒数为 5 的倍数的时候，它先按规则 1~3 确定一个方向，面对该方向后逆时针转 90°，若它沿当前方向会走到一个不可达点，它会不停地每次逆时针转 90°，直到它面对着一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向。 5. 如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点。 6. 你可以认为蚂蚁在选定方向后，瞬间移动到它的目标点，这一秒钟剩下的时间里，它就停留在目标点。 7. 蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动。 然后，是一些有关地图的信息： 1. 每一秒，地图所有点上的信息素会损失 1 单位，如果那个点上有信息素的话。 2. 地图上某些地方是炮台。炮台的坐标在输入中给出。 3. 地图的长、宽在输入中给出，对于n*m的地图，它的左上角坐标为(0,0)，右下角坐标为(n,m)。蚂蚁洞的位置为(0,0)，蛋糕的位置为(n,m)。 4. 你可以把蚂蚁看做一个直径为 1 单位的圆，圆心位于蚂蚁所在的整点。 5. 游戏开始时，地图上没有蚂蚁，每个点上的信息素含量均为 0。 一些有关炮塔的信息： 1. 炮塔被放置在地图上的整点处。 2. 为了简单一些，我们认为这些炮塔都是激光塔。激光塔的射速是 1 秒/次，它的攻击伤害为 d/次，攻击范围为 r。你可以认为每秒蚂蚁移动完毕后，塔才开始攻击。并且，只有当代表蚂蚁的圆的圆心与塔的直线距离不超过 r 时，塔才算打得到那只蚂蚁。 3. 如果一只蚂蚁扛着蛋糕，那么它会成为 target，也就是说，任何打得到它的塔的炮口都会对准它。如果蛋糕好好地呆在原位，那么每个塔都会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只。 4. 激光塔有个比较奇怪的特性：它在选定了打击目标后，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损 d 格血，但激光不会穿透它的打击目标打到后面的蚂蚁。 5. 尽管在真实游戏中，塔是可以升级的，但在这里我们认为塔的布局和等级就此定了下来，不再变动。 再介绍一下蚂蚁窝： 1. 如果地图上的蚂蚁不足 6 只，并且洞口没有蚂蚁，那么窝中每秒会爬出一只蚂蚁，直到地图上的蚂蚁数为 6 只。 2. 刚出生的蚂蚁站在洞口。3. 每只蚂蚁有一个级别，级别决定了蚂蚁的血量，级别为 k 的蚂蚁的血量为[4*1.1^k]。每被塔打一次，蚂蚁的血减少 d。注意，血量为 0 的蚂蚁仍能精力充沛地四处乱爬，只有一只蚂蚁的血被打成负数时，它才算挂了。 3. 蚂蚁的级别是这样算的：前 6 只出生的蚂蚁是 1 级，第 7~12 只是 2 级，依此类推。 最后给出关于蛋糕的介绍： 1. 简单起见，你可以认为此时只剩最后一块蛋糕了。如果有蚂蚁走到蛋糕的位置，并且此时蛋糕没有被扛走，那么这只蚂蚁就扛上了蛋糕。蚂蚁被打死后蛋糕归位。 2. 如果一只扛着蛋糕的蚂蚁走到蚂蚁窝的位置，我们就认为蚂蚁成功抢到了蛋糕，游戏结束。 3. 蚂蚁扛上蛋糕时，血量会增加[该蚂蚁出生时血量/2]，但不会超过上限。 整理一下 1 秒钟内发生的事件： 1. 1 秒的最初，如果地图上蚂蚁数不足 6，一只蚂蚁就会在洞口出生。 2. 接着，蚂蚁们在自己所在点留下一些信息素后，考虑移动。先出生的蚂蚁先移动。 3. 移动完毕后，如果有蚂蚁在蛋糕的位置上并且蛋糕没被拿走，它把蛋糕扛上，血量增加，并在这时被所有塔设成 target。 4. 然后所有塔同时开始攻击。如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位。 5. 攻击结束后，如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕。游戏也在此时结束。 6. 最后，地图上所有点的信息素损失 1 单位。所有蚂蚁的年龄加 1。 7. 漫长的 1 秒到此结束。 Input输入的第一行是 个用空格隔开的整数， 、 ，分别表示了地图的长和宽。第二行是 个用空格隔开的整数， 、 、 ，依次表示炮塔的个数、单次攻击伤害以及攻击范围。接下来 行，每行是 个用空格隔开的整数 、 ，描述了一个炮塔的位置。当然，蚂蚁窝的洞口以及蛋糕所在的位置上一定没有炮塔。最后一行是一个正整数 ，表示我们模拟游戏的前 秒钟。 Output如果在第 秒或之前蚂蚁抢到了蛋糕，输出一行“ ”，其中 为游戏结束的时间，否则输出“ ”。如果游戏在 秒或之前结束，输出游戏结束时所有蚂蚁的信息，否则输出 秒后所有蚂蚁的信息。格式如下：第一行是 个整数 ，表示此时活着的蚂蚁的总数。接下来 行，每行 个整数，依次表示一只蚂蚁的年龄（单位为秒）、等级、当前血量，以及在地图上的位置 。输出按蚂蚁的年龄递减排序。 Sample Input12343 51 1 22 25 Sample Output1234567The game is going on55 1 3 1 44 1 3 0 43 1 3 0 32 1 3 0 21 1 4 0 1 Hint样例说明 的地图，有 个单次伤害为 、攻击范围为 的激光炮塔，它的位置为 ，模拟游戏的前 秒。 秒内有 只蚂蚁出生，都是向东爬行，其中第 只在路过 点时被激光塔伤了 格血。在第 秒的时候，最早出生的蚂蚁按移动规则 本来该向东移动，但由于规则 的作用，它在发现向北和向西移动都会到达不可达点后，最终选择了向南移动。数据说明 的数据满足 ， ， 如果觉得此题面不好看，请戳这里：https://www.zybuluo.com/Jerusalem/note/221811如果做得无聊了，可以玩玩：http://wanga.me/2794 标签：大模拟 Solution这是那种“做一做，一个下午就没了”的恶心题。我从上午十一点开做，足足做到晚上七点半才做完。恶心~ 大模拟，题面已经比较清楚了。坑点如下： 蚂蚁既是一个点，也是一个直径为 的圆（注意，是直径！）即在判断一个炮台和一只蚂蚁的距离时，应取圆心与炮台距离，但在判断一只蚂蚁是否会被炮台顺带打到，即在打目标蚂蚁的路径上时，应判断激光直线是否与圆有交点。 新出生的蚂蚁刚从蚁巢里出来时，要标记 为有物体，否则回来的蚂蚁会和它重在一起。 若当前蚂蚁出生的时间为 ，则其年龄为 。 寻找移动方向时，应先按规则 选择下一个位置。如果出生时间为 的倍数，则应该逆时针（注意，是逆时针）旋转，并且找到一个可行方向就走过去，不考虑信息素多少。 所有炮台是一起开炮，所以应该先把所有炮台的目标确定后，再统一扣蚂蚁的生命值。这样会出现蚂蚁生命在同一秒内被扣成负数还要继续扣的情况，这样就是正确的。 Extra Samples贡献几组数据，可自测： Sample #1Input12345674 44 10 51 12 21 22 11000 Output12345678Game over after 831 seconds6110 49 86 2 388 49 26 0 177 49 286 3 158 50 29 0 022 50 419 4 310 50 469 3 2 Sample #2Input12346 41 10000 102 2256 Output12The game is going on0 Sample #3Input1234 70 0 060200 Output12345678Game over after 60200 seconds660199 1 4 0 060198 1 4 2 660197 1 4 4 760196 1 4 2 160195 1 4 3 560194 1 4 4 5 Sample #4Input1234567892 56 1 30 11 11 31 42 32 4200000 Output12345678The game is going on615311 86 13525 1 512518 86 10203 0 59447 87 12495 0 46371 87 13461 0 33295 87 14586 0 2219 87 15873 1 2 Code（ 上过了，洛谷上死活 一个点，不知道为什么）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define EPS 1e-5using namespace std;typedef double dnt;int n, m, s, d, r, cnt, num, tar = -1;vector &lt;int&gt; living; int information[10][10];bool lose = false, cake = true, is_taken[10][10];int nxt[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};int calc_lim_blood(int k) {dnt ret = 4; while (k--) ret *= 1.1; return (int)floor(ret);}struct Ant { int x, y, id, px, py; bool has_cake; int cur_blood, lim_blood, level, age; void birth(int _id) { living.push_back(id = _id), num++, has_cake = false; x = y = age = 0, px = py = -1, level = id/6+1; cur_blood = lim_blood = calc_lim_blood(level), is_taken[x][y] = true; } void dead() { num--; int pos; for (pos = 0; pos &lt; (int)living.size(); pos++) if (living[pos] == id) break; for (; pos &lt; (int)living.size()-1; pos++) living[pos] = living[pos+1]; living.erase(living.end()-1); if (has_cake) cake = true, tar = -1; is_taken[x][y] = false; } void recover() {cur_blood = min(cur_blood+(int)floor(lim_blood/2), lim_blood);} void hurt() {cur_blood -= d;} void left_information() {information[x][y] += has_cake ? 5 : 2;} pair &lt;int, int&gt; choose_direction() { int nx = -1, ny = -1, cur; for (int i = 0; i &lt; 4; i++) { int tx = x+nxt[i][0], ty = y+nxt[i][1]; if (tx &lt; 0 || tx &gt; n || ty &lt; 0 || ty &gt; m) continue; if (is_taken[tx][ty] || (tx == px &amp;&amp; ty == py)) continue; if (nx == -1 &amp;&amp; ny == -1) nx = tx, ny = ty; else if (information[tx][ty] &gt; information[nx][ny]) nx = tx, ny = ty; } if ((age+1)%5 == 0) { if (nx == x &amp;&amp; ny == y+1) nx = ny = -1, cur = 0; if (nx == x+1 &amp;&amp; ny == y) nx = ny = -1, cur = 1; if (nx == x &amp;&amp; ny == y-1) nx = ny = -1, cur = 2; if (nx == x-1 &amp;&amp; ny == y) nx = ny = -1, cur = 3; for (int i = cur-1; ~i; i--) { int tx = x+nxt[i][0], ty = y+nxt[i][1]; if (tx &lt; 0 || tx &gt; n || ty &lt; 0 || ty &gt; m) continue; if (is_taken[tx][ty] || (tx == px &amp;&amp; ty == py)) continue; if (nx == -1 &amp;&amp; ny == -1) nx = tx, ny = ty; } for (int i = 3; i &gt;= cur; i--) { int tx = x+nxt[i][0], ty = y+nxt[i][1]; if (tx &lt; 0 || tx &gt; n || ty &lt; 0 || ty &gt; m) continue; if (is_taken[tx][ty] || (tx == px &amp;&amp; ty == py)) continue; if (nx == -1 &amp;&amp; ny == -1) nx = tx, ny = ty; } } return make_pair(nx, ny); } void move() { pair &lt;int, int&gt; np = choose_direction(); if (np.first == -1 &amp;&amp; np.second == -1) np.first = x, np.second = y; is_taken[x][y] = false, is_taken[np.first][np.second] = true; px = x, py = y, x = np.first, y = np.second; } bool can_take_cake() {return x == n &amp;&amp; y == m &amp;&amp; cake;} void take_cake() {if (can_take_cake()) recover(), cake = false, has_cake = true, tar = id;} bool steal_cake() {return x == 0 &amp;&amp; y == 0 &amp;&amp; has_cake;}} ant[2000000]; dnt dis(int x1, int y1, int x2, int y2) {return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);} dnt getcos(int x1, int y1, int x2, int y2, int x3, int y3) { int a1 = x1-x2, b1 = y1-y2, a2 = x3-x2, b2 = y3-y2; return (a1*a2+b1*b2)/(dnt)(sqrt(dis(x1, y1, x2, y2))*sqrt(dis(x3, y3, x2, y2))); } bool reach(int tarid, int inid, int x, int y) { dnt cos1 = getcos(ant[inid].x, ant[inid].y, x, y, ant[tarid].x, ant[tarid].y); dnt cos2 = getcos(ant[inid].x, ant[inid].y, ant[tarid].x, ant[tarid].y, x, y); if (cos1 &lt; EPS || cos2 &lt; EPS) return false; dnt t = sqrt(dis(ant[inid].x, ant[inid].y, x, y))*sqrt(1.0-cos1*cos1); return t-0.5 &lt; EPS; }struct Laser { int x, y; int dist(int id) {return (x-ant[id].x)*(x-ant[id].x)+(y-ant[id].y)*(y-ant[id].y);} void build(int _x, int _y) {x = _x, y = _y, is_taken[x][y] = true;} bool can_hit(int id) {return (x-ant[id].x)*(x-ant[id].x)+(dnt)(y-ant[id].y)*(y-ant[id].y) &lt;= r*r;} int choose_target() { if (~tar &amp;&amp; can_hit(tar)) return tar; int ret = -1; for (int i = 0, cur = living[i]; i &lt; (int)living.size(); cur = living[++i]) if (can_hit(cur)) if (ret == -1 || dist(ret) &gt; dist(cur)) ret = cur; return ret; } void attack() { int id = choose_target(); if (id == -1) return; for (int i = 0; i &lt; (int)living.size(); i++) if (reach(id, living[i], x, y)) ant[living[i]].hurt(); }} laser[10];void add_age() {for (int i = 0; i &lt; (int)living.size(); i++) ant[living[i]].age++;}void lose_information() {for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) information[i][j] -= (information[i][j] &gt; 0);}bool game_over() {for (int i = 0; i &lt; (int)living.size(); i++) if (ant[living[i]].steal_cake()) return true; return false;}bool per_second(int t) { if (num &lt; 6 &amp;&amp; !is_taken[0][0]) ant[cnt].birth(cnt), cnt++; for (int i = 0; i &lt; (int)living.size(); i++) ant[living[i]].left_information(); for (int i = 0; i &lt; (int)living.size(); i++) ant[living[i]].move(); for (int i = 0; i &lt; (int)living.size(); i++) ant[living[i]].take_cake(); for (int i = 0; i &lt; s; i++) laser[i].attack(); for (int i = 0, cur; i &lt; (int)living.size(); i++) {cur = living[i]; if (ant[cur].cur_blood &lt; 0) ant[cur].dead(), i--;} if (game_over()) {printf("Game over after %d seconds\n", t), lose = true; return false;} add_age(), lose_information(); return true;}void output() { printf("%d\n", num); for (int i = 0, cur = living[i]; i &lt; (int)living.size(); cur = living[++i]) printf("%d %d %d %d %d\n", ant[cur].age, ant[cur].level, ant[cur].cur_blood, ant[cur].x, ant[cur].y);}int main() { scanf("%d%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;d, &amp;r); for (int i = 0, x, y; i &lt; s; i++) scanf("%d%d", &amp;x, &amp;y), laser[i].build(x, y); int t; scanf("%d", &amp;t); for (int i = 1; i &lt;= t; i++) if (!per_second(i)) break; if (!lose) printf("The game is going on\n"); output(); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4325【NOIp2015】斗地主]]></title>
    <url>%2FBZOJ4325%E3%80%90NOIp2015%E3%80%91%E6%96%97%E5%9C%B0%E4%B8%BB%20%E6%90%9C%E7%B4%A2%2B%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Problem斗地主Time Limit: Memory Limit: Description牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 到 加上大小王的共 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下： 小 王 大 王 ，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下： Input第一行包含用空格隔开的 个正整数 ，表示手牌的组数以及每组手牌的张数。接下来 组数据，每组数据 行，每行一个非负整数对 ，表示一张牌，其中 表示牌的数码， 表示牌的花色，中间用空格隔开。特别的，我们用1来表示数码A， 表示数码 ， 表示数码 ， 表示数码 ；黑桃、红心、梅花、方片分别用 来表示；小王的表示方法为 ，大王的表示方法为 。 Output共 行，每行一个整数，表示打光第 组手牌的最少次数。 Sample Input1234567891 87 48 49 110 411 15 11 41 1 Sample Output13 HINT共有 组手牌，包含 张牌：方片 ，方片 ，黑桃 ，方片 ，黑桃 ，黑桃 ，方片 以及黑桃 。可以通过打单顺子（方片 ，方片 ，黑桃 ，方片 ，黑桃 ），单张牌（黑桃 ）以及对子牌（黑桃 以及方片 ）在 次内打光。 , 传送门 标签：搜索 贪心 Solution题面看起来挺吓人，做起来却比较容易，特别是代码复杂度不高（毕竟做了恶心的猪国杀作铺垫）。发现确定顺子之后，其他所有牌都可以贪心取，从耗费牌数多的往牌数少的取。用一个 作大框架，在 到每一层（即每次取一组顺子）的前后用贪心算出当前不再取顺子而直接贪心取的总次数，打擂即可。 Code（貌似这个代码只能过原数据，加强版因为“有几个相同的王不能组成对子”这一 ，我的代码过不了，要加特判）1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#define SIZE 14#define INF 2147483647using namespace std;int n, ans, c[SIZE];void init() {ans = INF; for (int i = 0; i &lt; SIZE; i++) c[i] = 0;}void modify(int l, int r, int x) {for (int i = l; i &lt;= r; i++) c[i] += x;}int calc() { int c1, c2, c3, c4, ret; c1 = c2 = c3 = c4 = ret = 0; for (int i = 0; i &lt; SIZE; i++) c1 += (c[i] == 1), c2 += (c[i] == 2), c3 += (c[i] == 3), c4 += (c[i] == 4); while (c2 &gt;= 2 &amp;&amp; c4 &gt;= 1) c2 -= 2, c4 -= 1, ret++; while (c2 &gt;= 1 &amp;&amp; c3 &gt;= 1) c2 -= 1, c3 -= 1, ret++; while (c1 &gt;= 2 &amp;&amp; c4 &gt;= 1) c1 -= 2, c4 -= 1, ret++; while (c2 &gt;= 1 &amp;&amp; c4 &gt;= 1) c2 -= 1, c4 -= 1, ret++; while (c1 &gt;= 1 &amp;&amp; c3 &gt;= 1) c1 -= 1, c3 -= 1, ret++; return ret+c1+c2+c3+c4;}void DFS(int stp) { int lft = calc(); bool flag = false; if (stp &gt; ans) return; ans = min(ans, stp+lft); for (int l = 2; l+1 &lt; SIZE; l++) { int tr = l; while (c[tr] &gt;= 3 &amp;&amp; tr &lt; SIZE) tr++; if (--tr-l+1 &lt; 2) continue; flag = true; for (int r = tr; r &gt;= l+1; r--) modify(l, r, -3), DFS(stp+1), modify(l, r, 3); } for (int l = 2; l+2 &lt; SIZE; l++) { int tr = l; while (c[tr] &gt;= 2 &amp;&amp; tr &lt; SIZE) tr++; if (--tr-l+1 &lt; 3) continue; flag = true; for (int r = tr; r &gt;= l+2; r--) modify(l, r, -2), DFS(stp+1), modify(l, r, 2); } for (int l = 2; l+4 &lt; SIZE; l++) { int tr = l; while (c[tr] &gt;= 1 &amp;&amp; tr &lt; SIZE) tr++; if (--tr-l+1 &lt; 5) continue; flag = true; for (int r = tr; r &gt;= l+4; r--) modify(l, r, -1), DFS(stp+1), modify(l, r, 1); } lft = calc(), ans = min(ans, stp+lft);}int main() { int T; scanf("%d%d", &amp;T, &amp;n); while (T--) { init(); for (int i = 0, a, b; i &lt; n; i++) scanf("%d%d", &amp;a, &amp;b), a = a == 1 ? 13 : (a == 0 ? 0 : a-1), c[a]++; DFS(0), printf("%d\n", ans); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>贪心</tag>
        <tag>NOIp</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1821【JSOI2010】Group部落划分 < MST >]]></title>
    <url>%2FBZOJ1821%E3%80%90JSOI2010%E3%80%91Group%E9%83%A8%E8%90%BD%E5%88%92%E5%88%86%20MST%2F</url>
    <content type="text"><![CDATA[Problem【JSOI2010】Group 部落划分 Description聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。 不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了 个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了 个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法： 对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。 例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。 Input第一行包含两个整数 和 ( , )，分别代表了野人居住点的数量和部落的数量。接下来 行，每行包含两个正整数 ，描述了一个居住点的坐标( ) Output输出一行，为最优划分时，最近的两个部落的距离，精确到小数点后两位。 Sample Input123454 20 00 11 11 0 Sample Output11.00 标签：MST Solution此题是 的一个简单变形。本题要求分为 个部落，即在生成树上拆 条边。使得其最小距离最大，可以 贪 心 向 下 选 ， 选 到 剩 k-1$条边为止。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define MAX_N 1000using namespace std;typedef double dnt;struct node {int u, v; dnt c;} E[MAX_N*MAX_N+50];bool cmp (const node &amp;a, const node &amp;b) {return a.c &lt; b.c;}int n, k, cnt, x[MAX_N+5], y[MAX_N+5], fa[MAX_N+5];void init() {for (int i = 1; i &lt;= n; i++) fa[i] = i;}dnt dist(int a, int b) {return (dnt)sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));}int getf(int c) {return fa[c] == c ? c : fa[c] = getf(fa[c]);}dnt Kruskal() { sort(E, E+cnt, cmp); for (int i = 0, tot = 0; i &lt; cnt; i++) { int u = getf(E[i].u), v = getf(E[i].v); if (u != v) fa[u] = v, tot++; if (tot &gt; n-k) return E[i].c; }}int main() { scanf("%d%d", &amp;n, &amp;k), init(); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;x[i], &amp;y[i]); for (int i = 1; i &lt;= n; i++) for (int j = i+1; j &lt;= n; j++) E[cnt++] = (node){i, j, dist(i, j)}; printf("%.2lf", Kruskal()); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3228 Gold Transportation < MST >]]></title>
    <url>%2FPOJ3228%20Gold%20Transportation%20MST%2F</url>
    <content type="text"><![CDATA[ProblemGold TransportationTime Limit: Memory Limit: DescriptionRecently, a number of gold mines have been discovered in Zorroming State. To protect this treasure, we must transport this gold to the storehouses as quickly as possible. Suppose that the Zorroming State consists of N towns and there are M bidirectional roads among these towns. The gold mines are only discovered in parts of the towns, while the storehouses are also owned by parts of the towns. The storage of the gold mine and storehouse for each town is finite. The truck drivers in the Zorroming State are famous for their bad temper that they would not like to drive all the time and they need a bar and an inn available in the trip for a good rest. Therefore, your task is to minimize the maximum adjacent distance among all the possible transport routes on the condition that all the gold is safely transported to the storehouses. InputThe input contains several test cases. For each case, the first line is integer . The second line is integers associated with the storage of the gold mine in every towns .The third line is also integers associated with the storage of the storehouses in every towns .Next is integer .Then M lines follow. Each line is three integers , and , means that there is a road between and for distance of . means end of the input. OutputFor each case, output the minimum of the maximum adjacent distance on the condition that all the gold has been transported to the storehouses or “No Solution”. Sample Input123456789101143 2 0 00 0 3 361 2 41 3 101 4 122 3 62 4 83 4 50 Sample Output16 Translation有 个村庄，每个村庄有一个黄金矿和一个仓库，求一棵生成树森林，使得每棵生成树上的黄金矿都可被这棵生成树上的仓库存下，并且森林中最大边权最小。 标签：MST Solution一个简单的 变形。用 从大到小贪心选边，每加一条边就 判断森林中是否所有点所在的树都可以“自给自足”。总时间复杂度 ，即 。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 200#define MAX_M 20000using namespace std;int n, m, f[MAX_N+5], s[MAX_N+5];struct node {int u, v, c;} E[MAX_M+5];bool cmp(const node &amp;a, const node &amp;b) {return a.c &lt; b.c;}int getf(int x) {if (f[x] == x) return x; int tmp = getf(f[x]); s[tmp] += s[x], s[x] = 0; return f[x] = tmp;}bool chk() {for (int i = 1; i &lt;= n; i++) if (f[i] == i &amp;&amp; s[i] &lt; 0) return false; return true;}int main() { while (scanf("%d", &amp;n) &amp;&amp; n) { for (int i = 1; i &lt;= n; i++) f[i] = i, s[i] = 0; for (int i = 1, x; i &lt;= n; i++) scanf("%d", &amp;x), s[i] -= x; for (int i = 1, x; i &lt;= n; i++) scanf("%d", &amp;x), s[i] += x; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].c); sort(E, E+m, cmp); bool flag = false; for (int i = 0; i &lt; m; i++) { int u = getf(E[i].u), v = getf(E[i].v); if (u != v) f[u] = v, s[v] += s[u], s[u] = 0; if (chk()) {flag = true, printf("%d\n", E[i].c); break;} } if (!flag) printf("No Solution\n"); } return 0;}]]></content>
      <tags>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3993【SDOI2015】星际战争]]></title>
    <url>%2FBZOJ3993%E3%80%90SDOI2015%E3%80%91%E6%98%9F%E9%99%85%E6%88%98%E4%BA%89%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2015】星际战争 Description 年，在银河系的某星球上， 军团和 军团正在激烈地作战。在战斗的某一阶段， 军团一共派遣了 个巨型机器人进攻 军团的阵地，其中第 个巨型机器人的装甲值为 。当一个巨型机器人的装甲值减少到 或者以下时，这个巨型机器人就被摧毁了。 军团有 个激光武器，其中第i个激光武器每秒可以削减一个巨型机器人 的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。 军团看到自己的巨型机器人被 军团一个一个消灭，他们急需下达更多的指令。为了这个目标， 军团需要知道 军团最少需要用多长时间才能将 军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。 Input第一行，两个整数， 、 。第二行， 个整数， 、 。第三行， 个整数， 、 。接下来的 行，每行 个整数，这些整数均为 或者 。这部分中的第 行的第 个整数为 表示第 个激光武器不可以攻击第 个巨型机器人，为 表示第 个激光武器可以攻击第 个巨型机器人。 Output一行，一个实数，表示 军团要摧毁 军团的所有巨型机器人最少需要的时间。输出结果与标准答案的绝对误差不超过 即视为正确。 Sample Input123452 23 104 60 11 1 Sample Output11.300000 HINT样例说明战斗开始后的前 秒，激光武器 攻击 号巨型机器人，激光武器 攻击 号巨型机器人。 号巨型机器人被完全摧毁， 号巨型机器人还剩余 的装甲值；接下来的 秒，激光武器 、 同时攻击 号巨型机器人。 号巨型机器人被完全摧毁。数据范围对于全部的数据， ， ， ，输入数据保证 军团一定能摧毁 军团的所有巨型机器人 标签：二分答案 网络流 Solution如果直接处理这个问题，会发现限制有点多，不太好处理。考虑二分答案。二分最少时间，那么每个激光炮在此时间内可造成的伤害就可以算出，这时只需判断合理分配这些伤害能否使敌方团灭。发现可以建图跑最大流判断。从源点 向所有激光炮连边，容量为此激光炮可造成的总伤害。从所有机器人向汇点 连边，容量为机器人血量。从每个激光炮向其所可以造成伤害的所有机器人连边，容量为 ，这样跑一遍最大流，判断是否等于所有机器人的总血量即可。建图可以不用全部新建，只用在开始的时候建一个图，二分判断时将所有 到激光炮的边容量改成 即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAX_N 100#define EPS 1e-8#define INF 0x3f3f3f3f#define mid (l+r)/2using namespace std;typedef double dnt;struct node {int v, nxt; dnt c;} E[MAX_N*MAX_N*5+500]; dnt sum;int n, m, s, t, a[MAX_N+5], b[MAX_N+5], mrk[MAX_N+5][MAX_N+5], pre[MAX_N+5], d[MAX_N+5], cnt;void init() {memset(pre, -1, sizeof(pre)), cnt = 0, s = 0, t = n+m+1;}void insert(int u, int v, dnt c) {E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++;}void build() { init(); for (int i = 1; i &lt;= n; i++) insert(i, t, a[i]), insert(t, i, 0), sum += a[i]; for (int i = 1; i &lt;= m; i++) insert(s, i+n, INF), insert(i+n, s, 0); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (mrk[i][j]) insert(i+n, j, INF), insert(j, i+n, 0);}bool BFS() { queue &lt;int&gt; que; memset(d, -1, sizeof(d)); que.push(s), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v; if (E[i].c &lt;= EPS || ~d[v]) continue; d[v] = d[u]+1; que.push(v); } } return ~d[t];}dnt DFS(int u, dnt flow) { if (u == t) return flow; dnt ret = 0; for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v; if (E[i].c &lt;= EPS || d[v] != d[u]+1) continue; dnt tmp = DFS(v, min(flow, E[i].c)); E[i].c -= tmp, E[i^1].c += tmp, ret += tmp, flow -= tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}bool chk(dnt tans) { for (int i = 0; i &lt; cnt; i += 2) E[i].c += E[i^1].c, E[i^1].c = 0; for (int i = pre[s]; ~i; i = E[i].nxt) E[i].c = (dnt)b[E[i].v-n]*tans; dnt tot = 0; while (BFS()) tot += DFS(s, INF); return fabs(tot-sum) &lt;= EPS;}dnt bi_search(dnt l, dnt r) { dnt ret = -1; for (int i = 0; i &lt; 100; i++) if (chk(mid)) ret = r = mid; else l = mid; return ret;}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int i = 1; i &lt;= m; i++) scanf("%d", b+i); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) scanf("%d", &amp;mrk[i][j]); build(), printf("%.5lf", bi_search(0, INF)); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ728 Desert King]]></title>
    <url>%2FPOJ2728%20Desert%20King%20%E4%BA%8C%E5%88%86%2BMST%2F</url>
    <content type="text"><![CDATA[ProblemDesert KingDescriptionDavid the Great has just become the king of a desert country. To win the respect of his people, he decided to build channels all over his country to bring water to every village. Villages which are connected to his capital village will be watered. As the dominate ruler and the symbol of wisdom in the country, he needs to build the channels in a most elegant way.After days of study, he finally figured his plan out. He wanted the average cost of each mile of the channels to be minimized. In other words, the ratio of the overall cost of the channels to the total length must be minimized. He just needs to build the necessary channels to bring water to all the villages, which means there will be only one way to connect each village to the capital.His engineers surveyed the country and recorded the position and altitude of each village. All the channels must go straight between two villages and be built horizontally. Since every two villages are at different altitudes, they concluded that each channel between two villages needed a vertical water lifter, which can lift water up or let water flow down. The length of the channel is the horizontal distance between the two villages. The cost of the channel is the height of the lifter. You should notice that each village is at a different altitude, and different channels can’t share a lifter. Channels can intersect safely and no three villages are on the same line.As King David’s prime scientist and programmer, you are asked to find out the best solution to build the channels. InputThere are several test cases. Each test case starts with a line containing a number , which is the number of villages. Each of the following lines contains three integers, , and . is the position of the village and is the altitude. The first village is the capital. A test case with ends the input, and should not be processed. OutputFor each test case, output one line containing a decimal number, which is the minimum ratio of overall cost of the channels to the total length. This number should be rounded three digits after the decimal point. Sample Input12345640 0 00 1 11 1 21 0 30 Sample Output11.000 Translation给出 个村庄和 条路，以及每条路的长度和代价，要求选出一棵生成树使得其路径总代价除以路径总长度最小。 标签：最优比例生成树 二分答案 MST Solution本题是最优比例生成树的裸题。熟悉二分答案的套路。 注意到如果一个答案 可作为平均值，那么比x大的所有答案均可作为平均值，问题具有二分性于是二分答案，即最后的平均值，对于每个答案，构造最小生成树判断可行性，具体如下：对于第 条边，长度为 ，代价为 ，那么将此边的权值设为 ，跑一遍最小生成树，如果总权值小于 ，则有可行解。注意此题为稠密图，应用 。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define MAX_N 1000using namespace std;int n;double map[MAX_N+5][MAX_N+5], val[MAX_N+5][MAX_N+5];struct Point {double x, y, h;} p[MAX_N+5];double calc(double x1, double y1, double x2, double y2) {return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));}bool check(double t) { double ret = 0; double dis[MAX_N+5]; bool vis[MAX_N+5]; memset(dis, 127, sizeof(dis)); memset(vis, 0, sizeof(vis)); dis[1] = 0; for (int i = 0; i &lt; n; i++) { int tv = 0; for (int j = 1; j &lt;= n; j++) if (!vis[j] &amp;&amp; (!tv || dis[j] &lt; dis[tv])) tv = j; vis[tv] = 1, ret += dis[tv]; for (int j = 1; j &lt;= n; j++) if (!vis[j]) dis[j] = min(dis[j], val[tv][j]-map[tv][j]*t); } return ret &lt; 0;}double bi_search() { double l = 0, r = 1e5, mid; while (abs(l-r) &gt; 1e-6) { mid = (l+r)/2; if (check(mid)) r = mid; else l = mid; } return mid;}int main() { while (scanf("%d", &amp;n) &amp;&amp; n) { for (int i = 1; i &lt;= n; i++) scanf("%lf%lf%lf", &amp;p[i].x, &amp;p[i].y, &amp;p[i].h); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) map[i][j] = map[j][i] = calc(p[i].x, p[i].y, p[j].x, p[j].y), val[i][j] = val[j][i] = abs(p[i].h-p[j].h); printf("%.3f\n", bi_search()); } return 0;}]]></content>
      <tags>
        <tag>图论</tag>
        <tag>二分答案</tag>
        <tag>MST</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1972 【SDOI2010】 猪国杀]]></title>
    <url>%2FBZOJ1972%E3%80%90SDOI2010%E3%80%91%E7%8C%AA%E5%9B%BD%E6%9D%80%20%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2010】猪国杀Time Limit: Memory Limit: 题目描述 Description 概述《猪国杀》是一种多猪牌类回合制游戏，一共有三种角色：主猪，忠猪，反猪。 每局游戏主猪有且只有一只，忠猪和反猪可以有多只，每只猪扮演一种角色。 游戏目的：·主猪（MP）：自己存活的情况下消灭所有的反猪。 ·忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。 ·反猪（FP）：杀死主猪。 游戏过程：·游戏开始时候，每个玩家手里都会有4张牌，且体力上限和初始体力都是4。 ·开始游戏时，从主猪开始，按照逆时针方向（数据中就是按照编号从1,2,3..n,1..的顺序）依次行动。 ·每个玩家自己的回合可以分为2个阶段： ·摸牌阶段： ·从牌堆顶部摸两张牌，依次放到手牌的最右边。 ·出牌阶段： ·你可以使用0张到任意张牌，每次使用牌的时候都使用最靠左的能够使用的牌。 ·当然，要满足如下规则： ·1.如果没有猪哥连弩，每个出牌阶段只能使用一次“杀”来攻击。 ·2.任何牌被使用后被弃置（武器是装备上）。 ·被弃置的牌以后都不能再用，即与游戏无关。 各种牌介绍：·每张手牌用一个字母表示，字母代表牌的种类。 ·基本牌： 『桃(P)』： ·在自己的回合内，如果自己的体力值不等于体力上限，那么使用一个桃可以为自己补充一点体力，否则不能使用桃。 ·桃只能对自己使用。 ·在自己的回合外，如果自己的血变为0或者更低，那么也可以使用。 『杀(K)』： ·在自己的回合内，对攻击范围内除自己以外的一名角色使用。 ·如果没有被『闪』抵消，则造成1点伤害。无论有无武器，杀的攻击范围都是1。 『闪(D)』： ·当你受到杀的攻击时，可以弃置一张闪来抵消杀的效果。 ·锦囊牌： 『决斗(F)』： ·出牌阶段，对除自己以外任意一名角色使用，由目标角色先开始，自己和目标角色轮流弃置一张杀，首先没有杀可弃的一方受到1点伤害，另一方视为此伤害的来源。 『南猪入侵(N)』： ·出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置一张杀，否则受到1点伤害。 『万箭齐发(W)』： ·和南猪入侵类似，不过要弃置的不是杀而是闪。 『无懈可击(J)』： ·在目标锦囊生效前抵消其效果。 ·每次有一张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会。 ·效果： ·用于决斗时，决斗无效并弃置。 ·用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对一个角色产生效果）。 ·用于无懈可击时，成为目标的无懈可击被无效。 ·装备牌： 『猪哥连弩(Z)』： ·武器，攻击范围1，出牌阶段你可以使用任意张杀。 ·同一时刻最多只能装一个武器。 ·如果先前已经有了一把武器，那么之后再装武器的话，会弃置以前的武器来装现在的武器。 特殊事件及概念解释：·伤害来源： ·杀、南猪入侵、万箭齐发的伤害来源均是使用该牌的猪。 ·决斗的伤害来源如上。 ·距离： ·两只猪的距离定义为沿着逆时针方向间隔的猪数＋1。即初始时1和2的距离为1，但是2和1的距离就是n-1。 ·注意一个角色的死亡会导致一些猪距离的改变； ·玩家死亡： ·如果该玩家的体力降到0或者更低，并且自己手中没有足够的桃使得自己的体力值回到1，那么就死亡了。 ·死亡后所有的牌（装备区，手牌区）被弃置。 ·奖励与惩罚： ·反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸三张牌。 ·忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置。 ·注意，一旦达成胜利条件，游戏立刻结束，因此即使会摸3张牌或者还有牌可以用也不用执行了。 几种行为：·献殷勤： ·使用无懈可击挡下南猪入侵、万箭齐发、决斗。 ·使用无懈可击抵消表敌意。 ·表敌意： ·对某个角色使用杀、决斗。 ·使用无懈可击抵消献殷勤。 ·跳忠： ·即通过行动表示自己是忠猪。 ·跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意。 ·跳反： ·即通过行动表示自己是反猪。 ·跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤。 ·忠猪不会跳反，反猪也不会跳忠。 ·不管是忠猪还是反猪，能够跳必然跳。 行动准则：·共性： ·每个角色如果手里有桃且生命值未满，那么必然吃掉。 ·有南猪入侵、万箭齐发、必然使用。 ·有装备必然装上。 ·受到杀时，有闪必然弃置。 ·响应南猪入侵或者万箭齐发时候，有杀/闪必然弃置。 ·不会对未表明身份的猪献殷勤（包括自己）。 ·特性： ·主猪： ·主猪会认为没有跳身份，且用南猪入侵/万箭齐发对自己造成伤害的猪是类反猪（没伤害到不算，注意类反猪并没有表明身份），如果之后跳了，那么主猪会重新认识这只猪。 ·对于每种表敌意的方式，对逆时针方向能够执行到的第一只类反猪或者已跳反猪表；如果没有，那么就不表敌意。 ·决斗时会不遗余力弃置杀。 ·如果能对已经跳忠的猪或自己献殷勤，那么一定献。 ·如果能够对已经跳反的猪表敌意，那么一定表。 ·忠猪： ·对于每种表敌意的方式，对逆时针方向能够执行到的第一只已经跳反的猪表，如果没有，那么就不表敌意。 ·决斗时，如果对方是主猪，那么不会弃置杀，否则，会不遗余力弃置杀。 ·如果有机会对主猪或者已经跳忠的猪献殷勤，那么一定献。 ·反猪： ·对于每种表敌意的方式，如果有机会则对主猪表，否则，对逆时针方向能够执行到的第一只已经跳忠的猪表，如果没有，那么就不表敌意。 ·决斗时会不遗余力弃置杀。 ·如果有机会对已经跳反的猪献殷勤，那么一定献。 现在，我们已经知道每只猪的角色、手牌，还有牌堆初始情况，并且假设每个角色会按照如下的行为准则进行游戏，你需要做的就是告诉小猪 最后的结果。限于 只会用 语言写 ，他请你用 、 或 语言来帮他预测最后的结果。 输入描述 Input Description输入文件第一行包含两个正整数 ( )和 ( )，分别代表玩家数和牌堆中牌的数量。数据保证牌的数量够用。接下来 行，每行 个字符串，依次表示对第 只猪的角色和初始 张手牌描述。编号为 的肯定是主猪。再接下来一行，一共 个字符串，按照从牌堆顶部到牌堆底部的顺序描述每张牌。所有的相邻的两个字符串都严格用 个空格隔开，行尾没有多余空格。 输出描述 Output Description输出数据第一行包含一个字符串代表游戏结果。如果是主猪胜利，那么输出 ，否则输出 。数据保证游戏总会结束。接下来 行，第 行是对第 只猪的手牌描述（注意只需要输出手牌），按照手牌从左往右的顺序输出，相邻两张牌用一个空格隔开，行末尾没有多余空格。如果这只猪已阵亡，那么只要输出 即可。注意如果要输出手牌而没有手牌的话，那么只需输出一个空行。 样例数据 Sample DataSample Input #1123453 10MP D D F FZP N N N DFP J J J JF F D D J J F F K D Sample Output #11234FPDEADDEADJ J J J J J D 数据范围及提示 Data Size &amp; Hint样例 说明：第一回合主猪没有目标可以表敌意；接下来忠猪使用了 张南猪入侵，主猪掉了 点体力，并认为该角色为类反猪， 号角色尽管手里有无懈可击，但是因为自己未表明身份，所以同样不能对自己用，乖乖掉 点体力；下一回合反猪无牌可出；接下来主猪对着类反猪爆发，使用 张决斗，忠猪死亡，结果主猪弃掉所有牌；下来反猪摸到一张杀直接杀死主猪获胜。数据说明：一共 组测试数据，每个点 分。 的数据没有锦囊牌，另外 的数据没有无懈可击。 如果觉得此题面不好看，请戳这里：https://mubu.com/doc/2707815814591da4 标签：模拟 Solution本题是大模拟，题面很恶心，又长又绕，根本无法概括，不过读懂以后按序操作还是比较容易的。坑点如下： 如果牌堆中没牌了，那么需要不断的摸取最后一张牌 无懈可击的使用：可以用来帮助身份已明且和自己一伙的人抵挡南猪入侵、万箭齐发、决杀等效果，或者帮助其抵消对方无懈可击的效果。一旦使出无懈可击即可表明自己的身份，表明身份后类反猪的身份会随之消失。注意无懈可击的使用顺序是从锦囊牌的出牌者开始按照逆时针的顺序进行出牌的。 一只猪死亡后立刻退场，不会再进行任何操作，所有手牌弃置。如果此时游戏结束，那么一切操作都暂停。 出完一张牌后（除桃）需要重新扫描所有的手牌，因为每次出牌可能会导致不同的猪身份的改变，进而前面跳过的牌可能有机会打出。 寻找打出杀得下家时要跳过已经死亡的猪。 打出决斗，无论最后是否生效，即认为身份表面。对于主猪对忠猪发起的决斗，忠猪乖乖掉血。 奉献几组样例，可以自测： Sample #1Input123453 10MP D D F FZP N N N DFP J J J JF F D D J J F F K D Output1234FPDEADDEADJ J J J J J D Sample #2Input12345675 10MP W D F KZP N N D DFP F W W KZP K K N DFP K D P WJ K W K D N N K J N Output12345MPF NDDEADDEAD Sample #3Input123453 4MP J J K NZP J D K WFP P N P KJ J K W Output123MPK KDEAD Sample #4Input123453 10MP W D J WZP J P D NFP N D F FJ D N N F J J D K W Output123MPD J DDEAD Sample #5Input123453 1MP D N F KZP F W F NFP D N N DK Output1234MPKF K KDEAD Code注释版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 10#define MAX_M 2000using namespace std;int n, m, Type[MAX_N+5]; //真实身份（1主公 2忠臣 3反贼）int lft; bool GameOver; //剩余反贼、游戏结束标记char Heap[MAX_M*2+5]; int CurPos; //牌堆int bef[MAX_M*5+5], nxt[MAX_M*5+5], cnt; char c[MAX_M*5+5]; //手牌char Draw() {CurPos = CurPos == m ? m : CurPos+1; return Heap[CurPos];} //摸牌void Attack(int, int); void Duel(int, int); void Invade(int); void Arrow(int);struct Player { int id, Sta; //编号、目前身份（0没跳 1类反 2跳忠 3跳反） int head, tail, now, tp; //手牌链表 int cntWX, cntA, cntP, cntS; //手中无懈可击、杀、桃、闪的数量 int blood, atk, pre, suc; //血量、首要攻击目标、存活的上一头猪、存活的下一头猪 bool dead, equip; //是否死亡、是否装备连弩 void Bonus() { //奖励 c[++cnt] = Draw(), bef[cnt] = tail; if (head == 0) head = tail = cnt; else nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; } void Punish() { //惩罚 head = tail = now = cntWX = cntA = cntP = cntS = 0, equip = false; } void DrawSession() { //摸牌阶段 c[++cnt] = Draw(), bef[cnt] = tail; if (head == 0) head = tail = cnt; else nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; } void Use(int x) { //使用一张牌 if (c[x] == 'J') cntWX--; if (c[x] == 'K') cntA--; if (c[x] == 'P') cntP--; if (c[x] == 'D') cntS--; if (x == head &amp;&amp; x == tail) head = tail = 0; else if (x == head) head = nxt[x], bef[nxt[x]] = 0; else if (x == tail) tail = bef[x], nxt[bef[x]] = 0; else bef[nxt[x]] = bef[x], nxt[bef[x]] = nxt[x]; } char GetNxt() { //返回下一张牌 if (!now) return 0; tp = now, now = nxt[now]; return c[tp]; } int findWX() { //找下一张无懈可击 now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'J') return tp; return 0; } int findA() { //找下一张杀 now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'K') return tp; return 0; } int findP() { //找下一张桃 now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'P') return tp; return 0; } int findS() { //找下一张闪 now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'D') return tp; return 0; } bool tryWX() { //尝试出无懈可击 if (cntWX) {Use(findWX()); return true;} return false; } bool tryA() { //尝试出杀 if (cntA) {Use(findA()); return true;} return false; } bool tryS() { //尝试出闪 if (cntS) {Use(findS()); return true;} return false; } bool tryP() { //尝试出桃 if (cntP) {Use(findP()); return true;} return false; } void Round() { DrawSession(); now = head; bool atked = false; char tmp; while ((tmp = GetNxt()) &amp;&amp; !GameOver) { //cout &lt;&lt; tmp &lt;&lt; " "; if (tmp == 'D' || tmp == 'J') continue; if (tmp == 'K' &amp;&amp; atk == suc &amp;&amp; (!atked || equip)) { Use(tp), Attack(id, atk), now = head, atked = true; if (GameOver) return; } if (tmp == 'P' &amp;&amp; blood != 4) Use(tp), blood++; if (tmp == 'F') { if (!atk) continue; Use(tp); if (Type[id] == 3) Duel(id, 1); else Duel(id, atk); now = head; if (GameOver || dead) return; } if (tmp == 'N') { Use(tp), Invade(id), now = head; if (GameOver) return; } if (tmp == 'W') { Use(tp), Arrow(id), now = head; if (GameOver) return; } if (tmp == 'Z') Use(tp), equip = true, now = head; } //cout &lt;&lt; endl; } void Output() { if (dead) {printf("DEAD\n"); return;} for (; head; head = nxt[head]) if (head == tail) cout &lt;&lt; c[head]; else cout &lt;&lt; c[head] &lt;&lt; ' '; printf("\n"); }} pig[MAX_N+5];void FindAtk(int x) { int y = pig[x].suc; if (Type[x] == 1) { while (y != x) { if (pig[y].Sta == 1 || pig[y].Sta == 3) { pig[x].atk = y; return; } y = pig[y].suc; } pig[x].atk = 0; } if (Type[x] == 2) { while (y != x) { if (pig[y].Sta == 3) { pig[x].atk = y; return; } y = pig[y].suc; } pig[x].atk = 0; } if (Type[x] == 3) { while (y != x) { if (Type[y] == 1 || pig[y].Sta == 2) { pig[x].atk = y; return; } y = pig[y].suc; } pig[x].atk = 0; }}void Maintain() { int x = pig[1].suc; FindAtk(1); while (x != 1) FindAtk(x), x = pig[x].suc;}void Kill(int x, int y) { //杀死对方 pig[y].dead = true; if (Type[y] == 1) {GameOver = true; return;} if (Type[y] == 3) { if (--lft == 0) {GameOver = true; return;} pig[x].Bonus(); } if (Type[x] == 1 &amp;&amp; Type[y] == 2) pig[x].Punish(); int PRE = pig[y].pre, SUC = pig[y].suc; pig[PRE].suc = SUC, pig[SUC].pre = PRE; Maintain();}void Hurt(int x, int y) { //命中对方 if (--pig[y].blood == 0) if (pig[y].tryP()) pig[y].blood++; else Kill(x, y);}void Attack(int x, int y) { //杀 if (Type[x] != 1 &amp;&amp; pig[x].Sta &lt; 2) { if (Type[y] == 3) pig[x].Sta = 2; else pig[x].Sta = 3; Maintain(); } if (!pig[y].tryS()) Hurt(x, y);}bool WXcycle(int st, bool YType) { //无懈可击 int last = st, x = st; bool ORI = YType; if (YType == (Type[x] == 3) &amp;&amp; pig[x].tryWX()) { last = x, YType ^= 1; if (pig[x].Sta &lt;= 2) pig[x].Sta = 3-YType, Maintain(); } x = pig[x].suc; while (x != last) { if (YType == (Type[x] == 3) &amp;&amp; pig[x].tryWX()) { last = x, YType ^= 1; if (pig[x].Sta &lt;= 2) pig[x].Sta = 3-YType, Maintain(); } x = pig[x].suc; } return ORI != YType;}void Duel(int x, int y) { //决斗 if (Type[x] != 1 &amp;&amp; pig[x].Sta &lt; 2) { if (Type[y] == 3) pig[x].Sta = 2; else pig[x].Sta = 3; Maintain(); } if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) { if (WXcycle(x, 0)) return; } else { if (WXcycle(x, 1)) return; } if (Type[x] == 1 &amp;&amp; Type[y] == 2) Hurt(x, y); else for (;;) { if (!pig[y].tryA()) {Hurt(x, y); return;} if (!pig[x].tryA()) {Hurt(y, x); return;} }}void Invade(int x) { //南猪入侵 int y = pig[x].suc; while (y != x) { if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) { if (WXcycle(x, 0)) {y = pig[y].suc; continue;} } else { if (WXcycle(x, 1)) {y = pig[y].suc; continue;} } if (!pig[y].tryA()) { Hurt(x, y); if (GameOver) return; if (y == 1 &amp;&amp; pig[x].Sta == 0) pig[x].Sta = 1, Maintain(); } y = pig[y].suc; }}void Arrow(int x) { //万箭齐发 int y = pig[x].suc; while (y != x) { if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) { if (WXcycle(x, 0)) {y = pig[y].suc; continue;} } else { if (WXcycle(x, 1)) {y = pig[y].suc; continue;} } if (!pig[y].tryS()) { Hurt(x, y); if (GameOver) return; if (y == 1 &amp;&amp; pig[x].Sta == 0) pig[x].Sta = 1, Maintain(); } y = pig[y].suc; }}int main() { scanf("%d%d", &amp;n, &amp;m); char s[2]; int tot = 0; for (int i = n; i &gt; 1; i--) pig[i].pre = i-1; pig[1].pre = n; for (int i = 1; i &lt; n; i++) pig[i].suc = i+1; pig[n].suc = 1; for (int i = 1; i &lt;= n; i++) { scanf("%s", s); if (s[0] == 'M') Type[i] = 1; if (s[0] == 'Z') Type[i] = 2; if (s[0] == 'F') Type[i] = 3, lft++; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; } for (int i = 1; i &lt;= m; i++) scanf("%s", s), Heap[++tot] = s[0]; m = tot; Maintain(); for (int i = 1; i &lt;= n; i++) pig[i].id = i, pig[i].blood = 4, pig[i].DrawSession(), pig[i].DrawSession(); for (int cur = 1; !GameOver; cur = pig[cur].suc) pig[cur].Round(); printf("%s\n", pig[1].dead ? "FP" : "MP"); for (int i = 1; i &lt;= n; i++) pig[i].Output(); return 0;} 压行版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 10#define MAX_M 2000using namespace std;int n, m, Type[MAX_N+5], lft, CurPos, cnt; bool GameOver;char Heap[MAX_M*2+5], c[MAX_M*5+5]; int bef[MAX_M*5+5], nxt[MAX_M*5+5];char Draw() {CurPos = CurPos == m ? m : CurPos+1; return Heap[CurPos];}void Attack(int, int); void Duel(int, int); void Invade(int); void Arrow(int);struct Player { int id, Sta, head, tail, now, tp, cntWX, cntA, cntP, cntS, blood, atk, pre, suc; bool dead, equip; void Bonus() { c[++cnt] = Draw(), bef[cnt] = tail; if (head == 0) head = tail = cnt; else nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; } void Punish() {head = tail = now = cntWX = cntA = cntP = cntS = 0, equip = false;} void DrawSession() { c[++cnt] = Draw(), bef[cnt] = tail; if (head == 0) head = tail = cnt; else nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; } void Use(int x) { if (c[x] == 'J') cntWX--; if (c[x] == 'K') cntA--; if (c[x] == 'P') cntP--; if (c[x] == 'D') cntS--; if (x == head &amp;&amp; x == tail) head = tail = 0; else if (x == head) head = nxt[x], bef[nxt[x]] = 0; else if (x == tail) tail = bef[x], nxt[bef[x]] = 0; else bef[nxt[x]] = bef[x], nxt[bef[x]] = nxt[x]; } char GetNxt() {if (!now) return 0; tp = now, now = nxt[now]; return c[tp];} int findWX() {now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'J') return tp; return 0;} int findA() {now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'K') return tp; return 0;} int findP() {now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'P') return tp; return 0;} int findS() {now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'D') return tp; return 0;} bool tryWX() {if (cntWX) {Use(findWX()); return true;} return false;} bool tryA() {if (cntA) {Use(findA()); return true;} return false;} bool tryS() {if (cntS) {Use(findS()); return true;} return false;} bool tryP() {if (cntP) {Use(findP()); return true;} return false;} void Round() { DrawSession(); now = head; bool atked = false; char tmp; while ((tmp = GetNxt()) &amp;&amp; !GameOver) { if (tmp == 'D' || tmp == 'J') continue; if (tmp == 'K' &amp;&amp; atk == suc &amp;&amp; (!atked || equip)) {Use(tp), Attack(id, atk), now = head, atked = true; if (GameOver) return;} if (tmp == 'P' &amp;&amp; blood != 4) Use(tp), blood++; if (tmp == 'F') { if (!atk) continue; Use(tp); if (Type[id] == 3) Duel(id, 1); else Duel(id, atk); now = head; if (GameOver || dead) return; } if (tmp == 'N') {Use(tp), Invade(id), now = head; if (GameOver) return;} if (tmp == 'W') {Use(tp), Arrow(id), now = head; if (GameOver) return;} if (tmp == 'Z') Use(tp), equip = true, now = head; } } void Output() { if (dead) {printf("DEAD\n"); return;} for (; head; head = nxt[head]) if (head == tail) cout &lt;&lt; c[head]; else cout &lt;&lt; c[head] &lt;&lt; ' '; printf("\n"); }} pig[MAX_N+5];void FindAtk(int x) { int y = pig[x].suc; if (Type[x] == 1) { while (y != x) {if (pig[y].Sta == 1 || pig[y].Sta == 3) {pig[x].atk = y; return;} y = pig[y].suc;} pig[x].atk = 0; } if (Type[x] == 2) { while (y != x) {if (pig[y].Sta == 3) {pig[x].atk = y; return;} y = pig[y].suc;} pig[x].atk = 0; } if (Type[x] == 3) { while (y != x) {if (Type[y] == 1 || pig[y].Sta == 2) {pig[x].atk = y; return;} y = pig[y].suc;} pig[x].atk = 0; }}void Maintain() {int x = pig[1].suc; FindAtk(1); while (x != 1) FindAtk(x), x = pig[x].suc;}void Kill(int x, int y) { pig[y].dead = true; if (Type[y] == 1) {GameOver = true; return;} if (Type[y] == 3) {if (--lft == 0) {GameOver = true; return;} pig[x].Bonus();} if (Type[x] == 1 &amp;&amp; Type[y] == 2) pig[x].Punish(); int PRE = pig[y].pre, SUC = pig[y].suc; pig[PRE].suc = SUC, pig[SUC].pre = PRE; Maintain();}void Hurt(int x, int y) {if (--pig[y].blood == 0) if (pig[y].tryP()) pig[y].blood++; else Kill(x, y);}void Attack(int x, int y) { if (Type[x] != 1 &amp;&amp; pig[x].Sta &lt; 2) { if (Type[y] == 3) pig[x].Sta = 2; else pig[x].Sta = 3; Maintain(); } if (!pig[y].tryS()) Hurt(x, y);}bool WXcycle(int st, bool YType) { int last = st, x = st; bool ORI = YType; if (YType == (Type[x] == 3) &amp;&amp; pig[x].tryWX()) {last = x, YType ^= 1; if (pig[x].Sta &lt;= 2) pig[x].Sta = 3-YType, Maintain();} x = pig[x].suc; while (x != last) { if (YType == (Type[x] == 3) &amp;&amp; pig[x].tryWX()) {last = x, YType ^= 1; if (pig[x].Sta &lt;= 2) pig[x].Sta = 3-YType, Maintain();} x = pig[x].suc; } return ORI != YType;}void Duel(int x, int y) { if (Type[x] != 1 &amp;&amp; pig[x].Sta &lt; 2) {if (Type[y] == 3) pig[x].Sta = 2; else pig[x].Sta = 3; Maintain();} if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) {if (WXcycle(x, 0)) return;} else {if (WXcycle(x, 1)) return;} if (Type[x] == 1 &amp;&amp; Type[y] == 2) Hurt(x, y); else for (;;) {if (!pig[y].tryA()) {Hurt(x, y); return;} if (!pig[x].tryA()) {Hurt(y, x); return;}}}void Invade(int x) { int y = pig[x].suc; while (y != x) { if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) {if (WXcycle(x, 0)) {y = pig[y].suc; continue;}} else {if (WXcycle(x, 1)) {y = pig[y].suc; continue;}} if (!pig[y].tryA()) { Hurt(x, y); if (GameOver) return; if (y == 1 &amp;&amp; pig[x].Sta == 0) pig[x].Sta = 1, Maintain(); } y = pig[y].suc; }}void Arrow(int x) { int y = pig[x].suc; while (y != x) { if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) {if (WXcycle(x, 0)) {y = pig[y].suc; continue;}} else {if (WXcycle(x, 1)) {y = pig[y].suc; continue;}} if (!pig[y].tryS()) { Hurt(x, y); if (GameOver) return; if (y == 1 &amp;&amp; pig[x].Sta == 0) pig[x].Sta = 1, Maintain(); } y = pig[y].suc; }}int main() { scanf("%d%d", &amp;n, &amp;m); char s[2]; int tot = 0; for (int i = n; i &gt; 1; i--) pig[i].pre = i-1; pig[1].pre = n; for (int i = 1; i &lt; n; i++) pig[i].suc = i+1; pig[n].suc = 1; for (int i = 1; i &lt;= n; i++) { scanf("%s", s); if (s[0] == 'M') Type[i] = 1; if (s[0] == 'Z') Type[i] = 2; if (s[0] == 'F') Type[i] = 3, lft++; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; } for (int i = 1; i &lt;= m; i++) scanf("%s", s), Heap[++tot] = s[0]; m = tot; Maintain(); for (int i = 1; i &lt;= n; i++) pig[i].id = i, pig[i].blood = 4, pig[i].DrawSession(), pig[i].DrawSession(); for (int cur = 1; !GameOver; cur = pig[cur].suc) pig[cur].Round(); printf("%s\n", pig[1].dead ? "FP" : "MP"); for (int i = 1; i &lt;= n; i++) pig[i].Output(); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4757 Tree < LCA+可持久化Trie >]]></title>
    <url>%2FHDU4757%20Tree%20LCA%2B%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie%2F</url>
    <content type="text"><![CDATA[ProblemTreeDescriptionZero and One are good friends who always have fun with each other.This time, they decide to do something on a tree which is a kind of graph that there is only one path from node to node. First, Zero will give One an tree and every node in this tree has a value. Then, Zero will ask One a series of queries. Each query contains three parameters: , , which mean that he want to know the maximum value produced by each value on the path from node to node (include node , node ). Unfortunately, One has no idea in this question. So he need you to solve it. InputThere are several test cases and the cases end with . For each case:The first line contains two integers and , which are the amount of tree’s nodes and queries, respectively.The second line contains integers and is the value on the node.The next lines contains two integers , which means there is an connection between and .The next m lines contains three integers , which are the parameters of Zero’s query. OutputFor each query, output the answer. Sample Input1234563 21 2 21 22 31 3 12 3 2 Sample Output1230 Translation给出一棵树，求两点 间树上链路中的数异或 得到的最大结果。 标签：LCA 可持久化Trie Solution最大异或和上树…有异或，一个经典的解法就是建一棵 字典树，然后贪心跑一遍，尽量选和给出数当前位不同的数。对于树上的此类问题，可以把Trie树可持久化，对于每个点，存它到根节点的路径上所有数的Trie树，这样是有前缀和性质的，求 后作差即可求出链路上的数。可持久化方法和主席树差不多。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define MAX_N 100000#define MAX_D 15using namespace std;int n, m, cnt, c[MAX_N+5], root[MAX_N+5];int anc[MAX_N+5][MAX_D+5], dep[MAX_N+5];bool vis[MAX_N+5];vector &lt;int&gt; G[MAX_N+5];struct node {int ls, rs, size;} trie[MAX_N*20+500];void init() { root[0] = cnt = 0; memset(root, 0, sizeof(root)); memset(anc, 0, sizeof(anc)); memset(dep, 0, sizeof(dep)); memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) G[i].clear();}void DFS(int u) { vis[u] = true; for (int i = 1; (1&lt;&lt;i) &lt;= dep[u]; i++) anc[u][i] = anc[anc[u][i-1]][i-1]; for (int i = 0; i &lt; G[u].size(); i++) if (!vis[G[u][i]]) anc[G[u][i]][0] = u, dep[G[u][i]] = dep[u]+1, DFS(G[u][i]);}int LCA(int a, int b) { int i, j; if (dep[a] &lt; dep[b]) swap(a, b); for (i = 0; (1&lt;&lt;i) &lt;= dep[a]; i++) ; i--; for (j = i; j &gt;= 0; j--) if (dep[a]-(1&lt;&lt;j) &gt;= dep[b]) a = anc[a][j]; if (a == b) return a; for (j = i; j &gt;= 0; j--) if (anc[a][j] != anc[b][j]) a = anc[a][j], b = anc[b][j]; return anc[a][0];}void insert(int v, int o, int val, int range) { trie[v] = trie[o]; if (range == 0) {trie[v].size++; return;} int x = val/range; if (x == 0) insert(trie[v].ls = ++cnt, trie[o].ls, val%range, range/2); else insert(trie[v].rs = ++cnt, trie[o].rs, val%range, range/2); trie[v].size = trie[trie[v].ls].size+trie[trie[v].rs].size;}void build(int u) { root[u] = ++cnt; insert(root[u], root[anc[u][0]], c[u], (1&lt;&lt;MAX_D)); for (int i = 0; i &lt; G[u].size(); i++) if (G[u][i] != anc[u][0]) build(G[u][i]);}int query(int v1, int v2, int v3, int v4, int x, int range) { if (range == 0) return 0; int tmp1 = trie[trie[v1].ls].size+trie[trie[v2].ls].size-trie[trie[v3].ls].size-trie[trie[v4].ls].size; int tmp2 = trie[trie[v1].rs].size+trie[trie[v2].rs].size-trie[trie[v3].rs].size-trie[trie[v4].rs].size; if (x/range == 0) { if (tmp2) return range+query(trie[v1].rs, trie[v2].rs, trie[v3].rs, trie[v4].rs, x%range, range/2); else return query(trie[v1].ls, trie[v2].ls, trie[v3].ls, trie[v4].ls, x%range, range/2); } else { if (tmp1) return range+query(trie[v1].ls, trie[v2].ls, trie[v3].ls, trie[v4].ls, x%range, range/2); else return query(trie[v1].rs, trie[v2].rs, trie[v3].rs, trie[v4].rs, x%range, range/2); }}int main() { while (scanf("%d%d", &amp;n, &amp;m) != EOF) { init(); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) {int u, v; scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u);} DFS(1); build(1); while (m--) { int u, v, x, lca; scanf("%d%d%d", &amp;u, &amp;v, &amp;x); lca = LCA(u, v); printf("%d\n", query(root[u], root[v], root[lca], root[anc[lca][0]], x, (1&lt;&lt;MAX_D))); } for (int i = 1; i &lt;= cnt; i++) trie[i].ls = trie[i].rs = trie[i].size = 0; } return 0;}]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LCA</tag>
        <tag>HDU</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1070【SCOI2007】修车]]></title>
    <url>%2FBZOJ1070%E3%80%90SCOI2007%E3%80%91%E4%BF%AE%E8%BD%A6%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2007】修车 Description同一时刻有 位车主带着他们的爱车来到了汽车维修中心。维修中心共有 位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这 位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 Input第一行有两个 ，表示技术人员数与顾客数。 接下来 行，每行 个整数。第 行第 个数表示第 位技术人员维修第 辆车需要用的时间 。 Output最小平均等待时间，答案精确到小数点后 位。 Sample Input1232 23 21 4 Sample Output11.50 HINT数据范围: , , 标签：费用流 Solution此题建模是费用流中常见的拆点建模。把每个技术人员拆成 个点，第 个点代表着此工作人员修的倒数第 辆车对答案的贡献。对于每个顾客，如果他倒数第 个修车，花费 的时间，会对答案产生 的贡献。因此从每个顾客向每个技术人员的 个点连边，容量为 ，花费为 ，然后跑费用流即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 10000#define MAX_M 200000#define INF 2147483647using namespace std;int n, m, s, t, ans, a[65][10];int pre[MAX_N+5], cnt;struct node {int v, c, w, nxt;} E[MAX_M+5];void init() {s = 0, t = n*m+n+1, cnt = 0; memset(pre, -1, sizeof(pre));}void insert(int u, int v, int c, int w) { E[cnt].v = v, E[cnt].c = c, E[cnt].w = w, E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0, E[cnt].w =-w, E[cnt].nxt = pre[v], pre[v] = cnt++;}bool SPFA() { queue &lt;int&gt; que; bool inque[MAX_N+5]; int dis[MAX_N+5], pree[MAX_N+5]; memset(inque, false, sizeof(inque)), memset(pree, -1, sizeof(pree)); for (int i = s; i &lt;= t; i++) dis[i] = INF; dis[s] = 0, que.push(s), inque[s] = true; while (!que.empty()) { int u = que.front(); que.pop(), inque[u] = false; for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; dis[u]+w &lt; dis[v]) { dis[v] = dis[u]+w, pree[v] = i; if (!inque[v]) que.push(v), inque[v] = true; } } } if (dis[t] == INF) return false; int flow = INF; for (int i = pree[t]; ~i; i = pree[E[i^1].v]) flow = min(flow, E[i].c); for (int i = pree[t]; ~i; i = pree[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; ans += dis[t]; return true;}int main() { scanf("%d%d", &amp;m, &amp;n), init(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[i][j]); for (int i = 1; i &lt;= n; i++) insert(s, i, 1, 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= n; k++) insert(i, j*n+k, 1, a[i][j]*k); for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= n; k++) insert(j*n+k, t, 1, 0); while (SPFA()) ; printf("%.2lf", (double)ans/n); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2466【中山市选2009】树]]></title>
    <url>%2FBZOJ2466%E3%80%90%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892009%E3%80%91%E6%A0%91%20%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[Problem【中山市选2009】树 Description图论中的树为一个无环的无向图。给定一棵树，每个节点有一盏指示灯和一个按钮。如果节点的按扭被按了，那么该节点的灯会从熄灭变为点亮（当按之前是熄灭的），或者从点亮到熄灭（当按之前是点亮的），并且该节点的直接邻居也发生同样的变化。开始的时候，所有的指示灯都是熄灭的。请编程计算最少要按多少次按钮，才能让所有节点的指示灯变为点亮状态。 Input输入文件有多组数据。输入第一行包含一个整数 ，表示树的节点数目。每个节点的编号从 到 。输入接下来的 行，每一行包含两个整数 ， ，表示节点 和 之间有一条无向边。当输入 为 时，表示输入结束。 Output对于每组数据，输出最少要按多少次按钮，才能让所有节点的指示灯变为点亮状态。每一组数据独占一行。 Sample Input123431 21 30 Sample Output11 HINT对于 的数据，满足 。 标签：高斯消元 Solution将所有节点按的次数设为 ，会得到一个线性异或方程组。这时可以 高 消 水过。 不懂高消可以戳这里。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#define MAX_N 100using namespace std;int n, x[MAX_N+5], num[MAX_N+5], cnt;bitset &lt;MAX_N+5&gt; f[MAX_N+5];void init() {cnt = 0; for (int i = 1; i &lt;= n; i++) f[i].reset(), f[i][i] = f[i][n+1] = 1;}void gauss() { int cur = 1; for (int i = 1, tmp; i &lt;= n; i++) { for (tmp = cur; tmp &lt;= n; tmp++) if (f[tmp][i] == 1) break; if (tmp &gt; n) {num[cnt++] = i; continue;} swap(f[cur], f[tmp]); for (int j = 1; j &lt;= n; j++) if (j != cur &amp;&amp; f[j][i]) f[j] ^= f[cur]; cur++; }}int calc(int sta) { int ret = 0; for (int i = 1; i &lt;= n; i++) x[i] = f[i][n+1]; for (int i = 0; i &lt; cnt; i++) { if (!(sta&amp;(1&lt;&lt;i))) continue; ret++; for (int j = 1; j &lt;= n; j++) if (f[j][num[i]]) x[j] ^= 1; } for (int i = 1; i &lt;= n; i++) ret += x[i]; return ret;}int main() { while (scanf("%d", &amp;n) &amp;&amp; n != 0) { init(); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), f[u][v] = f[v][u] = 1; gauss(); int ans = n; for (int sta = 0; sta &lt; (1&lt;&lt;cnt); sta++) ans = min(ans, calc(sta)); printf("%d\n", ans); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1001【BJOI2006】狼抓兔子]]></title>
    <url>%2FBZOJ1001%E3%80%90BJOI2006%E3%80%91%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【BJOI2006】狼抓兔子 Description现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对一个网格的地形：左上角点为 ,右下角点为 .有以下三种类型的道路 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 的窝里，现在它们要跑到右下解 的窝中去，狼王开始伏击些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为 ，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. Input第一行为 .表示网格的大小， 均小于等于 .接下来分三部分第一部分共 行，每行 个数，表示横向道路的权值.第二部分共 行，每行 个数，表示纵向道路的权值.第三部分共 行，每行 个数，表示斜向道路的权值.输入文件保证不超过 Output输出一个整数，表示参与伏击的狼的最小数量. Sample Input123456783 45 6 44 3 17 5 35 6 7 88 7 6 55 5 56 6 6 Sample Output114 HINT 新加数据一组，可能会卡掉从前可以过的程序。 标签：网络流 Solution此题是裸的网络流，看看数据范围，再看看时限，很容易发现直接 最小割可过。其实还可以用对偶图上跑最短路做，貌似特判有点多，不太好写，但是要快一些，艹榜可用。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define INF 0x7fffffffusing namespace std;struct node {int v, c, nxt;} E[12000005];int n, m, pre[1000005], d[1000005], cnt;void init() {cnt = 0, memset(pre, -1, sizeof(pre));}void insert(int u, int v, int c) { E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0, E[cnt].nxt = pre[v], pre[v] = cnt++;}bool BFS() { memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(1), d[1] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return d[n*m] != -1;}int DFS(int u, int flow) { if (u == n*m) return flow; int ret = 0; for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); flow -= tmp, ret += tmp, E[i].c -= tmp, E[i^1].c += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() {int ret = 0; while (BFS()) ret += DFS(1, INF); return ret;}int main() { scanf("%d%d", &amp;n, &amp;m), init(); for (int i = 1; i &lt;= n; i++) for (int j = 1, x; j &lt; m; j++) scanf("%d", &amp;x), insert(m*(i-1)+j, m*(i-1)+j+1, x), insert(m*(i-1)+j+1, m*(i-1)+j, x); for (int i = 1; i &lt; n; i++) for (int j = 1, x; j &lt;= m; j++) scanf("%d", &amp;x), insert(m*(i-1)+j, m*i+j, x), insert(m*i+j, m*(i-1)+j, x); for (int i = 1; i &lt; n; i++) for (int j = 1, x; j &lt; m; j++) scanf("%d", &amp;x), insert(m*(i-1)+j, m*i+j+1, x), insert(m*i+j+1, m*(i-1)+j, x); printf("%d", Dinic()); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3207 Ikki's Story IV - Panda's Trick < 2-SAT >]]></title>
    <url>%2FPOJ3207%20Ikki's%20Story%20IV%20-%20Panda's%20Trick%202-SAT%2F</url>
    <content type="text"><![CDATA[ProblemIkki’s Story IV - Panda’s TrickDescriptionliympanda, one of Ikki’s friend, likes playing games with Ikki. Today after minesweeping with Ikki and winning so many times, he is tired of such easy games and wants to play another game with Ikki.liympanda has a magic circle and he puts it on a plane, there are n points on its boundary in circular border: . Evil panda claims that he is connecting m pairs of points. To connect two points, liympanda either places the link entirely inside the circle or entirely outside the circle. Now liympanda tells Ikki no two links touch inside/outside the circle, except on the boundary. He wants Ikki to figure out whether this is possible…Despaired at the minesweeping game just played, Ikki is totally at a loss, so he decides to write a program to help him. InputThe input contains exactly one test case.In the test case there will be a line consisting of of two integers: and . The following lines each contain two integers and , which denote the endpoints of the wire. Every point will have at most one link. OutputOutput a line, either “panda is telling the truth…” or “the evil panda is lying again”. Sample Input1234 20 13 2 Sample Output1panda is telling the truth... 标签：2-SAT Translation 个数排成一圈，给出若干条两点间的线段，可以在圈内连，也可在圈外连，问能否使得无相交线段（端点相交不算） Solution本题是 的判定裸题。把每条线段拆成两个点，即第 条为 和 ，分别代表 在圈内和在圈外。若线段 和 相交，则连边 ， ，这样跑一个 再判断 和 是否在一个联通块内即可判断是否有冲突。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define MAX_M 500using namespace std;int n, m, x[MAX_M+5], y[MAX_M+5];int dfn[MAX_M*2+5], low[MAX_M*2+5], id[MAX_M*2+5], index, cnt;vector &lt;int&gt; G[MAX_M*2+5];stack &lt;int&gt; sta;bool insta[MAX_M*2+5];void tarjan(int u) { dfn[u] = low[u] = ++index; sta.push(u), insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (insta[v]) low[u] = min(low[u], dfn[v]); } if (dfn[u] == low[u]) { cnt++; for (int i = sta.top(); ; i = sta.top()) { id[i] = cnt; sta.pop(); if (i == u) break; } }}void build() { for (int i = 2; i &lt;= m; i++) for (int j = 1; j &lt; i; j++) if ((x[i] &lt;= x[j] &amp;&amp; y[i] &gt;= x[j] &amp;&amp; y[i] &lt;= y[j]) || (x[i] &gt;= x[j] &amp;&amp; x[i] &lt;= y[j] &amp;&amp; y[i] &gt;= y[j])) G[i].push_back(j+m), G[j].push_back(i+m), G[i+m].push_back(j), G[j+m].push_back(i);}bool check() { for (int i = 1; i &lt;= m; i++) if (id[i] == id[i+m]) return false; return true;}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) { scanf("%d%d", &amp;x[i], &amp;y[i]); if (x[i] &gt; y[i]) swap(x[i], y[i]); } build(); for (int i = 1; i &lt;= m*2; i++) if (!dfn[i]) tarjan(i); if (check()) printf("panda is telling the truth...\n"); else printf("the evil panda is lying again\n"); return 0;}]]></content>
      <tags>
        <tag>图论</tag>
        <tag>2-SAT</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1997 Planer < 2-SAT >]]></title>
    <url>%2FBZOJ1997%E3%80%90HNOI2010%E3%80%91Planer%202-SAT%2F</url>
    <content type="text"><![CDATA[ProblemPlanerDescription Input Output Sample Input123456789101112131415161718192 6 9 1 4 1 5 1 6 2 4 2 5 2 6 3 4 3 5 3 6 1 4 2 5 3 6 5 5 1 2 2 3 3 4 4 5 5 1 1 2 3 4 5 Sample Output12NOYES 标签：2-SAT 并查集 Solution本题和 没什么区别…只是刚做 时是复习 ，所以写了 ，然而某天碰到这题突然想到了并查集。貌似此题可以种类并查集 过。把每条线段拆成两个点，代表从里面连和外面连，对于相交线段 ，一定有 和 不同时在里面或外面，于是 , 。这样合并时判断是否有 , 在同一集中即可。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 200#define MAX_M 10000using namespace std;int n, m, p[MAX_N+5], l[MAX_M+5], r[MAX_M+5], fa[MAX_M*2+5];void init() {for (int i = 0; i &lt; 2*m; i++) fa[i] = i;}int getf(int x) {return fa[x] == x ? x : fa[x] = getf(fa[x]);}void merge(int a, int b) {a = getf(a), b = getf(b); if (a != b) fa[a] = b;}int main() { int T; scanf("%d", &amp;T); while (T--) { scanf("%d%d", &amp;n, &amp;m), init(); bool flag = true; for (int i = 0; i &lt; m; i++) scanf("%d%d", &amp;l[i], &amp;r[i]); for (int i = 0, x; i &lt; n; i++) scanf("%d", &amp;x), p[x] = i; for (int i = 0; i &lt; m; i++) l[i] = p[l[i]], r[i] = p[r[i]]; for (int i = 0; i &lt; m; i++) if (l[i] &gt; r[i]) swap(l[i], r[i]); for (int i = 1; i &lt; m; i++) for (int j = 0; j &lt; i; j++) if ((l[i] &lt; l[j] &amp;&amp; r[i] &gt; l[j] &amp;&amp; r[i] &lt; r[j]) || (l[i] &gt; l[j] &amp;&amp; l[i] &lt; r[j] &amp;&amp; r[i] &gt; r[j])) merge(i*2, j*2+1), merge(i*2+1, j*2); for (int i = 0; i &lt; m; i++) flag &amp;= (getf(i*2) != getf(i*2+1)); printf("%s\n", flag ? "YES" : "NO"); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201701001-08总结]]></title>
    <url>%2F20171001-08%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[长沙雅礼中学2017国庆训练滚粗记 _兴致勃勃地去，遍体鳞伤地回……__八场考试爆六场，水题全都没做起……_ Day 1上午三道水题 好简单，数轴上画圆，转化成线段覆盖。然而我并没有看出来~,,ԾㅂԾ,,~ 在哪里见过一样…突然意识到是暑假讲过的题。 线段树套路题。并没有想起来正解，考完意识到是傻逼暴力修改。 数位 ，搞方程一小时没肝出来。 中午颓颓颓 下午讲 讲 花了一个半小时把上午的题改了，成功跳过了 基础部分。后面的题挺有意思。发现若干道 讲过的题和 原题。最后一道没听懂。 晚上讲了三道难题，听得半懂，口胡 Day 2上午 两 道 水 题 一 道 数 论 显然是 ，撸方程一个半小时没肝出来，果断打了 肯定图论，没想出正解，打了一个 分层，加上若干剪枝优化，并没骗到分 乍一看容斥或莫比乌斯反演…等等这是 模拟啊…果断放掉推反演，搞半天打了 。结果标解是反演…ヾ(≧へ≦)〃又水了低保分 中午颓颓颓 下午 讲数论先改了一个半小时题，发现 把我会的都讲完了。接着就开始讲莫比乌斯反演等省选内容。出发后第一次怀疑这不是 集训… 晚上讲了三道有意思的题，口胡 Day 3上午 一 道 原 题 两 道 正 常 题 一看是线段树，感觉好熟悉，应该是原题，然后就忘了标解了…考完 说这题我当时给他讲过，他印象可深了。然而我作为讲题人居然忘了…对我的智商和记忆力深表怀疑。此题正解： 弱 智 线 段 树 ，卡常。 显然是 ，然而题目叙述不清楚，一半的人都读错了（ 孔爷），读错之后太复杂，根本无法推 ，所以暴力也错了，怀疑样例耗掉半小时… 是二进制题，可能会用字典树或者 ，博弈逻辑搅半天，并未发现那个看似复杂的操作就是循环移位。忘了异或的套路，时间不够打了 。 中午颓颓颓 下午 讲贪心分治今天很正常，大概是 难度。发现几道做过的题。出发后第一次有了 集训营的感觉而非省选集训营。 晚上讲题人的“水题选讲”难度定位在 省 选 三道数论恶心题，推公式几大页 ，完全没懂。安慰自己，省选之前不会有这些鬼东西。 Day 4上午 两 道 水 题 一 道 原 题 裸约瑟夫，结果忘了当时初二自己是怎么推递推式的了… 树状数组，虽然被题面旁边的少女骚扰了半天，还是很快发现这是道水题，树状数组打出来。结果忘写 ，被毒瘤出题人卡常… 是经典 题，然而我并没有做过，考试也没想到，只会求最大值不会输出方案。看到正解觉得好憋屈，方程都一样，就是没时间想回溯输出了。 中午颓颓颓 下午雅礼学长讲搜索题目也很正常，大多就是剪枝启发式之类。出发后第二次也是最后一次有了 集训营的感觉。 晚上由于端午没讲题颓颓颓 Day 5上午三道正常题 图上 ，很好推，但是转移忘写位运算，强行把复杂度写丑了… 字符串，可以证明不会有无解，所以随机化乱搞。当时并没有想到，于是倒着暴力搜，居然过了… 是树形 ，但是比较难想，而且复杂度会爆。并没有写出来。下午讲题才发现这个 有最优策略，退化成贪心。 中午颓颓颓 下午听 讲数论听到一半果断改题。至于原因吗…完全听不懂，除了基础能懂以外，全都不会用。这已经有 省 选 的难度了。最后居然讲起了神技 容斥… 还超时一小时，强行占吃饭时间讲了线性代数/(ToT)/~~ 晚上听杂题今天的题比较正常， 难度，可以听懂，没太大问题 Day 6上午三道 题 看到“最小距离最大值”就去想二分答案，结果复杂度还是爆了，强行加了个优化，把最好复杂度优化了。本来以为会gg，结果居然过了。出题人表示很诧异，此题正解 生成树 知道是 ，但就是没推出方程。时间不够了，果断打 看表达式应该是斜率凸包，但是在树上维护凸包我只会暴力弹栈，复杂度跟暴力差不多，于是打了 。考完看到打暴力弹栈被卡得跟裸暴力一样的同学觉得自己赚了 中午颓颓颓 下午听 讲杂题题目很好，思维很巧妙，涨姿势了。懒癌一题没听懂，其他题大概懂了，口胡 。 晚上讲三道 题前两题能听懂，比较巧妙。最后一道分形，很有意思，半懂半懂。 Day 7上午三道数学题，预测到自己肯定gg 期望题，不太好证明，但是打表很好发现规律，然而我考试并没有打表。 题，考虑漏了情况，打了个贪心，然后自己把自己卡掉了… 看到 三 维 凸 包 期 望 就知道没搞。考完出题人说这套题比前两天简单…蛤？ 中午颓颓颓 下午听 讲图论一开始挺简单，但是开始讲定理就懵了。倒是听懂了若干道网络流建模题。 晚上三道杂题发现一道 讲过的博弈论原题，其他题目比较正常 Day 8上午三道 题目出题人在 说题目按字典序排序，结果我一来就挑了最难的题做…然后gg 按边 ，拆掉返祖边，然后树形 智商题，先转化然后 ，连转换都没想到 结论题，没推出结论，也没找规律，gg 中午颓颓颓 下午听 讲几何都懂了，但是不会写，而且旋转卡壳和半平面交是 内容吗？雾~ 晚上听了四道杂题大概都懂了，但是只能口胡 。唯一一道能写的在 上是权限题… Conclusion八天爆六天，成功滚粗…看来九月份没停课还是很要命的，完全没了做题的感觉，没怎么深入地想。十月份慢慢复习调整，把学 和 的计划再往后推一推。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【福利】洛谷模板汇总]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Graph TheoryDisjoint Set123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#define MAX_N 10000using namespace std;int n, m, f, x, y, father[MAX_N+5];int getfather(int v) { if (father[v] == v) { return v; } father[v] = getfather(father[v]); return father[v];}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { father[i] = i; } for (int i = 0; i &lt; m; i++) { cin &gt;&gt; f &gt;&gt; x &gt;&gt; y; if (f == 1) { int f1 = getfather(x); int f2 = getfather(y); if (f1 != f2) { father[f1] = f2; } } else { int f1 = getfather(x); int f2 = getfather(y); if (f1 != f2) { cout &lt;&lt; "N" &lt;&lt; endl; } else { cout &lt;&lt; "Y" &lt;&lt; endl; } } } return 0;} Minimum Spanning TreeKruskal12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 5000#define MAX_M 200000using namespace std;struct node { int u, v, l;} edge[MAX_M+5];int n, m, tot = 0;int father[MAX_N+5];bool comp(const node &amp;a, const node &amp;b) { return a.l &lt; b.l;}int getfather(int v) { if (father[v] == v) { return v; } father[v] = getfather(father[v]); return father[v];}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].l; } sort(edge, edge+m, comp); for (int i = 1; i &lt;= n; i++) father[i] = i; int flag = n-1; for (int i = 0; i &lt; m; i++) { int f1 = getfather(edge[i].u); int f2 = getfather(edge[i].v); if (f1 != f2) { father[f1] = f2; tot += edge[i].l; flag--; } if (flag == 0) break; } if (flag == 0) { cout &lt;&lt; tot; } else { cout &lt;&lt; "orz"; } return 0;} Prim1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define MAX_N 5000#define INF 2147483647using namespace std;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int n, m, dis[MAX_N+5], tot; bool col[MAX_N+5];void addedge(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void Prim() { for (int i = 1; i &lt;= n; i++) dis[i] = INF; dis[1] = 0; for (int i = 1, u = -1; i &lt;= n; i++, u = -1) { for (int j = 1; j &lt;= n; j++) if (!col[j] &amp;&amp; (u == -1 || dis[u] &gt; dis[j])) u = j; col[u] = true, tot += dis[u]; for (int j = 0; j &lt; (int)G[u].size(); j++) { int v = G[u][j], c = E[u][j]; if (!col[v] &amp;&amp; dis[v] &gt; c) dis[v] = c; } }}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 0, u, v, c; i &lt; m; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), addedge(u, v, c), addedge(v, u, c); Prim(); printf("%d", tot); return 0;} Shortest PathDijkstra1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define MAX_N 10000#define INF 2147483647#define pii pair &lt;int, int&gt;#define mp make_pair#define fir first#define sec secondusing namespace std;int n, m, s, dis[MAX_N+5];vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];void addedge(int u, int v, int c) {G[u].push_back(v), E[u].push_back(c);}void Dijkstra() { for (int i = 1; i &lt;= n; i++) dis[i] = INF; dis[s] = 0; priority_queue &lt;pii&gt; que; que.push(mp(0, s)); while (!que.empty()) { int u = que.top().sec, d = que.top().fir; que.pop(); if (dis[u] != -d) continue; for (int i = 0; i &lt; (int)G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (dis[u]+c &gt;= dis[v]) continue; dis[v] = dis[u]+c, que.push(mp(-dis[v], v)); } }}int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;s); for (int i = 0, u, v, c; i &lt; m; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), addedge(u, v, c); Dijkstra(); for (int i = 1; i &lt;= n; i++) printf("%d ", dis[i]); return 0;} SPFA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_M 500000#define MAX_N 10000#define INF 2147483647using namespace std;struct node { int v, len, next; node() { v = len = next = 0; }} edge[MAX_M+5];int n, m, s;int first[MAX_N+5], cnt = 0;int dis[MAX_N+5];void insert(int u, int v, int l) { cnt++; edge[cnt].v = v; edge[cnt].len = l; edge[cnt].next = first[u]; first[u] = cnt;}void SPFA() { for (int i = 1; i &lt;= n; i++) { dis[i] = INF; } int que[MAX_N*20+5], mark[MAX_N+5]; int head = 0, tail = 1; memset(mark, 0, sizeof(mark)); que[1] = s; mark[s] = 1; dis[s] = 0; while (head &lt;= tail) { head++; for (int tmp = first[que[head]]; tmp; tmp = edge[tmp].next) { if (dis[que[head]]+edge[tmp].len &lt; dis[edge[tmp].v]) { dis[edge[tmp].v] = dis[que[head]]+edge[tmp].len; if (mark[edge[tmp].v] == 0) { mark[edge[tmp].v] = 1; tail++; que[tail] = edge[tmp].v; } } } mark[que[head]] = 0; }}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; memset(first, 0, sizeof(first)); int u, v, l; for (int i = 0; i &lt; m; i++) { cin &gt;&gt; u &gt;&gt; v &gt;&gt; l; insert(u, v, l); } SPFA(); for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; dis[i] &lt;&lt; " "; } return 0;} Tarjan1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define MAX_N 100000using namespace std;int n, m, c[MAX_N+5], f[MAX_N+5];int dfn[MAX_N+5], low[MAX_N+5], col[MAX_N+5], val[MAX_N+5], ind, cnt;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];stack &lt;int&gt; sta;bool insta[MAX_N+5];void tarjan(int u) { dfn[u] = low[u] = ++ind, sta.push(u), insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (insta[v]) low[u] = min(low[u], dfn[v]); } if (dfn[u] == low[u]) { cnt++; for (int i = sta.top(); ; i = sta.top()) { col[i] = cnt, val[cnt] += c[i], insta[i] = false; sta.pop(); if (u == i) break; } }}int DFS(int u) { if (f[u]) return f[u]; int mx = 0; for (int i = 0; i &lt; E[u].size(); i++) mx = max(mx, DFS(E[u][i])); return f[u] = val[u]+mx;}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); while (m--) { int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; u++) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (col[u] == col[v]) continue; E[col[u]].push_back(col[v]); } } int ans = 0; for (int i = 1; i &lt;= cnt; i++) if (!f[i]) ans = max(ans, DFS(i)); printf("%d", ans); return 0;} Cut Vertex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 100000#define MAX_M 200000using namespace std;struct Edge { int v, next;} edge[MAX_M+5];int first[MAX_N+5], flag[MAX_N+5], num[MAX_N+5], low[MAX_N+5];int n, m, cnt = 0;void insert(int u, int v, int pos) { edge[pos].next = first[u]; edge[pos].v = v; first[u] = pos;}void dfs(int cur, int father) { int child = 0; num[cur] = low[cur] = ++cnt; for (int tmp = first[cur]; tmp; tmp = edge[tmp].next) { if (!num[edge[tmp].v]) { child++; dfs(edge[tmp].v, cur); low[cur] = min(low[cur], low[edge[tmp].v]); if (low[edge[tmp].v] &gt;= num[cur]) { flag[cur] = 1; } } else if (num[edge[tmp].v] &lt; num[cur] &amp;&amp; edge[tmp].v != father) { low[cur] = min(low[cur], num[edge[tmp].v]); } } if (father == -1 &amp;&amp; child == 1) { flag[cur] = 0; }}int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) { int u, v; cin &gt;&gt; u &gt;&gt; v; insert(u, v, i*2+1); insert(v, u, i*2+2); } int tot = 0; for (int i = 1; i &lt;= n; i++) { if (!num[i]) { dfs(i, -1); } if (flag[i]) { tot++; } } cout &lt;&lt; tot &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { if (flag[i]) { cout &lt;&lt; i &lt;&lt; " "; } } return 0;} Lowest Common AncestorMultiplication12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 500000using namespace std;struct Edge { int next, to;} edge[(MAX_N&lt;&lt;1)+5];int n, m, s, x, y, cnt;int d[MAX_N+5], p[MAX_N+5][25], first[MAX_N+5];bool vis[MAX_N+5];inline int read() { int ret = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret*10+ch-'0', ch = getchar(); return ret;}void INSERT(int a, int b) { edge[++cnt].next = first[a]; edge[cnt].to = b; first[a] = cnt;}void DFS(int u) { vis[u] = true; for (int i = 1; (1&lt;&lt;i) &lt;= n; i++) { if ((1&lt;&lt;i) &lt;= d[u]) { p[u][i] = p[p[u][i-1]][i-1]; } } for (int i = first[u]; i; i = edge[i].next) { int v = edge[i].to; if (!vis[v]) { d[v] = d[u]+1; p[v][0] = u; DFS(v); } }}int LCA(int a, int b) { int i, j; if (d[a] &lt; d[b]) swap(a, b); for (i = 0; (1&lt;&lt;i) &lt;= d[a]; i++) {} i--; for (j = i; j &gt;= 0; j--) { if (d[a]-(1&lt;&lt;j) &gt;= d[b]) { a = p[a][j]; } } if (a == b) { return a; } for (j = i; j &gt;= 0; j--) { if (p[a][j] != p[b][j]) { a = p[a][j]; b = p[b][j]; } } return p[a][0];}int main() { n = read(), m = read(), s = read(); for (int i = 1; i &lt; n; i++) { x = read(), y = read(); INSERT(x, y); INSERT(y, x); } DFS(s); for (int i = 0; i &lt; m; i++) { x = read(), y = read(); cout &lt;&lt; LCA(x, y) &lt;&lt; endl; } return 0;} TreeChainDivision12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define MAX_N 500000using namespace std;vector &lt;int&gt; G[MAX_N+5];int n, m, r, dep[MAX_N+5], sz[MAX_N+5];int fa[MAX_N+5], son[MAX_N+5], top[MAX_N+5];void DFS(int u) { sz[u] = 1; for (auto v : G[u]) { if (v == fa[u]) continue; fa[v] = u, dep[v] = dep[u]+1, DFS(v), sz[u] += sz[v]; if (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v; }}void DFS(int u, int tp) { top[u] = tp; if (son[u]) DFS(son[u], tp); for (auto v : G[u]) if ((v^fa[u]) &amp;&amp; (v^son[u])) DFS(v, v);}int LCA(int u, int v) { while (top[u]^top[v]) if (dep[top[u]] &gt; dep[top[v]]) u = fa[top[u]]; else v = fa[top[v]]; return dep[u] &lt; dep[v] ? u : v;}int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;r); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); DFS(r), DFS(r, r); while (m--) {int u, v; scanf("%d%d", &amp;u, &amp;v); printf("%d\n", LCA(u, v));} return 0;} Negative Loop12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define MAX_N 200000#define SIZE 25000000using namespace std;int f; char BUF[SIZE], *buf = BUF;inline void read(int &amp;x) { bool flag = 0; while (*buf &lt; 48) if (*buf++ == 45) flag = 1; x = 0; while (*buf &gt; 32) x = x*10+*buf++-48; x = flag ? -x : x;}vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int dis[MAX_N+5];bool insta[MAX_N+5], flag;void init(int n) { flag = false; for (int i = 1; i &lt;= n; i++) G[i].clear(), E[i].clear(); memset(dis, 0, sizeof(dis)), memset(insta, false, sizeof(insta));}void DFS(int u) { insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i], c = E[u][i]; if (dis[u]+c &gt;= dis[v]) continue; if (insta[v] || flag) {flag = true; break;} dis[v] = dis[u]+c, DFS(v); } insta[u] = false;}int main() { f = fread(BUF, 1, SIZE, stdin); int T; read(T); while (T--) { int n, m; read(n), read(m); init(n); while (m--) { int u, v, c; read(u), read(v), read(c); G[u].push_back(v), E[u].push_back(c); if (c &gt;= 0) G[v].push_back(u), E[v].push_back(c); } for (int i = 1; i &lt;= n; i++) {DFS(i); if (flag) break;} if (flag) printf("YE5\n"); else printf("N0\n"); } return 0;} Network Flow12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define MAX_N 10000#define MAX_M 100000#define INF 0x7f7f7f7fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, s, t, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node {int v, c, nxt;} E[(MAX_M&lt;&lt;1)+5];void init() {memset(pr, -1, sizeof pr);}void insert(int u, int v, int c) {E[cnt] = (node){v, c, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c) {insert(u, v, c), insert(v, u, 0);}bool BFS() { queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}void cpy() {for (int i = 1; i &lt;= n; i++) cr[i] = pr[i];}void rec() {for (int i = 1; i &lt;= n; i++) pr[i] = cr[i];}int Dinic() {int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;}int main() { read(n), read(m), read(s), read(t), init(); for (int i = 1, u, v, c; i &lt;= m; i++) read(u), read(v), read(c), addedge(u, v, c); return printf("%d\n", Dinic()), 0;} Minimum Cost Maximum Flow1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 5000#define MAX_M 50000#define INF 0x7f7f7f7fusing namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node {int v, c, w, nxt;} E[(MAX_M&lt;&lt;1)+5];void init() {memset(pr, -1, sizeof pr);}void insert(int u, int v, int c, int w) {E[cnt] = (node){v, c, w, pr[u]}, pr[u] = cnt++;}void addedge(int u, int v, int c, int w) {insert(u, v, c, w), insert(v, u, 0, -w);}bool SPFA() { queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) { int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) { d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; } } } if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]*flow; return true;}int main() { read(n), read(m), read(s), read(t), init(); for (int i = 1, u, v, c, w; i &lt;= m; i++) read(u), read(v), read(c), read(w), addedge(u, v, c, w); while (SPFA()) ; printf("%d %d\n", mxf, mic); return 0;} Bipartite MatchingHungary123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define MAX_N 1000using namespace std;int n, m, e, match[MAX_N+5], cnt;vector &lt;int&gt; G[MAX_N+5];bool vis[MAX_N+5];bool DFS(int u) { for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!vis[v]) { vis[v] = true; if (!match[v] || DFS(match[v])) { match[v] = u; return true; } } } return false;}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; e; int a, b; for (int i = 0; i &lt; e; i++) { cin &gt;&gt; a &gt;&gt; b; if (a &gt; n || b &gt; m) continue; G[a].push_back(b); } for (int i = 1; i &lt;= n; i++) { memset(vis, false, sizeof(vis)); if (DFS(i)) { cnt++; } } cout &lt;&lt; cnt; return 0;} Dinic12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 2000#define MAX_M 1000000#define INF 2147483647using namespace std;int n, m, s, t, n1, n2;int pre[MAX_N+5], tmp[MAX_N+5], d[MAX_N+5], cnt;struct node {int v, c, nxt;} E[MAX_M*2+MAX_N*2+5];void init() {cnt = 0; s = 0, t = n; memset(pre, -1, sizeof(pre));}void insert(int u, int v, int c) {E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++;}bool BFS() { memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s), d[s] = 0; while (!que.empty()) { int u = que.front(); for (int i = pre[u]; i != -1; i = E[i].nxt) { int v = E[i].v; if (E[i].c &amp;&amp; d[v] == -1) { d[v] = d[u]+1; que.push(v); } } que.pop(); } return d[t] != -1;}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int &amp;i = pre[u]; i != -1; i = E[i].nxt) { int v = E[i].v; if (E[i].c &amp;&amp; d[u]+1 == d[v]) { int tmp = DFS(v, min(flow, E[i].c)); E[i].c -= tmp, E[i^1].c += tmp, flow -= tmp, ret += tmp; if (!flow) break; } } if (!ret) d[u] = -1; return ret;}int Dinic() { int ret = 0; for (int i = 0; i &lt;= n; i++) tmp[i] = pre[i]; while (BFS()) { ret += DFS(s, INF); for (int i = 0; i &lt;= n; i++) pre[i] = tmp[i]; } return ret;}int main() { scanf("%d%d%d", &amp;n1, &amp;n2, &amp;m); n = n1+n2+1; init(); for (int i = 1; i &lt;= n1; i++) insert(s, i, 1), insert(i, s, 0); for (int i = n1+1; i &lt;= n1+n2; i++) insert(i, t, 1), insert(t, i, 0); for (int i = 0; i &lt; m; i++) { int u, v; scanf("%d%d", &amp;u, &amp;v); if (u &gt; n1 || v &gt; n2) continue; insert(u, n1+v, 1), insert(n1+v, u, 0); } printf("%d", Dinic()); return 0;} Math TheoryGauss Elimination123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 100#define EXP 1e-7using namespace std;typedef double fnt;int n; vector &lt;fnt&gt; f[MAX_N+5]; fnt ans[MAX_N+5];bool gauss() { for (int i = 1, tmp; i &lt;= n; i++) { for (tmp = i; tmp &lt;= n; tmp++) if (f[tmp][i] &lt;= -EXP || f[tmp][i] &gt;= EXP) break; if (tmp &gt; n) return false; swap(f[i], f[tmp]); for (int j = 1; j &lt;= n; j++) { fnt div = f[j][i]/f[i][i]; if (j == i) continue; for (int k = i; k &lt;= n+1; k++) f[j][k] -= f[i][k]*div; } } for (int i = 1; i &lt;= n; i++) ans[i] = f[i][n+1]/f[i][i]; return true;}int main() { scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) { f[i].push_back(0); for (int j = 1; j &lt;= n+1; j++) { fnt x; scanf("%lf", &amp;x); f[i].push_back(x); } } if (gauss()) for (int i = 1; i &lt;= n; i++) printf("%.2lf\n", ans[i]); else printf("No Solution"); return 0;} Inverse12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 3000000using namespace std;typedef long long lnt;lnt inv[MAX_N+5];void init(int n, lnt p) {inv[0] = inv[1] = 1; for (int i = 2; i &lt;= n; i++) inv[i] = (p-p/i*inv[p%i]%p)%p;}int main() { int n; lnt p; scanf("%d%lld", &amp;n, &amp;p); init(n, p); for (int i = 1; i &lt;= n; i++) printf("%lld\n", inv[i]); return 0;} Linear Basis123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 50using namespace std;typedef long long lnt;int n; lnt base[MAX_N+5], pow[MAX_N+5];int main() { scanf("%d", &amp;n); pow[0] = 1; for (int i = 1; i &lt;= MAX_N; i++) pow[i] = pow[i-1]*2; for (int i = 1; i &lt;= n; i++) { lnt x; scanf("%lld", &amp;x); for (int j = MAX_N; j &gt;= 0; j--) if (pow[j]&amp;x) { if (base[j]) x ^= base[j]; else {base[j] = x; break;} } } lnt ans = 0; for (int i = MAX_N; i &gt;= 0; i--) if ((ans^pow[i]) &gt; ans) ans ^= base[i]; printf("%lld", ans); return 0;} Lucas123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_P 100000using namespace std;typedef long long lnt;lnt f[MAX_P+5] = {1};void init(lnt p) {for (int i = 1; i &lt;= MAX_P; i++) f[i] = f[i-1]*i%p;}lnt FLT(lnt x, lnt p) { lnt ret = 1; x %= p; for (int k = p-2; k; k &gt;&gt;= 1) ret = k%2 ? ret*x%p : ret, x = x*x%p; return ret;}lnt lucas(lnt n, lnt m, lnt p) {return m ? (n%p &gt;= m%p ? f[n%p]*FLT(f[m%p]*f[n%p-m%p], p)*lucas(n/p, m/p, p)%p : 0) : 1;}int main() { int T; scanf("%d", &amp;T); while (T--) { lnt n, m, p; scanf("%lld%lld%lld", &amp;n, &amp;m, &amp;p); init(p), printf("%lld\n", lucas(n+m, min(n, m), p)%p); } return 0;} Matrix Fast Power12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 100#define MOD 1000000007using namespace std;int n;struct Matrix { long long ele[MAX_N][MAX_N]; inline Matrix operator * (const Matrix &amp;x) const { Matrix ret; memset(ret.ele, 0, sizeof(ret.ele)); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; n; k++) ret.ele[i][j] = (ret.ele[i][j]+ele[i][k]*x.ele[k][j])%MOD; return ret; }};Matrix Power(Matrix a, long long k) { if (k == 1) return a; Matrix ret = Power(a, k/2); if (k%2) return a*ret*ret; return ret*ret;}int main() { long long k; Matrix a; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; a.ele[i][j]; a = Power(a, k); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) cout &lt;&lt; a.ele[i][j] &lt;&lt; " "; cout &lt;&lt; endl; } return 0;} Prime Sieve123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define MAX_N 10000000using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m; bool NotPri[MAX_N+5];int pri[MAX_N+5], mu[MAX_N+5], phi[MAX_N+5], cnt;void init() { NotPri[1] = true, mu[1] = phi[1] = 1; for (int i = 2; i &lt;= n; i++) { if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1, phi[i] = i-1; for (int j = 0; j &lt; cnt; j++) { if (i*pri[j] &gt; n) break; NotPri[i*pri[j]] = true; if (i%pri[j]) phi[i*pri[j]] = phi[i]*phi[pri[j]], mu[i*pri[j]] = -mu[i]; else {phi[i*pri[j]] = phi[i]*pri[j], mu[i*pri[j]] = 0; break;} } }}int main() { read(n), read(m), init(); for (int x; m; m--) read(x), puts(NotPri[x] ? "No" : "Yes"); return 0;} Trigeminal Search1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int n;double s, t;double a[14];double calc(double x) { double tot = 0, tmp = 1; for (int i = 0; i &lt;= n; i++) { tot += tmp*a[i]; tmp *= x; } return tot;}void f(double l, double r) { if (abs(r-l) &lt;= 0.000001) { printf("%.5f", l); return; } double ml = (2*l+r)/3, mr = (l+2*r)/3; if (calc(ml) &gt; calc(mr)) { f(l, mr); } else { f(ml, r); }}int main() { cin &gt;&gt; n &gt;&gt; s &gt;&gt; t; for (int i = n; i &gt;= 0; i--) { cin &gt;&gt; a[i]; } f(s, t); return 0;} Fast Fourier Transformation12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000using namespace std;typedef double dnt;const dnt Pi = acos(-1);template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}struct Complex {dnt r, i;} a[(MAX_N&lt;&lt;2)+5], b[(MAX_N&lt;&lt;2)+5], c[(MAX_N&lt;&lt;2)+5];Complex operator + (Complex x, Complex y) {return (Complex){x.r+y.r, x.i+y.i};}Complex operator - (Complex x, Complex y) {return (Complex){x.r-y.r, x.i-y.i};}Complex operator * (Complex x, Complex y) {return (Complex){x.r*y.r-x.i*y.i, x.r*y.i+x.i*y.r};}void Rader(Complex *s, int l) { for (int i = 1, j = l/2, k; i &lt; l-1; i++) { if (i &lt; j) swap(s[i], s[j]); k = l/2; while (j &gt;= k) j -= k, k &gt;&gt;= 1; j += k; }}void FFT(Complex *s, int l, int f) { Rader(s, l); Complex wn, w; for (int i = 2; i &lt;= l; i &lt;&lt;= 1) { wn = (Complex){cos(2*Pi/i), f*sin(2*Pi/i)}; for (int j = 0; j &lt; l; j += i) { w = (Complex){1, 0}; for (int k = j; k &lt; j+i/2; k++, w = w*wn) { Complex x = s[k], y = w*s[k+i/2]; s[k] = x+y, s[k+i/2] = x-y; } } } if (f == -1) for (int i = 0; i &lt;= l; i++) s[i].r /= l;}int main() { int n, m; read(n), read(m); for (int i = 0, x; i &lt;= n; i++) read(x), a[i].r = x; for (int i = 0, x; i &lt;= m; i++) read(x), b[i].r = x; int l; for (l = 1; l &lt;= n+m; l &lt;&lt;= 1) ; FFT(a, l, 1), FFT(b, l, 1); for (int i = 0; i &lt;= l; i++) c[i] = a[i]*b[i]; FFT(c, l, -1); for (int i = 0; i &lt;= n+m; i++) printf("%d ", (int)(c[i].r+0.5)); return 0;} Data StructureHeap1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;int n, heap[1000000+5], size = 0;void insert(int x) { size++; heap[size] = x; int current = size; int father = current/2; while (father &gt; 0 &amp;&amp; heap[father] &gt; heap[current]) { swap(heap[father], heap[current]); current = father; father = current/2; }}void pop() { heap[1] = heap[size]; size--; int current = 1; int child = current*2; if (child &lt; size &amp;&amp; heap[child] &gt; heap[child+1]) child++; while (child &lt;= size &amp;&amp; heap[current] &gt; heap[child]) { swap(heap[current], heap[child]); current = child; child = 2*current; if (child &lt; size &amp;&amp; heap[child] &gt; heap[child+1]) child++; }}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { int f; cin &gt;&gt; f; if (f == 1) { int x; cin &gt;&gt; x; insert(x); } else if (f == 2) { cout &lt;&lt; heap[1] &lt;&lt; endl; } else { pop(); } } return 0;} Mergeable Heap123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 100000using namespace std;struct node {int val, dis, ls, rs;} heap[MAX_N+5];int n, m, fa[MAX_N+5];int getf(int x) {return fa[x] == x ? fa[x] : getf(fa[x]);}int merge(int a, int b) { if (!a || !b) return a^b; if (heap[a].val &gt; heap[b].val || (heap[a].val == heap[b].val &amp;&amp; a &gt; b)) swap(a, b); heap[a].rs = merge(heap[a].rs, b), fa[heap[a].rs] = a; if (heap[heap[a].rs].dis &gt; heap[heap[a].ls].dis) swap(heap[a].ls, heap[a].rs); heap[a].dis = heap[a].rs == 0 ? 0 : heap[heap[a].rs].dis+1; return a;}int pop(int a) { int l = heap[a].ls, r = heap[a].rs; heap[a].ls = heap[a].rs = heap[a].val = 0, fa[l] = l, fa[r] = r; return merge(l, r);}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;heap[i].val), fa[i] = i; while (m--) { int opt; scanf("%d", &amp;opt); if (opt == 1) { int x, y; scanf("%d%d", &amp;x, &amp;y), x = getf(x), y = getf(y); if (heap[x].val &amp;&amp; heap[y].val &amp;&amp; x != y) merge(x, y); } if (opt == 2) { int x; scanf("%d", &amp;x), x = getf(x); if (!heap[x].val) printf("-1\n"); else printf("%d\n", heap[x].val), pop(x); } } return 0;} Binary Indexed Tree112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 500000using namespace std;int n, m;int tree[MAX_N+5];int lowbit(int x) { return x&amp;(-x);}void modify(int pos, int x) { while (pos &lt;= n) { tree[pos] += x; pos += lowbit(pos); }}long long query(int t) { long long tot = 0; while (t &gt; 0) { tot += tree[t]; t -= lowbit(t); } return tot;}int main() { memset(tree, 0, sizeof(tree)); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { int tmp; cin &gt;&gt; tmp; modify(i, tmp); } for (int i = 0; i &lt; m; i++) { int f, a, b; cin &gt;&gt; f &gt;&gt; a &gt;&gt; b; if (f == 1) { modify(a, b); } else { cout &lt;&lt; query(b)-query(a-1) &lt;&lt; endl; } } return 0;} 212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 500000using namespace std;int n, m;int tree[MAX_N+5];int lowbit(int x) { return x&amp;(-x);}void modify(int pos, int x) { while (pos &lt;= n) { tree[pos] += x; pos += lowbit(pos); }}long long query(int pos) { long long tot = 0; while (pos &gt; 0) { tot += tree[pos]; pos -= lowbit(pos); } return tot;}int main() { memset(tree, 0, sizeof(tree)); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { int x; cin &gt;&gt; x; modify(i, x); modify(i+1, -x); } for (int i = 0; i &lt; m; i++) { int f; cin &gt;&gt; f; if (f == 1) { int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify(l, x); modify(r+1, -x); } else { int x; cin &gt;&gt; x; cout &lt;&lt; query(x) &lt;&lt; endl; } } return 0;} Segment Tree112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 100000using namespace std;int n, k;long long tree[MAX_N*4+50], tag[MAX_N*4+50];void updata(int v) { tree[v] = tree[v*2]+tree[v*2+1];}void downtag(int v, int s, int t) { tag[v*2] += tag[v]; tag[v*2+1] += tag[v]; int m = (s+t)/2; tree[v*2] += tag[v]*(m-s+1); tree[v*2+1] += tag[v]*(t-m); tag[v] = 0;}void modify(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) { tree[v] += x*(t-s+1); tag[v] += x; return; } int m = (s+t)/2; downtag(v, s, t); if (l &lt;= m) { modify(v*2, s, m, l, r, x); } if (r &gt;= m+1) { modify(v*2+1, m+1, t, l, r, x); } updata(v);}void build(int v, int s, int t) { if (s == t) { cin &gt;&gt; tree[v]; return; } int m = (s+t)/2; build(v*2, s, m); build(v*2+1, m+1, t); updata(v);}long long query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) { return tree[v]; } int m = (s+t)/2; downtag(v, s, t); long long ret = 0; if (l &lt;= m) { ret += query(v*2, s, m, l, r); } if (r &gt;= m+1) { ret += query(v*2+1, m+1, t, l, r); } updata(v); return ret;}int main() { cin &gt;&gt; n &gt;&gt; k; build(1, 1, n); for (int i = 0; i &lt; k; i++) { int f, l, r, x; cin &gt;&gt; f; if (f == 1) { cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify(1, 1, n, l, r, x); } else { cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(1, 1, n, l, r) &lt;&lt; endl; } } return 0;} 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 100000#define ll long longusing namespace std;int n, m;ll p;ll tree[MAX_N*4+5], mul[MAX_N*4+5], add[MAX_N*4+5];void updata(int v) { tree[v] = (tree[v*2]+tree[v*2+1])%p;}void downtag(int v, int s, int t, int mid) { if (mul[v] == 1 &amp;&amp; add[v] == 0) return; mul[v*2] = mul[v*2]*mul[v]%p; add[v*2] = (add[v*2]*mul[v]%p+add[v])%p; tree[v*2] = (tree[v*2]*mul[v]%p+add[v]*(ll)(mid-s+1)%p)%p; mul[v*2+1] = mul[v*2+1]*mul[v]%p; add[v*2+1] = (add[v*2+1]*mul[v]%p+add[v])%p; tree[v*2+1] = (tree[v*2+1]*mul[v]%p+add[v]*(ll)(t-mid)%p)%p; mul[v] = 1; add[v] = 0; return;}void create(int v, int s, int t) { mul[v] = 1; add[v] = 0; if (s == t) { cin &gt;&gt; tree[v]; tree[v] %= p; return; } int mid = (s+t)/2; create(v*2, s, mid); create(v*2+1, mid+1, t); updata(v);}void modify1(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) { add[v] = (add[v]+(ll)x)%p; tree[v] = (tree[v]+(ll)x*(ll)(t-s+1)%p)%p; return; } int mid = (s+t)/2; downtag(v, s, t, mid); if (l &lt;= mid) { modify1(v*2, s, mid, l, r, x); } if (r &gt;= mid+1) { modify1(v*2+1, mid+1, t, l, r, x); } updata(v);}void modify2(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) { mul[v] = mul[v]*(ll)x%p; add[v] = add[v]*(ll)x%p; tree[v] = tree[v]*(ll)x%p; return; } int mid = (s+t)/2; downtag(v, s, t, mid); if (l &lt;= mid) { modify2(v*2, s, mid, l, r, x); } if (r &gt;= mid+1) { modify2(v*2+1, mid+1, t, l, r, x); } updata(v);}ll query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) { return tree[v]; } int mid = (s+t)/2; ll ret = 0; downtag(v, s, t, mid); if (l &lt;= mid) { ret = (ret+query(v*2, s, mid, l, r))%p; } if (r &gt;= mid+1) { ret = (ret+query(v*2+1, mid+1, t, l, r))%p; } updata(v); return ret;}int main() { cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; create(1, 1, n); for (int i = 0; i &lt; m; i++) { int f; cin &gt;&gt; f; if (f == 1) { int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify2(1, 1, n, l, r, x%p); } else if (f == 2) { int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify1(1, 1, n, l, r, x%p); } else { int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(1, 1, n, l, r) &lt;&lt; endl; } } return 0;} Sparse Table1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAX_N 100000using namespace std;int n, m, num[MAX_N+5], mx[MAX_N+5][20];void setTable() { for (int i = 1; i &lt;= n; i++) mx[i][0] = num[i]; for (int j = 1; (1&lt;&lt;j) &lt;= n; j++) for (int i = 1; i+(1&lt;&lt;j)-1 &lt;= n; i++) mx[i][j] = max(mx[i][j-1], mx[i+(1&lt;&lt;j-1)][j-1]);}int query(int l, int r) { int range = (int)(log(r-l+1)/log(2)); return max(mx[l][range], mx[r-(1&lt;&lt;range)+1][range]);}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;num[i]); setTable(); while (m--) { int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%d\n", query(l, r)); } return 0;} Chairman Tree1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 200000using namespace std;int n, m, num[MAX_N+5], hash[MAX_N+5], tot, root[MAX_N+5], cnt;struct pre {int id, val;} p[MAX_N+5];bool cmp (const pre &amp;a, const pre &amp;b) {return a.val &lt; b.val;}struct node {int ls, rs, val;} tr[MAX_N*50];void updata(int v) {tr[v].val = tr[tr[v].ls].val+tr[tr[v].rs].val;}void build(int v, int s, int t) { if (s == t) return; int mid = s+t&gt;&gt;1; tr[v].ls = ++cnt, tr[v].rs = ++cnt; build(tr[v].ls, s, mid), build(tr[v].rs, mid+1, t);}void modify(int v, int o, int s, int t, int x) { tr[v] = tr[o]; if (s == t) {tr[v].val++; return;} int mid = s+t&gt;&gt;1; if (x &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, x); else modify(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, x); updata(v);}int query(int v1, int v2, int s, int t, int k) { if (s == t) return s; int mid = s+t&gt;&gt;1, tmp = tr[tr[v2].ls].val-tr[tr[v1].ls].val; if (k &lt;= tmp) return query(tr[v1].ls, tr[v2].ls, s, mid, k); else return query(tr[v1].rs, tr[v2].rs, mid+1, t, k-tmp);}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) p[i].id = i, scanf("%d", &amp;p[i].val); sort(p+1, p+n+1, cmp); for (int i = 1; i &lt;= n; i++) {if (p[i].val != p[i-1].val || i == 1) hash[++tot] = p[i].val; num[p[i].id] = tot;} root[0] = ++cnt, build(root[0], 1, tot); for (int i = 1; i &lt;= n; i++) root[i] = ++cnt, modify(root[i], root[i-1], 1, tot, num[i]); while (m--) { int l, r, k; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); printf("%d\n", hash[query(root[l-1], root[r], 1, tot, k)]); } return 0;} Treap12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX_N 100000using namespace std;struct TNode { TNode* s[2]; int val, k, size; TNode() {} TNode(int _val, TNode* _s) {val = _val, s[0] = s[1] = _s, k = rand(), size = 1;} void updata() {size = s[0]-&gt;size+s[1]-&gt;size+1;}} nil, tr[MAX_N+5], *null, *root, *cnt;typedef TNode* P_TNode;void init() { srand(19260817); nil = TNode(0, NULL), null = &amp;nil; null-&gt;s[0] = null-&gt;s[1] = null, null-&gt;size = 0; cnt = tr, root = null;}P_TNode newnode(int val) { *cnt = TNode(val, null); return cnt++;}P_TNode merge(P_TNode a, P_TNode b) { if (a == null) return b; if (b == null) return a; if (a-&gt;k &gt; b-&gt;k) {a-&gt;s[1] = merge(a-&gt;s[1], b), a-&gt;updata(); return a;} if (a-&gt;k &lt;= b-&gt;k) {b-&gt;s[0] = merge(a, b-&gt;s[0]), b-&gt;updata(); return b;}}void split(P_TNode v, int val, P_TNode &amp;ls, P_TNode &amp;rs) { if (v == null) {ls = rs = null; return;} if (val &lt; v-&gt;val) {rs = v; split(rs-&gt;s[0], val, ls, rs-&gt;s[0]);} if (val &gt;= v-&gt;val) {ls = v; split(ls-&gt;s[1], val, ls-&gt;s[1], rs);} v-&gt;updata();}void insert(int val) { P_TNode ls, rs; split(root, val, ls, rs); root = merge(merge(ls, newnode(val)), rs);}void remove(int val) { P_TNode ls, mids, rs; split(root, val-1, ls, rs); split(rs, val, mids, rs); root = merge(ls, merge(merge(mids-&gt;s[0], mids-&gt;s[1]), rs));}int get_rank(int val) { P_TNode ls, rs; split(root, val-1, ls, rs); int ret = ls-&gt;size+1; root = merge(ls, rs); return ret;}int get_kth(P_TNode v, int k) { if (k &lt;= v-&gt;s[0]-&gt;size) return get_kth(v-&gt;s[0], k); if (k &gt; v-&gt;s[0]-&gt;size+1) return get_kth(v-&gt;s[1], k-v-&gt;s[0]-&gt;size-1); return v-&gt;val;}int get_nearest(P_TNode v, int sn) { while (v-&gt;s[sn] != null) v = v-&gt;s[sn]; return v-&gt;val;}int predecessor(int val) { P_TNode ls, rs; split(root, val-1, ls, rs); int ret = get_nearest(ls, 1); root = merge(ls, rs); return ret;}int successor(int val) { P_TNode ls, rs; split(root, val, ls, rs); int ret = get_nearest(rs, 0); root = merge(ls, rs); return ret;}int main() { init(); int n, opt, x; scanf("%d", &amp;n); while (n--) { scanf("%d%d", &amp;opt, &amp;x); if (opt == 1) insert(x); if (opt == 2) remove(x); if (opt == 3) printf("%d\n", get_rank(x)); if (opt == 4) printf("%d\n", get_kth(root, x)); if (opt == 5) printf("%d\n", predecessor(x)); if (opt == 6) printf("%d\n", successor(x)); } return 0;} SplayNormal1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#define INF 0x7f7f7f7f#define flag (cur-&gt;fa-&gt;fa!=tar&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;struct SplayNode { SplayNode *s[2], *fa; int val, w, sz; void updata() {sz = w+(s[0]?s[0]-&gt;sz:0)+(s[1]?s[1]-&gt;sz:0);}};struct SplayTree { SplayNode* rt; SplayNode* newnode(int _val) { SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = _val, v-&gt;w = v-&gt;sz = 1; return v; } SplayTree() { rt = newnode(-INF), rt-&gt;s[1] = newnode(INF); rt-&gt;s[1]-&gt;fa = rt, rt-&gt;updata(); } void rotate(SplayNode* v, bool sn) { SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); } void splay(SplayNode* cur, SplayNode* tar) { while (cur != tar &amp;&amp; cur-&gt;fa != tar) { bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); } if (cur-&gt;fa == tar) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); if (tar == rt) rt = cur; } SplayNode* predecessor(int _val) { SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt; cur-&gt;val]) if (cur-&gt;val &lt; _val) cpy = cur; return cpy; } SplayNode* successor(int _val) { SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt;= cur-&gt;val]) if (cur-&gt;val &gt; _val) cpy = cur; return cpy; } void insert(int _val) { SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); if (suc-&gt;s[0]) suc-&gt;s[0]-&gt;w++, suc-&gt;s[0]-&gt;sz++; else suc-&gt;s[0] = newnode(_val), suc-&gt;s[0]-&gt;fa = suc; suc-&gt;updata(), rt-&gt;updata(); } void remove(int _val) { SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); suc-&gt;s[0]-&gt;w--, suc-&gt;s[0]-&gt;sz--; if (!suc-&gt;s[0]-&gt;w) suc-&gt;s[0] = NULL; suc-&gt;updata(), rt-&gt;updata(); } int get_rank(int _val) { SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); if (suc == NULL) return rt-&gt;sz; return rt-&gt;sz-suc-&gt;sz; } SplayNode* get_kth(SplayNode* v, int k) { int lsz = v-&gt;s[0] ? v-&gt;s[0]-&gt;sz : 0; if (k &lt;= lsz) return get_kth(v-&gt;s[0], k); if (k &gt; lsz+v-&gt;w) return get_kth(v-&gt;s[1], k-lsz-v-&gt;w); return v; }} BBST;int main() { int n, opt, x; scanf("%d", &amp;n); while (n--) { scanf("%d%d", &amp;opt, &amp;x); if (opt == 1) BBST.insert(x); if (opt == 2) BBST.remove(x); if (opt == 3) printf("%d\n", BBST.get_rank(x)); if (opt == 4) printf("%d\n", BBST.get_kth(BBST.rt, x+1)-&gt;val); if (opt == 5) printf("%d\n", BBST.predecessor(x)-&gt;val); if (opt == 6) printf("%d\n", BBST.successor(x)-&gt;val); } return 0;} Reverse123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define INF 0x7f7f7f7f#define flag (cur-&gt;fa-&gt;fa!=tar&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;struct SplayNode { SplayNode *s[2], *fa; int val, w, sz; bool rev; void updata() {sz = w+(s[0]?s[0]-&gt;sz:0)+(s[1]?s[1]-&gt;sz:0);} void downtag() { if (!rev) return; rev = false, swap(s[0], s[1]); if (s[0]) s[0]-&gt;rev ^= 1; if (s[1]) s[1]-&gt;rev ^= 1; }};struct SplayTree { SplayNode* rt; SplayNode* newnode(int _val) { SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = _val, v-&gt;sz = v-&gt;w = 1; v-&gt;rev = false; return v; } SplayTree(int n) { rt = newnode(-INF), rt-&gt;s[1] = newnode(INF); rt-&gt;s[1]-&gt;fa = rt, rt-&gt;updata(); for (int i = 1; i &lt;= n; i++) insert(i); } void rotate(SplayNode* v, bool sn) { SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); } void splay(SplayNode* cur, SplayNode* tar) { while (cur != tar &amp;&amp; cur-&gt;fa != tar) { bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); } if (cur-&gt;fa == tar) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); if (tar == rt) rt = cur; } SplayNode* predecessor(int _val) { SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt; cur-&gt;val]) if (cur-&gt;val &lt; _val) cpy = cur; return cpy; } SplayNode* successor(int _val) { SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt;= cur-&gt;val]) if (cur-&gt;val &gt; _val) cpy = cur; return cpy; } void insert(int _val) { SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); if (suc-&gt;s[0]) suc-&gt;s[0]-&gt;w++, suc-&gt;s[0]-&gt;sz++; else suc-&gt;s[0] = newnode(_val), suc-&gt;s[0]-&gt;fa = suc; suc-&gt;updata(), rt-&gt;updata(); } void reverse(int l, int r) { SplayNode *nl = get_kth(rt, l), *nr = get_kth(rt, r+2); splay(nl, rt), splay(nr, rt-&gt;s[1]), nr-&gt;s[0]-&gt;rev ^= 1; } SplayNode* get_kth(SplayNode* v, int k) { v-&gt;downtag(); int lsz = v-&gt;s[0] == NULL ? 0 : v-&gt;s[0]-&gt;sz; if (k &lt;= lsz) return get_kth(v-&gt;s[0], k); if (k &gt; lsz+v-&gt;w) return get_kth(v-&gt;s[1], k-lsz-v-&gt;w); return v; } void output(SplayNode* v) { if (v == NULL) return; v-&gt;downtag(), output(v-&gt;s[0]); if (v-&gt;val != -INF &amp;&amp; v-&gt;val != INF) printf("%d ", v-&gt;val); output(v-&gt;s[1]); }};int main() { int n, m; scanf("%d%d", &amp;n, &amp;m); SplayTree BBST(n); for (int i = 1, l, r; i &lt;= m; i++) scanf("%d%d", &amp;l, &amp;r), BBST.reverse(l, r); return BBST.output(BBST.rt), 0;} Range Tree123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define INF 2147483647#define mid ((s+t)&gt;&gt;1)#define flag (cur-&gt;fa-&gt;fa!=tar&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;int n, m, c[MAX_N+5];struct SplayNode { SplayNode *s[2], *fa; int val, w, sz; void updata() {sz = w+(s[0]?s[0]-&gt;sz:0)+(s[1]?s[1]-&gt;sz:0);}};struct SplayTree { SplayNode* rt; SplayNode* newnode(int _val) { SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = _val, v-&gt;w = v-&gt;sz = 1; return v; } SplayTree() { rt = newnode(-INF), rt-&gt;s[1] = newnode(INF); rt-&gt;s[1]-&gt;fa = rt, rt-&gt;updata(); } void rotate(SplayNode* v, bool sn) { SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); } void splay(SplayNode* cur, SplayNode* tar) { while (cur != tar &amp;&amp; cur-&gt;fa != tar) { bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); } if (cur-&gt;fa == tar) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); if (tar == rt) rt = cur; } SplayNode* predecessor(int _val) { SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt; cur-&gt;val]) if (cur-&gt;val &lt; _val) cpy = cur; return cpy; } SplayNode* successor(int _val) { SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt;= cur-&gt;val]) if (cur-&gt;val &gt; _val) cpy = cur; return cpy; } void insert(int _val) { SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); if (suc-&gt;s[0]) suc-&gt;s[0]-&gt;w++, suc-&gt;s[0]-&gt;sz++; else suc-&gt;s[0] = newnode(_val), suc-&gt;s[0]-&gt;fa = suc; suc-&gt;updata(), rt-&gt;updata(); } void remove(int _val) { SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); suc-&gt;s[0]-&gt;w--, suc-&gt;s[0]-&gt;sz--; if (!suc-&gt;s[0]-&gt;w) suc-&gt;s[0] = NULL; suc-&gt;updata(), rt-&gt;updata(); } int get_rank(int _val) { SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); if (suc == NULL) return rt-&gt;sz-1; return rt-&gt;sz-suc-&gt;sz-1; }} tr[(MAX_N&lt;&lt;2)+5];void ins(int v, int s, int t, int p, int x) { tr[v].insert(x); if (s == t) return; if (p &lt;= mid) ins(v&lt;&lt;1, s, mid, p, x); else ins(v&lt;&lt;1|1, mid+1, t, p, x);}void modify(int v, int s, int t, int p, int x, int o) { tr[v].remove(o), tr[v].insert(x); if (s == t) return; if (p &lt;= mid) modify(v&lt;&lt;1, s, mid, p, x, o); else modify(v&lt;&lt;1|1, mid+1, t, p, x, o);}int query(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].get_rank(x); int ret = 0; if (l &lt;= mid) ret += query(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) ret += query(v&lt;&lt;1|1, mid+1, t, l, r, x); return ret;}int get_ind(int l, int r, int k) { int s = 0, t = INF, ret = -1; while (s &lt;= t) if (query(1, 1, n, l, r, mid) &gt;= k) t = mid-1; else ret = mid, s = mid+1; return ret;}int get_pre(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].predecessor(x)-&gt;val; int ret = -INF; if (l &lt;= mid) ret = max(ret, get_pre(v&lt;&lt;1, s, mid, l, r, x)); if (r &gt;= mid+1) ret = max(ret, get_pre(v&lt;&lt;1|1, mid+1, t, l, r, x)); return ret;}int get_suc(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].successor(x)-&gt;val; int ret = INF; if (l &lt;= mid) ret = min(ret, get_suc(v&lt;&lt;1, s, mid, l, r, x)); if (r &gt;= mid+1) ret = min(ret, get_suc(v&lt;&lt;1|1, mid+1, t, l, r, x)); return ret;}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", c+i), ins(1, 1, n, i, c[i]); while (m--) { int opt, l, r, p, k, x; scanf("%d", &amp;opt); if (opt == 1) scanf("%d%d%d", &amp;l, &amp;r, &amp;x), printf("%d\n", query(1, 1, n, l, r, x)+1); if (opt == 2) scanf("%d%d%d", &amp;l, &amp;r, &amp;k), printf("%d\n", get_ind(l, r, k)); if (opt == 3) scanf("%d%d", &amp;p, &amp;x), modify(1, 1, n, p, x, c[p]), c[p] = x; if (opt == 4) scanf("%d%d%d", &amp;l, &amp;r, &amp;x), printf("%d\n", get_pre(1, 1, n, l, r, x)); if (opt == 5) scanf("%d%d%d", &amp;l, &amp;r, &amp;x), printf("%d\n", get_suc(1, 1, n, l, r, x)); }} Tree Chain Division123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 100000using namespace std;int n, m, r, p, ind;vector &lt;int&gt; G[MAX_N+5];int c[MAX_N+5];int dep[MAX_N+5], fa[MAX_N+5], size[MAX_N+5], son[MAX_N+5];int top[MAX_N+5], dfn[MAX_N+5], last[MAX_N+5];int seg[(MAX_N&lt;&lt;2)+5], tag[(MAX_N&lt;&lt;2)+5];void DFS1(int u) { size[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == fa[u]) continue; dep[v] = dep[u]+1; fa[v] = u; DFS1(v); size[u] += size[v]; if (!son[u] || size[son[u]] &lt; size[v]) son[u] = v; }}void DFS2(int u, int tp) { top[u] = tp, dfn[u] = ++ind; if (son[u]) DFS2(son[u], tp); for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == fa[u] || v == son[u]) continue; DFS2(v, v); } last[u] = ind;}void updata(int v) {seg[v] = (seg[v&lt;&lt;1]+seg[v&lt;&lt;1|1])%p;}void downtag(int v, int s, int t) { if (!tag[v]) return; int mid = s+t&gt;&gt;1; seg[v&lt;&lt;1] = (seg[v&lt;&lt;1]+tag[v]*(mid-s+1))%p; seg[v&lt;&lt;1|1] = (seg[v&lt;&lt;1|1]+tag[v]*(t-mid))%p; tag[v&lt;&lt;1] = (tag[v&lt;&lt;1]+tag[v])%p; tag[v&lt;&lt;1|1] = (tag[v&lt;&lt;1|1]+tag[v])%p; tag[v] = 0;}void modify(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) {seg[v] = (seg[v]+x*(t-s+1))%p, tag[v] = (tag[v]+x)%p; return;} downtag(v, s, t); int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, x); updata(v);}int query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) return seg[v]; downtag(v, s, t); int mid = s+t&gt;&gt;1, ret = 0; if (l &lt;= mid) ret = (ret+query(v&lt;&lt;1, s, mid, l, r))%p; if (r &gt;= mid+1) ret = (ret+query(v&lt;&lt;1|1, mid+1, t, l, r))%p; updata(v); return ret;}void solve1(int x, int y, int z) { while (top[x] != top[y]) { if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); modify(1, 1, n, dfn[top[x]], dfn[x], z); x = fa[top[x]]; } modify(1, 1, n, min(dfn[x], dfn[y]), max(dfn[x], dfn[y]), z);}int solve2(int x, int y) { int ret = 0; while (top[x] != top[y]) { if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ret = (ret+query(1, 1, n, dfn[top[x]], dfn[x]))%p; x = fa[top[x]]; } ret = (ret+query(1, 1, n, min(dfn[x], dfn[y]), max(dfn[x], dfn[y])))%p; return ret;}void solve3(int x, int z) {modify(1, 1, n, dfn[x], last[x], z);}int solve4(int x) {return query(1, 1, n, dfn[x], last[x]);}int main() { scanf("%d%d%d%d", &amp;n, &amp;m, &amp;r, &amp;p); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) { int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); } DFS1(r); DFS2(r, r); for (int i = 1; i &lt;= n; i++) modify(1, 1, n, dfn[i], dfn[i], c[i]); while (m--) { int opt; scanf("%d", &amp;opt); if (opt == 1) { int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); solve1(x, y, z); } if (opt == 2) { int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", solve2(x, y)); } if (opt == 3) { int x, z; scanf("%d%d", &amp;x, &amp;z); solve3(x, z); } if (opt == 4) { int x; scanf("%d", &amp;x); printf("%d\n", solve4(x)); } } return 0;} Link-Cut Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define MAX_N 300000#define INF 0x7f7f7f7f#define flag (!tar(cur-&gt;fa-&gt;fa)&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;struct SplayNode { SplayNode *s[2], *fa; int val, sum; bool rev; void updata() {sum = val^(s[0]?s[0]-&gt;sum:0)^(s[1]?s[1]-&gt;sum:0);} void downtag() { if (fa &amp;&amp; (fa-&gt;s[0] == this || fa-&gt;s[1] == this)) fa-&gt;downtag(); if (rev &amp;&amp; s[0]) swap(s[0]-&gt;s[0], s[0]-&gt;s[1]), s[0]-&gt;rev ^= 1; if (rev &amp;&amp; s[1]) swap(s[1]-&gt;s[0], s[1]-&gt;s[1]), s[1]-&gt;rev ^= 1; rev = false; }} *tr[MAX_N+5];struct LinkCutTree { SplayNode* newnode(int _val) { SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = v-&gt;sum = _val, v-&gt;rev = 0; return v; } SplayNode* get_rt(SplayNode* v) {for (; v-&gt;fa; v = v-&gt;fa) ; return v;} bool tar(SplayNode* v) {return (v&amp;&amp;v-&gt;fa==NULL)||(v&amp;&amp;v-&gt;fa-&gt;s[0]!=v&amp;&amp;v-&gt;fa-&gt;s[1]!=v);} LinkCutTree(int n) {for (int i=1,_val;i&lt;=n;i++) scanf("%d", &amp;_val), tr[i]=newnode(_val);} void rotate(SplayNode* v, bool sn) { SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa &amp;&amp; !tar(f)) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); } void splay(SplayNode* cur) { cur-&gt;downtag(); while (!tar(cur) &amp;&amp; !tar(cur-&gt;fa)) { bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); } if (!tar(cur) &amp;&amp; tar(cur-&gt;fa)) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); cur-&gt;updata(); } void access(SplayNode* cur) { for (SplayNode* cpy = NULL; cur; cpy = cur, cur = cur-&gt;fa) splay(cur), cur-&gt;s[1] = cpy, cur-&gt;updata(); } void mroot(SplayNode* v) { access(v), splay(v); swap(v-&gt;s[0], v-&gt;s[1]), v-&gt;rev ^= 1; } void link(SplayNode* u, SplayNode* v) { if (get_rt(u) == get_rt(v)) return; mroot(u), u-&gt;fa = v; } void cut(SplayNode* u, SplayNode* v) { if (u == v || get_rt(u) != get_rt(v)) return; mroot(u), access(v), splay(v); if (v-&gt;s[0] == u) u-&gt;fa = v-&gt;s[0] = NULL, v-&gt;updata(); } void modify(SplayNode* v, int _val) { splay(v), v-&gt;val = _val, v-&gt;updata(); } int query(SplayNode* u, SplayNode* v) { mroot(u), access(v), splay(v); return v-&gt;sum; }};int main() { int n, m; scanf("%d%d", &amp;n, &amp;m); LinkCutTree LCT(n); while (m--) { int opt, x, y; scanf("%d%d%d", &amp;opt, &amp;x, &amp;y); if (opt == 0) printf("%d\n", LCT.query(tr[x], tr[y])); if (opt == 1) LCT.link(tr[x], tr[y]); if (opt == 2) LCT.cut(tr[x], tr[y]); if (opt == 3) LCT.modify(tr[x], y); } return 0;} StringKnuth-Morris-Pratt Algorithm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#define MAX_M 1000using namespace std;int next[MAX_M];void CalcNext(string&amp; s) { int m = s.length(); int begin = 1, matched = 0; while (begin+matched &lt; m) { if (s[begin+matched] == s[matched]) { matched++; next[begin+matched-1] = matched; } else { if (matched == 0) { begin++; } else { begin += matched-next[matched-1]; matched = next[matched-1]; } } }}void KMP(string&amp; T, string&amp; P) { int n = T.length(), m = P.length(); int begin = 0, matched = 0; while (begin &lt;= n-m) { if (matched &lt; m &amp;&amp; T[begin+matched] == P[matched]) { matched++; if (matched == m) { cout &lt;&lt; begin+1 &lt;&lt; endl; } } else { if (matched == 0) { begin++; } else { begin += matched-next[matched-1]; matched = next[matched-1]; } } }}int main() { string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; CalcNext(s2); KMP(s1, s2); for (int i = 0; i &lt; s2.length(); i++) { cout &lt;&lt; next[i] &lt;&lt; " "; } return 0;} Manacher12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_L 11000000using namespace std;char s[MAX_L*2+5];int f[MAX_L*2+5];int manacher (char* s0) { int len = strlen(s0); for (int i = 0; i &lt; len; i++) s[i*2+1] = '#', s[i*2+2] = s0[i]; s[len = len*2+1] = '#'; int pos = 0, r = 0, ret = 0; for (int i = 1; i &lt;= len; i++) { f[i] = (i &lt; r) ? min(f[2*pos-i], r-i) : 1; while (i-f[i] &gt;= 1 &amp;&amp; i+f[i] &lt;= len &amp;&amp; s[i-f[i]] == s[i+f[i]]) f[i]++; if (i+f[i] &gt; r) pos = i, r = i+f[i]; ret = max(ret, f[i]-1); } return ret;}int main() { char s0[MAX_L+5]; scanf("%s", s0); printf("%d\n", manacher(s0)); return 0;} Aho-Corasick Automation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define DICNUM 26#define MAX_LETTER 10500#define MAX_LENGTH 1000000using namespace std;char P[155][75], T[MAX_LENGTH+5];int root = 1, cnt, trie[MAX_LETTER+5][DICNUM], fail[MAX_LETTER+5], end[MAX_LETTER+5], tot[155];void init() { memset(P, 0, sizeof(P)), memset(T, 0, sizeof(T)), memset(tot, 0, sizeof(tot)); for (int i = 1; i &lt;= cnt; i++) memset(trie[i], 0, sizeof(trie[i])), fail[i] = end[i] = 0; cnt = 1;}void insert(int id, char s[]) { int cur = 1, len = strlen(s); for (int i = 0; i &lt; len; cur = trie[cur][s[i++]-'a']) if (!trie[cur][s[i]-'a']) trie[cur][s[i]-'a'] = ++cnt; end[cur] = id;}void SetFail() { queue &lt;int&gt; que; que.push(root); while (!que.empty()) { int u = que.front(); que.pop(); for (int i = 0; i &lt; DICNUM; i++) if (trie[u][i]) fail[trie[u][i]] = trie[fail[u]][i], que.push(trie[u][i]); else trie[u][i] = trie[fail[u]][i]; }}void query() { int cur = root, index, len = strlen(T); for (int i = 0; i &lt; len; i++) { index = T[i]-'a'; while (!trie[cur][index]) cur = fail[cur]; cur = trie[cur][index]; for (int j = cur; j; j = fail[j]) tot[end[j]]++; }}int main() { int n; for (int i = 0; i &lt; DICNUM; i++) trie[0][i] = root; while (scanf("%d", &amp;n) &amp;&amp; n) { init(); for (int i = 1; i &lt;= n; i++) scanf("%s", P[i]), insert(i, P[i]); SetFail(), scanf("%s", T), query(); int ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, tot[i]); printf("%d\n", ans); for (int i = 1; i &lt;= n; i++) if (tot[i] == ans) printf("%s\n", P[i]); } return 0;} Hash Table1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#define size 15000using namespace std;int n, cnt = 0;string tmp;string hash[size];int calc(string&amp; index) { int ret = 0; for (int i = 0; i &lt; index.length(); i++) { ret = (ret*256+index[i]+128)%size; } return ret;}bool search(string&amp; index, int&amp; pos) { pos = calc(index); while (hash[pos] != "" &amp;&amp; hash[pos] != index) { pos = (pos+1)%size; } if (hash[pos] == index) { return true; } else { return false; }}int insert(string&amp; index) { int pos; if (search(index, pos)) { return 0; } else { hash[pos] = index; return 1; }}int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) { cin &gt;&gt; tmp; cnt += insert(tmp); } cout &lt;&lt; cnt &lt;&lt; endl; return 0;} Suffix Array12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 1000000using namespace std;int n; char ch[MAX_N+5];int s[MAX_N+5], sa[MAX_N+5], tx[MAX_N+5], ty[MAX_N+5], cnt[MAX_N+5], rank[MAX_N+5];int trans(char c) { if (c &gt;= '0' &amp;&amp; c &lt;= '9') return c-'0'+1; if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c-'A'+11; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c-'a'+37;}void getSA() { int *x = tx, *y = ty; int DICNUM = 63; for (int i = 1; i &lt;= n; i++) cnt[x[i] = s[i]]++; for (int i = 2; i &lt;= DICNUM; i++) cnt[i] += cnt[i-1]; for (int i = n; i; i--) sa[cnt[x[i]]--] = i; for (int h = 1; h &lt;= n; h &lt;&lt;= 1) { int c = 0; for (int i = n-h+1; i &lt;= n; i++) y[++c] = i; for (int i = 1; i &lt;= n; i++) if (sa[i] &gt; h) y[++c] = sa[i]-h; memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) cnt[x[i]]++; for (int i = 2; i &lt;= DICNUM; i++) cnt[i] += cnt[i-1]; for (int i = n; i; i--) sa[cnt[x[y[i]]]--] = y[i]; swap(x, y), c = 0, x[sa[1]] = ++c; for (int i = 2; i &lt;= n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i-1]] &amp;&amp; y[sa[i]+h] == y[sa[i-1]+h]) ? c : ++c; DICNUM = c; if (c == n) break; }}int main() { scanf("%s", ch); n = strlen(ch); for (int i = 0; i &lt; n; i++) s[i+1] = trans(ch[i]); getSA(); printf("%d", sa[1]); for (int i = 2; i &lt;= n; i++) printf(" %d", sa[i]); return 0;} Suffix Automaton123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 1000000using namespace std;typedef long long lnt;struct node {int ch[26], par, len;} SAM[MAX_N*2+500];int sz, root, last, cnt[MAX_N*2+500], dfn[MAX_N*2+500], f[MAX_N*2+500];int newnode(int _len) {SAM[++sz].len = _len; return sz;}void init() {sz = 0, root = last = newnode(0);}void extend(int c) { int p = last, np = newnode(SAM[p].len+1); last = np, f[np] = 1; for (; p &amp;&amp; !SAM[p].ch[c]; p = SAM[p].par) SAM[p].ch[c] = np; if (!p) SAM[np].par = root; else { int q = SAM[p].ch[c]; if (SAM[q].len == SAM[p].len+1) SAM[np].par = q; else { int nq = newnode(SAM[p].len+1); memcpy(SAM[nq].ch, SAM[q].ch, sizeof(SAM[q].ch)); SAM[nq].par = SAM[q].par, SAM[q].par = SAM[np].par = nq; for (; p &amp;&amp; SAM[p].ch[c] == q; p = SAM[p].par) SAM[p].ch[c] = nq; } }}int main() { char s[MAX_N+5]; init(), scanf("%s", s); int l = strlen(s); for (int i = 0; i &lt; l; i++) extend(s[i]-'a'); for (int i = 1; i &lt;= sz; i++) cnt[SAM[i].len]++; for (int i = 1; i &lt;= l; i++) cnt[i] += cnt[i-1]; for (int i = 1; i &lt;= sz; i++) dfn[cnt[SAM[i].len]--] = i; lnt ans = 0; for (int i = sz; i &gt;= 1; i--) { int p = dfn[i]; f[SAM[p].par] += f[p]; if (f[p] &gt; 1) ans = max(ans, (lnt)f[p]*SAM[p].len); } printf("%lld", ans); return 0;}]]></content>
      <tags>
        <tag>图论</tag>
        <tag>数论数学</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>LG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1787【AHOI2008】Meet紧急集合]]></title>
    <url>%2FBZOJ1787%E3%80%90AHOI2008%E3%80%91Meet%E7%B4%A7%E6%80%A5%E9%9B%86%E5%90%88%20LCA%2F</url>
    <content type="text"><![CDATA[Problem【AHOI2008】Meet 紧急集合Description欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有 个等待点，有 条道路连接着它们，每条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一点到另一点要花费一个游戏币。参加游戏的三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对讲机（用于和同组的成员联系）。当集合号吹响后，每个成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在 个等待点中确定一个集合点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。小可可和他的朋友邀请你一起参加这个游戏，有你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？ Input第一行两个正整数 和 （ ， ），之间用一个空格隔开。分别表示等待点的个数（等待点也从 到 进行编号）和获奖所需完成的集合次数。随后有 行，每行两个正整数 和 ，之间用空格隔开，表示编号为 和编号为 的等待点之间有一条路。接着还有 行，每行用三个正整数表示某次集合前小可可、小可可的朋友以及你所在的等待点的编号。 Output一共有 行，每行两个数 和 ，用一个空格隔开。其中第 行表示第 次集合点选择在编号为 的等待点，集合总共的花费是 个游戏币。 Sample Input123456789106 41 22 32 44 55 64 5 66 3 12 4 46 6 6 Sample Output12345 22 54 16 0 HINT 的数据中， ， 的数据中， ， 标签：LCA Solution对于每组询问，找出三个点中两两的 ，这三个 中必然至少有两个相同。找出那个不同的 ，以它为集合点，算出距离，一定最小。原理可见 博客。 Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 500000using namespace std;int n, m, fa[MAX_N+5][35], dep[MAX_N+5];vector &lt;int&gt; G[MAX_N+5];void DFS(int u) { for (int i = 1; i &lt;= 30; i++) if (dep[u] &gt;= (1&lt;&lt;i)) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (v == fa[u][0]) continue; fa[v][0] = u, dep[v] = dep[u]+1, DFS(v); }}int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 30; i &gt;= 0; i--) if (dep[a]-(1&lt;&lt;i) &gt;= dep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 30; i &gt;= 0; i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];}int calc(int a, int b) {int c = LCA(a, b); return dep[a]+dep[b]-2*dep[c];}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); DFS(1); while (m--) { int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); int lca = LCA(a, b)^LCA(a, c)^LCA(b, c); int dis = calc(a, lca)+calc(b, lca)+calc(c, lca); printf("%d %d\n", lca, dis); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa12345 Dynamic len(set(a[L:R]))]]></title>
    <url>%2FUVa12345%20Dynamic%20len(set(a%5BLR%5D))%20%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[ProblemDynamic len(set(a[L:R]))DescriptionIn python, we can use len(start(a[L:R])) to calculate the number of distinct values of elements .Tere are some interactive examples that may help you understand how it is done. Remember that the indices of python lists start from .123456789101112131415&gt;&gt;&gt;a=[1,2,1,3,2,1,4]&gt;&gt;&gt; print a[1:6][2, 1, 3, 2, 1]&gt;&gt;&gt; print set(a[1:6])set([1, 2, 3])&gt;&gt;&gt; printlen(set(a[1:6]))3&gt;&gt;&gt; a[3]=2&gt;&gt;&gt; printlen(set(a[1:6]))2&gt;&gt;&gt; print len(set(a[3:5]))1 Your task is to simulate this process. InputThere will be only one test case. The first line contains two integers and .The next line contains the original list.All the integers are between and (inclusive). The next m lines contain the statementsthat you need to execute.A line formatted as ‘ ’ means , and a line formatted as ‘ ’ means .It is guaranteed that the statements will not cause error. OutputPrint the simulated result, one line for each query. Sample Input1234567 41 2 1 3 2 1 4Q 1 6M 3 2Q 1 6Q 3 5 Sample Output123321 标签：带修莫队 Translation给出一个长为 的序列，有 个操作，分为两类： 询问此序列 位间有多少种不同数 将第 位改为 。 Solution本题数据范围只有五万，一看就是带根号的算法，可以 莫队水过。我们发现 操作是标准莫队，但 操作是修改，因而需用带修莫队。带修莫队即在普通莫队的双指针种再加一个指针，指向时间。对于离线后询问建的扩展，如果是同一时间，就直接移动双指针；如果是不同时间，就先暴力移动时间指针，然后再移双指针即可。暴力出奇迹~~~ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAX_N 50000#define MAX_C 1000000using namespace std;int n, m, tmp, col[MAX_N+5];int cnt[MAX_C+5], pos[MAX_N+5], lst[MAX_N+5], ans[MAX_N+5];bool mark[MAX_N+5];struct Modify {int pos, x, pre;} M[MAX_N+5];struct Query {int l, r, id, ts;} Q[MAX_N+5];bool cmp(const Query &amp;a, const Query &amp;b) { return pos[a.l] &lt; pos[b.l] || (pos[a.l] == pos[b.l] &amp;&amp; pos[a.r] &lt; pos[b.r]) || (pos[a.l] == pos[b.l] &amp;&amp; pos[a.r] == pos[b.r] &amp;&amp; a.ts &lt; b.ts);}void add(int x) { if (mark[x]) { cnt[col[x]]--; if (!cnt[col[x]]) tmp--; } else { if (!cnt[col[x]]) tmp++; cnt[col[x]]++; } mark[x] ^= 1;}void change(int x, int y) { if (mark[x]) add(x), col[x] = y, add(x); else col[x] = y;}int main() { scanf("%d%d", &amp;n, &amp;m); int magic = (int)(sqrt((double)n+0.5)); int tot = 0, ind = 0; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;col[i]), lst[i] = col[i], pos[i] = i/magic; for (int i = 1; i &lt;= m; i++) { char opt[2]; int x, y; scanf("%s%d%d", opt, &amp;x, &amp;y); x++; if (opt[0] == 'Q') { Q[++tot].id = tot; Q[tot].l = x, Q[tot].r = y, Q[tot].ts = ind; } else { M[++ind].pos = x, M[ind].x = y, M[ind].pre = lst[x]; lst[x] = y; } } sort(Q+1, Q+tot+1, cmp); int now = 0, l = 1, r = 0; for (int i = 1; i &lt;= tot; i++) { if (now &lt; Q[i].ts) for (int j = now+1; j &lt;= Q[i].ts; j++) change(M[j].pos, M[j].x); if (now &gt; Q[i].ts) for (int j = now; j &gt; Q[i].ts; j--) change(M[j].pos, M[j].pre); if (l &gt; Q[i].l) for (int j = l-1; j &gt;= Q[i].l; j--) add(j); if (r &lt; Q[i].r) for (int j = r+1; j &lt;= Q[i].r; j++) add(j); if (l &lt; Q[i].l) for (int j = l; j &lt; Q[i].l; j++) add(j); if (r &gt; Q[i].r) for (int j = r; j &gt; Q[i].r; j--) add(j); now = Q[i].ts, l = Q[i].l, r = Q[i].r; ans[Q[i].id] = tmp; } for (int i = 1; i &lt;= tot; i++) printf("%d\n", ans[i]); return 0;}]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>莫队</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3068 最长回文 < Manacher >]]></title>
    <url>%2FHDU3068%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%20Manacher%2F</url>
    <content type="text"><![CDATA[Problem最长回文Time Limit: Memory Limit: Problem Description给出一个只由小写英文字符 组成的字符串 , 求 中最长回文串的长度.回文就是正反读都是一样的字符串, 如 , 等 Input输入有多组 ,不超过 组,每组输入为一行小写英文字符 组成的字符串 两组 之间由空行隔开(该空行不用处理)字符串长度 Output每一行一个整数 ,对应一组 ,表示该组 的字符串中所包含的最长回文长度. Sample Input12aaaaabab Sample Output1243 标签：Manacher Solution 板子题。不懂 可以戳此博客。简单来说， 就是记录以每个位置为中心的回文串的半径长度，这样在后面计算的时候可以根据对称性，利用前面的结果加速，找更长匹配时暴力扩展，复杂度 。由于此算法仅能对付长度为奇数的回文串（毕竟你算的是以每个点为中心的回文串），故先在每两个字符间插入一个占位符。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_L 110000using namespace std;char s[MAX_L*2+5];int f[MAX_L*2+5];int manacher (char* s0) { int len = strlen(s0); for (int i = 0; i &lt; len; i++) s[i*2+1] = '#', s[i*2+2] = s0[i]; s[len = len*2+1] = '#'; int pos = 0, r = 0, ret = 0; for (int i = 1; i &lt;= len; i++) { f[i] = (i &lt; r) ? min(f[2*pos-i], r-i) : 1; while (i-f[i] &gt;= 1 &amp;&amp; i+f[i] &lt;= len &amp;&amp; s[i-f[i]] == s[i+f[i]]) f[i]++; if (i+f[i] &gt; r) pos = i, r = i+f[i]; ret = max(ret, f[i]-1); } return ret;}int main() { char s0[MAX_L+5]; while (~scanf("%s", s0)) printf("%d\n", manacher(s0)); return 0;}]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2038 小Z的袜子]]></title>
    <url>%2FBZOJ2038%20%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90%20%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[Problem小Z的袜子Description作为一个生活散漫的人，小 每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小 再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小 把这 只袜子从 到 编号，然后从编号 到 (尽管小 并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬)。你的任务便是告诉小 ，他有多大的概率抽到两只颜色相同的袜子。当然，小 希望这个概率尽量高，所以他可能会询问多个 以方便自己选择。 Input输入文件第一行包含两个正整数 和 。 为袜子的数量， 为小 所提的询问的数量。接下来一行包含 个正整数 ，其中 表示第 只袜子的颜色，相同的颜色用相同的数字表示。再接下来 行，每行两个正整数 ， 表示一个询问。 Output包含 行，对于每个询问在一行中输出分数 表示从该询问的区间 中随机抽出两只袜子颜色相同的概率。若该概率为 则输出 ，否则输出的 必须为最简分数。 Sample Input1234566 41 2 3 3 3 22 61 33 51 6 Sample Output12342/50/11/14/15 Hint样例解释询问 ：共 种可能，其中抽出两个 有 种可能，抽出两个 有 种可能，概率为 。询问 ：共 种可能，无法抽到颜色相同的袜子，概率为 。询问 ：共 种可能，均为抽出两个3，概率为 。数据规模和约定 的数据中 ； 的数据中 ； 的数据中 ， ， 。 标签：莫队 Solution莫队经典例题。不懂莫队的可以戳这里：http://www.cnblogs.com/hzf-sbit/p/4056874.html简单来说，莫队就是将询问离线，维护双指针，暴力扩展或缩小范围，为了加速，用分块，可以达到 。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAX_N 50000using namespace std;typedef long long ll;int n, m;int col[MAX_N+5], f[MAX_N+5], pos[MAX_N+5];ll gcd(ll a, ll b) {return (b == 0) ? a : gcd(b, a%b);}struct Query { int id, l, r; ll a, b; void reduction() {ll tmp = gcd(a, b); a /= tmp, b /= tmp;}} Q[MAX_N+5];bool cmp_l(const Query &amp;a, const Query &amp;b) {return pos[a.l] &lt; pos[b.l] || (pos[a.l] == pos[b.l] &amp;&amp; a.r &lt; b.r);}bool cmp_id(const Query &amp;a, const Query &amp;b) {return a.id &lt; b.id;}void add(int c, ll &amp;tmp, int x) {tmp += x*2*f[c]+1; f[c] += x;}int main() { scanf("%d%d", &amp;n, &amp;m); int magic = (int)sqrt((double)n+0.5); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;col[i]), pos[i] = (i-1)/magic+1; for (int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q+1, Q+m+1, cmp_l); ll tmp = 0; int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) { if (l &gt; Q[i].l) {for (int j = l-1; j &gt;= Q[i].l; j--) add(col[j], tmp, 1); l = Q[i].l;} if (r &lt; Q[i].r) {for (int j = r+1; j &lt;= Q[i].r; j++) add(col[j], tmp, 1); r = Q[i].r;} if (l &lt; Q[i].l) {for (int j = l; j &lt; Q[i].l; j++) add(col[j], tmp, -1); l = Q[i].l;} if (r &gt; Q[i].r) {for (int j = r; j &gt; Q[i].r; j--) add(col[j], tmp, -1); r = Q[i].r;} if (Q[i].l == Q[i].r) {Q[i].a = 0, Q[i].b = 1; continue;} Q[i].a = tmp-(Q[i].r-Q[i].l+1), Q[i].b = (ll)(Q[i].r-Q[i].l+1)*(Q[i].r-Q[i].l); Q[i].reduction(); } sort(Q+1, Q+m+1, cmp_id); for (int i = 1; i &lt;= m; i++) printf("%lld/%lld\n", Q[i].a, Q[i].b); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1103【POI2007】大都市meg]]></title>
    <url>%2FBZOJ1103%E3%80%90POI2007%E3%80%91%E5%A4%A7%E9%83%BD%E5%B8%82meg%20%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Problem【POI2007】大都市megDescription经济全球化浪潮的影响下,习惯于漫步在清晨的乡间小路的邮递员 也开始骑着摩托车传递邮件了。不过，她经常回忆起以前在乡间漫步的情景。昔日，乡下有依次编号为 的 个小村庄，某些村庄之间有一些双向的土路。从每个村庄都恰好有一条路径到达村庄 （即比特堡）。并且，对于每个村庄，它到比特堡的路径恰好只经过编号比它的编号小的村庄。另外，对于所有道路而言，它们都不在除村庄以外的其他地点相遇。在这个未开化的地方，从来没有过高架桥和地下铁道。随着时间的推移，越来越多的土路被改造成了公路。至今， 还清晰地记得最后一条土路被改造为公路的情景。现在，这里已经没有土路了——所有的路都成为了公路，而昔日的村庄已经变成了一个大都市。 想起了在改造期间她送信的经历。她从比特堡出发，需要去某个村庄，并且在两次送信经历的间隔期间,有某些土路被改造成了公路.现在 需要你的帮助：计算出每次送信她需要走过的土路数目。（对于公路，她可以骑摩托车；而对于土路，她就只好推车了。） Input第一行是一个数 ( )以下 行，每行两个整数 ( )，表示原有一条路连接 和 以下一行，包含一个整数 ( )，表示 曾经在改造期间送过 次信。以下 行，每行有两种格式的若干信息，表示按时间先后发生过的 次事件:若这行为 ( )，表示将 到 的土路修为公路。若这行为 , 则表示 曾经从比特堡送信到村庄 。 Output有m行，每行包含一个整数，表示对应的某次送信时经过的土路数目。 Sample Input123456789101112131451 21 31 44 54W 5A 1 4W 5A 4 5W 5W 2A 1 2A 1 3 Sample Output12342101 标签：树上差分 线段树 Solution考虑树上 ，以 号点为根，对于每个 ，即将 的子树的权值全部加一，对于每个 ，答案即为 点的权值。由于只有子树权值操作，我们可以用树上差分。 表示 和它的父结点的权值差，这样对于每个 ，即为 ，对于每个 ，即为 可以直接用树状数组维护，这样编程复杂度更低。 Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 250000using namespace std;int n, m, tr[MAX_N+5], l[MAX_N+5], r[MAX_N+5], ind;vector &lt;int&gt; G[MAX_N+5];void DFS(int u) { l[u] = ++ind; for (int i = 0; i &lt; G[u].size(); i++) DFS(G[u][i]); r[u] = ind;}void inc(int pos) {for (; pos &lt;= n; pos += pos&amp;-pos) tr[pos]++;}void dec(int pos) {for (; pos &lt;= n; pos += pos&amp;-pos) tr[pos]--;}int sum(int pos) {int ret = 0; for (; pos; pos -= pos&amp;-pos) ret += tr[pos]; return ret;}int main() { scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) {int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v);} DFS(1); for (int i = 2; i &lt;= n; i++) inc(l[i]), dec(r[i]+1); scanf("%d", &amp;m); m += n-1; while (m--) { char opt[1]; scanf("%s", opt); if (opt[0] == 'W') { int x; scanf("%d", &amp;x); printf("%d\n", sum(l[x])); } if (opt[0] == 'A') { int u, v; scanf("%d%d", &amp;u, &amp;v); dec(l[v]), inc(r[v]+1); } } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>差分</tag>
        <tag>树状数组</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170918-24总结]]></title>
    <url>%2F20170918-24%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[半停课第二周， 羡 慕 队 长 和 副 队 前半周颓颓颓，本来说是要复习欧拉图的，做了两道 的水题，就去挑 水题了…后半周搞了几道有点意思的题。印象深刻的是 降雨量：线段树题，本来很水，但是若干恶心特判，调一下午。久了没考试，周六跟小班考试， 推 颓了两个半小时，居然没写出来，最后写了一道玄学题，得了 分。 暴力打错，尴尬QAQ~~最后发现 数据有误（就是我写的玄学题），我竟无言以对发现每周一次考试简直不够，现在调题慢好多，水题竟调两小时…下周停课，复习 ，跟小班考试，慢慢找回感觉吧]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3226【SDOI2008】校门外的区间]]></title>
    <url>%2FBZOJ3226%E3%80%90SDOI2008%E3%80%91%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E5%8C%BA%E9%97%B4%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2008】校门外的区间 Description受校门外的树这道经典问题的启发， 君根据基本的离散数学的知识，抽象出 种运算维护集合 ( 初始为空)并最终输出 。现在，请你完成这道校门外的树之难度增强版——校门外的区间。 种运算如下： 编号 表示格式 数学表示 基本集合运算如下： 运算 结果 Input输入共 行。每行的格式为 ，用一个空格隔开， 表示运算的种类， 为一个区间(区间用 表示)。 Output共一行，即集合 ，每个区间后面带一个空格。若 为空则输出 。 Sample Input12345U [1,5]D [3,3]S [2,4]C (1,5)I (2,3] Sample Output1(2,3) HINT对于 的数据， ， 标签：线段树 Solution假设只有闭区间，对于每个数，标记其为 还是 。四种运算对应如下（ 为区间修改， 为区间取反）： 再考虑加入开区间，开区间看作对应 的闭区间。即将 看作 。为了存 的小数，我们将所有区间均乘 ，即 变为 。又考虑到有 的区间，因而对于所有区间两端点再加 ，即 变为 。最后用线段树维护即可。对于输出， 扫一遍，找出每个数是 还是 ，然后合并区间，双指针跑。本题细节较多，写的时候得小心。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#define n (65536*2+1)using namespace std;struct node {int val, tag, rev;} tr[n*4+500];void build(int v, int s, int t) { tr[v].tag = -1; if (s == t) return; int mid = s+t&gt;&gt;1; build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t);}void downtag(int v, int s, int t) { if (s == t) {if (~tr[v].tag) tr[v].val = tr[v].tag; tr[v].val ^= tr[v].rev, tr[v].tag = -1, tr[v].rev = 0; return;} if (~tr[v].tag) tr[v&lt;&lt;1].tag = tr[v&lt;&lt;1|1].tag = tr[v].tag, tr[v&lt;&lt;1].rev = tr[v&lt;&lt;1|1].rev = 0; tr[v&lt;&lt;1].rev ^= tr[v].rev, tr[v&lt;&lt;1|1].rev ^= tr[v].rev; tr[v].tag = -1, tr[v].rev = 0;}int query(int v, int s, int t, int p) { downtag(v, s, t); if (s == t) return tr[v].val; int mid = s+t&gt;&gt;1; return p &lt;= mid ? query(v&lt;&lt;1, s, mid, p) : query(v&lt;&lt;1|1, mid+1, t, p);}void modify(int v, int s, int t, int l, int r, int x) { if (s &gt; t) return; downtag(v, s, t); if (s &gt;= l &amp;&amp; t &lt;= r) {tr[v].tag = x; return;} int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, x);}void reverse(int v, int s, int t, int l, int r) { if (s &gt; t) return; downtag(v, s, t); if (s &gt;= l &amp;&amp; t &lt;= r) {tr[v].rev ^= 1; return;} int mid = s+t&gt;&gt;1; if (l &lt;= mid) reverse(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) reverse(v&lt;&lt;1|1, mid+1, t, l, r);}int main() { char opt, lbr, rbr; int l, r; build(1, 1, n); while (~scanf("%c %c%d,%d%c\n", &amp;opt, &amp;lbr, &amp;l, &amp;r, &amp;rbr)) { l &lt;&lt;= 1, r &lt;&lt;= 1, l = l+(lbr == '(')+2, r = r-(rbr == ')')+2; if (opt == 'U') modify(1, 1, n, l, r, 1); if (opt == 'I') modify(1, 1, n, 1, l-1, 0), modify(1, 1, n, r+1, n, 0); if (opt == 'D') modify(1, 1, n, l, r, 0); if (opt == 'C') modify(1, 1, n, 1, l-1, 0), modify(1, 1, n, r+1, n, 0), reverse(1, 1, n, l, r); if (opt == 'S') reverse(1, 1, n, l, r); } int st = -1, en = -1; bool flag = false; for (int i = 1; i &lt;= n; i++) { if (query(1, 1, n, i)) { if (st == -1) st = i; en = i; } else { if (~st) { if (flag) printf(" "); else flag = true; printf("%c", (st%2 == 1) ? '(' : '['); printf("%d,%d", st/2-1, (en+1)/2-1); printf("%c", (en%2 == 1) ? ')' : ']'); } st = en = -1; } } if (!flag) printf("empty set"); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1934【SHOI2007】善意的投票]]></title>
    <url>%2FBZOJ1934%E3%80%90SHOI2007%E3%80%91%E5%96%84%E6%84%8F%E7%9A%84%E6%8A%95%E7%A5%A8%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem善意的投票题目描述幼儿园里有 个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？ 输入输出格式输入格式文件的第一行只有两个整数 ， ，保证有 ， 。其中 代表总人数， 代表好朋友的对数。文件第二行有 个整数，第 个整数代表第 个小朋友的意愿，当它为 时表示同意睡觉，当它为 时表示反对睡觉。接下来文件还有 行，每行有两个整数 ， 。表示 ， 是一对好朋友，我们保证任何两对 ， 不会重复。输出格式只需要输出一个整数，即可能的最小冲突数。 输入输出样例输入样例123453 31 0 01 21 33 2 输出样例11 说明 ， 。 标签：网络流 最小割 Solution最小割建图如下：如果本人意见为 ，则与源点相连，反之与汇点相连。对于每对朋友关系，互相连边。所有边的容量均为 ，跑最大流最小割即可。 原理：对于每个人，如果有朋友与他意见不合，则他要么割自己到源点（汇点）的一条边，要么割与朋友的边，代价等于容量。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 300#define MAX_M MAX_N*(MAX_N-1)*2 #define INF 2147483647using namespace std;int n, m, s, t;int d[MAX_N+5], first[MAX_N+5], cnt;struct node {int v, c, next;} E[MAX_M+5];void Init() { cnt = 0; memset(first, -1, sizeof(first));}void Insert(int u, int v, int c) { E[cnt].v = v, E[cnt].c = c; E[cnt].next = first[u]; first[u] = cnt++;}void AddEdge(int u, int v, int c) { Insert(u, v, c); Insert(v, u, 0);}bool BFS() { memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s), d[s] = 0; while (!que.empty()) { int u = que.front(); for (int i = first[u]; i != -1; i = E[i].next) { int v = E[i].v; if (E[i].c &amp;&amp; d[v] == -1) { d[v] = d[u]+1; que.push(v); } } que.pop(); } return (d[t] != -1);}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = first[u]; i != -1; i = E[i].next) { int v = E[i].v; if (E[i].c &amp;&amp; d[v] == d[u]+1) { int tmp = DFS(v, min(flow, E[i].c)); if (!tmp) continue; flow -= tmp, E[i].c -= tmp; ret += tmp, E[i^1].c += tmp; if (!flow) break; } } if (!ret) d[u] = -1; return ret;}int Dinic() { int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}int main() { Init(); scanf("%d%d", &amp;n, &amp;m); s = 0, t = n+1; for (int i = 1; i &lt;= n; i++) { int f; scanf("%d", &amp;f); if (f == 1) { AddEdge(s, i, 1); } else { AddEdge(i, t, 1); } } for (int i = 0; i &lt; m; i++) { int u, v; scanf("%d%d", &amp;u, &amp;v); AddEdge(u, v, 1); AddEdge(v, u, 1); } printf("%d", Dinic()); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3144【HZNOI2013】切糕]]></title>
    <url>%2FBZOJ3144%E3%80%90HZNOI2013%E3%80%91%E5%88%87%E7%B3%95%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem切糕Description经历千辛万苦小 得到了一块切糕，切糕的形状是长方体，小 打算拦腰将切糕切成两半分给小 。出于美观考虑，小 希望切面能尽量光滑且和谐。于是她找到你，希望你能帮她找出最好的切割方案。出于简便考虑，我们将切糕视作一个长 ，宽 ，高 的长方体点阵。我们将位于第 层中第 行，第 列上的点称为 ，它有一个非负的不和谐值 。一个合法的切面满足以下两个条件： 与每个纵轴有且仅有一个交点。即切面是一个函数 ，对于所有 ， ，我们需指定一个切割点 ，且 。 切面需要一定的光滑性要求，即相邻纵轴上的切割点不能相距太远。对于所有 和 ，若 ，则 , 其中 是给定的一个非负整数。 能有许多切面满足上面的条件，小 希望找出总的切割点上的不和谐值最小的那个，即 最小。 Input第一行是三个正整数 ，表示切糕的长 、 宽 、高 。第二行有一个非负整数 ，表示光滑性要求。接下来是 个 行 列的矩阵，第 个矩阵的第 行第 列是 。 的数据满足 ， ，且给出的所有的不和谐值不超过 。 Output仅包含一个整数，表示在合法基础上最小的总不和谐值。 Sample Input1234562 2 2 1 6 16 12 62 6 Sample Output16 Hint最佳切面的 为 标签：网络流 最小割 Solution建模神题。建图：建 层，每层 的图，相邻两竖边建模如下 (图片转载自Zarxdy34)这样如果割掉红边，右边割的边必须在绿边下面才能有流。所以割的边就限制在绿边上面了。因此这样一来，下界就满足了。对于上界，右边的几个点反过来同种方式建边（图中只画了左侧的边） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_A 40#define MAX_N 70000#define MAX_M 300000#define INF 2147483647using namespace std;int s, t, id[MAX_A+5][MAX_A+5][MAX_A+5];int move[2][4] = {{0, 1, 0, -1}, {1, 0, -1, 0}};struct Edge {int v, c, nxt;} E[MAX_M+5];int pre[MAX_N+5], d[MAX_N+5], cnt, num;queue &lt;int&gt; que;void init() {cnt = num = 0; memset(pre, -1, sizeof(pre));}void insert(int u, int v, int c) { E[cnt].v = v, E[cnt].c = c; E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0; E[cnt].nxt = pre[v], pre[v] = cnt++;}bool BFS() { memset(d, -1, sizeof(d)); while (!que.empty()) que.pop(); d[s] = 0, que.push(s); while (!que.empty()) { int u = que.front(); for (int i = pre[u]; i != -1; i = E[i].nxt) if (E[i].c &amp;&amp; d[E[i].v] == -1) d[E[i].v] = d[u]+1, que.push(E[i].v); que.pop(); } return d[t] != -1;}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pre[u]; i != -1; i = E[i].nxt) { int v = E[i].v; if (E[i].c &amp;&amp; d[u]+1 == d[v]) { int tmp = DFS(v, min(flow, E[i].c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; } } if (!ret) d[u] = -1; return ret;}int Dinic() { int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}int main() { init(); int a, b, h, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;h, &amp;d); for (int i = 1; i &lt;= h+1; i++) for (int j = 1; j &lt;= a; j++) for (int k = 1; k &lt;= b; k++) id[i][j][k] = ++num; s = 0, t = ++num; for (int j = 1; j &lt;= a; j++) for (int k = 1; k &lt;= b; k++) insert(s, id[1][j][k], INF), insert(id[h+1][j][k], t, INF); for (int i = 1; i &lt;= h; i++) for (int j = 1; j &lt;= a; j++) for (int k = 1; k &lt;= b; k++) { int c; scanf("%d", &amp;c); insert(id[i][j][k], id[i+1][j][k], c); } for (int i = d+1; i &lt;= h+1; i++) for (int j = 1; j &lt;= a; j++) for (int k = 1; k &lt;= b; k++) { int x, y; for (int l = 0; l &lt; 4; l++) if (id[i][x = j+move[0][l]][y = k+move[1][l]]) insert(id[i][j][k], id[i-d][x][y], INF); } printf("%d", Dinic()); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1015【JSOI2008】星球大战]]></title>
    <url>%2FBZOJ1015%E3%80%90JSOI2008%E3%80%91%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98%20%E7%A6%BB%E7%BA%BF%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Problem【JSOI2008】星球大战题目描述很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。 输入输出格式输入格式输入文件第一行包含两个整数， 和 ，分别表示星球的数目和以太隧道的数目。星球用 的整数编号。接下来的 行，每行包括两个整数 ，其中（ 且 ），表示星球 和星球 之间有以太隧道。注意所有的以太隧道都是双向的。接下来一行是一个整数 ，表示帝国计划打击的星球个数。接下来的 行每行一个整数 ，满足 ，表示帝国计划打击的星球编号。帝国总是按输入的顺序依次摧毁星球的。输出格式输出文件的第一行是开始时星球的连通块个数。接下来的 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。 输入输出样例输入样例12345678910111213141516171819208 130 11 66 55 00 61 22 33 44 57 17 27 63 6516357 输出样例123456111233 标签：离线并查集 Solution并查集水题。因为只会删边，不会增边，因此我们从最后时刻往前面模拟，每次加边（从最后一条边往前加），加边后输出联通块个数即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define MAX_N 400000#define MAX_M 200000using namespace std;int n, m, k, cnt;int f[MAX_N+5], mark[MAX_N+5], opt[MAX_N+5];vector &lt;int&gt; edge[MAX_N+5];stack &lt;int&gt; ans;int find(int v) { if (f[v] == v) return v; return f[v] = find(f[v]);}void merge(int v) { if (mark[v]) cnt++; for (int i = 0; i &lt; edge[v].size(); i++) { int u = edge[v][i]; if (mark[u]) continue; int anc1 = find(v); int anc2 = find(u); if (anc1 != anc2) cnt--, f[anc1] = anc2; } mark[v] = 0;}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) { int x, y; scanf("%d%d", &amp;x, &amp;y); edge[x].push_back(y); edge[y].push_back(x); } for (int i = 0; i &lt; n; i++) f[i] = i; scanf("%d", &amp;k); for (int i = 1; i &lt;= k; i++) { scanf("%d", &amp;opt[i]); mark[opt[i]] = 1; } cnt = n-k; for (int i = 0; i &lt; n; i++) if (!mark[i]) merge(i); ans.push(cnt); for (int i = k; i &gt;= 1; i--) { merge(opt[i]); ans.push(cnt); } while (!ans.empty()) { printf("%d\n", ans.top()); ans.pop(); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1189【HNOI2007】紧急疏散evacuate]]></title>
    <url>%2FBZOJ1189%E3%80%90HNOI2007%E3%80%91%E7%B4%A7%E6%80%A5%E7%96%8F%E6%95%A3evacuate%20%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%2B%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2007】紧急疏散evacuate Description发生了火警，所有人员需要紧急疏散！假设每个房间是一个 的矩形区域。每个格子如果是’ ’，那么表示这是一块空地；如果是’ ’，那么表示这是一面墙，如果是’ ’，那么表示这是一扇门，人们可以从这儿撤出房间。已知门一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散的时候，每一秒钟每个人都可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上就没有人数限制了（也就是说每块空地可以同时站无数个人）。但是，由于门很窄，每一秒钟只能有一个人移动到门的位置，一旦移动到门的位置，就表示他已经安全撤离了。现在的问题是：如果希望所有的人安全撤离，最短需要多少时间？或者告知根本不可能。 Input输入文件第一行是由空格隔开的一对正整数 与 ， ， ，以下 行 列描述一个 的矩阵。其中的元素可为字符’ ’, ‘ ’和’ ’，且字符间无空格。 Output只有一个整数K，表示让所有人安全撤离的最短时间，如果不可能撤离，那么输出’ ’（不包括引号）。 Sample Input1234565 5XXXXXX...DXX.XXX..XXXXDXX Sample Output13 HINT2015.1.12新加数据一组，鸣谢1756500824 语言请用scanf("%s",s)读入！ 标签：二分答案 网络流 Solution这题真坑逼，调了两小时。坑点已用红色加粗。 首先我们可以很容易地想到需要以每个门为起点 ，记录每个点到每个门的距离是多少。然后二分答案，对于当前答案 ，建图如下：从源点向每个有人的点连容量为 的边，从每个门向汇点连容量为 的边。然后对于每个人，枚举每个门，如果这个人到某个门的距离小于等于 ，那么这个人一定会在 时限内到达这个门前，所以我们从这个人向这个门连一条容量为 的边。跑一遍最大流，如果流量等于人数，则可行。写出来就是这样：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_N 500#define MAX_M 400000#define INF 2147483647using namespace std;int n, m, s, t, id[20][20], ind, tot, num, pre[MAX_N+5], cnt; char map[20][20];vector &lt;int&gt; G[MAX_N+5], exi; int dis[MAX_N+5][MAX_N+5]; bool vis[MAX_N+5];int nxt[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};struct node {int v, c, nxt;} E[MAX_M+5];void init() {cnt = 0; s = 0, t = n*m+1; memset(pre, -1, sizeof(pre));}void insert(int u, int v, int c) { E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0, E[cnt].nxt = pre[v], pre[v] = cnt++;}char gc(int x) {return map[(x-1)/m][(x-1)%m];}void BFS(int beg, int k) { memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n*m; i++) dis[i][k] = INF; queue &lt;int&gt; que; dis[beg][k] = 0, que.push(beg), vis[beg] = true; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v] || gc(v) != '.') continue; dis[v][k] = dis[u][k]+1, que.push(v), vis[v] = true; } }}int d[MAX_N+5];bool BFS() { memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v; if (~d[v] || !E[i].c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[v] != d[u]+1 || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp, flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}bool check(int tans) { init(); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') insert(s, id[i][j], 1); for (int k = 0; k &lt; exi.size(); k++) insert(exi[k], t, tans); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') for (int k = 0; k &lt; exi.size(); k++) if (dis[id[i][j]][k] &lt;= tans) insert(id[i][j], exi[k], 1); int ret = 0; while (BFS()) ret += DFS(s, INF); return ret == num;}int bi_search(int l, int r) { int ret; while (l &lt;= r) { int mid = l+r&gt;&gt;1; if (check(mid)) ret = mid, r = mid-1; else l = mid+1; } return ret;}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) id[i][j] = ++ind; for (int i = 0; i &lt; n; i++) scanf("%s", map[i]); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) for (int k = 0; k &lt; 4; k++) { int x = i+nxt[k][0], y = j+nxt[k][1]; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || map[i][j] == 'X' || map[x][y] == 'X') continue; G[id[i][j]].push_back(id[x][y]); } for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') num++; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == 'D') exi.push_back(id[i][j]); for (int i = 0; i &lt; exi.size(); i++) BFS(exi[i], i); int ans = bi_search(0, m*n); if (ans &lt; m*n) printf("%d", ans); else printf("impossible"); return 0;} 然而 掉了。原因很简单：某位神犇出了一组数据：12345674 5XXDXXXX.XXX...XXXDXXans=3 然而用刚刚的方法做答案是 。这是因为 和 都在 时刻到达 的门前，两个人分别过需要多一秒钟。 ~这里我们需要另一种建模方式：首先源点向所有人连容量为 的边，然后把每个门拆成 个点，如果某人到某门的时间为 ，则从这个人向这个人的第 到 个点都连容量为 的边。最后把每个门的 个点向汇点连容量为 的边即可。 Code​12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_N 50000#define MAX_M 1000000#define INF 2147483647using namespace std;int n, m, s, t, id[20][20], ind, tot, num, pre[MAX_N+5], cnt; char map[20][20];vector &lt;int&gt; G[MAX_N+5], exi; int dis[MAX_N+5][500]; bool vis[MAX_N+5];int nxt[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};struct node {int v, c, nxt;} E[MAX_M+5];void init() {cnt = 0; s = 0, t = MAX_N; memset(pre, -1, sizeof(pre));}void insert(int u, int v, int c) { E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0, E[cnt].nxt = pre[v], pre[v] = cnt++;}char gc(int x) {return map[(x-1)/m][(x-1)%m];}void BFS(int beg, int k) { memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n*m; i++) dis[i][k] = INF; queue &lt;int&gt; que; dis[beg][k] = 0, que.push(beg), vis[beg] = true; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (vis[v] || gc(v) != '.') continue; dis[v][k] = dis[u][k]+1, que.push(v), vis[v] = true; } }}int d[MAX_N+5];bool BFS() { memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s), d[s] = 0; while (!que.empty()) { int u = que.front(); que.pop(); for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v; if (~d[v] || !E[i].c) continue; d[v] = d[u]+1, que.push(v); } } return ~d[t];}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int i = pre[u]; ~i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (d[v] != d[u]+1 || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp, flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}bool check(int tans) { init(); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') insert(s, id[i][j], 1); for (int k = 0; k &lt; exi.size(); k++) for (int l = 1; l &lt;= tans; l++) insert(n*m+l*exi.size()+k, t, 1); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') for (int k = 0; k &lt; exi.size(); k++) if (dis[id[i][j]][k] &lt;= tans) for (int l = dis[id[i][j]][k]; l &lt;= tans; l++) insert(id[i][j], n*m+l*exi.size()+k, 1); int ret = 0; while (BFS()) ret += DFS(s, INF); return ret == num;}int bi_search(int l, int r) { int ret; while (l &lt;= r) { int mid = l+r&gt;&gt;1; if (check(mid)) ret = mid, r = mid-1; else l = mid+1; } return ret;}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) id[i][j] = ++ind; for (int i = 0; i &lt; n; i++) scanf("%s", map[i]); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) for (int k = 0; k &lt; 4; k++) { int x = i+nxt[k][0], y = j+nxt[k][1]; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || map[i][j] == 'X' || map[x][y] == 'X') continue; G[id[i][j]].push_back(id[x][y]); } for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') num++; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == 'D') exi.push_back(id[i][j]); for (int i = 0; i &lt; exi.size(); i++) BFS(exi[i], i); int ans = bi_search(0, m*n); if (ans &lt; m*n) printf("%d", ans); else printf("impossible"); return 0;} `]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1008【HNOI2008】越狱]]></title>
    <url>%2FBZOJ1008%E3%80%90HNOI2008%E3%80%91%E8%B6%8A%E7%8B%B1%20%E8%A1%A5%E9%9B%86%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2008】越狱 Description监狱有连续编号为 的 个房间，每个房间关押一个犯人，有 种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。 Input输入两个整数 ， 。 Output能越狱的状态数，答案模 。 Sample Input12 3 Sample Output16 HINT 种状态为 标签：补集转换 Solution考虑到补集转换，这道题就是一水题。总共有 种方案，其中不能发生越狱的有 种方案，快速幂求出，相减即可。注意处理负数。 Code123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MOD 100003using namespace std;typedef long long lnt;lnt PowerMod(lnt a, lnt b) { if (b == 1) return a%MOD; lnt ret = PowerMod(a, b/2); return b&amp;1 ? a%MOD*ret%MOD*ret%MOD : ret*ret%MOD;}int main() { lnt m, n; scanf("%lld%lld", &amp;m, &amp;n); printf("%lld", ((PowerMod(m, n)-m%MOD*PowerMod(m-1, n-1))%MOD+MOD)%MOD); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>组合数学</tag>
        <tag>补集转换</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1066【SCOI2007】蜥蜴]]></title>
    <url>%2FBZOJ1066%E3%80%90SCOI2007%E3%80%91%E8%9C%A5%E8%9C%B4%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SCOI2007】蜥蜴Description在一个 行 列的网格地图中有一些高度不同的石柱，一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。 每行每列中相邻石柱的距离为 ，蜥蜴的跳跃距离是 ，即蜥蜴可以跳到平面距离不超过 的任何一个石柱上。石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 （如果仍然落在地图内部，则到达的石柱高度不变），如果该石柱原来高度为 ，则蜥蜴离开后消失。以后其他蜥蜴不能落脚。任何时刻不能有两只蜥蜴在同一个石柱上。 Input输入第一行为三个整数 ， ， ，即地图的规模与最大跳跃距离。以下 行为石竹的初始状态， 表示没有石柱， 表示石柱的初始高度。以下 行为蜥蜴位置，“ ”表示蜥蜴，“ ”表示没有蜥蜴。 Output输出仅一行，包含一个整数，即无法逃离的蜥蜴总数的最小值。 Sample Input12345678910115 8 20000000002000000003211000200000000000000..................LLLL.................. Sample Output11 HINT 的数据满足： , 标签：网络流 Solution简单的拆点建模题。从源点向每个有蜥蜴的点连容量为 的边，从每个能跳出去的点向汇点连容量为 的边。对于石笋高度，把每个点拆成两个点，它们间的边容量为石笋高度，若位置 可跳到 ，则从 的第二个点向 的第一个点连容量为 的边。最后跑最大流即可。点数少，都懒得用边表了，直接用邻接矩阵 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 20#define INF 2147483647using namespace std;int n, m, r, s, t, cnt, tot, id[MAX_N+5][MAX_N+5], map[MAX_N*MAX_N*2+5][MAX_N*MAX_N*2+5];char a[MAX_N+5][MAX_N+5], b[MAX_N+5][MAX_N+5];void build(int x, int y) { for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if ((i != x || j != y) &amp;&amp; (a[i][j] != '0') &amp;&amp; r*r &gt;= (x-i)*(x-i)+(y-j)*(y-j)) map[id[x][y]+1][id[i][j]] = INF;}int d[MAX_N*MAX_N*2+5];bool BFS() { queue &lt;int&gt; que; memset(d, -1, sizeof(d)); d[s] = 0, que.push(s); while (!que.empty()) { int u = que.front(); que.pop(); for (int v = 0; v &lt;= cnt; v++) { if (d[v] != -1 || !map[u][v]) continue; d[v] = d[u]+1, que.push(v); } } return d[t] != -1;}int DFS(int u, int flow) { if (u == t) return flow; int ret = 0; for (int v = 0; v &lt;= cnt; v++) { if (d[v] != d[u]+1 || !map[u][v]) continue; int tmp = DFS(v, min(flow, map[u][v])); map[u][v] -= tmp, map[v][u] += tmp, flow -= tmp, ret += tmp; if (!flow) break; } if (!ret) d[u] = -1; return ret;}int Dinic() { int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;}int main() { scanf("%d%d%d", &amp;n, &amp;m, &amp;r); for (int i = 1; i &lt;= n; i++) { scanf("%s", a[i]+1); for (int j = 1; j &lt;= m; j++) { if (a[i][j] == '0') continue; id[i][j] = cnt+1, map[cnt+1][cnt+2] = a[i][j]-'0', cnt += 2; } } s = 0, t = ++cnt; for (int i = 1; i &lt;= n; i++) { scanf("%s", b[i]+1); for (int j = 1; j &lt;= m; j++) { if (b[i][j] == 'L') tot++, map[s][id[i][j]] = 1; if (i-r &lt; 1 || i+r &gt; n || j-r &lt; 1 || j+r &gt; m) map[id[i][j]+1][t] = INF; if (a[i][j] != '0') build(i, j); } } printf("%d", tot-Dinic()); return 0;}]]></content>
      <tags>
        <tag>网络流</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4348 To The Moon]]></title>
    <url>%2FHDU4348%20To%20The%20Moon%20%E5%B8%A6%E4%BF%AE%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【HDU4348】To The Moon DescriptionTo The Moon is a independent game released in November 2011, it is a role-playing adventure game powered by RPG Maker.The premise of To The Moon is based around a technology that allows us to permanently reconstruct the memory on dying man. In this problem, we’ll give you a chance, to implement the logic behind the scene.You‘ve been given integers . On these integers, you need to implement the following operations: : Adding a constant d for every , and increase the time stamp by , this is the only operation that will cause the time stamp increase. : Querying the current sum of . : Querying a history sum of in time . : Back to time . And once you decide return to a past, you can never be access to a forward edition anymore. , , , . The system start from time , and the first modification is in time , , and won’t introduce you to a future state. Input123n mA1 A2 ... An... (here following the m operations. ) Output1... (for each query, simply print the result. ) Sample Input1234567891011121310 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 42 40 0C 1 1 1C 2 2 -1Q 1 2H 1 2 1 Sample Output12345645591501 标签：带修主席树 Translation维护一个数据结构，使得其可有四种操作：区间修改，区间求和，某时间的区间和，返回某时间。 Solution很明显这是一道主席树的板子题。不过此题要带区间修改。普通区间修改需要加 ，并不断下传。而对于主席树，下传意味着新建节点，可能会 。所以这里我们暴力一点，直接标记永久化，这样写起来简洁，而且省空间。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 100000using namespace std;struct node {int ls, rs; long long val, tag;} tr[MAX_N*50+5];int n, m;int cnt, now, root[MAX_N+5];void updata(int v, int s, int t) {tr[v].val = tr[tr[v].ls].val+tr[tr[v].rs].val+(long long)(t-s+1)*tr[v].tag;}void build(int v, int s, int t) { tr[v].ls = tr[v].rs = tr[v].tag = tr[v].val = 0; if (s == t) { scanf("%I64d", &amp;tr[v].val); return; } tr[v].ls = ++cnt, tr[v].rs = ++cnt; int mid = s+t&gt;&gt;1; build(tr[v].ls, s, mid); build(tr[v].rs, mid+1, t); updata(v, s, t);}void modify(int v, int o, int s, int t, int l, int r, long long x) { tr[v] = tr[o]; if (s &gt;= l &amp;&amp; t &lt;= r) { tr[v].tag += x; tr[v].val += (long long)(t-s+1)*x; return; } int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, l, r, x); if (r &gt;= mid+1) modify(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, l, r, x); updata(v, s, t);}long long query(int v, int s, int t, int l, int r, long long tot) { if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].val+(long long)(t-s+1)*tot; tot += tr[v].tag; int mid = s+t&gt;&gt;1; long long ret = 0; if (l &lt;= mid) ret += query(tr[v].ls, s, mid, l, r, tot); if (r &gt;= mid+1) ret += query(tr[v].rs, mid+1, t, l, r, tot); return ret;}int main() { while(scanf("%d%d", &amp;n, &amp;m) != EOF) { cnt = now = 0; root[now] = ++cnt; build(root[now], 1, n); while (m--) { char ch; cin &gt;&gt; ch; if (ch == 'C') { int l, r; long long d; scanf("%d%d%I64d", &amp;l, &amp;r, &amp;d); now++; root[now] = ++cnt; modify(root[now], root[now-1], 1, n, l, r, d); } if (ch == 'Q') { int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%I64d\n", query(root[now], 1, n, l, r, 0LL)); } if (ch == 'H') { int l, r, t; scanf("%d%d%d", &amp;l, &amp;r, &amp;t); printf("%I64d\n", query(root[t], 1, n, l, r, 0LL)); } if (ch == 'B') { int t; scanf("%d", &amp;t); now = t; } } } return 0;}]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LG1073【NOIp2009】最优贸易 < Tarjan+DP >]]></title>
    <url>%2FLG1073%E3%80%90NOIp2009%E3%80%91%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%20Tarjan%2BDP%2F</url>
    <content type="text"><![CDATA[PRoblem最优贸易题目描述 国有 个大城市和 条道路，每条道路连接这 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 条。 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 国 个城市的标号从 ，阿龙决定从 号城市出发，并最终在 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。现在给出 个城市的水晶球价格， 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入输出格式输入格式：第一行包含 个正整数 和 ，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 个城市的商品价格。接下来 行，每行有 个正整数， ， ， ，每两个整数之间用一个空格隔开。如果 ，表示这条道路是城市 到城市 之间的单向道路；如果 ，表示这条道路为城市 和城市 之间的双向道路。输出格式：输出文件 共 行，包含 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 。 输入输出样例输入样例：12345675 5 4 3 5 6 1 1 2 1 1 4 1 2 3 2 3 5 1 4 5 2 输出样例：15 说明数据范围输入数据保证 号城市可以到达 号城市。对于 的数据， 。对于 的数据， 。对于 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 的数据， ， ， ， ， 各 城 市 水 晶 球 价 格 。 提高组 第三题 标签：Tarjan DP Solution吐槽一下，这人的旅费远大于他赚的差价作为中间商，真是个无脑商人… 首先肯定要缩点，记录每个分量的所有点中价格的最大值和最小值，缩点后 的时候就是 了，不会有环。接下来是 同时 。 表示从源点走到 点，最大差价是多少。初值为 。从源点所在点开始 ，从 走到一个点 ，先更新 的值，即 。然后更新 ，分别指最大价格在从源点到 的路径上和最大价格在 这个分量里。最后输出终点所在分量的 值即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define MAX_N 100000#define INF 2147483647using namespace std;int n, m, c[MAX_N+5], mm[MAX_N+5], mx[MAX_N+5], f[MAX_N+5];int dfn[MAX_N+5], low[MAX_N+5], id[MAX_N+5], ind, cnt;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];stack &lt;int&gt; sta; bool insta[MAX_N+5];void tarjan(int u) { dfn[u] = low[u] = ++ind, sta.push(u), insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (insta[v]) low[u] = min(low[u], dfn[v]); } if (low[u] == dfn[u]) { cnt++, mm[cnt] = INF, mx[cnt] = 0; for (int i = sta.top(); ; i = sta.top()) { id[i] = cnt, mm[cnt] = min(mm[cnt], c[i]), mx[cnt] = max(mx[cnt], c[i]); sta.pop(), insta[i] = false; if (i == u) break; } }}queue &lt;int&gt; que; bool inque[MAX_N+5];void BFS() { for (int i = 1; i &lt;= cnt; i++) f[i] = mx[i]-mm[i]; que.push(id[1]), inque[id[1]] = true; while (!que.empty()) { int u = que.front(); que.pop(), inque[u] = false; for (int i = 0; i &lt; E[u].size(); i++) { int v = E[u][i]; mm[v] = min(mm[v], mm[u]); f[v] = max(max(f[u], f[v]), mx[v]-mm[v]); if (!inque[v]) que.push(v), inque[v] = true; } }}int main() { scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); while (m--) { int u, v, d; scanf("%d%d%d", &amp;u, &amp;v, &amp;d); if (d == 1) G[u].push_back(v); else G[u].push_back(v), G[v].push_back(u); } for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; u++) for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (id[u] == id[v]) continue; E[id[u]].push_back(id[v]); } BFS(); printf("%d", f[id[n]]); return 0;}]]></content>
      <tags>
        <tag>图论</tag>
        <tag>DP</tag>
        <tag>Tarjan</tag>
        <tag>NOIp</tag>
        <tag>LG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3110 K大数查询]]></title>
    <url>%2FBZOJ3110%20K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%20%E6%A0%91%E5%A5%97%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ProblemK大数查询Description有 个位置， 个操作。操作有两种，每次操作如果是 的形式表示在第 个位置到第 个位置，每个位置加入一个数 ；如果是 形式，表示询问从第 个位置到第 个位置，第 大的数是多少。 Input第一行 ， 接下来 行，每行形如 或 Output输出每个询问的结果 Sample Input1234562 51 1 2 11 1 2 22 1 1 22 1 1 12 1 2 3 Sample Output123121 Hint样例说明第一个操作后位置 的数只有 ，位置 的数也只有 。第二个操作后位置 的数有 、 ，位置 的数也有 、 。第三次询问位置 到位置 第 大的数是 。第四次询问位置 到位置 第 大的数是 。第五次询问位置 到位置 第 大的数是 。数据规模 操作中 操作中 标签：值域线段树套区间线段树 Solution这道题乍一看时主席树，但实际上是树套树。外层值域线段树，内层区间线段树，外层只提供内层的根的位置，真正参与计算的是内层。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 50000using namespace std;typedef long long ll;int n, m, cnt;int root[(MAX_N&lt;&lt;2)+500], ls[MAX_N*16*16+500], rs[MAX_N*16*16+500];ll tr[MAX_N*16*16+500], tag[MAX_N*16*16+500];inline void updata(int v, int s, int t) {tr[v] = tr[ls[v]]+tr[rs[v]]+tag[v]*(ll)(t-s+1);}//内层修改void modify(int &amp;v, int s, int t, int l, int r) { if (!v) v = ++cnt; if (s &gt;= l &amp;&amp; t &lt;= r) {tr[v] += (ll)(t-s+1), tag[v]++; return;} int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify(ls[v], s, mid, l, r); if (r &gt;= mid+1) modify(rs[v], mid+1, t, l, r); updata(v, s, t);}//外层修改void insert(int v, int s, int t, int l, int r, int x) { modify(root[v], 1, n, l, r); if (s == t) return; int mid = s+t&gt;&gt;1; if (x &lt;= mid) insert(v&lt;&lt;1, s, mid, l, r, x); if (x &gt;= mid+1) insert(v&lt;&lt;1|1, mid+1, t, l, r, x);}//内层查询ll calc(int v, int s, int t, int l, int r) { if (!v) return 0; if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v]; int mid = s+t&gt;&gt;1; ll ret = tag[v]*(ll)(min(t, r)-max(s, l)+1); if (l &lt;= mid) ret += calc(ls[v], s, mid, l, r); if (r &gt;= mid+1) ret += calc(rs[v], mid+1, t, l, r); return ret;}//外层查询ll query(int v, int s, int t, int l, int r, int k) { if (s == t) return s; int mid = s+t&gt;&gt;1; ll tmp = calc(root[v&lt;&lt;1|1], 1, n, l, r); if (k &gt;= tmp+1) return query(v&lt;&lt;1, s, mid, l, r, k-tmp); if (k &lt;= tmp) return query(v&lt;&lt;1|1, mid+1, t, l, r, k);}int main() { scanf("%d%d", &amp;n, &amp;m); while (m--) { int opt, a, b, c; scanf("%d%d%d%d", &amp;opt, &amp;a, &amp;b, &amp;c); if (opt == 1) insert(1, 1, n, a, b, c); if (opt == 2) printf("%lld\n", query(1, 1, n, a, b, c)); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1182 【NOI2001】 食物链]]></title>
    <url>%2FPOJ1182%20%E3%80%90NOI2001%E3%80%91%20%E9%A3%9F%E7%89%A9%E9%93%BE%20%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Problem食物链Description动物王国中有三类动物 ，这三类动物的食物链构成了有趣的环形。 吃 ， 吃 ， 吃 。有 个动物，以 编号。每个动物都是 中的一种，但是我们并不知道它到底是哪一种。人用两种说法对这 个动物所构成的食物链关系进行描述：一种说法是 ，表示 和 是同类。二种说法是 ，表示 吃 。人对 个动物，用上述两种说法，一句接一句地说出 句话，这 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中 或 比 大，就是假话； 当前的话表示 吃 ，就是假话。 你的任务是根据给定的 （ ） 和 句话 （ ） ，输出假话的总数。 Input第一行是两个整数 和 ，以一个空格分隔。以下 行每行是三个正整数 ， ， ，两数之间用一个空格隔开，其中 表示说法的种类。若 ，则表示 和 是同类。若 ，则表示 吃 。 Output只有一个整数，表示假话的数目。 Sample Input12345678100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5 Sample Output13 标签：种类并查集 Solution逻辑推理的题有一部分和并查集有关，此题是种类并查集的经典例题。首先我们把每个动物分成三个点，对于点 ，点 表示第 个动物的种类，点 表示第 个动物的食物，点 表示第 个动物的天敌。这样一来，提供信息： 和 同类，相当于提供三条信息： 、 在同一个集中 、 在同一个集中 、 在同一个集中 于是我们 同理，提供信息： 吃 ，相当于提供三条信息： 、 在同一个集中 、 在同一个集中 、 在同一个集中 于是我们 如果在接到信息 和 同类后，发现 和 同类或 和 同类，则此信息与先前信息矛盾。因为对称性，我们不用再判断 是否和 或 同类。同理可处理 吃 的情况。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 50000using namespace std;int n, k, f[MAX_N*3+5], cnt = 0;int get(int x) { if (x != f[x]) f[x] = get(f[x]); return f[x];}inline void merge(int x, int y) { int ancx = get(x), ancy = get(y); if (ancx != ancy) f[ancx] = ancy; return;}int main() { scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n*3; i++) f[i] = i; for (int i = 0; i &lt; k; i++) { int s, x, y; scanf("%d%d%d", &amp;s, &amp;x, &amp;y); if (x &gt; n || y &gt; n) { cnt++; continue; } if (s == 1) { if (get(x) == get(y+n) || get(x) == get(y+2*n)) { cnt++; } else { merge(x, y); merge(x+n, y+n); merge(x+2*n, y+2*n); } } else { if (x == y || get(x) == get(y) || get(x) == get(y+n)) { cnt++; } else { merge(x, y+2*n); merge(x+n, y); merge(x+2*n, y+n); } } } printf("%d", cnt); return 0;}]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>NOI</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1170 Shopping Offers]]></title>
    <url>%2FPOJ1170%20Shopping%20Offers%20%E4%BA%94%E7%BB%B4DP%2F</url>
    <content type="text"><![CDATA[ProblemShopping OffersDescriptionIn a shop each kind of product has a price. For example, the price of a flower is ICU (Informatics Currency Units) and the price of a vase is ICU. In order to attract more customers, the shop introduces some special offers.A special offer consists of one or more product items for a reduced price. Examples: three flowers for ICU instead of , or two vases together with one flower for ICU instead of .Write a program that calculates the price a customer has to pay for certain items, making optimal use of the special offers. That is, the price should be as low as possible. You are not allowed to add items, even if that would lower the price.For the prices and offers given above, the (lowest) price for three flowers and two vases is ICU: two vases and one flower for the reduced price of ICU and two flowers for the regular price of ICU. InputYour program is to read from standard input. The first line contains the number of different kinds of products in the basket . Each of the next b lines contains three values , , and . The value is the (unique) product code . The value indicates how many items of this product are in the basket . The value p is the regular price per item . Notice that all together at most items can be in the basket. The line contains the number of special offers . Each of the next lines describes one offer by giving its structure and its reduced price. The first number n on such a line is the number of different kinds of products that are part of the offer . The next n pairs of numbers indicate that items with product code are involved in the offer. The last number on the line stands for the reduced price . The reduced price of an offer is less than the sum of the regular prices. OutputYour program is to write to standard output. Output one line with the lowest possible price to be paid. Sample Input12345627 3 28 2 521 7 3 52 7 1 8 2 10 Sample Output114 标签：五维DP Translation有至多五种物品，给出每一种物品的单价和几种套餐的价格，求买目标物品至少需要多少钱。 Solution这是一道大水题。因为只有五种物品，可以用五维的 来表示，五个维度分别表示五种物品的个数，即 表示第一种物品取 个，第二种物品取 个……第五种物品取 个至少需要多少钱。把每种物品的单价看作一种只有一个物品的套餐，这样枚举套餐，看能否转移。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 5#define MAX_S 100#define MAX_C 1000#define INF 2147483647using namespace std;int n, m, cnt, basket[MAX_N+5], offer[MAX_S+10][MAX_N+5], v[MAX_S+10], map[MAX_C+5];int f[MAX_N+5][MAX_N+5][MAX_N+5][MAX_N+5][MAX_N+5];int main() { scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) { int id, num, p; scanf("%d%d%d", &amp;id, &amp;num, &amp;p); map[id] = i, basket[i] = num, offer[cnt][i] = 1, v[cnt++] = p; } scanf("%d", &amp;m); for (int i =0; i &lt; m; i++) { int num, id, k, p; scanf("%d", &amp;num); for (int i = 0; i &lt; num; i++) { scanf("%d%d", &amp;id, &amp;k); offer[cnt][map[id]] = k; } scanf("%d", &amp;p); v[cnt++] = p; } for (int a0 = 0; a0 &lt;= basket[0]; a0++) for (int a1 = 0; a1 &lt;= basket[1]; a1++) for (int a2 = 0; a2 &lt;= basket[2]; a2++) for (int a3 = 0; a3 &lt;= basket[3]; a3++) for (int a4 = 0; a4 &lt;= basket[4]; a4++) { if (a0 == 0 &amp;&amp; a1 == 0 &amp;&amp; a2 == 0 &amp;&amp; a3 == 0 &amp;&amp; a4 == 0) {f[a0][a1][a2][a3][a4] = 0; continue;} f[a0][a1][a2][a3][a4] = INF; for (int i = 0; i &lt; cnt; i++) { if (a0 &lt; offer[i][0] || a1 &lt; offer[i][1] || a2 &lt; offer[i][2] || a3 &lt; offer[i][3] || a4 &lt; offer[i][4]) continue; f[a0][a1][a2][a3][a4] = min(f[a0][a1][a2][a3][a4], f[a0-offer[i][0]][a1-offer[i][1]][a2-offer[i][2]][a3-offer[i][3]][a4-offer[i][4]]+v[i]); } } printf("%d", f[basket[0]][basket[1]][basket[2]][basket[3]][basket[4]]); return 0;}]]></content>
      <tags>
        <tag>DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1798【AHOI2009】seq维护序列]]></title>
    <url>%2FBZOJ1798%E3%80%90AHOI2009%E3%80%91%20seq%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem维护序列题目描述老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。 有长为 的数列，不妨设为 。有如下三种操作形式： 把数列中的一段数全部乘一个值; 把数列中的一段数全部加一个值; 询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模 的值。 输入输出格式输入格式第一行两个整数 和 ( ）。第二行含有N个非负整数,从左到右依次为 , ( )。第三行有一个整数 ，表示操作总数。从第四行开始每行描述一个操作，输入的操作有以下三种形式： 操作 ：“ ”(不含双引号)。表示把所有满足 的 改为 。 操作 ：“ ”(不含双引号)。表示把所有满足 的 改为 。 操作 ：“ ”(不含双引号)。询问所有满足 的 的和模 的值 。 同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。输出格式对每个操作 ，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。 输入输出样例输入样例：123456787 431 2 3 4 5 6 751 2 5 53 2 42 3 7 93 1 33 4 7 输出样例：1232358 说明【样例说明】初始时数列为 。经过第 次操作后，数列为 。对第 次操作，和为 ，模 的结果是 。经过第 次操作后，数列为 对第 次操作，和为 ，模 的结果是 。对第 次操作，和为 ,模 的结果是 。 标签：线段树 Solution这题就是个线段树的板题，和洛谷的线段树模板 没什么区别。区间加、乘，区间求和注意 时加和乘的优先级，应该先把乘法 乘上加法 传到子结点，然后传乘法 。特别注意：乘法 下传后应改为 ，而不是 ！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 100000#define ll long longusing namespace std;int n, m;ll p;ll tree[MAX_N*4+5], mul[MAX_N*4+5], add[MAX_N*4+5];void updata(int v) { tree[v] = (tree[v&lt;&lt;1]+tree[v&lt;&lt;1|1])%p;}void downtag(int v, int s, int t, int mid) { if (mul[v] == 1 &amp;&amp; add[v] == 0) return; mul[v*2] = mul[v*2]*mul[v]%p; add[v*2] = (add[v*2]*mul[v]%p+add[v])%p; tree[v*2] = (tree[v*2]*mul[v]%p+add[v]*(ll)(mid-s+1)%p)%p; mul[v*2+1] = mul[v*2+1]*mul[v]%p; add[v*2+1] = (add[v*2+1]*mul[v]%p+add[v])%p; tree[v*2+1] = (tree[v*2+1]*mul[v]%p+add[v]*(ll)(t-mid)%p)%p; mul[v] = 1; add[v] = 0; return;}void create(int v, int s, int t) { mul[v] = 1; add[v] = 0; if (s == t) { scanf("%lld", &amp;tree[v]); tree[v] %= p; return; } int mid = s+t&gt;&gt;1; create(v&lt;&lt;1, s, mid); create(v&lt;&lt;1|1, mid+1, t); updata(v);}void modify1(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) { add[v] = (add[v]+(ll)x)%p; tree[v] = (tree[v]+(ll)x*(ll)(t-s+1)%p)%p; return; } int mid = s+t&gt;&gt;1; downtag(v, s, t, mid); if (l &lt;= mid) { modify1(v&lt;&lt;1, s, mid, l, r, x); } if (r &gt;= mid+1) { modify1(v&lt;&lt;1|1, mid+1, t, l, r, x); } updata(v);}void modify2(int v, int s, int t, int l, int r, int x) { if (s &gt;= l &amp;&amp; t &lt;= r) { mul[v] = mul[v]*(ll)x%p; add[v] = add[v]*(ll)x%p; tree[v] = tree[v]*(ll)x%p; return; } int mid = s+t&gt;&gt;1; downtag(v, s, t, mid); if (l &lt;= mid) { modify2(v&lt;&lt;1, s, mid, l, r, x); } if (r &gt;= mid+1) { modify2(v&lt;&lt;1|1, mid+1, t, l, r, x); } updata(v);}ll query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) { return tree[v]; } int mid = s+t&gt;&gt;1; ll ret = 0; downtag(v, s, t, mid); if (l &lt;= mid) { ret = (ret+query(v&lt;&lt;1, s, mid, l, r))%p; } if (r &gt;= mid+1) { ret = (ret+query(v&lt;&lt;1|1, mid+1, t, l, r))%p; } updata(v); return ret;}int main() { scanf("%d%d", &amp;n, &amp;p); create(1, 1, n); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) { int f; scanf("%d", &amp;f); if (f == 1) { int l, r, x; scanf("%d%d%d", &amp;l, &amp;r, &amp;x); modify2(1, 1, n, l, r, x%p); } else if (f == 2) { int l, r, x; scanf("%d%d%d", &amp;l, &amp;r, &amp;x); modify1(1, 1, n, l, r, x%p); } else { int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%lld\n", query(1, 1, n, l, r)); } } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2002 Bounce 弹飞绵羊]]></title>
    <url>%2FBZOJ2002%20Bounce%20%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A%20%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[ProblemBounce 弹飞绵羊Description某天， 发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始， 在地上沿着一条直线摆上 个装置，每个装置设定初始弹力系数 ，当绵羊达到第 个装置时，它会往后弹 步，达到第 个装置，若不存在第 个装置，则绵羊被弹飞。绵羊想知道当它从第 个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣， 可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 Input第一行包含一个整数 ，表示地上有 个装置，装置的编号从 到 ,接下来一行有 个正整数，依次为那 个装置的初始弹力系数。第三行有一个正整数 ，接下来 行每行至少有两个数 、 ，若 ，你要输出从 出发被弹几次后被弹飞，若 则还会再输入一个正整数 ，表示第 个弹力装置的系数被修改成 。 Output对于每个 的情况，你都要输出一个需要的步数，占一行。 Sample Input1234564 1 2 1 1 31 12 1 11 1 Sample Output1223 Hint对于 的数据 ；对于 的数据 , 标签：LCT 分块 Solution本题其实应该是 的基础题，但是因为我身为蒟蒻写不来 ，就用分块做了。把原数列分为 个块，对于每个块，维护块内的每个位置需要多少步才能跳到块外，以及跳到块外后的位置，对于修改操作，重算那个块内的所有位置的两个值，这样单次询问或修改复杂度 ，总复杂度 。可过。 Code1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAX_N 200000using namespace std;int n, m, magic, k[MAX_N+5];int pos[MAX_N+5], times[MAX_N+5];void update(int l, int r) { for (int i = r; i &gt;= l; i--) if (i+k[i] &gt;= n) pos[i] = -1, times[i] = 1; else if (i+k[i] &gt;= (i/magic+1)*magic) pos[i] = i+k[i], times[i] = 1; else pos[i] = pos[i+k[i]], times[i] = times[i+k[i]]+1;}int main() { scanf("%d", &amp;n), magic = sqrt(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;k[i]); update(0, n-1); scanf("%d", &amp;m); while (m--) { int opt; scanf("%d", &amp;opt); if (opt == 1) { int x, ans = 0; scanf("%d", &amp;x); while (x != -1) ans += times[x], x = pos[x]; printf("%d\n", ans); } if (opt == 2) {int x, y; scanf("%d%d", &amp;x, &amp;y), k[x] = y; update(x/magic*magic, x);} } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3673 可持久化并查集 by zky]]></title>
    <url>%2FBZOJ3673%20%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86%20by%20zky%20%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Problem可持久化并查集 by zkyDescription 个集合 个操作操作： 合并 所在集合 回到第 次操作之后的状态(查询算作操作) 询问 是否属于同一集合，是则输出 否则输出 Input第一行两个整数 以后 行，每行三个或两个整数 或 ，意义如上所述 Ouput对于每个 操作，输出 Sample Input12345675 61 1 23 1 22 03 1 22 13 1 2 Sample Output123101 Hint 标签：主席树 可持久化数组 Solution本题的做法其实和并查集没太大关联。如果是撤销，那可以用不加路径压缩的并查集完成，但是如果回到某时间，则不太好写。这时，我们发现并查集这个东西构造其实很简单，只需要一个 数组就行了。所以我们自然可以想到直接用一个二维数组存储每个时间的 数组，即用增加的一维表示时间。但是， 、 是 级别，所以肯定会 ，这里我们就需要用到主席树，把 数组可持久化。这里需要注意我们不能用路径压缩优化，因为我们需要回到前面的状态，为了让它跑得更快，我们可以用按秩合并优化。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 20000using namespace std;int n, m, cnt, now, root[MAX_N*10+5];struct node {int fa, dep, ls, rs;} tr[MAX_N*100+5];void build(int v, int l, int r) { if (l == r) {tr[v].fa = l; return;} int mid = l+r&gt;&gt;1; tr[v].ls = ++cnt, tr[v].rs = ++cnt; build(tr[v].ls, l, mid); build(tr[v].rs, mid+1, r);}void modifyfa(int v, int o, int s, int t, int pos, int x) { tr[v] = tr[o]; if (s == t) {tr[v].fa = x; return;} int mid = s+t&gt;&gt;1; if (pos &lt;= mid) modifyfa(tr[v].ls = ++cnt, tr[o].ls, s, mid, pos, x); else modifyfa(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, pos, x);}void modifydep(int v, int s, int t, int pos) { if (s == t) {tr[v].dep++; return;} int mid = s+t&gt;&gt;1; if (pos &lt;= mid) modifydep(tr[v].ls, s, mid, pos); else modifydep(tr[v].rs, mid+1, t, pos);}int find(int v, int s, int t, int pos) { if (s == t) return v; int mid = s+t&gt;&gt;1; if (pos &lt;= mid) return find(tr[v].ls, s, mid, pos); else return find(tr[v].rs, mid+1, t, pos);}int getf(int r, int x) { int pos = find(r, 1, n, x); if (tr[pos].fa != x) return getf(r, tr[pos].fa); return pos;}int main() { scanf("%d%d", &amp;n, &amp;m); cnt = 0, root[0] = ++cnt; build(root[0], 1, n); for (int now = 1; now &lt;= m; now++) { int opt; scanf("%d", &amp;opt); if (opt == 1) { root[now] = root[now-1]; int a, b; scanf("%d%d", &amp;a, &amp;b); int posa = getf(root[now], a), posb = getf(root[now], b); if (tr[posa].fa == tr[posb].fa) continue; if (tr[posa].dep &gt; tr[posb].dep) swap(posa, posb); root[now] = ++cnt; modifyfa(root[now], root[now-1], 1, n, tr[posa].fa, tr[posb].fa); if (tr[posa].dep == tr[posb].dep) modifydep(root[now], 1, n, tr[posb].fa); } if (opt == 2) { int k; scanf("%d", &amp;k); root[now] = root[k]; } if (opt == 3) { root[now] = root[now-1]; int a, b; scanf("%d%d", &amp;a, &amp;b); if (tr[getf(root[now], a)].fa == tr[getf(root[now], b)].fa) printf("1\n"); else printf("0\n"); } } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2155 Matrix]]></title>
    <url>%2FPOJ2155%20Matrix%20%E6%A0%91%E5%A5%97%E6%A0%91%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[ProblemMatrixTime Limit: Memory Limit: DescriptionGiven an matrix , whose elements are either or . means the number in the row and column. Initially we have .We can change the matrix in the following way. Given a rectangle whose upper-left corner is and lower-right corner is , we change all the elements in the rectangle by using “not” operation (if it is a ‘ ’ then change it into ‘ ’ otherwise change it into ‘ ’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. ( ) changes the matrix by using the rectangle whose upper-left corner is and lower-right corner is . ( ) querys . InputThe first line of the input is an integer representing the number of test cases. The following X blocks each represents a test case.The first line of each block contains two numbers and ( , ) representing the size of the matrix and the number of the instructions. The following lines each represents an instruction having the format “ ” or “ ”, which has been described above. OutputFor each querying output one line, which has an integer representing .There is a blank line between every two continuous test cases. Sample Input12345678910111212 10C 2 1 2 2Q 2 2C 2 1 2 1Q 1 1C 1 1 2 1C 1 2 1 2C 1 1 2 2Q 1 1C 1 1 2 1Q 2 1 Sample Output12341001 标签：线段树套线段树/二维树状数组 Solution此题最简单的方法是二维树状数组，但因为二维树状数组没太大用，所以练习线段树的树套树。此题用作树套树的模板题再合适不过。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 1000using namespace std;int n, m;int tr[(MAX_N&lt;&lt;2)+5][(MAX_N&lt;&lt;2)+5];void modify_y(int v1, int v2, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) { tr[v1][v2] ^= 1; return; } int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify_y(v1, v2&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) modify_y(v1, v2&lt;&lt;1|1, mid+1, t, l, r);}void modify_x(int v, int s, int t, int x1, int y1, int x2, int y2) { if (s &gt;= x1 &amp;&amp; t &lt;= x2) { modify_y(v, 1, 1, n, y1, y2); return; } int mid = s+t&gt;&gt;1; if (x1 &lt;= mid) modify_x(v&lt;&lt;1, s, mid, x1, y1, x2, y2); if (x2 &gt;= mid+1) modify_x(v&lt;&lt;1|1, mid+1, t, x1, y1, x2, y2);}int query_y(int v1, int v2, int s, int t, int pos) { if (s == t) return tr[v1][v2]; int mid = s+t&gt;&gt;1; if (pos &lt;= mid) return tr[v1][v2]^query_y(v1, v2&lt;&lt;1, s, mid, pos); else return tr[v1][v2]^query_y(v1, v2&lt;&lt;1|1, mid+1, t, pos);}int query_x(int v, int s, int t, int x, int y) { if (s == t) return query_y(v, 1, 1, n, y); int mid = s+t&gt;&gt;1; if (x &lt;= mid) return query_y(v, 1, 1, n, y)^query_x(v&lt;&lt;1, s, mid, x, y); else return query_y(v, 1, 1, n, y)^query_x(v&lt;&lt;1|1, mid+1, t, x, y);}int main() { int T; scanf("%d", &amp;T); while (T--) { memset(tr, 0, sizeof(tr)); scanf("%d%d", &amp;n, &amp;m); while (m--) { char ch; cin &gt;&gt; ch; if (ch == 'C') { int x1, y1, x2, y2; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); modify_x(1, 1, n, x1, y1, x2, y2); } if (ch == 'Q') { int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", query_x(1, 1, n, x, y)); } } printf("\n"); } return 0;}]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>树套树</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5340 Three Palindromes < Manacher >]]></title>
    <url>%2FHDU5340%20Three%20Palindromes%20Manacher%2F</url>
    <content type="text"><![CDATA[ProblemThree PalindromesDescriptionCan we divided a given string into three nonempty palindromes? InputFirst line contains a single integer which denotes the number of test cases.For each test case , there is an single line contains a string which only consist of lowercase English letters. OutputFor each case, output the Yes or No​ in a single line. Sample Input1232abcabaadada Sample Output12YesNo 标签：Manacher Translation给出字符串 ，判断 是否能被分为三段回文串。 Solution看到回文串，可知本题大概和Manacher有关。在Manacher中，我们有一个数组 ， 记录从第i位向两边拓展，最长回文串的半径是多少。注意到本题有一个特殊的数据—— ，而三段中，只要能确定任意两段，另一段就能确定。而这三段中肯定有两段是覆盖到串首或串尾的。因而我们可以用 是否等于 来确定 位置是否能成为第一个段的中心点，如法炮制可求出第三段。这时我们暴力枚举第一段和第三段，这样确定第二段后，找到此段中心，可通过 确定第二段是否是回文串。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_L 20000using namespace std;char s[MAX_L*2+5];int f[MAX_L*2+5];bool manacher (char* s0) { int len = strlen(s0), pos = 0, r = 0; for (int i = 0; i &lt; len; i++) s[i*2+1] = '#', s[i*2+2] = s0[i]; s[len = len*2+1] = '#'; for (int i = 1; i &lt;= len; i++) { f[i] = (i &lt; r) ? min(f[2*pos-i], r-i) : 1; while (i-f[i] &gt;= 1 &amp;&amp; i+f[i] &lt;= len &amp;&amp; s[i-f[i]] == s[i+f[i]]) f[i]++; if (i+f[i] &gt; r) pos = i, r = i+f[i]; } int lm[MAX_L*2+5], rm[MAX_L*2+5], cntl = 0, cntr = 0; for (int i = 1; i &lt;= len; i++) { if (f[i] == i &amp;&amp; f[i] &gt; 1) lm[cntl++] = i; if (f[len-i+1] == i &amp;&amp; f[len-i+1] &gt; 1) rm[cntr++] = len-i+1; } for (int i = 0; i &lt; cntl; i++) for (int j = 0; j &lt; cntr; j++) { int s = lm[i]+f[lm[i]], t = rm[j]-f[rm[j]]; if (s &gt; t) continue; if (f[s+t&gt;&gt;1] == 1) continue; if (f[s+t&gt;&gt;1]*2-1 &lt; t-s+1) continue; return true; } return false;}int main() { int T; scanf("%d", &amp;T); while (T--) { char s0[MAX_L+5]; scanf("%s", s0); if (manacher(s0)) printf("Yes\n"); else printf("No\n"); } return 0;}]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1201 Intervals]]></title>
    <url>%2FPOJ1201%20Intervals%20%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[ProblemIntervalsDescriptionYou are given closed, integer intervals and integers .Write a program that:reads the number of intervals, their end points and integers from the standard input, computes the minimal size of a set of integers which has at least common elements with interval , for each , writes the answer to the standard output. InputThe first line of the input contains an integer ( ) – the number of intervals. The following n lines describe the intervals. The line of the input contains three integers , and separated by single spaces and such that and . OutputThe output contains exactly one integer equal to the minimal size of set sharing at least elements with interval , for each . Sample Input12345653 7 38 10 36 8 11 3 110 11 1 Sample Output16 标签：差分约束系统 Translation给出 个区间，试确定一个集合使得对于 ，第 个区间内至少有 个数，并使得此集合尽量小，输出最小大小。 Solution首先用前缀和。 表示从 到 中共选出多少个数到集合中。这样对于集合 ，有 ，于是我们可以从点 到 连一条权值为 的边。因为题意是要满足所有的边，所以我们需要找最长路。此题有一些细节问题。首先，找最长路需要起点和终点，我们需要找到这些集合覆盖的范围，即找到左端点（其实应该是左端点 ）的最小值 和右端点的最大值 ，找 到 的最大值。此外，光有上述的那些边时无法构成一个连通图的，所以我们需要找一些隐含条件。可以发现有 ， ，为了保持一致，应将后面的式子转化为大于等于，即 ，这样对于 ，从 到 连接一条权值为 的路，从 到 连接一条权值为 的路，之后就可以直接用 找最长路了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 50000using namespace std;int n, cnt, s, t, pre[MAX_N+5], dis[MAX_N+5];struct node {int v, c, nxt;} E[MAX_N*3+5];void insert(int u, int v, int c) { E[++cnt].v = v, E[cnt].c = c; E[cnt].nxt = pre[u], pre[u] = cnt;}void SPFA() { queue &lt;int&gt; que; bool inque[MAX_N+5]; memset(dis, 128, sizeof(dis)); memset(inque, 0, sizeof(inque)); dis[s] = 0; que.push(s), inque[s] = true; while (!que.empty()) { int u = que.front(); for (int i = pre[u]; i; i = E[i].nxt) { int v = E[i].v, c = E[i].c; if (dis[u]+c &gt; dis[v]) { dis[v] = dis[u]+c; if (!inque[v]) que.push(v), inque[v] = true; } } que.pop(), inque[u] = false; }}int main() { while (scanf("%d", &amp;n) != EOF) { cnt = 0, s = 50000, t = 0; memset(pre, 0, sizeof(pre)); memset(E, 0, sizeof(E)); for (int i = 0; i &lt; n; i++) { int u, v, c; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); insert(u, v+1, c); s = min(s, u); t = max(t, v+1); } for (int i = s; i &lt; t; i++) insert(i, i+1, 0), insert(i+1, i, -1); SPFA(); printf("%d\n", dis[t]); } return 0;}]]></content>
      <tags>
        <tag>图论</tag>
        <tag>POJ</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2434【NOI2011】阿狸的打字机]]></title>
    <url>%2FBZOJ2434%E3%80%90NOI2011%E3%80%91%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%2BFail%E6%A0%91%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Problem阿狸的打字机Description阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有 个按键，分别印有 个小写英文字母和 、 两个字母。经阿狸研究发现，这个打字机是这样工作的： 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。 按一下印有 的按键，打字机凹槽中最后一个字母会消失。 按一下印有 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。 例如，阿狸输入 ，纸上被打印的字符如下： 我们把纸上打印出来的字符串从 开始顺序编号，一直到 。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 （其中 ），打字机会显示第 个打印的字符串在第 个打印的字符串中出现了多少次。阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？ Input输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。第二行包含一个整数 ，表示询问个数。接下来 行描述所有由小键盘输入的询问。其中第 行包含两个整数 , ，表示第 个询问为 。 Output输出 行，其中第 行包含一个整数，表示第 个询问的答案。 Sample Input12345aPaPBbP31 21 32 3 Sample Output123210 Hint 输 入 总 长 标签：AC自动机 Fail树 树状数组 Solution这道题的提示还是很明显的。读完题目，很容易发现此题打字的部分就是在建一棵 。输入小写字母即在 中添加一个子结点并向儿子结点走，输入‘ ’即退回到父结点，输入’ ‘即在当前结点打标记。因而我们可以构建 如下：123456789101112131415161718192021222324void init() { //我写Trie树的习惯：把根节点定为1 cnt = 0, root = 1, fa[root] = 0; //0号节点所有儿子都练到根，这样AC自动机CalcFail时更方便 for (int i = 0; i &lt; 26; i++) trie[0][i] = root;}void build() { init(); n = strlen(s); ind = 1;//ind记录当前结点数 for (int i = 0, cur = root; i &lt; n; i++) { if (s[i] == 'B') { //退到父结点 cur = fa[cur]; } else if (s[i] == 'P') { //打标记，标记为第cnt个字符串 pos[++cnt] = cur; } else { //新建子结点 trie[cur][s[i]-'a'] = ++ind; fa[ind] =cur, cur = ind;` } }} 接下来我们对付这题的询问。首先，它要求一个字符串在另一个字符串中出现多少次，这显然是 自动机的操作，所以我们建立 数组如下： 12345678910111213141516void CalcFail() { queue &lt;int&gt; que; que.push(root); while (!que.empty()) { int u = que.front(); for (int i = 0; i &lt; DICNUM; i++) { if (trie[u][i]) { fail[trie[u][i]] = trie[fail[u]][i]; que.push(trie[u][i]); } else { trie[u][i] = trie[fail[u]][i]; } } que.pop(); }} 现在我们考虑 数组的实质。如果 结点的 指向 结点，则 结点代表的字符串一定是 结点代表字符串的后缀，即经过 的所有路径组成的字符串都包含 结点代表的字符串。对于一个字符串，它的所有字串为它所有前缀的所有后缀，所以对于询问 ，我们需要找出从根节点到 的路径中有多少结点可以通过 指针转移到 。 这时我们就需要考虑 树了。对于任意结点 ，我们把所有通过 指针能直接转移到 的结点作为 的子结点，而 通过 指针转移到的结点作为 的父结点。这样我们就能构建一棵树。这样一来，对于询问 ，问题等价于从根到 的结点中有多少节点是在 的子树中。我们就可以用 序操作。然后用树状数组维护。 为了使询问变得更好操作，我们考虑把询问按 值排序，这样我们就只需一直往下走，然后标记经过的结点，然后统计 子树即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAX_N 100000#define DICNUM 26using namespace std;int n, m, cnt, ind;int root, trie[MAX_N+5][DICNUM], fa[MAX_N+5], fail[MAX_N+5], pos[MAX_N+5], ans[MAX_N+5];char s[MAX_N+5];vector &lt;int&gt; G[MAX_N+5];int into[MAX_N+5], outo[MAX_N+5];int tr[MAX_N+5];struct Query {int x, y, id;} q[MAX_N+5];bool cmp (const Query &amp;a, const Query &amp;b) {return a.y &lt; b.y;}void init() { cnt = 0, root = 1, fa[root] = 0; for (int i = 0; i &lt; DICNUM; i++) trie[0][i] = root;}void CalcFail() { queue &lt;int&gt; que; que.push(root); while (!que.empty()) { int u = que.front(); for (int i = 0; i &lt; DICNUM; i++) { if (trie[u][i]) { fail[trie[u][i]] = trie[fail[u]][i]; que.push(trie[u][i]); } else { trie[u][i] = trie[fail[u]][i]; } } que.pop(); }}void DFS(int u) { into[u] = ++ind; for (int i = 0; i &lt; G[u].size(); i++) DFS(G[u][i]); outo[u] = ind;}void build() { init(); n = strlen(s); ind = 1; for (int i = 0, cur = root; i &lt; n; i++) { if (s[i] == 'B') { cur = fa[cur]; } else if (s[i] == 'P') { pos[++cnt] = cur; } else { trie[cur][s[i]-'a'] = ++ind; fa[ind] = cur, cur = ind; } } CalcFail(); for (int i = 1; i &lt;= ind; i++) G[fail[i]].push_back(i); ind = 0; DFS(root);}void inc(int pos) {for (; pos &lt;= ind; pos += pos&amp;(-pos)) tr[pos]++;}void dec(int pos) {for (; pos &lt;= ind; pos += pos&amp;(-pos)) tr[pos]--;}int sum(int pos) {int ret = 0; for (; pos; pos -= pos&amp;(-pos)) ret += tr[pos]; return ret;}void solve() { sort(q, q+m, cmp); for (int i = 0, j = 0, cur = root, now = 0; i &lt; n; i++) if (s[i] == 'B') { dec(into[cur]); cur = fa[cur]; } else if (s[i] == 'P') { now++; for (; j &lt; m &amp;&amp; q[j].y == now; j++) ans[q[j].id] = sum(outo[pos[q[j].x]])-sum(into[pos[q[j].x]]-1); } else { cur = trie[cur][s[i]-'a']; inc(into[cur]); }}int main() { scanf("%s", s); build(); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) scanf("%d%d", &amp;q[i].x, &amp;q[i].y), q[i].id = i; solve(); for (int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>NOI</tag>
        <tag>树状数组</tag>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2588 Count on a tree]]></title>
    <url>%2FBZOJ2588%20Count%20on%20a%20tree%20%E6%A0%91%E4%B8%8A%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ProblemCount on a treeDescription给定一棵 个节点的树，每个点有一个权值，对于 个询问 ，你需要回答 和 这两个节点间第 小的点权。其中 是上一个询问的答案，初始为 ，即第一个询问的 是明文。 Input第一行两个整数 。第二行有 个整数，其中第 个整数表示点 的权值。后面 行每行 个整数 ，表示点 到点 有一条边。最后 行每行 个整数 ，表示一组询问。 Output 行，表示每个询问的答案。最后一个询问不输出换行符 Sample Input12345678910111213148 5105 2 9 3 8 5 7 71 21 31 43 53 63 74 82 5 10 5 210 5 311 5 4110 8 2 Sample Output123452891057 Hint 标签：LCA 主席树 Solution这是一个区间第 小的问题，所以可以很自然的想到值域主席树。但是此题将区间移到了树上，于是写树上主席树。在解区间第 小的时候，对于每次询问区间 ，我们需要找到 位置的线段树和 位置的线段树，然后递归 的时候用个数相减。对于这道题，我们把每个结点到根的那条链作为一个序列，用区间第 小的方法存储，然后找到 和 的 （假定它为 ），递归 的时候计算左区间数的个数，即 结 点 对 应 线 段 树 左 区 间 数 的 个 数 结 点 数 的 个 数 结 点 数 的 个 数 的 父 结 点 数 的 个 数 即 。写的时候注意强制在线的操作方式和读入数后先离散化。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;#define LOG 20#define MAX_N 100000#define mid ((s+t)&gt;&gt;1)using namespace std;template &lt;class T&gt; inline void read(T &amp;x) { x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');}int n, m, q, cnt;int rt[MAX_N+5], fa[MAX_N+5][LOG+1], dep[MAX_N+5];int a[MAX_N+5], b[MAX_N+5], h[MAX_N+5], rk[MAX_N+5];vector &lt;int&gt; G[MAX_N+5]; struct node {int ls, rs, c;} tr[MAX_N*35+5];bool cmp (const int &amp;x, const int &amp;y) {return a[x] &lt; a[y];}void addedge(int u, int v) {G[u].push_back(v), G[v].push_back(u);}void DFS(int u) { for (int i = 1; i &lt;= LOG; i++) if (dep[u] &gt;= (1&lt;&lt;i)) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int i = 0, v; i &lt; (int)G[u].size(); i++) if ((v = G[u][i]) ^ fa[u][0]) fa[v][0] = u, dep[v] = dep[u]+1, DFS(v);}int LCA(int a, int b) { if (dep[a] &lt; dep[b]) swap(a, b); for (int i = LOG; ~i; i--) if (dep[a]-(1&lt;&lt;i) &gt;= dep[b]) a = fa[a][i]; if (a == b) return a; for (int i = LOG; ~i; i--) if (fa[a][i]^fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];}void modify(int v, int o, int s, int t, int x) { tr[v] = tr[o]; if (s == t) {tr[v].c++; return;} if (x &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, x); else modify(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, x); tr[v].c = tr[tr[v].ls].c+tr[tr[v].rs].c;}int query(int v1, int v2, int v3, int v4, int s, int t, int k) { if (s == t) return s; int lsz = tr[tr[v1].ls].c+tr[tr[v2].ls].c-tr[tr[v3].ls].c-tr[tr[v4].ls].c; if (k &lt;= lsz) return query(tr[v1].ls, tr[v2].ls, tr[v3].ls, tr[v4].ls, s, mid, k); return query(tr[v1].rs, tr[v2].rs, tr[v3].rs, tr[v4].rs, mid+1, t, k-lsz);}void build(int u) { modify(rt[u] = ++cnt, rt[fa[u][0]], 1, m, b[u]); for (int i = 0, v; i &lt; (int)G[u].size(); i++) if ((v = G[u][i]) ^ fa[u][0]) build(v);}int main() { read(n), read(q); for (int i = 1; i &lt;= n; i++) read(a[i]), rk[i] = i; for (int i = 1, u, v; i &lt; n; i++) read(u), read(v), addedge(u, v); sort(rk+1, rk+n+1, cmp); for (int i = 1; i &lt;= n; b[rk[i++]] = m) if (i == 1 || (a[rk[i]]^a[rk[i-1]])) h[++m] = a[rk[i]]; DFS(1), build(1); int lst = 0; while (q--) { int u, v, k; read(u), read(v), read(k), u ^= lst; int anc = LCA(u, v); printf("%d\n", lst = h[query(rt[u], rt[v], rt[anc], rt[fa[anc][0]], 1, m, k)]); } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1179【APIO2009】ATM < Tarjan >]]></title>
    <url>%2FBZOJ1179%E3%80%90APIO2009%E3%80%91ATM%20Tarjan%2F</url>
    <content type="text"><![CDATA[Problem【APIO2009】ATM Description 城中的道路都是单向的。不同的道路由路口连接。按照法律规定，在每个路口都设立了一个 银行的 取款机。令人奇怪的是， 的酒吧都设在路口，虽然并不是每个路口都设有酒吧。 计划实施 有史以来最惊天动地的 抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的 机，最终他将在一个酒吧庆祝他的胜利。使用高超的黑客技术，他获知了每个 机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某酒吧时最多能抢劫的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫某个 机后，该 机就不会再有钱了。 Input第一行包含两个整数 、 。 表示路口的个数， 表示道路条数。接下来 行，每行两个整数，这两个整数都在 到 之间，第 行的两个整数表示第i条道路的起点和终点的路口编号。接下来 行，每行一个整数，按顺序表示每个路口处的 机中的钱数。接下来一行包含两个整数 、 ， 表示市中心的编号，也就是出发的路口。 表示酒吧数目。接下来的一行中有 个整数，表示 个有酒吧的路口的编号。 Output输出一个整数，表示 从市中心开始到某个酒吧结束所能抢劫的最多的现金总数。 Sample Input1234567891011121314151617186 71 22 33 52 44 12 66 510128161 51 44356 Sample Output147 HINT 的输入保证 。 的输入保证 。每个 机中可取的钱数为一个非负整数且不超过 。输入数据保证你可以从市中心沿着 的单向的道路到达其中的至少一个酒吧。 标签：Tarjan SPFA Solution题面有一种莫名其妙的喜感这道题是我的第一道 题（虽然是水题）首先，很容易看出要tarjan缩点。题目说城市的路是单向边，而且可以经过任意一点任意多次，所以走到强连通分量，这个强连通分量的所有点都可以到达，所有 机都可以抢。于是我们先缩点，顺带记录每个分量的 机价值总和，并统计每个分量有没有酒吧，即能否作为停止点。然后跑一遍SPFA，找以所有带酒吧的分量为终点的最长路即可。五十行随便写完，数据无坑。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define MAX_N 500000using namespace std;int n, m, s, p, c[MAX_N+5], end[MAX_N+5], endc[MAX_N+5], dfn[MAX_N+5], low[MAX_N+5], id[MAX_N+5], sz[MAX_N+5], ind, cnt;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];stack &lt;int&gt; sta; bool insta[MAX_N+5];void tarjan(int u) { dfn[u] = low[u] = ++ind, sta.push(u), insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) { int v = G[u][i]; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (insta[v]) low[u] = min(low[u], dfn[v]); } if (dfn[u] == low[u]) { cnt++; for (int i = sta.top(); ; i = sta.top()) { id[i] = cnt, sz[cnt] += c[i], insta[i] = false; sta.pop(); if (i == u) break; } }}queue &lt;int&gt; que; bool inque[MAX_N+5]; int f[MAX_N+5], ans;void SPFA() { f[s] = sz[s], que.push(s), inque[s] = true; while (!que.empty()) { int u = que.front(); que.pop(), inque[u] = false; for (int i = 0; i &lt; E[u].size(); i++) { int v = E[u][i]; if (f[v] &gt; f[u]+sz[v]) continue; f[v] = f[u]+sz[v]; if (!inque[v]) que.push(v), inque[v] = true; if (endc[v]) ans = max(ans, f[v]); } }}int main() { scanf("%d%d", &amp;n, &amp;m); while (m--) {int u, v; scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v);} for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); scanf("%d%d", &amp;s, &amp;p); while (p--) {int x; scanf("%d", &amp;x), end[x] = 1;} for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i++) endc[id[i]] |= end[i]; for (int u = 1; u &lt;= n; u++) for (int i = 0; i &lt; G[u].size(); i++) {int v = G[u][i]; if (id[u] != id[v]) E[id[u]].push_back(id[v]);} s = id[s], SPFA(); printf("%d", ans); return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>APIO</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1012【JSOI2008】最大数]]></title>
    <url>%2FBZOJ1012%E3%80%90JSOI2008%E3%80%91%E6%9C%80%E5%A4%A7%E6%95%B0%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem最大数题目描述现在请求你维护一个数列，要求提供以下两种操作： 查询操作。语法： 功能：查询当前数列中末尾 个数中的最大的数，并输出这个数的值。限制： 不超过当前数列的长度。 插入操作。语法： 功能：将 加上 ，其中 是最近一次查询操作的答案（如果还未执行过查询操作，则 ），并将所得结果对一个固定的常数 取模，将所得答案插入到数列的末尾。限制： 是整数（可能为负数）并且在长整范围内。 注意：初始时数列是空的，没有一个数。 输入输出格式输入格式第一行两个整数， 和 ，其中 表示操作的个数 ， 如上文中所述，满足 接下来的 行，每行一个字符串，描述一个具体的操作。语法如上文所述。输出格式对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。 输入输出样例输入样例1234565 100A 96Q 1A 97Q 1Q 2 输出样例123969396 标签：线段树 Solution线段树裸题。记录当前长度 ，每个结点维护区间最大值，操作 为 ，操作 为 。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 200000#define INF 2000000000#define ll long longusing namespace std;ll tree[MAX_N*4+50];int n, len = 0;void updata(int v) { tree[v] = max(tree[v&lt;&lt;1], tree[v&lt;&lt;1|1]);}void build(int v, int s, int t) { if (s == t) { tree[v] = -INF; return; } int mid = s+t&gt;&gt;1; build(v&lt;&lt;1, s, mid); build(v&lt;&lt;1|1, mid+1, t); updata(v);}void modify(int v, int s, int t, int pos, ll x) { if (s == t) { tree[v] = x; return; } int mid = s+t&gt;&gt;1; if (pos &lt;= mid) { modify(v&lt;&lt;1, s, mid, pos, x); } else { modify(v&lt;&lt;1|1, mid+1, t, pos, x); } updata(v);}ll query(int v, int s, int t, int l, int r) { if (s &gt;= l &amp;&amp; t &lt;= r) { return tree[v]; } int mid = s+t&gt;&gt;1; ll ret = -INF; if (l &lt;= mid) { ret = max(ret, query(v&lt;&lt;1, s, mid, l, r)); } if (r &gt;= mid+1) { ret = max(ret, query(v&lt;&lt;1|1, mid+1, t, l, r)); } return ret;}int main() { ll x, prev = 0, mod; char opt; int l; scanf("%d%lld", &amp;n, &amp;mod); build(1, 1, n); for (int i = 0; i &lt; n; i++) { cin &gt;&gt; opt; if (opt == 'A') { scanf("%lld", &amp;x); modify(1, 1, n, ++len, (x%mod+prev)%mod); } else { scanf("%d", &amp;l); prev = query(1, 1, n, len-l+1, len); printf("%lld\n", prev); prev %= mod; } } return 0;}]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170710总结]]></title>
    <url>%2F20170710%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是数据结构的最后一天。上午考试一反常态，花式翻车。 是签到水题，居然没开 ， 爆成负； 用的是 （调试为 下），考试为 下，应该用 ，爆零了。 是一个 的版题，但是因为对翻转操作不熟悉，没有写正解。看来得多写写 ，因为比较好写又灵活的平衡树就是 了（当然， 也算）。 写了一个玄学的值域主席树优化，虽然最坏复杂度还是 ，但是如果值域范围小，在 以内都能过，因而我 和 都过了一半以上，可惜是子任务，不然就赚了。 正解是分块，不太好写。隔壁 说是莫队，而且他的程序碾压标程，三项都比标程好,,ԾㅂԾ,,…莫队大法好下午先讲了树链剖分，然后讲了一些数据结构杂题。杂题的思维难度都比较高，而且根本看不出和数据结构有什么联系。个人认为，数据结构其实就是工具，和解题方法无关，方法归方法，数据结构只是在解题的时候进行优化。除了版题以外，对于其他数据结构题，想的时候还是不要使劲往数据结构上靠，应该先全面想，再在局部用数据结构优化，这样才能打开思维。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170707总结]]></title>
    <url>%2F20170707%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是数据结构最难的一天，学了平衡树。讲了替罪羊树、 、 。学长说掌握两种即可，又因为替罪羊树最基础，所以我没有写替罪羊树，只是理解了一下，准备学 和 。今天我写的是 ，不得不说，比以前见过的 好写多了，操作就只有 和 两种，插入删除都是 到要插入/删除的点，把其他点和要插入的点 或把除要删除的点外的点 ，而经过压行，这两个函数都只有四行， 和 都只有三行，所以 好写好调。下午调 ，作死地把所有操作都分别写到函数里，以至于是先 再返回答案，这样 的时候会改变答案的值。这就是指针的迷惑性，虽然指针没有任何变化，但它指向的东西变了，诶，初学指针……调 调了很久，以至于都没时间写 了。周末再写一写 。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170706总结]]></title>
    <url>%2F20170706%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天学习了一些较为冗杂的小知识点。首先介绍了 的 库和 。这些库里的东西虽然好用，但是从空间上和时间上来看，大多数不如手写，有时候为了降低代码复杂度可以使用，但是不能用多了，否则 ， 得太多甚至会成 。 库里有个 的东西很玄学，和分块一样，它可以强行优化暴力，在某些问题上有大用。接着讲了 维偏序。口诀：一维排序，二维分治，三维数据结构。三维在分治的基础上套了一个树状数组或线段树，四维则类似，只是数据结构变成了树套树，代码复杂度应该很高。五维及以上若再套一层树，时间复杂度还不如暴力，因而应该直接暴力，这里就可以用前面讲得 优化了。 维偏序的题不太好写，可以多做做题，其中三维和五维最具代表性，可以见识一下。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170705总结]]></title>
    <url>%2F20170705%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天学习了可持久化线段树、主席树和线段树套线段树。三者都是与线段树相关的较难数据结构。可持久化线段树和主席树感觉写起来较为简单，模板细节也并不多（ 除外），模板题很快写完了，就试着去写 。这道题是主席树带区间修改，而每次都 则会 ，因而只能不下放 标记，在询问的时候一路累加。累加的一步分类较多，应注意细节。调了很久，从 变成 又变成 ，因为对拍若每个数的值都小，则都没错，所以个人认为应该是 操作的错误，毕竟大数据爆成了负数。线段树套线段树虽然是第一次接触，但是因为接触过二维树状数组，理解起来也不难。代码虽短，但有些细节，最恼火的是二维不好调，因而肉眼查错很重要。树套树若加入平衡树，一定会很难，得多写题，多背模板，防止小错调半天。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170704总结]]></title>
    <url>%2F20170704%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是数据结构的第二天。上午考试，题目难度适中。 考读题，较水。 是线段树的奇葩用法，和普通用法不同，它是只递归单区间，另一区间则转化计算。 是昨天讲过的题，线段树套单调队列，因为代码较为复杂，没能调出来。综上可知，线段树一些较难的题都是不具有合并性质的线段树或有限制（后效性）的线段树，一般只能得出左右两区间中其中一个区间的算法，另一区间则不断递归完成。两个区间有一个区间根本不去算，而是递归，这样让我感觉有些虚，经常想不清楚，应多加练习。下午先讲了 序列，这类题一般可以用树剖来做（前天第一次写，一直没调出来/(ToT)/~~，其中较难的是括号序列，尽管听懂了，但题目变化很多，需要练一练题。接着讲了几种并查集进阶，即带权并查集、可撤销并查集（貌似漏了种类并查集），这部分题目不难，只是实现的时候要注意细节，以防被卡常数。然后讲了分块，这种玄学的暴力优化在很多时候都有用，因为出题人预测不到，而且好写好调，性价比高，是个好东西。最后是传说中的莫队算法。这种算法号称“可以解决一切 ”，只是有时候容易卡常数，因而需要多加练习，用最好的写法。今天的题目比较难，得多消化消化。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170703总结]]></title>
    <url>%2F20170703%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天开始就是数据结构了。上午先快速地复习了栈、队列、链表、堆等基础数据结构。在此之中， 学长提到了 和左偏树。前者是链表实现暴力，能在暴搜的时候作很大优化，后者是支持合并的堆，在某些题有用。接下来复习了线段树和树状数组。做了几道较难的题，见识一下这种数据结构的各种灵活变化。其中一道叫“图腾”的题让我受益匪浅。线段树和树状数组作为优化的时候经常出现，而二位的线段树和树状数组则不常用，除了模板题就没什么应用了。写了几道模板题练手，现在把线段树写熟了，可以考虑开始压代码，毕竟原理什么的都很清楚，压代码也不会到调不出来的地步。下午做 的题。其中一道是树链剖分的题，以前没学过，今天花了两个小时学写树剖。（ 某神犇对把树链映射到线段树上的讲解太过省略，想了半天才想清楚）因为是两个部分，因而代码量适中偏大，调了很久才搞对。得多写写树剖的题，熟悉模板，这样就会越写越熟。线段树的变形很多，需要多加练习。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170701总结]]></title>
    <url>%2F20170701%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是 的最后一节课。上午讲了最后两种较难的 ，即状压和数位。状压 我较为熟悉，思想和细节都不复杂。而数位 虽然思想也较为简单，但从写码的细节上来说，较为复杂，会涉及到分类。周日写两道数位 的题来看看。下午是 优化。先复习了凸包算法（ 水平扫描），然后讲斜率优化。这种优化思想是把 方程转化成 或 的形式，其中 是常数，描出所有的 ，然后用凸包求上凸壳或下凸壳，使得dp过程中所用的总是可用的最优状态。接下来是矩阵快速幂优化，个人觉得就是把连加的 方程转化成连乘的 方程，转化为幂后就可用矩阵快速幂了。这两种方法都对数学有要求，虽然听起来不难，但自己推会有些困难，应多加练习。最后是杂题选讲，其实就是对前面两种优化的巩固，题目的 方程转换模式都是差不多的。 优化需要多写写题，希望以后在考试中能接触到。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170630总结]]></title>
    <url>%2F20170630%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是 的第二天，主讲树形 ，题目较难。早上考试，看到题目有些难，想做快些，结果把 题意看错，得不偿失。 也因此没有时间把记忆化改为 。不过 的确很难，是著名的鹰蛋问题。这道题的正解很有意思，有时间可以写一写。下午是树形 的讲解，复习了经典的找直径、重心和“没有上司的舞会”这一经典题目。随后 “创世纪”一题将“没有上司的舞会”拓展到基环树上。接着是 的一道比赛题，因为没有怎么接触过树上背包，对此类问题有些生疏，故听得有些朦胧。树形 后，又将了 中的 。此类问题和树形 差不多，只是根据题意有所区别，更为灵活。最后讲了 问题，即构造一个无向图使每个点度为 ，且有一个桥。在此给出构造方法（复习一遍，加深印象）：若 为偶数，则无解。若 为奇数，先构造一个 个结点的完全图，节点编号为 ，接着删去 到 这些边，每个点的度都为 了。然后再新建 个点，分别向原来的 个点连线，于是原来的 个点度都为 ， 个新点度都为 。在这三个点中任选两个相连。现在把整个图复制一遍，变为两个图，把这两个图中度为 的两个点连起来，这样就有桥了。今天的题目整体较难，得写一些以加深印象。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170629总结]]></title>
    <url>%2F20170629%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天进入 。上午讲了基础的 ，把记忆化、背包、区间的 又复习了一遍。区间 虽然状态转移方程较为好写，但我还是不太能在短时间内理出循环递推的顺序，得多写些题熟练一下。接着讲了几道较难的 ，我没有想出正解，但听了思路之后也是长了见识，虽然状态和转移方程都能确定，但没能想出合理有效的优化。下午考试较为简单，因为是 ，我强迫自己写了 ，没有暴力骗分（虽然数据水，暴力搜索能拿大部分分）。 记忆化搜索写错了一个数组， 了，尴尬,,???,,…… 可以用线段树优化，但因花大部分时间在 ，又不确定线段树能否写对，就并没有优化，但因数据过水，居然 了。 想到了正解，但在枚举约束的时候忘记可以只枚举 到 了，时间较为仓促。今天的时间安排不太好，在最难的 花了太多时间，简单的 居然 了。此外，应多熟悉位运算， 的思路和异或有很大关系，若先前知道很多性质， 就不会花太多时间了。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170628总结]]></title>
    <url>%2F20170628%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是图论的最后一节课，除了网络流外都上完了。复习了欧拉路、拓扑，重新熟悉了代码。对于连通分量，复习了有向图的 和割点割边，新学了无向图里的边双和点双连通分量。圆桌会议那道题虽然懂了，但自愧写不出来那样巧妙的代码。接下来是 ，隐隐约约懂了，但推起细节却又有些模糊， 问题很玄妙，得花时间多理解理解。最后是最短路，给了几道比较难的题，但常用的做法就是拆点或在每个状态跑一遍 ，最后一道 二 分 答 案 最 短 路 的题很精妙，但估计我调不出来。上午和中午的课余时间把昨天的三道题都调出来了。图论就是这样，难想，难建模，但想出来就是模板（可能综合几个模板）。下午考试很难， 完全没想到是拓扑，甚至怀疑这不是图论，但听了评讲后觉得还是蛮简单的。 想到了 序，又因时间复杂度想了 种优化，只可惜连记录进入时间戳都想到了，居然没想到打出来的时间戳，很冤。 的确没有思路，因为没来得及听 大神讲，晚上问了杨林翰。听完觉得很精妙，有点像 的那种推理方式，但又有许多不同。对于图论，我还得加强建模的训练。明天开始就是 了，我的弱项，希望 吧]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170627总结]]></title>
    <url>%2F20170627%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天进入真正的图论，复习了 序、 和最小生成树。 的两种方法，倍增写得很熟， 则不那么熟练，学长提及了玄学的 表，于是又把这个构造 查询 的神奇结构复习了一遍。我记得 除了线段树，树状数组和 表以外，还有一种叫莫队的东西。我九上的时候接触过，现在都忘完了，期待过几天讲数据结构的时候能遇到。关于最小生成树，虽然知道 和 两种算法，但是自己感觉这个东西如果研究深了也是很棘手的。比如今天的例题 魔法森林，虽然费劲脑力听懂了思路，但是自愧写不出来，对代码要求很高。增量最小生成树和次小生成树我都在 上看了博客，思路清晰了，但是不知道写的时候会不会出问题。学长最后讲的有向图最小生成树，即最小树形图，我没听懂，因为时间匆忙，也没有问，得多研究研究 的两篇博文。下午考试三道打 居然还得了 ，意料之外。三道题都比较难。 和货车运输很像，因为写过货车运输，惯性思维就想到 ，事实证明我想复杂了。这道题多用笔画画图应该能想出正解。 也是差一点想到正解，也是想复杂了。这里我总结出一种化繁为简的思考方法，即不要全面地考虑整个问题，应该把它分成子问题，逐个击破，而且想一个子问题的时候就不要受另外子问题的干扰。这道题我做复杂了，写了一个 ，两个 ，一个 才写出来，不过我能在40分钟把它写和调出来还是值得欣慰的，看来多考考对代码能力提升很大。 貌似数据有些问题，到现在还不知道怎么做，等明天大神讲。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170626总结]]></title>
    <url>%2F20170626%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是图论的第一节课。上午图论入门，讲了位运算和搜索。位运算虽然简单，但用处巨大，特别是在搜索和 中。复习了一下 的原理，新学了求1个数的平行算法（虽然可以打表，但是了解一下算数算法保险一些）。我自己学状压 的时候学过子集枚举，现在重温以便，发现还不够熟悉，希望过几天讲 的时候能在熟练一下。搜索作为一项基本功，还是很重要的。 和 就不说了，后面讲的双向 和迭代加深虽然以前知道原理，但没有实现过。希望这几天的考试题里能有所涉及，毕竟现在时间较紧，除了课上的例题和考试就没有多少机会调题了。 算法有点没懂，明天去问问。今天貌似没有讲启发式搜索，记忆化搜索也只是点了一下，这两种搜索我还不会，希望以后有机会接触。搜索题都是能想不会做，斗地主和八数码我都调不出来，还得提升代码能力。下午的题较为简单。三道题应该都是有原题出处的。 改编自 星球大战，以前做过，不难想到离线并查集。 貌似见过，不过我以前好像没做过，考场上想出一个用优先队列的做法，虽然能过六个点，复杂度还是较高。标程的二分答案的确没想到。上次考分治也没想到，看来得刷点分治的题。 是经典省选题，以前一直不会做。今天听了剪枝优化的方法，按位搜索还好，但倒着搜则显得有些突兀，不知道是怎么想到的，毕竟正搜倒搜和数据有很大关系。这和 提高组的靶形数独很像。以后多积累些经验，就应该能直到什么时候要倒搜了。现在时间越来越紧了，需要调整作息，保证所花时间都有最高效益。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170623总结]]></title>
    <url>%2F20170623%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[上午继续听 大神的课，复习了贪心、二分答案、三分答案。我一直没有系统地刷过贪心的题，今天大神将贪心的各类题都过了一遍，都懂了，只是不知道写码的时候会不会出现问题。贪心的例题里 叉的哈夫曼树以前没见过，看来和二叉的哈夫曼树还有点区别。此外，还有两道字典树上的贪心，思想都懂了，可能写码会有些细节上的问题。三分答案的精度一直是个问题，我只 了一道模板题，连经典的铁人两项都没过，周末再调调。下午考试，整体难度比昨天难。 想到了贪心，但是据大神说“很容易想到这种有漏洞的方法”(T_T)~~花了一个小时写出来的才得 分。 枚举的时候就有错，思路上就错完了，还花了一个半小时写高精，看来以后得想清楚在写，不能忽略自己的感觉（写到一半就有 的感觉）。 很难，的确没想到，第 个和第 个点是手玩的，考完才发现第 个点也可以手玩，可惜啊，做的时候看到 就吓到了。提交答案题找规律和特殊数据是很重要的，下次注意。考完听大神讲 ，将了三种策略，包括较为常规的“转换为标准图”、玄学的分治和完全没想到的平衡树旋转。平衡树还可以这样用，真是开了眼界。看来得好好搞搞平衡树（我寒假花了一周在 上看，结果连 都写不好，代码量太大啊）这几天连续听难题感觉思维稍微打开一点了，希望能保持这种状态。另外，考试对思维帮助相当大，这样再多考几次思维就容易打开了o(*￣▽￣*)ブ]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170622总结]]></title>
    <url>%2F20170622%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[上午听 大神的课，重新学配 ，并复习了二分大神讲得很清楚，将所有基础知识点都复习了一遍，只可惜讲对拍的时候演示得太快，没学会大神在 程序内调用对拍的方法，只能苦逼地写脚本/(ToT)/​~~听课之余复习了一下前天的 ，又写了一道题（简单题，解密码，解完就是标准模板），发现貌似 有很多地方可以缩码，只是现下掌握不算熟练，多做点题后再压。 自动机的 题很有意思，有空可以研究研究。下午考试花式翻车，不过自己思想上还是差一截，难题做得不够，而且以前遇到难题想不了多久就放弃了。希望以后考试能够适应，毕竟考试逼着我多想。回来之后在调试， 没太大问题（现在正在调 ）， 可能有点麻烦，虽然懂思想，但大神说这题细节多，要调很久，明天可以多调一下。我做的题还不多，难题就更少了，只能把接触到的题都保证调好，能多见识点就多见识点。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[MathJax]]></title>
    <url>%2FMathJax%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[wxh表情包]]></title>
    <url>%2FWXH%E8%A1%A8%E6%83%85%E5%8C%85%2F</url>
    <content type="text"><![CDATA[！ Part I : 那是wxh！ Part II : 毒瘤wxh! Part III : 信息巨头wxh！ Part IV : 机房wxh！ Part V : gay wxh！]]></content>
  </entry>
  <entry>
    <title><![CDATA[dalao传]]></title>
    <url>%2F%E5%A4%A7%E4%BD%AC%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[dalao 传从前，在宇宙大爆炸时，由于上帝的一个错误，导致了一个智慧体的产生。它具有无限的计算能力。他一直在宇宙中观察着众生.有一天，他发现了地球上出现了一个叫做 的东西，他感到很高兴，于是花了 学完了 所有知识。但当他观看地球人的题目时，他突然为他们的低智商感到愤怒！于是，他决定化身为一个地球人，来传授一些人生的经验。 为了伪装自己，他考试时总是在计算如何才能有正常人的成绩，但他仍然以第 名的成绩进入了 ，并被称作为大佬。大佬打 的时候，总是从最后一题开始看，即便是这样，他也只需要 就解决所有问题，以至于管理员认为他是一个脚本，封了他的号（后来他给 充了一些钱，成为了管理员）。 大佬有着操控代码的能力，他一只手就可以操控仙人掌，平衡树，随意让他们以各种状态存在。大佬深深知道着整个世界其实由代码构建而成，而他可以随意在宇宙终端里执行命令。于是，他可以随意改变自己的时间。他会突然出生，或突然老去。当他时间不够时，他就可以以 来补充时间（然而大佬实际上不需要让时间守恒）。有时候，他也可以瞬移，只需要改动坐标，这样他甚至可以把自己传送到四维空间。他也可以用代码干别的事情，但他从来不当众使用（除了出生）。 大佬骄傲地说：“我又出生啦！” 王修涵大定理理论体系简述王修涵（以下简称 ）并不是一个个体的名字，而是组成这个宇宙的基本物质。 是智慧的化身，任何具有一定智能的生命身上都具有一定的 能量，智商的高低是由 能量的多少来确定的。上文的上帝实际上是这个宇宙意志的体现，由于 能量的流动有一定方向性，在某个位置一定会存在一个巨大的能量体，我们把这个个体称为“王修涵”（以防混淆，整体的名字用 表示，个体用王修涵特指），因为他已经可以代表这个名为 的宇宙意志。 对王修涵该个体的简述在这个宇宙中，王修涵是最强的人根据 科学实验室最近发表的理论，王修涵的 能量已经达到了总量的 ，这在这个宇宙中应该是最高的 王修涵做事时，总是会派出他的分身去做由于超高能量体如果出现在地球上，必然会引起时空扭曲。所以王修涵作为宇宙中能量最高的个体，要是降临地球，整个太阳系必然会发生未知的量子反应。根据 博士的推测，王修涵本身的意志是不伤害智能生命。所以我们看到的王修涵，只是这个王修涵的一个分身。这分身的 能量时大时小，所以就形成了王修涵没有场场 的现象。即便这样，王修涵的分身也已经碾压绝大多数个体了 王修涵定理的基本定律定律 能量多的人是不会假的事实上，根据 博士所发现的宇宙鄙视链定律，人只能膜 能量比自己高的人。但在现实生活中为什么经常有大佬装弱的现象，然而宇宙本身没有矛盾呢？ 科学实验室发现， 能量场为了维护宇宙的正确性，会在错误发生时产生一个 的高能量体（即 的分身）。这个能量体是通过 能量的流动形成的 定律 能量具有流动性和方向性就像其他的宇宙能量一样， 能量也是可以流动的，一个 高能量体是可以自发的向外辐射能量的。 科学实验室最近观测到的 大 小 佬 就是这个理论的证明。在这里，超高能量体王修涵与知名 选手谈话，导致该选手短时间变强。这也解释了为什么与 聊天的人都特别强。同时， 能量也是有方向性的，假设没有方向性，那么 能量应当随机分布在这个宇宙中，而并不会有王修涵这个超强个体的产生。 博士指出， 能量是存在自身意志的， 能量会随着他的意志指向去流动。]]></content>
  </entry>
</search>
