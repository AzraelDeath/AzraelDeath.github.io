<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[BZOJ4407 于神之怒加强版]]></title>
    <url>%2FBZOJ4407%20%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemDZY Loves MathTime Limit: $80 Sec$Memory Limit: $512 MB$ Description给下$N,M,K$，计算$\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k\mod(10^9+7)$的值。 Input输入有多组数据，输入数据的第一行两个正整数$T,K$，代表有$T$组数据，$K$的意义如上所示，下面第$2$行到第$T+1$行，每行为两个正整数$N,M$，其意义如上式所示。 Output对于每一个询问，输出一行一个数作为回答。 Sample Input121 23 3 Sample Output120 HINT$1\le N,M,K\le5\times 10^6,\;1\le T\le2000$官方题解 标签：莫比乌斯反演 Solution先套路转换出$\mu$：$$\begin{aligned}Ans&amp;=\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k\\&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=d]\\&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{x|\gcd(i ,j)}\mu(x)\\&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{x=1}^{\lfloor\frac{\min(n,m)}{d}\rfloor}\mu(x)\lfloor\frac{n}{x\cdot d}\rfloor\lfloor\frac{m}{x\cdot d}\rfloor\\&amp;=\sum_{t=1}^{\min(n,m)}\sum_{d=1}^{t}d^k\mu(\frac{t}{d})\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\\&amp;=\sum_{t=1}^{\min(n,m)}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum_{d=1}^{t}d^k\mu(\frac{t}{d})\\\end{aligned}$$那么每次询问对于前半部分可以根号分块，随后需要$O(1)$计算后半部分的值，因而需要线筛预处理后半部分的值。 令$f(t)=\sum_{d=1}^{t}d^k\mu(\frac{t}{d})$，$t=p_1^{a_1}\times p_2^{q_2}\times\cdots p_l^{a_l}$由于$y=d^k$和$y=\mu(d)$均为积性函数，因而$f$也为积性函数。那么就有$$\begin{aligned}f(t)&amp;=\prod_{i=1}^{l}f(p_i^{a_i})\\&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(\frac{p_i^{a_i}}{p_i^j})\\&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(p_i^{a_i-j})\\\end{aligned}$$易知当$j\in[0,a_i-1)$时，均有$\mu(p_i^{a_i-j})=0$，因此有$$\begin{aligned}f(t)&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(p_i^{a_i-j})\\&amp;=\prod_{i=1}^{l}(\mu(p_i)\cdot p_i^{k\cdot(a_i-1)}+\mu(1)\cdot p_i^{k\cdot a_i})\\&amp;=\prod_{i=1}^{l}(p_i^{k\cdot a_i}-p_i^{k\cdot(a_i-1)})\\&amp;=\prod_{i=1}^{l}p_i^{k\cdot(a_i-1)}(p_i-1)\end{aligned}$$接下来考虑在线筛中如何处理。首先，对于所有质数，均有$f(p)=p^k-1$。而对于合数，假设当前筛到的数是$x$，对于一个比它小的素数$p$，有两种情况： 若$p|x$，设$p$在$x$分解质因数中的次数为$a$，那么$f(x\times p)$相比于$f(x)$而言，在含$p$的约数中$p$的次数都增加了$1$，否则$\mu=0$无贡献。因此$k\cdot(a-1)$增加了$k$，这样总共扩大了$p^k$倍，故$f(x\times p)=f(x)\times p^k$； 若$p\nmid x$，由积性函数可知$f(x\times p)=f(x)\times f(p)$。 这样就可以$O(n\log{n})$筛出$f$的函数值，每次询问$O(T\sqrt{n})$根号分块，总复杂度$O(n\log{n}+T\sqrt{n})$。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define MAX_N 5000000#define MOD 1000000007using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;lnt k, cnt, ans, f[MAX_N+5], p[MAX_N+5], pri[MAX_N+5]; bool NotPri[MAX_N+5];lnt PM(lnt x, lnt y) &#123;if (!y) return 1LL; lnt ret = PM(x, y&gt;&gt;1); return (y&amp;1) ? ret*ret%MOD*x%MOD : ret*ret%MOD;&#125;void init() &#123; NotPri[1] = true, f[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) &#123; if (!NotPri[i]) pri[cnt++] = i, p[i] = PM(i, k), f[i] = p[i]-1; for (int j = 0; j &lt; cnt; j++) &#123; if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) f[i*pri[j]] = f[i]*f[pri[j]]%MOD; else &#123;f[i*pri[j]] = f[i]*p[pri[j]]%MOD; break;&#125; &#125; &#125; for (int i = 2; i &lt;= MAX_N; i++) (f[i] += f[i-1]) %= MOD;&#125;int main() &#123; int T; read(T), read(k), init(); while (T--) &#123; lnt n, m; read(n), read(m), ans = 0; for (lnt l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), (ans += (n/l)*(m/l)%MOD*(f[r]-f[l-1]+MOD)%MOD) %= MOD; printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3309 DZY Loves Math]]></title>
    <url>%2FBZOJ3309%20DZY%20Loves%20Math%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemDZY Loves MathTime Limit: $20 Sec$Memory Limit: $512 MB$ Description对于正整数$n$，定义$f(n)$为$n$所含质因子的最大幂指数。例如$f(1960)=f(2^3\times5^1\times7\times2)=3$, $f(10007)=1$, $f(1)=0$。给定正整数$a,b$，求$\sum_{i=1}^{a}\sum_{j=1}^{b}{f(\gcd(i,j))}$。 Input第一行一个数$T$，表示询问数。接下来$T$行，每行两个数$a,b$，表示一个询问。 Output对于每一个询问，输出一行一个非负整数作为回答。 Sample Input1234547558588 96531146514903 44512117425644 11894426335198 4957 Sample Output12343579345393990114225956593420433283884584615400094813 HINT$T\le 10^4$$1\le a,b\le 10^7$ 标签：莫比乌斯反演 Solution好题，$get$线筛新姿势。 首先套路转化出莫比乌斯函数：$$\begin{aligned}Ans&amp;=\sum_{i=1}^{a}\sum_{j=1}^{b}f(\gcd(i,j))\\&amp;=\sum_{d=1}^{\min(a,b)}\sum_{i=1}^{a}\sum_{j=1}^{b}f(d)[\gcd(i,j)=d]\\&amp;=\sum_{d=1}^{\min(a,b)}f(d)\sum_{i=1}^{\lfloor\frac{a}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{b}{d}\rfloor}\sum_{k|\gcd(i,j)}\mu(k)\\&amp;=\sum_{d=1}^{\min(a,b)}f(d)\sum_{k=1}^{\lfloor\frac{\min(a,b)}{d}\rfloor}\mu(k)\times\lfloor\frac{a}{d\times k}\rfloor\times\lfloor\frac{b}{d\times k}\rfloor\\&amp;=\sum_{t=1}^{\min(a,b)}\lfloor\frac{a}{t}\rfloor\lfloor\frac{b}{t}\rfloor\sum_{d|t}\mu(\frac{t}{d})\times f(d)\\\end{aligned}$$这时会发现前面用根号分块很好处理，而后面的部分需要$O(1)$计算，所以需要线性筛预处理。 令$g(t)=\sum_{d|t}\mu(\frac{t}{d})\times f(d)$，考虑通过$\mu$与$f$的性质找到其积性关系。 设$t=p_1^{a_1}\times p_2^{a_2}\times\cdots\times p_k^{a_k}$，$\frac{t}{d}=p_1^{a_1’}\times p_2^{a_2’}\times\cdots\times p_k^{a_k’}$，$d=p_1^{a_1-a_1’}\times p_2^{a_2-a_2’}\times\cdots\times p_k^{a_k-a_k’}$那么一定有$0\le a_1’,a_2’,\cdots,a_k’\le 1$，否则$\mu(\lfloor\frac{t}{d}\rfloor)=0$，不计入总贡献。 若$a_1=a_2=\cdots=a_k=\max{a}$ 对于$f(d)=\max{a}-1$的情况，只有一种，即$a_1’=a_2’=\cdots=a_k’=0$。而$\mu(\frac{t}{d})=(-1)^k$。故贡献为$(a-1)\times(-1)^k=a\times(-1)^k-(-1)^k$； 对于$f(d)=\max{a}$的情况，根据组合原理，有$\sum_{i=0}^{k-1}(-1)^i\binom{i}{k}$，而又由二项式基本定理知$\sum_{i=0}^{k}(-1)^k\binom{i}{k}=0$，因而贡献为$(-1)^k\binom{k}{k}=(-1)^k$。 故此情况$g(d)=a\times(-1)^k-(-1)^k+(-1)^k=a\times(-1)^k$。 若$\exists i,j$使得$i\ne j,\;a_i\ne a_j$ 不论$f(d)=\max{a}$还是$f(d)=\max{a}-1$，都存在至少一个质因数$p_r$使得$a_r’$不论取$0$还是$1$对$f(d)$的取值都没有影响。然而$a_r’$取$0$或$1$会使得$\mu(\frac{t}{d})$取到$-1$或$1$，此处的贡献为$f(d)+(-f(d))=0$，一定全部被抵消。 故此情况$g(d)=0$。 综上，线性筛预处理$g(t)$需要知道每个数最小的质因数的次数$num$和最小质因数的幂指数次幂$sp$，这样看是否有$num[i\times pri[j]]=num[i/sp[i]]$即可知$i\times pri[j]$的最小与次小质因数的次数是否相等，由此可判断是情况$1$还是情况$2$。这样先线性筛预处理后，对每次询问$O(\sqrt{\min(a,b)})$进行根号分块，即可达到$O(T\sqrt{\min(a,b)})$的复杂度。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;#define MAX_N 10000000using namespace std;typedef long long lnt;template &lt;class T&gt; inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int g[MAX_N+5], sp[MAX_N+5], num[MAX_N+5];int pri[MAX_N+5], cnt; lnt ans;bool NotPri[MAX_N+5];void init(int n) &#123; NotPri[0] = NotPri[1] = true; for (int i = 2; i &lt;= n; i++) &#123; if (!NotPri[i]) pri[cnt++] = sp[i] = i, g[i] = num[i] = 1; for (int j = 0; j &lt; cnt; j++) &#123; if (i*pri[j] &gt; n) break; NotPri[i*pri[j]] = true; if (i%pri[j]) sp[i*pri[j]] = pri[j], num[i*pri[j]] = 1, g[i*pri[j]] = num[i] == 1 ? -g[i] : 0; else sp[i*pri[j]] = sp[i]*pri[j], num[i*pri[j]] = num[i]+1, g[i*pri[j]] = sp[i] == i ? 1 : (num[i/sp[i]] == num[i*pri[j]] ? -g[i/sp[i]] : 0); if (i%pri[j] == 0) break; &#125; &#125; for (int i = 1; i &lt;= n; i++) g[i] += g[i-1];&#125;int main() &#123; int T; read(T), init(MAX_N); while (T--) &#123; int a, b; read(a), read(b), ans = 0; for (int l = 1, r; l &lt;= min(a,b); l = r+1) r = min(a/(a/l), b/(b/l)), ans += 1LL*(a/l)*(b/l)*(g[r]-g[l-1]); printf("%lld\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2154 Crash的数字表格]]></title>
    <url>%2FBZOJ2154%20Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemCrash的数字表格Time Limit: $20 Sec$Memory Limit: $259 MB$ Description今天的数学课上，$Crash$小朋友学习了最小公倍数$(Least\;Common\;Multiple)$。对于两个正整数$a$和$b$，$LCM(a, b)$表示能同时被a和b整除的最小正整数。例如，$LCM(6, 8) = 24$。回到家后，$Crash$还在想着课上学的东西，为了研究最小公倍数，他画了一张$N\times M$的表格。每个格子里写了一个数字，其中第$i$行第$j$列的那个格子里写着数为$LCM(i, j)$。看着这个表格，$Crash$想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当$N$和$M$很大时，$Crash$就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，$Crash$只想知道表格里所有数的和$\mod 20101009\;\;$的值。 Input输入的第一行包含两个正整数，分别表示$N$和$M$。 Output输出一个正整数，表示表格中所有数的和$\mod 20101009\;\;$的值。 Sample Input14 5 Sample Output1122 HINT$100\%$的数据满足$N,M\le10^7$。 标签：莫比乌斯反演 Solution$$\begin{aligned}Ans&amp;=\sum_{x=1}^{n}\sum_{y=1}^{m}\frac{x\times y}{\gcd(x,y)}\\&amp;=\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{n}\sum_{y=1}^{m}[\gcd(x,y)=d]\frac{x\times y}{d}\\\end{aligned}$$$$\begin{aligned}&amp;Let\;f(n,m,d)=\sum_{x=1}^{n}\sum_{y=1}^{m}[\gcd(x,y)=d]\cdot x\cdot y\\&amp;then\;f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)=\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(x,y)=1]\cdot x\cdot y\\&amp;\therefore Ans=\sum_{d=1}^{\min(n,m)}\frac{f(n,m,d)}{d}=\sum_{d=1}^{\min(n,m)}f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)\times d\\&amp;\;\;\;\;If\;we\;can\;calculate\;f(p,q,1)\;in\;a\;rapid\;way,\\&amp;\;\;\;\;we\;can\;calculate\;the\;answer\;rapidly.\\\end{aligned}$$$$\begin{aligned}f(p,q,1)&amp;=\sum_{i=1}^{p}\sum_{j=1}^{q}\sum_{d|\gcd(i,j)}\mu(d)\cdot i\cdot j\\&amp;=\sum_{d=1}^{\min(p,q)}\mu(d)\times d^2\;\sum_{i=1}^{\lfloor\frac{p}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{q}{d}\rfloor}i\times j\\&amp;=\sum_{d=1}^{\min(p,q)}\mu(d)\times d^2\times\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}\\\end{aligned}$$由以上推导，可见$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$和$\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}$是可以根号分块的，在外层对$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$进行分块，在每个值相同的块中，对$\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}$进行分块以求出$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$带回外层算贡献。 综上，外层复杂度为$O(\sqrt{n})$，内层复杂度为$O(\sqrt{n})$，总时间复杂度为$O(n)$。 其实可以做得更块，详见加强版BZOJ2693。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define MAX_N 10000000#define MOD 20101009using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;lnt n, m, ans, s[MAX_N+5];int cnt, pri[MAX_N+5], mu[MAX_N+5];bool NotPri[MAX_N+5];void getMu() &#123; NotPri[1] = true, mu[1] = 1; for (int i = 2; i &lt;= min(n,m); i++) &#123; if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0; j &lt; cnt; j++) &#123; if (i*pri[j] &gt; min(n,m)) break; NotPri[i*pri[j]] = true; if (i%pri[j]) mu[i*pri[j]] = -mu[i]; else &#123;mu[i*pri[j]] = 0; break;&#125; &#125; &#125; for (int i = 1; i &lt;= min(n,m); i++) s[i] = (s[i-1]+1LL*mu[i]*i*i%MOD)%MOD;&#125;lnt f(lnt p, lnt q) &#123; lnt ret = 0; for (lnt l = 1, r; l &lt;= min(p, q); l = r+1) r = min(p/(p/l), q/(q/l)), (ret += (p/l*(p/l+1)/2%MOD)*(q/l*(q/l+1)/2%MOD)%MOD*(s[r]-s[l-1])%MOD) %= MOD; return ret;&#125;int main() &#123; read(n), read(m), getMu(); for (lnt l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), (ans += (l+r)*(r-l+1)/2%MOD*f(n/l, m/l)%MOD) %= MOD; return printf("%lld", (ans+MOD)%MOD), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2693 jzptab]]></title>
    <url>%2FBZOJ2693%20jzptab%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemjzptabTime Limit: $10 Sec$Memory Limit: $512 MB$ Description求$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$，答案模$10^9+9$输出。多组询问。 Input一个正整数$T$表示数据组数。接下来$T$行，每行两个正整数 表示$N,M$。 Output$T$行，每行一个整数，表示第$i$组数据的结果。 Sample Input1214 5 Sample Output1122 HINT$T\le 10^4$$N,M\le 10^7$ Sourse版权所有者：倪泽堃 标签：莫比乌斯反演 Solution此题和$BZOJ2154$所求相同，只是又多组询问，如果每次都像$BZOJ2154$那样$O(n)$做为$TLE$。故需要改变求和方式。这里将使用$BZOJ2154$的最终推导结果来继续恒等变形。前面的推导见：BZOJ2154。$$\begin{aligned}Answer&amp;=\sum_{d=1}^{\min(n,m)}{d}\sum_{k=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(k)\times k^2\times\frac{\lfloor\frac{n}{d\times k}\rfloor\times(\lfloor\frac{n}{d\times k}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{d\times k}\rfloor\times(\lfloor\frac{m}{d\times k}\rfloor+1)}{2}\\&amp;=\sum_{d=1}^{\min(n,m)}\sum_{t=k\times d(k\in\mathbb{N^*})}^{\min(n,m)}\mu(\frac{t}{d})\times\frac{t^2}{d^2}\times\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}\times{d}\\&amp;=\sum_{t=1}^{\min(n,m)}{\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}}\sum_{k|t}\mu(k)\times k^2\times\frac{t}{k}\\\end{aligned}$$$$\begin{aligned}&amp;Let\;F(t)=\sum_{k|t}\mu(k)\times k^2\times \frac{t}{k} ,\\&amp;then\;S=\sum_{t=1}^{\min(n,m)}{\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}}\times F(t)\\\end{aligned}$$$$\begin{aligned}&amp;\because f(x)=\mu(x),\;g(x)=x^2,\;h(x)=\frac{t}{x}\;are\;all\;multiplicative\;functions\\&amp;\therefore F(x)=\sum_{t|x}f(t)\times g(t)\times h(t)\;is\;a\;multiplicative\;function\\&amp;\Longrightarrow We\;can\;use\;a\;Linear\;Seive\;to\;calculate\;F(x)\\&amp;If\;x\equiv1\sim y-1\mod{y}\;\;(y\;is\;a\;prime\;number)\\&amp;\;\;\;\;then\;F(x\times y)=F(x)\times F(y)\\&amp;If\;x\equiv0\mod{y}\;\;(y\;is\;a\;prime\;number)\\&amp;\;\;\;\;then\;\mu(x\times y)=0,\;F(x\times y)=F(x)\times y\end{aligned}$$综上，$F(x)$的前缀和可用线性筛预处理，对于每次询问对$\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}$根号分块，即可做到$O(T\sqrt{n})$的复杂度。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAX_N 10000000#define MOD 100000009using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;lnt n, m, cnt, ans, s[MAX_N+5], pri[MAX_N+5]; bool NotPri[MAX_N+5];void init() &#123; NotPri[1] = true, s[1] = 1; for (lnt i = 2; i &lt;= MAX_N; i++) &#123; if (!NotPri[i]) pri[cnt++] = i, s[i] = (i-i*i%MOD)%MOD; for (int j = 0; j &lt; cnt; j++) &#123; if (i*pri[j] &gt; MAX_N) break; NotPri[i*pri[j]] = true; if (i%pri[j]) s[i*pri[j]] = s[i]*s[pri[j]]%MOD; else &#123;s[i*pri[j]] = s[i]*pri[j]; break;&#125; &#125; &#125; for (int i = 1; i &lt;= MAX_N; i++) (s[i] += s[i-1]) %= MOD;&#125;int main() &#123; int T; read(T), init(); while (T--) &#123; lnt n, m; read(n), read(m), ans = 0; for (lnt l = 1, r; l &lt;= min(n, m); l = r+1) r = min(n/(n/l), m/(m/l)), (ans += (n/l*(n/l+1)/2%MOD)*(m/l*(m/l+1)/2%MOD)%MOD*(s[r]-s[l-1])%MOD) %= MOD; printf("%lld\n", (ans+MOD)%MOD); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1096【ZJOI2007】仓库建设]]></title>
    <url>%2FBZOJ1096%E3%80%90ZJOI2007%E3%80%91%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem【ZJOI2007】仓库建设Time Limit: $10 Sec$Memory Limit: $162 MB$ Description$L$公司有$N$个工厂，由高到底分布在一座山上。如图所示，工厂$1$在山顶，工厂$N$在山脚。由于这座山处于高原内陆地区（干燥少雨），$L$公司一般把产品直接堆放在露天，以节省费用。突然有一天，$L$公司的总裁$L$先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是$L$先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第$i$个工厂目前已有成品$P_i$件，在第$i$个工厂位置建立仓库的费用是$C_i$。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于$L$公司产品的对外销售处设置在山脚的工厂$N$，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送$1$个单位距离的费用是$1$。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据： 工厂$i$距离工厂$1$的距离$X_i$（其中$X_1=0$） 工厂$i$目前已有成品数量$P_i$ 在工厂$i$建立仓库的费用$C_i$ 请你帮助$L$公司寻找一个仓库建设的方案，使得总的费用（$建造费用+运输费用$）最小。 Input第一行包含一个整数$N$，表示工厂的个数。接下来$N$行每行包含两个整数$X_i, P_i, C_i$, 意义如题中所述。 Output仅包含一个整数，为可以找到最优方案的费用。 Sample Input123430 5 105 3 1009 6 10 Sample Output132 标签：斜率优化$DP$ Solution由题意，易得到$DP$方程：$f[i]=c[i]+\min_{j=0}^{i-1}{f[j]+\sum_{k=j+1}^{i}p[k]\times(x[i]-x[k])}$那么对于当前$DP$到的位置$i$，一定存在$p,q\in[0,i)$使得$$\begin{aligned}f[p]+\sum_{k=p+1}^{i}p[k]\times(x[i]-x[k])&amp;\le f[q]+\sum_{k=q+1}^{i}p[k]\times(x[i]-x[k])\\f[p]+\sum_{k=p+1}^{i}p[k]\times x[i]-\sum_{k=p+1}^{i}p[k]\times x[k]&amp;\le f[q]+\sum_{k=q+1}^{i}p[k]\times x[i]-\sum_{k=q+1}^{i}p[k]\times x[k]\\Let\;s_1[i]=\sum_{j=1}^{i}p[j]\times x[j]&amp;,\;s_2[i]=\sum_{j=1}^{i}p[j]\\f[p]+(s_2[i]-s_2[p])\times x[i]-s_1[i]+s_1[p]&amp;\le f[q]+(s_2[i]-s_2[q])\times x[i]-s_1[i]+s_1[q]\\f[p]-s_2[p]\times x[i]+s_1[p]&amp;\le f[q]-s_2[q]\times x[i]+s_1[q]\\\frac{(f[p]-f[q])+(s_1[p]-s_1[q])}{s_2[p]-s_2[q]}&amp;\le x[i]\\\end{aligned}$$$$\therefore k(p,q)=\frac{(f[p]-f[q])+(s_1[p]-s_1[q])}{s_2[p]-s_2[q]}\le x[i]\iff p\;is\;better\;than\;q$$按照此斜率维护单调栈即可。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000using namespace std;typedef double dnt;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int n, c[MAX_N+5], x[MAX_N+5], m[MAX_N+5];lnt s1[MAX_N+5], s2[MAX_N+5], f[MAX_N+5]; int l, r, sta[MAX_N+5];dnt calc(int p, int q) &#123;return (dnt)(f[p]-f[q]+s1[p]-s1[q])/(dnt)(s2[p]-s2[q]);&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) read(x[i]), read(m[i]), read(c[i]); for (int i = 1; i &lt;= n; i++) s1[i] = s1[i-1]+1LL*m[i]*x[i], s2[i] = s2[i-1]+m[i]; for (int i = 1; i &lt;= n; i++) &#123; while (l &lt; r &amp;&amp; calc(sta[l+1], sta[l]) &lt;= x[i]) l++; f[i] = f[sta[l]]+1LL*x[i]*(s2[i]-s2[sta[l]])-s1[i]+s1[sta[l]]+c[i]; while (l &lt; r &amp;&amp; calc(sta[r], sta[r-1]) &gt; calc(i, sta[r])) r--; sta[++r] = i; &#125; return printf("%lld", f[n]), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>斜率优化</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1010【HNOI2008】玩具装箱toy]]></title>
    <url>%2FBZOJ1010%E3%80%90HNOI2008%E3%80%91%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1toy%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2008】玩具装箱toyTime Limit: $10 Sec$Memory Limit: $162 MB$ Description$P$教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。$P$教授有编号为$1\sim N$的$N$件玩具，第$i$件玩具经过压缩后变成一维长度为$C_i$.为了方便整理，$P$教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第$i$件玩具到第$j$个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum_{k=i}^{j}C_k$制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$X$,其制作费用为$(X-L)^2$.其中$L$是一个常量。$P$教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望费用最小. Input第一行输入两个整数$N,L$.接下来$N$行输入$C_i$.$1\le N\le50000,1\le L,C_i\le10^7$ Output输出最小费用. Sample Input1234565 434214 Sample Output11 标签：斜率优化$DP$ Solution令$L=L+1$，有如下$DP$方程：$f[i]=\min_{j=0}^{i-1}{f[j]+[(i-j+\sum_{k=j}^{i}C_k)-L]^2}$。 预处理$s[i]=\sum_{j=1}^{i}C_j,\;w[i]=s[i]+i$。对于当前$DP$到的位置$i$，必然存在$p,q\in[0,i)$，使得$$\begin{aligned}f[p]+[(i-p+\sum_{k=p}^{i}C_k)-L]^2&amp;\le f[q]+[(i-q+\sum_{k=q}^{i}C_k)-L]^2\\&amp;\Updownarrow\\f[p]+(w[i]-w[p]-L)^2&amp;\le f[q]+(w[i]-w[q]-L)^2\\&amp;\Updownarrow\\f[p]+w[i]^2+w[p]^2+L^2-2\times w[i]&amp;\times w[p]-2\times w[i]\times L+2\times w[p]\times L\\&amp;\le\\f[q]+w[i]^2+w[q]^2+L^2-2\times w[i]&amp;\times w[q]-2\times w[i]\times L+2\times w[q]\times L\\&amp;\Updownarrow\\f[p]+(w[p]+L)^2-2\times w[i]\times w[p]&amp;\le f[q]+(w[q]+L)^2-2\times w[i]\times w[q]\\&amp;\Updownarrow\\\frac{(f[p]-f[q])+((w[p]+L)^2-(w[q]+L)^2)}{2\times(w[p]-w[q])}&amp;\le w[i]\\\end{aligned}$$$$\therefore k(p,q)=\frac{(f[p]-f[q])+((w[p]+L)^2-(w[q]+L)^2)}{2\times(w[p]-w[q])}\le w[i]\iff p\;is\;better\;than\;q$$按照此斜率维护单调栈即可。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define MAX_N 50000using namespace std;typedef double dnt;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int n, l, sta[MAX_N+5], s, t; lnt f[MAX_N+5], w[MAX_N+5];dnt calc(int p, int q) &#123;return (f[p]-f[q]+(w[p]+l)*(w[p]+l)-(w[q]+l)*(w[q]+l))/(2.0*(w[p]-w[q]));&#125;int main() &#123; read(n), read(l), l++; for (int i = 1; i &lt;= n; i++) read(w[i]), w[i] += w[i-1]; for (int i = 1; i &lt;= n; i++) w[i] += i; for (int i = 1; i &lt;= n; i++) &#123; while (s &lt; t &amp;&amp; calc(sta[s+1], sta[s]) &lt;= w[i]) s++; f[i] = f[sta[s]]+(w[i]-w[sta[s]]-l)*(w[i]-w[sta[s]]-l); while (s &lt; t &amp;&amp; calc(sta[t], sta[t-1]) &gt; calc(i, sta[t])) t--; sta[++t] = i; &#125; return printf("%lld", f[n]), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>斜率优化</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4560 我是歌手]]></title>
    <url>%2FHDU4560%20%E6%88%91%E6%98%AF%E6%AD%8C%E6%89%8B%20%E4%BA%8C%E5%88%86%2B%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem我是歌手Time Limit: $2000 MS$Memory Limit: $32768 KB$ Description$2013$年一开始，一档音乐节目“我是歌手”就惊艳了大家一回。闲话少说，现在，你成为了这档节目的总导演，你的任务很简单，安排每一期节目的内容。现在有$N$个歌手，$M$种歌曲流派（$Rock$，$Pop$之类），每个歌手都有自己擅长的流派领域，这些资料都已整理。你的工作是，安排尽可能多场的演唱比赛。每一场比赛所有歌手都必须上场，为了提高收视率，每个人演唱的歌曲类型不能相同，即便一些歌手要被迫选择一些他们不擅长的。同时，为了展现全面性，在不同的演唱比赛上，每个歌手都会安排不同的歌曲流派。但是问题是，对于任何一个歌曲流派的歌迷，如果超过$K$个不擅长的歌手演唱了这种歌曲，他们就会表示不满，比如，发一些宣泄不满的帖子微博，为了表示观点挑起事端等等。你当然不希望这些事情与你的节目有关，在这个前提下，你可以任意安排尽可能多的比赛场次。 Input输入第一行为$T$，表示有$T$组测试数据。每组数据以四个数字$N$，$M$，$L$，$K$开始。$L$表示有$L$组擅长关系，接下来的$L$行，每一行有两个数字$A_i$，$B_i$，表示歌手$A_i$擅长$B_i$类型的歌曲。 Output对每组数据，先输出为第几组数据，然后输出最多比赛场次。 Sample Input1234567891031 1 1 01 11 3 0 13 3 5 11 11 22 22 33 1 Sample Output123Case 1: 1Case 2: 3Case 3: 2 Explanation123对第三组样例，可以如此安排：第一场三位歌手分别演唱(2,3,1)类型的歌曲，第二场分别演唱(1,2,3)。这样只有类型3被不擅长的歌手演唱过1次，挑剔的歌迷观众还可以接受。 Hint$1\le T \le 100 $$1\le N \le M \le 74, 0 \le K \le N $$0\le L \le N\times M$$1\le A_i \le N, 1 \le B_i \le M$相同关系不会重复出现 标签：带修主席树 Solution挺好的一道$二分+网络流$套路建模题。 二分最多能安排的场次，得到当前答案进行判定。 首先，如果保证每个人唱每种流派最多仅一次，并且$n$个流派均会被唱至少$tans$次，那么一定能找到一组解。这样就可以用最大流判定。由于有“每个流派仅能有$k$个不擅长的选手唱”，我们需要把每个流派又擅长的选手唱和不擅长的选手唱分开，而限制不擅长的选手的数量。可将每个流派拆成两个点，即第$i$个流派$Style_i$拆成$Style_i$和$Style_i’$。从$Style_i$向擅长的选手连边，从$Style_i’$向不擅长的选手连边，而由于从源点向$Style_i$连有$tans$的边，因而所有可用流量都在$Style_i$中，$Style_i’$的流量需要限制，故要在$Style_i$和$Style_i’$间连$K$的边来限制不擅长选手的数量。 建模总述：$$\begin{aligned}S &amp;\to Style_i(i\in [1,m]):Capacity=tans\\Style_i &amp;\to Style_i’(i\in [1,m]):Capacity=K\\Style_i &amp;\to Competitor_j(Competitor_j is good at Style_i):Capacity=1\\Style_i’ &amp;\to Competitor_j(Competitor_j is not good at Style_i):Capacity = 1\\Competitor_j &amp;\to T(j\in [1,n]):Capacity=tans\\\end{aligned}$$建模后跑最大流，看是否有$MaxFlow=tans\times n$即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MAX_M 2000000#define mid ((l+r)&gt;&gt;1)#define INF 0x7f7f7f7fusing namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int n, m, k, f, s, t, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node &#123;int v, c, nxt;&#125; E[MAX_M+5]; bool G[MAX_N+5][MAX_N+5];void init() &#123;cnt = s = 0, t = 3*m+1, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c) &#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;void cpy() &#123;for (int i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;void rec() &#123;for (int i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;int Dinic() &#123;int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;&#125;bool chk(int tans) &#123; init(); for (int i = 1; i &lt;= n; i++) addedge(i+2*m, t, tans); for (int i = 1; i &lt;= m; i++) addedge(s, i, tans), addedge(i, i+m, k); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) addedge(G[i][j] ? i : i+m, j+2*m, 1); return Dinic() == n*tans;&#125;int bi_search(int l, int r) &#123; int ret = 0; while (l &lt;= r) if (!chk(mid)) r = mid-1; else ret = mid, l = mid+1; return ret;&#125;int main() &#123; int T; read(T); for (int C = 1; C &lt;= T; C++) &#123; read(n), read(m), read(f), read(k), memset(G, false, sizeof G); for (int i = 0, x, y; i &lt; f; i++) read(x), read(y), G[y][x] = true; printf("Case %d: %d\n", C, bi_search(1, m)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF446C DZY Loves Fibonacci Numbers]]></title>
    <url>%2FCF446C%20DZY%20Loves%20Fibonacci%20Numbers%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[ProblemDZY Loves Fibonacci NumbersTime limit: $4Sec$Memory limit: $256MB$ DescriptionIn mathematical terms, the sequence $F_n$ of $Fibonacci$ $numbers$ is defined by the recurrence relation $F_1 = 1,F_2 = 1,F_3=F_1+F_2=3,\cdots F_n = F_{n-1}+F_{n-2}$.$DZY$ loves Fibonacci numbers very much. Today $DZY$ gives you an array consisting of $n$ integers: $a_1, a_2,cdots , a_n$. Moreover, there are $m$ queries, each query has one of the two types: Format of the query “$1$ $l$ $r$”. In reply to the query, you need to add $F_{i-l+1}$ to each element $a_i$, where $l\le i\le r$. Format of the query “$2$ $l$ $r$”. In reply to the query you should output the value of $\sum_{i=l}^{r}{a_i}$ modulo $10^9+9$. Help $DZY$ reply to all the queries. InputThe first line of the input contains two integers $n$ and $m$ $(1 \le n, m \le 3\times 10^5)$. The second line contains n integers $a_1, a_2, \cdots, a_n (1 ≤ a_i \le10^9)$ — initial array $a$.Then, m lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality $1 \le l \le r \le n$ holds. OutputFor each query of the second type, print the value of the sum on a single line. ExampleInput1234564 41 2 3 41 1 42 1 41 2 42 1 3 Output121712 NoteAfter the first query, $a = [2, 3, 5, 7]$.For the second query, $sum = 2 + 3 + 5 + 7 = 17$.After the third query, $a = [2, 4, 6, 9]$.For the fourth query, $sum = 2 + 4 + 6 = 12$. 标签：线段树 Translation题目大意：给出一个长为$3\times 10^5$级别的初始数组，要求维护两种操作： 将$a_l \sim a_r$中的每个数对应加上从$Fib_1\sim Fib_{l-r+1}$的斐波那契数，即使$a_i(i\in[l,r])$加上$Fib_{i-l+1}$ 询问$\sum_{i=l}^{r}{a_i}$模$10^9+9$的值 Solution不难想到此题需要用线段树维护。不过难点在于如何合并标记。 初步想法是每次打标记时记录下此区间是从斐波那契数列的多少项开始一一对应地加进去，不过这样是无法合并标记的，每个结点只能有一个标记，可以被卡成$O(n^2\log n)$。 考虑把标记换一种存法。对于一个数列$x_1=a,x_2=b,x_3=a+b,x_4=a+b\times 2,\cdots x_n=x_{n-1}+x_{n-2}$，我们将其称为一个“伪斐波那契数列”，不难发现其等于几个斐波那契数列的子序列之和，即在原题中，不管如何加，每个区间最后加的数列都是一个伪斐波那契数列。而此序列可以仅通过最前面的两项$a$和$b$推出后面的任意项以及前若干项之和，即$$\begin{aligned}x_n &amp;= x_{n-1}+x_{n-2}\\&amp;= 2\times x_{n-2}+x_{n-3}\\&amp;= 3\times x_{n-3}+2\times x_{n-4}\\&amp;= Fib_{n-2}\times x_1+Fib_{n-1}\times x_2\\\sum_{i=1}^{n}{x_i} &amp;= x_1+x_2+x_3+\cdots x_n\\&amp;= x_1+x_2+x_2+x_3+\cdots +x_n-x_2\\&amp;= x_3+x_4+x_4+x_5+\cdots +x_n-x_2\\&amp;= x_5+x_6+x_6+x_7+\cdots +x_n-x_2\\&amp;= x_{n-2}+x_{n-1}+x_{n-1}+x_{n}-x_2\\&amp;= x_n+x_{n+1}-x_2\\&amp;= x_{n+2}-x_{2}\end{aligned}$$用这两个公式我们可以$O(1)$计算任意项及前任意项的和。每个标记为一个数对$(a,b)$，那么合并标记的时候将两个标记的$a$和$b$分别相加，得到$(a_1+a_2,b_1+b_2)$即可。总时间复杂度$O(n\log n)$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000#define mid ((s+t)&gt;&gt;1)#define MOD 1000000009using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int n, m; lnt fib[MAX_N+5] = &#123;0LL, 1LL&#125;;struct node &#123;lnt c, f1, f2;&#125; tr[(MAX_N&lt;&lt;2)+5];lnt fn(lnt f1, lnt f2, int len) &#123;return len == 1 ? f1 : (len == 2 ? f2 : (f1*fib[len-2]%MOD+f2*fib[len-1]%MOD)%MOD);&#125;lnt sum(lnt f1, lnt f2, int len) &#123;return len == 1 ? f1 : (len == 2 ? (f1+f2)%MOD : (fn(f1, f2, len+2)-f2+MOD)%MOD);&#125;void updata(int v) &#123;tr[v].c = (tr[v&lt;&lt;1].c+tr[v&lt;&lt;1|1].c)%MOD;&#125;void downtag(int v, int s, int t) &#123; if (!tr[v].f1) return; lnt lf1 = tr[v].f1, lf2 = tr[v].f2, rf1 = fn(lf1, lf2, mid-s+2), rf2 = fn(lf1, lf2, mid-s+3); (tr[v&lt;&lt;1].f1 += lf1) %= MOD, (tr[v&lt;&lt;1].f2 += lf2) %= MOD, (tr[v&lt;&lt;1].c += sum(lf1, lf2, mid-s+1)) %= MOD; (tr[v&lt;&lt;1|1].f1 += rf1) %= MOD, (tr[v&lt;&lt;1|1].f2 += rf2) %= MOD, (tr[v&lt;&lt;1|1].c += sum(rf1, rf2, t-mid)) %= MOD; tr[v].f1 = tr[v].f2 = 0;&#125;void build(int v, int s, int t) &#123; if (s == t) &#123;read(tr[v].c); return;&#125; build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t); updata(v);&#125;void modify(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; (tr[v].f1 += fib[s-l+1]) %= MOD, (tr[v].f2 += fib[s-l+2]) %= MOD; (tr[v].c += sum(fib[s-l+1], fib[s-l+2], t-s+1)) %= MOD; return; &#125; downtag(v, s, t); if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r); updata(v);&#125;lnt query(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].c; lnt ret = 0; downtag(v, s, t); if (l &lt;= mid) (ret += query(v&lt;&lt;1, s, mid, l, r)) %= MOD; if (r &gt;= mid+1) (ret += query(v&lt;&lt;1|1, mid+1, t, l, r)) %= MOD; updata(v); return ret;&#125;void init() &#123;for (int i = 2; i &lt;= MAX_N; i++) fib[i] = (fib[i-2]+fib[i-1])%MOD;&#125;int main() &#123; read(n), read(m), init(), build(1, 1, n); while (m--) &#123; int opt, l, r; read(opt), read(l), read(r); if (opt == 1) modify(1, 1, n, l, r); else printf("%I64d\n", query(1, 1, n, l, r)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2671 Calc]]></title>
    <url>%2FBZOJ2671%20Calc%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%2F</url>
    <content type="text"><![CDATA[ProblemCalcTime Limit: $10 Sec$Memory Limit: $128 MB$ Description给出$N$，统计满足下面条件的数对$(a,b)$的个数： $1\le a&lt;b\le N$ $(a+b)|(a\cdot b)$ Input一行一个数$N$。 Output一行一个数表示答案。 Sample Input115 Sample Output14 HINT 测试点编号 数据规模 测试点编号 数据规模 $01$ $N\le 10$ $11$ $N\le 5\times 10^7$ $02$ $N \le 50$ $12$ $N\le 10^8$ $03$ $N\le 10^3$ $13$ $N\le 2\times 10^8$ $04$ $N\le 5\times 10^3$ $14$ $N\le 3\times 10^8$ $05$ $N\le 2\times 10^4$ $15$ $N\le 5\times 10^8$ $06$ $N\le 2\times 10^5$ $16$ $N\le 10^9$ $07$ $N\le 2\times 10^6$ $17$ $N\le 10^9$ $08$ $N\le 10^7$ $18$ $N\le 2^{31}-1$ $09$ $N\le 2\times 10^7$ $19$ $N\le 2^{31}-1$ $10$ $N\le 3\times 10^7$ $20$ $N\le 2^{31}-1$ 标签：莫比乌斯反演 Solution一道稍有变形的莫比乌斯反演，$blutrex$有$O(n^{\frac{3}{4}})$的算法，但我只会小常数的$O(n)$算法，不过可以过$BZOJ$数据。 问题即求$\sum_{i=1}^{n}\sum_{j=i+1}^{n}{[(i+j)|(i\times j)]}$的值。设$\gcd(i,j)=d$, $i=x\times d$, $j=y\times d$，易知$\gcd(x,y)=1$。那么$(i+j)|(i\times j)$$\iff$$((x+y)\times d)|(x\times y\times d^2)$$\iff$$(x+y)|(x\times y\times d)$$\iff$$(x+y)|d$。不妨设$d=k\times(x+y)​$，那么$a=x\times d=k\times x\times(x+y)​$, $b=y\times d=k\times y\times(x+y)​$。有$$\begin{equation}\begin{aligned}原式 =&amp; \sum_{x=1}^{n}\sum_{y=x+1}^{n}[\gcd(x,y)=1 \&amp;\&amp; a&lt;b\le n]\\=&amp; \sum_{y=1}^{\lfloor\sqrt{n}-1\rfloor}\sum_{x=1}^{y-1}\sum_{k\in \mathbb{Z}^*}{[\gcd(x,y)=1 \&amp;\&amp; k\times y\times (x+y)\le n]}\\=&amp; \sum_{y=1}^{\lfloor\sqrt{n}-1\rfloor}\sum_{x=1}^{y-1}[\gcd(x,y)=1]\times \lfloor\frac{n}{y\times(x+y)}\rfloor\\\end{aligned}\end{equation}$$显然$val=\lfloor\frac{n}{y\times(x+y)}\rfloor$只有$\sqrt{n}$级别种取值，可以根号分块来算，即枚举$y$，每次找到$val$相等的一段$x\in[lo,hi]$，统计$[lo,hi]$间满足$\gcd(x,y)=1$的$x$的个数，可以套用基础莫比乌斯反演公式，即$\sum_{d|y}{\mu(d)\cdot(\lfloor\frac{hi}{d}\rfloor-\lfloor\frac{lo-1}{d}\rfloor)}$。 此算法先枚举$y$的取值，再枚举$val$的取值，最后枚举$y$的约数$d$计算反演。其中$y$有$\sqrt{n}$级别种取值，$val$所对应的$[lo,hi]$都在$(0,y)$之间，即共有$\sqrt{y}\thickapprox\sqrt[4]{n}$级别种取值，而最后的$d$又有$\sqrt{y}\thickapprox\sqrt[4]{n}$级别种取值，故总时间复杂度应为$O(n)$。但是由于$val$的取值总数通常到不了$\sqrt[4]{n}$级别，且$d$的取值总数通常也到不了$\sqrt[4]{n}$级别，因此常数非常小，跑得贼快，可以过此题$2\times 10^9$级别的数据。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int pri[MAX_N+5], mu[MAX_N+5], fac[MAX_N+5], cnt; bool NotPri[MAX_N+5];void PriS() &#123; mu[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) &#123; if (!NotPri[i]) pri[cnt++] = i, mu[i] = -1; for (int j = 0, x; j &lt; cnt; j++) &#123; if ((x = i*pri[j]) &gt; MAX_N) break; NotPri[x] = true; if (i%pri[j]) mu[x] = -mu[i]; else &#123;mu[x] = 0; break;&#125; &#125; &#125;&#125;int main() &#123; int n; read(n), PriS(); lnt ans = 0LL; for (lnt i = 1, l, r; i &lt; sqrt(n); i++) &#123; cnt = 0; for (int j = 1; j &lt;= sqrt(i); j++) if (i%j == 0) fac[cnt++] = j; for (l = 1; l &lt; i; l = r+1) &#123; lnt val = n/(i*(i+l)); if (!val) break; r = min(n/val/i-i, i-1); for (lnt k = 0, j; k &lt; cnt; k++) &#123; j = fac[k], ans += mu[j]*(r/j-(l-1)/j)*val; lnt t = i/j; if (i%t == 0 &amp;&amp; (j^t)) ans += mu[t]*(r/t-(l-1)/t)*val; &#125; &#125; &#125; return printf("%lld\n", ans), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数论数学</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2339【HNOI2011】卡农]]></title>
    <url>%2FBZOJ2339%E3%80%90HNOI2011%E3%80%91%E5%8D%A1%E5%86%9C%20%E8%AE%A1%E6%95%B0DP%2B%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2011】卡农Time Limit: $10 Sec$Memory Limit: $128MB$ Description Input Output Sample Input 标签：计数$DP$ Solution考试时没想出来，不过听了觉得挺简单的。 首先把每个片段看成一个数，每个音阶看成该数的一位，则每位为$0$或$1$，题意可以转化为求在$1\sim 2^n-1$中选$m$个数使其异或和为$0$的方案数。我们先不考虑无序性，求出所有排列后除$m!$即为答案。 设$f[i]$为选$i$个数的方案数，考虑先选$i-1$个数，最后一个数即为前面的数的异或和，这样才能使总异或和位$0$。那么如果不考虑限制，直接选则有$P_{2^n-1}^{i-1}=(2^n-1)\times (2^n-2)\times (2^n-3)\times \cdots \times (2^n-i+1)$种选法。 只可能有两种不合法的情况，即最后一个数位$0$或最后一个数在前面$i-1$个数种出现过。对于第一种情况，不合法方案数为选$i-1$个数的合法方案数，即为$f[i-1]$。而对于第二种情况，去掉相同的数后，其他数异或和为$0$，这样就有$f[i-2]$中方案，而去掉的数的位置有$i-1$种选法，去掉的数的值有$2^n-1-(i-2)$种选法，故共会去掉$f[i-2]\times (i-1)\times (2^n-i+1)$种不合法方案。 于是，$DP$方程为$$f[i]=\begin{cases} 1 &amp;\mbox{$(i=0)$}\\ 0 &amp;\mbox{$(i=1)$}\\(2^n-1)\times (2^n-2)\times \cdots \times (2^n-i+1)-f[i-1]-f[i-2]\times (i-1)\times (2^n-i+1) &amp;\mbox{$(i\ge 2)$}\end{cases}$$ Code1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define MAX_N 1000000#define MOD 100000007using namespace std;typedef long long lnt;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int n, m; lnt p, q, c, f[MAX_N+5], g[MAX_N+5], inv[MAX_N+5] = &#123;1LL, 1LL&#125;;void init(int n) &#123;for (int i = 2; i &lt;= n; i++) inv[i] = (MOD-MOD/i*inv[MOD%i]%MOD)%MOD;&#125;int main() &#123; read(m), read(n), init(n), p = f[0] = c = 1LL, f[1] = 0LL, g[1] = 1LL; for (int i = 1; i &lt;= m; i++) (p *= 2) %= MOD; (p += MOD-1) %= MOD, q = p; for (int i = 2; i &lt;= n; i++, (q += MOD-1) %= MOD) g[i] = g[i-1]*q%MOD; for (int i = 2; i &lt;= n; i++) f[i] = (g[i]-(f[i-1]+1LL*(i-1)*(p-i+2)%MOD*f[i-2]%MOD)%MOD+MOD)%MOD; for (int i = 1; i &lt;= n; i++) (c *= inv[i]) %= MOD; return printf("%lld", f[n]*c%MOD), 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4334【JSOI2012】铁拳]]></title>
    <url>%2FBZOJ4334%E3%80%90JSOI2012%E3%80%91%E9%93%81%E6%8B%B3%20%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 【JSOI2012】铁拳Time Limit: $10 Sec$Memory Limit: $256 MB$ Description经过了可怕的第三次世界大战后，国家政府崩溃，各大财团趁机夺取掌控世界。长年战争后，八大财团幸存并割据一方，其中最强的当属掌控北美的铁拳。在铁拳财团所维护的文明区域中，有一项最为光荣、重要的赛事——$Iron Fist$，也就是铁拳大赛。$I$F中云集了世界各地各财团鼎力资助的世外高手，只为了赢得$IF Champion$，得到无上的荣耀，当然还有随之而来的权力。本来一切秩序井然，但一个来自贫民窟的少年风间仁意外地在海选中赢了$IF$正式选手，获得了决赛资格，从此格局被打乱……为了应对这突如其来的变数，$IF$管理层决定先对联盟中所有的选手进行评估，以更好地掌握大局。知最近$m$届比赛出现过的$n$位选手，背后都有着各自财团的资助，并且签下了合同。由于这是各财团的高度机密，合同的具体细节无从得知，但铁拳财团的间谍们通过各种渠道得知了每个选手的薪金范围（显然薪金是非负数）。对于最近$m$届的$IF$比赛（从$1$开始编号），每一届联盟都会进行清算，通过国际金融手段准确计算出这一届联盟选手身价总和的变化。每一届中，会有一些新选手加入，也会有部分选手在比赛中丧失了战斗能力，而被踢出联盟，流放到贫民窟。现在给出联盟中$n$位选手的身价范围，以及他们 进入联盟的届数（$0$表示在$m+1$届以前就已经是联盟选手） 和 离开联盟的届数（$0$表示是现役选手）。同时给出最近$m$届中，每一届联盟选手身价总和减去上一届的值。请你根据现有信息，尽可能准确地给出每个选手可能的薪金范围。各选手之间的薪金范围可以不同时成立，但对于一位选手的范围中的每一个数，都必须至少存在一种合法方案使该选手能得到相应薪金，而且这个范围跨度要尽可能大。如果输入信息有误，请输出$-1$，表示无解。 Input第一行一个正整数$m$，意义见上（下同）。第二行包含$m$个整数，第$i$个表示第$i$届中 选手身价总和 的变化情况。第三行一个正整数$n$。接下来n行，每行包含四个整数，分别表示 身价下限 、 身价上限 、 出道届数 、 退役届数，细节请参照上文。保证出道时间严格比退役时间小（$0$除外）。 Output一行，输出最小的答案。 Sample Input12345625 -131 4 1 02 3 1 01 5 1 2 Sample Output1231.00 2.002.00 3.001.00 1.00 HINT【样例解释】第二届只有$3$号离开了，可以锁定$3$号的薪金是$1$。如此一来，$1$号和$2$号薪金之和为$4$，那么$1$号最少能拿$1$，最多能拿$2$；$2$号最少能拿到$2$，最多能拿到$3$。【数据规模】对于$100\%$的数据，$n\le 200$，$m\le 100$，给定薪金范围不超过$20000$。应上传者要求，此题不公开，如有异议，请提出. 标签：线性规划，上下界网络流 Solution线性规划转上下界网络流。挺麻烦的。 首先这些条件可以看作$m$个等式，故可转化为线性规划。而解线性规划只有网络流和单纯形两种，不会单纯形，所以用了网络流。 将每个等式作为一个点，每个变量作为一条边，不难发现一个变量只会进入等式一次，出等式一次。若此变量从$l$等式进，从$r$等式出，范围为$[lo, hi]$，则连边$l\to r$，容量为$[lo,hi]$。对于$l=0$的变量，则连边$s\to r$；对于$r=0$的变量，则连边$l\to t$。接下来处理每个等式的差值。可以发现等式$i-1$与$i$的差值可以用边$s\to i$或$i\to t$表示，即为从源点补进来多少流量或从汇点分出去多少流量。因而可以连边：设等式$i-1$与$i$的差值为$gap_i$，若$gap_i&gt;0$，则连边$S\to i$，容量为$gap_i$；若$gap_i&lt;0$，则连边$i\to T$，容量为$-gap_i$。这样就可以构建出一个上下界网络流的模型。 建模后，可以在一开始就跑一遍可行流，判断是否有解。 之后有两种做法： 法$1$：对每条边的取值进行二分，分别去找最大值和最小值，每次$check$的时候把重设当前边的范围，跑可行流验证。 法$2$：对于每条边，找到先前求可行流时它的流量，考虑它最多可以再少承担多少流量或多承担多少流量。那么可以在残量网络上断掉当前边，以起点为源，终点为汇，跑最大流得到它最多可以减少多少流量；再以终点为汇，起点为源，跑最大流得到它最多可以增加多少流量。设最多可以减少$maxDecrease$，最多可以增加$maxIncrease$，此边的下限为$lo$，上限为$hi$，可行流中此边的流量为$cur$，则答案为$lo+cur-maxDecrease$和$lo+cur+maxIncrease$。这里需要注意两个答案都需要在$[lo,hi]$之间，即最终答案应该为$max(lo,lo+cur-maxDecrease)$和$min(hi,lo+cur+maxIncrease)$。 建议使用法$2$，同时$\%\%\%巨佬Joker$提供优质法$2$。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MAX_M 2000#define INF 0x7f7f7f7fusing namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;struct node &#123;int v, c, nxt;&#125; E[MAX_M+5], cpy[MAX_M+5];int n, m, s, t, ss, tt, cnt, d[MAX_N+5], pr[MAX_N+5], mat[MAX_N+5];int gap[MAX_N+5], range[MAX_N+5][2], zone[MAX_N+5][2]; bool mrk[MAX_N+5];void init() &#123;ss = m+1, tt = m+2, s = 0, t = m+3, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c) &#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;int addedge(int u, int v, int c) &#123;return insert(u, v, c), insert(v, u, 0), cnt-2;&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (~d[v] || !c || mrk[i]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c || mrk[i]) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123;int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;bool get_ava() &#123; int into = 0, outo = 0; init(), memset(d, 0, sizeof d); addedge(tt, ss, INF); for (int i = 1; i &lt;= m; i++) &#123; if (gap[i] &gt; 0) d[ss] += gap[i], d[i] -= gap[i]; if (gap[i] &lt; 0) d[i] -= gap[i], d[tt] += gap[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; int u = zone[i][0] == 0 ? ss : zone[i][0]; int v = zone[i][1] == 0 ? tt : zone[i][1]; mat[i] = addedge(u, v, range[i][1]-range[i][0]); d[u] += range[i][0], d[v] -= range[i][0]; &#125; for (int i = s+1; i &lt;= t-1; i++) &#123; if (d[i] &lt; 0) addedge(s, i, -d[i]), into -= d[i]; if (d[i] &gt; 0) addedge(i, t, d[i]), outo += d[i]; &#125; return into == outo &amp;&amp; Dinic() == into;&#125;void rec() &#123;for (int i = 0; i &lt; cnt; i++) E[i] = cpy[i];&#125;int main() &#123; read(m); for (int i = 1; i &lt;= m; i++) read(gap[i]); read(n); for (int i = 1; i &lt;= n; i++) read(range[i][0]), read(range[i][1]), read(zone[i][0]), read(zone[i][1]); if (!get_ava()) &#123;puts("-1"); return 0;&#125; for (int i = 0; i &lt; cnt; i++) cpy[i] = E[i]; for (int i = 1; i &lt;= n; i++) &#123; int eid = mat[i], base = E[eid^1].c, ori = E[eid].c+base; mrk[eid] = mrk[eid^1] = true; s = E[eid^1].v, t = E[eid].v, printf("%d.00 ", range[i][0]+max(base-Dinic(), 0)), rec(); s = E[eid].v, t = E[eid^1].v, printf("%d.00\n", range[i][0]+min(base+Dinic(), ori)), rec(); mrk[eid] = mrk[eid^1] = false; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>上下界网络流</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1069【SCOI2007】最大土地面积]]></title>
    <url>%2FBZOJ1069%E3%80%90SCOI2007%E3%80%91%E6%9C%80%E5%A4%A7%E5%9C%9F%E5%9C%B0%E9%9D%A2%E7%A7%AF%20%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[Problem 【SCOI2007】最大土地面积Time Limit: $1 Sec$Memory Limit: $128 MB$ Description在某块平面土地上有$N$个点，你可以选择其中的任意四个点，使得这四个点围成的土地面积最大。 Input第$1$行一个正整数$N$，接下来$N$行，每行$2$个数$x,y$，表示该点的横坐标和纵坐标。 Output最大的多边形面积，答案精确到小数点后$3$位。 Sample Input12345650 01 01 10 10.5 0.5 Sample Output11.000 HINT数据范围: $n\le 2000$，$|x|,|y|\le 10^5$ 标签：旋转卡壳 Solution基础旋转卡壳。 首先这四个点一定在凸包上，先求凸包。 考虑枚举每条对角线，找出其两边最远的点，即可找到该对角线对应的最大四边形。这样就是一个$O(n^3)$的暴力。 枚举对角线的一段，移动另一端，发现两边最远的点都是单调移动的，于是可以带上旋转卡壳，这样内层循环的总复杂度时$O(n)$，就有了一个$O(n^2)$的优质算法。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define MAX_N 2000using namespace std;typedef double dnt;int n, m;struct pnt &#123; dnt x, y; dnt operator * (const pnt &amp;t) const &#123;return x*t.y-y*t.x;&#125; pnt operator - (const pnt &amp;t) const &#123;return (pnt)&#123;x-t.x, y-t.y&#125;;&#125; bool operator &lt; (const pnt &amp;t) const &#123;return x == t.x ? y &lt; t.y : x &lt; t.x;&#125;&#125; p[MAX_N+5], c[MAX_N*2+5], mat[MAX_N*2+5][2];dnt S(pnt a, pnt b, pnt c, pnt d) &#123;return (a*b+b*c+c*d+d*a)/2;&#125;void ConvexHull() &#123; sort(p+1, p+n+1), c[++m] = p[1], c[++m] = p[2]; for (int i = 3; i &lt;= n; c[++m] = p[i++]) while (m &gt; 1 &amp;&amp; (p[i]-c[m-1])*(c[m]-c[m-1]) &gt;= 0) m--; int t = m; c[++m] = p[n-1]; for (int i = n-2; i; c[++m] = p[i--]) while (m &gt; t &amp;&amp; (p[i]-c[m-1])*(c[m]-c[m-1]) &gt;= 0) m--; m--; for (int i = 1; i &lt;= m; i++) c[i+m] = c[i];&#125;dnt RotatingCalipers() &#123; dnt ret = 0; if (m == 3) return (c[1]*c[2]+c[2]*c[3]+c[3]*c[1])/2; for (int i = 1; i &lt;= m; i++) &#123; for (int j = i+2, t = j-1; j &lt;= i+m-2; j++) &#123;while (t &lt; j &amp;&amp; (c[t+1]-c[t])*(c[j]-c[i]) &gt;= 0) t++; mat[j][0] = c[t];&#125; for (int j = i+m-2, t = j+1; j &gt;= i+2; j--) &#123;while (t &gt; j &amp;&amp; (c[t-1]-c[t])*(c[j]-c[i]) &lt;= 0) t--; mat[j][1] = c[t];&#125; for (int j = i+2; j &lt;= i+m-2; j++) ret = max(ret, S(c[i], mat[j][0], c[j], mat[j][1])); &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%lf%lf", &amp;p[i].x, &amp;p[i].y); return ConvexHull(), printf("%.3lf", RotatingCalipers()), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>旋转卡壳</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2406 矩阵]]></title>
    <url>%2FBZOJ2406%20%E7%9F%A9%E9%98%B5%20%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 矩阵Time Limit: $10 Sec$ Memory Limit: $128 MB$ Description Input第一行两个数$n$、$m$，表示矩阵的大小。接下来$n$行，每行$m$列，描述矩阵$A$。最后一行两个数$L$，$R$。 Output一行，输出最小的答案。 Sample Input12342 20 12 10 1 Sample Output11 HINT$N,M\le 200$, $0\le L\le R\le 1000$, $0\le A_{i,j}\le 1000$ 标签：线性规划，上下界网络流 Solution线性规划转上下界网络流。看到所求为最大值中的最小，可想到二分答案。对于当前答案$tans​$，验证是否能构造矩阵B使得： 对于$\forall i\in [1,n], \forall j\in[1,m]$，$L\le B_{i,j}\le R$ 对于$\forall i \in [1,n]$，$\sum_{j=1}^{m}{A_{i,j}}-tans \le \sum_{j=1}^{m}{B_{i,j}} \le \sum_{j=1}^{m}{A_{i,j}}+tans$ 对于$\forall j\in [1,m]$，$\sum_{i=1}^{n}{A_{i,j}}-tans \le \sum_{i=1}^{n}{B_{i,j}} \le \sum_{i=1}^{n}{A_{i,j}}+tans$而$n,m$又只有200，不难想到跑网络流验证。 将每行每列设为点（共$n+m$个），建图: $S\to row_i$ 容量$[\sum_{j=1}^{m}{A_{i,j}}-tans, \sum_{j=1}^{m}{A_{i,j}}+tans]$ $column_j \to T$ 容量$[\sum_{i=1}^{n}{A_{i,j}}-tans, \sum_{i=1}^{n}{A_{i,j}}+tans]$ $row_i\to column_j$ 容量$[L, R]$ 赫然是个上下界网络流。建虚拟源虚拟汇跑最大流看是否等于补流即可。建图，$SS,TT$为上下界网络流的原源和原汇，$S,T$为虚拟源和汇，$d[]$记录补流： $TT\to SS$ 容量$\infty$ $row_i\to column_j​$ 容量$R-L​$，$d[row_i] +L, d[column_j] - L​$ $SS\to row_i$ 容量$\sum_{j=1}^{m}{A_{i,j}}-tans$，$d[SS]+2\times tans, d[row_i]-2\times tans$ $column_j \to TT$ 容量$\sum_{i=1}^{n}{A_{i,j}}-tans$，$d[column_j]+2\times tans, d[TT]-2\times tans$ 随后将此图和虚拟源汇接上：对于$x\in {row_{1\sim n}}\cup {column_{1\sim m}}\cup {SS,TT}$ 若$d[x] &lt; 0$，连接$S\to x$ 容量$-d[x]$，$tot_补-d[x]$ 若$d[x] &gt; 0$，连接$x \to T$ 容量$d[x]$，$tot_分+d[x]$ 最后判断$tot_补=tot_分=MaxFlow$ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;bits/stdc++.h&gt;#define MAX_N 500000#define MAX_M 500000#define INF 0x3f3f3f3f#define mid ((p+q)&gt;&gt;1)using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int r, c, x[205], y[205], P, Q;int n, s, t, ss, tt, cnt, d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5];struct node &#123;int v, c, nxt;&#125; E[MAX_M+5];void init() &#123;cnt = 0, s = 0, t = r+c+1, ss = t+1, tt = t+2, memset(pr, -1, sizeof pr), memset(d, 0, sizeof d);&#125;void insert(int u, int v, int c) &#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123;int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;bool check(int tans) &#123; int into = 0, outo = 0; init(), n = r+c+2, addedge(tt, ss, INF); for (int i = 1; i &lt;= r; i++) for (int j = 1; j &lt;= c; j++) addedge(i, j+r, Q-P), d[i] += P, d[j+r] -= P; for (int i = 1; i &lt;= r; i++) addedge(ss, i, 2*tans), d[ss] += x[i]-tans, d[i] -= x[i]-tans; for (int i = 1; i &lt;= c; i++) addedge(i+r, tt, 2*tans), d[i+r] += y[i]-tans, d[tt] -= y[i]-tans; for (int i = 1; i &lt;= tt; i++) if (i^t) &#123; if (d[i] &lt; 0) addedge(s, i, -d[i]), into -= d[i]; if (d[i] &gt; 0) addedge(i, t, d[i]), outo += d[i]; &#125; return into == outo &amp;&amp; Dinic() == into;&#125;int bi_search(int p, int q) &#123;int ret = -1; while (p &lt;= q) if (check(mid)) ret = mid, q = mid-1; else p = mid+1; return ret;&#125;int main() &#123; read(r), read(c); for (int i = 1; i &lt;= r; i++) for (int j = 1, val; j &lt;= c; j++) read(val), x[i] += val, y[j] += val; return read(P), read(Q), printf("%d", bi_search(0, 200000)), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>上下界网络流</tag>
        <tag>线性规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3676【APIO2014】回文串]]></title>
    <url>%2FBZOJ3676%E3%80%90APIO2014%E3%80%91%E5%9B%9E%E6%96%87%E4%B8%B2%20%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[ProblemBZOJ3676【APIO2014】回文串Time Limit: $20 Sec$Memory Limit: $128 MB$ Description给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。 Input输入只有一行，为一个只包含小写字母$(a-z)$的非空字符串 $s$。 Output输出一个整数，表示所有回文子串中的最大存在值。 Sample InputInput $1$1abacaba Input $2$1www Sample OutputOutput $1$17 Output $2$14 HINT一个串是回文的，当且仅当它从左到右读和从右到左读完全一样。在第一个样例中，回文子串有$7$个：$a$，$b$，$c$，$aba$，$aca$，$bacab$，$abacaba$，其中： a出现$4$次，其出现值为$4$：$4\times 1=4$ b出现$2$次，其出现值为$2$：$2\times 1=2$ c出现$1$次，其出现值为$1$：$1\times 1=1$ aba出现$2$次，其出现值为$6$：$2\times 3=6$ aca出现$1$次，其出现值为$3$：$1\times 3=3$ bacab出现$1$次，其出现值为$5$：$1\times 5=5$ abacaba出现$1$次，其出现值为$7$：$1\times 7=7$ 故最大回文子串出现值为$7$。数据规模与评分数据满足 $1\le 字符串长度\le 3\times 10^5$。 标签：回文自动机 Solution回文自动机建出来直接统计答案。具体回文自动机讲解参见 $poursoul$ 的博客：http://blog.csdn.net/u013368721/article/details/42100363 Code1234567891011121314151617#include &lt;bits/stdc++.h&gt;#define DICNUM 26#define MAX_N 300000using namespace std;typedef long long lnt;char s[MAX_N+5]; int cnt, trie[MAX_N+5][DICNUM], fail[MAX_N+5], end[MAX_N+5], len[MAX_N+5];int newnode(int l) &#123;len[++cnt] = l; return cnt;&#125;void init() &#123;fail[0] = newnode(-1), s[0] = '$';&#125;int getf(int x, int l) &#123;while (s[l-len[x]-1]^s[l]) x = fail[x]; return x;&#125;int main() &#123; scanf("%s", s+1), init(); int n = (int)strlen(s+1); for (int i=1, x=s[1]-'a', pre=0, cur=getf(pre,1); i&lt;=n; end[pre=trie[cur][x]]++, x=s[++i]-'a', cur=getf(pre,i)) if (!trie[cur][x]) newnode(len[cur]+2), fail[cnt] = trie[getf(fail[cur], i)][x], trie[cur][x] = cnt; for (int i = cnt; i; i--) end[fail[i]] += end[i]; lnt ans = 0; for (int i = 1; i &lt;= cnt; i++) ans = max(ans, 1LL*len[i]*end[i]); return printf("%lld", ans), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>APIO</tag>
        <tag>字符串</tag>
        <tag>回文自动机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3676【NOI2015】品酒大会]]></title>
    <url>%2FBZOJ4199%E3%80%90NOI2015%E3%80%91%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A%20%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Problem BZOJ3676【NOI2015】品酒大会Time Limit: $10 Sec$ Memory Limit: $512 MB$ Description一年一度的“幻影阁夏日品酒大会”隆重开幕了。大会包含品尝和趣味挑战两个环节，分别向优胜者颁发“首席品酒家”和“首席猎手”两个奖项，吸引了众多品酒师参加。在大会的晚餐上，调酒师 $Rainbow$ 调制了 $n$ 杯鸡尾酒。这 $n$ 杯鸡尾酒排成一行，其中第 $i$ 杯酒 $(1\le i\le n)$ 被贴上了一个标签 $s_i$，每个标签都是 $26$ 个小写英文字母之一。设 $str(i,j)$ 表示第 $i$ 杯酒到第 $j$ 杯酒的 $j-i+1$ 个标签顺次连接构成的字符串。若 $str(l_1,r_1)=str(l_2,r_2)$，其中$1\le l_1\le r_1\le n$，$1\le l_2\le r_2\le n$，$l_1\ne l_2$，$r_1-l_1+1=r_2-l_2+1=p$，则称第 $l_1$ 杯酒与第 $l_2$ 杯酒是“$p$ 相似”的。当然两杯“$p$ 相似” $(p&gt;1)$ 的酒同时也是“$1$ 相似”、“$2$ 相似”、……、“$(p-1)$ 相似”的。特别地，对于任意的$1\le p,q\le n, p\ne q$，第 $p$ 杯酒和第 $q$ 杯酒都是“$0$ 相似”的。在品尝环节上，品酒师 $Freda$ 轻松地评定了每一杯酒的美味度，凭借其专业的水准和经验成功夺取了“首席品酒家”的称号，其中第 $i$ 杯酒$(1\le i\le n)$ 的美味度为 $a_i$。现在 $Rainbow$ 公布了挑战环节的问题：本次大会调制的鸡尾酒有一个特点，如果把第 $i$ 杯酒与第 $j$ 杯酒调兑在一起，将得到一杯美味度为 $a_i\times a_j$ 的酒。现在请各位品酒师分别对于 $p = 0,1,2,\cdots ,p-1$，统计出有多少种方法可以选出 $2$ 杯“$p$ 相似”的酒，并回答选择 $2$ 杯“$p$相似”的酒调兑可以得到的美味度的最大值。 Input第 $1$ 行包含 $1$ 个正整数 $n$，表示鸡尾酒的杯数。第 $2$ 行包含一个长度为 $n$ 的字符串 $S$，其中第 i 个字符表示第 $i$ 杯酒的标签。第 $3$ 行包含 $n$ 个整数，相邻整数之间用单个空格隔开，其中第 $i$ 个整数表示第 $i$ 杯酒的美味度 $a_i$。 Output输出文件包括 $n$ 行。第 $i$ 行输出 $2$ 个整数，中间用单个空格隔开。第 $1$个整数表示选出两杯“$i-1$ 相似”的酒的方案数，第 $2$ 个整数表示选出两杯“$i-1$ 相似”的酒调兑可以得到的最大美味度。若不存在两杯“$i-1$ 相似”的酒，这两个数均为 $0$。 SampleSample 1Input12310ponoiiipoi2 1 4 7 4 8 3 6 4 7 Output1234567891045 5610 563 320 00 00 00 00 00 00 0 Explanation二元组 $(p,q)$ 表示第 $p$ 杯酒与第 $q$ 杯酒。$0$ 相似：所有 $45$ 对二元组都是 $0$ 相似的，美味度最大的是 $8\times 7=56$。$1$ 相似：$(1,8)(2,4)(2,9)(4,9)(5,6)(5,7)(5,10)(6,7)(6,10)(7,10)，最大的是$$8\times 7=56$。$2$ 相似：$(1,8)(4,9)(5,6)，最大的是 $4\times 8=32$。没有 $3,4,5,\cdots ,9$ 相似的两杯酒，故均输出 $0$。 Sample 2Input12312abaabaabaaba1 -2 3 -4 5 -6 7 -8 9 -10 11 -12 Output12345678910111266 12034 12015 5512 409 277 165 73 -42 -41 -40 00 0 HINT 对于 $40\%$ 的数据， $n\le 2000$。 有 $10\%$ 的数据，不存在“$10$ 相似”的酒。 有 $20\%$ 的数据，所有 $a_i$ 的值都相等。 对于 $100\%$ 的数据， $1\le n\le 300000, |a_i|\le 10^9$。 标签：后缀数组，并查集 Solution建后缀数组后统计每种$height$的后缀对有哪些，发现当从高向低枚举相似度$p$时，只会有越来越多的字符串满足，则每次合并新加进来的后缀对，用并查集维护。即若后缀$i$和$i-1$最高为$k$相似，则从$n$倒叙枚举到$k$时把$i$和$i-1$所在的集合合并。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;bits/stdc++.h&gt;#define MAX_N 300000using namespace std;typedef long long lnt;int n, a[MAX_N+5]; char s[MAX_N+5];int sa[MAX_N+5], rk[MAX_N+5], height[MAX_N+5], tsa[MAX_N+5], cntA[MAX_N+5], cntB[MAX_N+5], A[MAX_N+5], B[MAX_N+5];lnt ans[MAX_N+5][2]; vector &lt;int&gt; m[MAX_N+5]; int fa[MAX_N+5], mina[MAX_N+5], maxa[MAX_N+5], size[MAX_N+5];int getf(int x) &#123;return x == fa[x] ? x : fa[x] = getf(fa[x]);&#125;void CalcSA() &#123; for (int i = 1; i &lt;= 26; i++) cntA[i] = 0; for (int i = 1; i &lt;= n; i++) cntA[s[i]-'a'+1]++; for (int i = 1; i &lt;= 26; i++) cntA[i] += cntA[i-1]; for (int i = n; i &gt;= 1; i--) sa[cntA[s[i]-'a'+1]--] = i; rk[sa[1]] = 1; for (int i = 2; i &lt;= n; i++) &#123;rk[sa[i]] = rk[sa[i-1]]; if (s[sa[i]] != s[sa[i-1]]) rk[sa[i]]++;&#125; for (int l = 1; l &lt; n; l &lt;&lt;= 1) &#123; for (int i = 1; i &lt;= n; i++) cntA[i] = 0; for (int i = 1; i &lt;= n; i++) cntB[i] = 0; for (int i = 1; i &lt;= n; i++) cntA[A[i] = rk[i]]++, cntB[B[i] = (i+l &lt;= n) ? rk[i+l] : 0]++; for (int i = 1; i &lt;= n; i++) cntB[i] += cntB[i-1]; for (int i = n; i &gt;= 1; i--) tsa[cntB[B[i]]--] = i; for (int i = 1; i &lt;= n; i++) cntA[i] += cntA[i-1]; for (int i = n; i &gt;= 1; i--) sa[cntA[A[tsa[i]]]--] = tsa[i]; rk[sa[1]] = 1; for (int i = 2; i &lt;= n; i++) &#123; rk[sa[i]] = rk[sa[i-1]]; if (A[sa[i]] != A[sa[i-1]] || B[sa[i]] != B[sa[i-1]]) rk[sa[i]]++; &#125; &#125; for (int i = 1, j = 0; i &lt;= n; i++) &#123; if (j) j--; while (s[i+j] == s[sa[rk[i]-1]+j]) j++; height[rk[i]] = j; &#125;&#125;int main() &#123; scanf("%d", &amp;n), scanf("%s", s+1); lnt tot = 0, pro = 0; for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); CalcSA(); for (int i = 2; i &lt;= n; i++) m[height[i]].push_back(i); for (int i = 1; i &lt;= n; i++) fa[i] = i, size[i] = 1, mina[i] = maxa[i] = a[sa[i]]; for (int i = n-1; ~i; i--) &#123; for (int j = 0; j &lt; (int)m[i].size(); j++) &#123; int u = getf(m[i][j]), v = getf(m[i][j]-1); if (u == v) continue; if (!tot) pro = max(1LL*mina[u]*mina[v], 1LL*maxa[u]*maxa[v]); else pro = max(pro, max(1LL*mina[u]*mina[v], 1LL*maxa[u]*maxa[v])); tot += 1LL*size[u]*size[v], fa[v] = u, size[u] += size[v]; mina[u] = min(mina[u], mina[v]), maxa[u] = max(maxa[u], maxa[v]); &#125; ans[i][0] = tot, ans[i][1] = pro; &#125; for (int i = 0; i &lt; n; i++) printf("%lld %lld\n", ans[i][0], ans[i][1]); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>NOI</tag>
        <tag>字符串</tag>
        <tag>后缀数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3282 Tree]]></title>
    <url>%2FBZOJ3282%20Tree%20LCT%2F</url>
    <content type="text"><![CDATA[ProblemTreeTime Limit: $30 Sec$Memory Limit: $512 MB$ Description给定$N$个点以及每个点的权值，要你处理接下来的$M$个操作。操作有$4$种。操作从$0$到$3$编号。点从$1$到$N$编号。$0$.后接两个整数 $(x, y)$，代表询问从$x$到$y$的路径上的点的权值的$xor$和。保证$x$到$y$是联通的。$1$.后接两个整数 $(x, y)$，代表连接$x$到$y$，若x到y已经联通则无需连接。$2$.后接两个整数 $(x, y)$，代表删除边$ (x, y)$，不保证边 $(x, y)$ 存在。$3$.后接两个整数 $(x, y)$，代表将点$x$上的权值变成$y$。 Input第$1$行两个整数，分别为$N$和$M$，代表点数和操作数。第$2$行到第$N+1$行，每行一个整数，整数在 $[1, 10^9]$ 内，代表每个点的权值。第$N+2$行到第$N+M+1$行，每行三个整数，分别代表操作类型和操作所需的量。 Output对于每一个$0$号操作，你须输出$x$到$y$的路径上点权的$xor$和。 Sample Input12345673 3 1231 1 20 1 2 0 1 1 Sample Output1231 Hint$1\le N,M\le 3\times 10^5$ 标签：LCT SolutionLCT板子题人生中的第一道LCT用了没带保护指针的splay，有几个细节挺坑 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define MAX_N 300000#define INF 0x7f7f7f7f#define flag (!tar(cur-&gt;fa-&gt;fa)&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;struct SplayNode &#123; SplayNode *s[2], *fa; int val, sum; bool rev; void updata() &#123;sum = val^(s[0]?s[0]-&gt;sum:0)^(s[1]?s[1]-&gt;sum:0);&#125; void downtag() &#123; if (fa &amp;&amp; (fa-&gt;s[0] == this || fa-&gt;s[1] == this)) fa-&gt;downtag(); if (rev &amp;&amp; s[0]) swap(s[0]-&gt;s[0], s[0]-&gt;s[1]), s[0]-&gt;rev ^= 1; if (rev &amp;&amp; s[1]) swap(s[1]-&gt;s[0], s[1]-&gt;s[1]), s[1]-&gt;rev ^= 1; rev = false; &#125;&#125; *tr[MAX_N+5];struct LinkCutTree &#123; SplayNode* newnode(int _val) &#123; SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = v-&gt;sum = _val, v-&gt;rev = 0; return v; &#125; SplayNode* get_rt(SplayNode* v) &#123;for (; v-&gt;fa; v = v-&gt;fa) ; return v;&#125; bool tar(SplayNode* v) &#123;return (v&amp;&amp;v-&gt;fa==NULL)||(v&amp;&amp;v-&gt;fa-&gt;s[0]!=v&amp;&amp;v-&gt;fa-&gt;s[1]!=v);&#125; LinkCutTree(int n) &#123;for (int i=1,_val;i&lt;=n;i++) scanf("%d", &amp;_val), tr[i]=newnode(_val);&#125; void rotate(SplayNode* v, bool sn) &#123; SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa &amp;&amp; !tar(f)) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); &#125; void splay(SplayNode* cur) &#123; cur-&gt;downtag(); while (!tar(cur) &amp;&amp; !tar(cur-&gt;fa)) &#123; bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); &#125; if (!tar(cur) &amp;&amp; tar(cur-&gt;fa)) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); cur-&gt;updata(); &#125; void access(SplayNode* cur) &#123; for (SplayNode* cpy = NULL; cur; cpy = cur, cur = cur-&gt;fa) splay(cur), cur-&gt;s[1] = cpy, cur-&gt;updata(); &#125; void mroot(SplayNode* v) &#123; access(v), splay(v); swap(v-&gt;s[0], v-&gt;s[1]), v-&gt;rev ^= 1; &#125; void link(SplayNode* u, SplayNode* v) &#123; if (get_rt(u) == get_rt(v)) return; mroot(u), u-&gt;fa = v; &#125; void cut(SplayNode* u, SplayNode* v) &#123; if (u == v || get_rt(u) != get_rt(v)) return; mroot(u), access(v), splay(v); if (v-&gt;s[0] == u) u-&gt;fa = v-&gt;s[0] = NULL, v-&gt;updata(); &#125; void modify(SplayNode* v, int _val) &#123; splay(v), v-&gt;val = _val, v-&gt;updata(); &#125; int query(SplayNode* u, SplayNode* v) &#123; mroot(u), access(v), splay(v); return v-&gt;sum; &#125;&#125;;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); LinkCutTree LCT(n); while (m--) &#123; int opt, x, y; scanf("%d%d%d", &amp;opt, &amp;x, &amp;y); if (opt == 0) printf("%d\n", LCT.query(tr[x], tr[y])); if (opt == 1) LCT.link(tr[x], tr[y]); if (opt == 2) LCT.cut(tr[x], tr[y]); if (opt == 3) LCT.modify(tr[x], y); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201701219-30总结]]></title>
    <url>%2F20171219-30%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[高新2017联训划水记Day1T1看到数论题就想放水…惊讶地发现貌似可以DP。不过状态定义出来推不出转移，就交了暴力…题解是个矩乘，我的状态没构造对。不过Joker貌似因为前置0出锅了。T2怎么又是数论…不过化一化发现貌似底数和指数可以合到一起，就是BSGS的板子了。这时候发现了一个大问题…BSGS怎么写啊！BSGS怎么写啊！！BSGS怎么写啊！！！作为一个mr板都没写过的老年选手，我仍不会写BSGS。写了个随机化骗分，不过和暴力分一样。T3好熟悉啊，FLOJ上出现三次的题呢，貌似叫什么重组病毒病毒重组之类的玩意。应该是个LCT吧。不过自己Splay板子都不熟，LCT就别说了，弃坑搞暴力。水了三道低保，20+20+20=60pts。 Day2T1没看到数据随机…打了一个n方的暴力，一直在想怎么搞到nlogn…结果是按长度排序后枚举且及时break…唯一的水题就这样甩了…T2先想了想字典树，但是是没法搞的。又去推了推线性基，结果没推出了。打暴力弃坑。标解高消按两个关键字贪心。T3由于T1的错误方向想太久已经没时间了，所幸交了暴力，水了30。标解线段树维护区间左右端黑白段长，需要线段树合并。50+40+30=120pts Day3T1数论，还好是水题。可知gcd一定是(a-b)的约数，(a-b)是固定的。因此枚举gcd即可。我和flx特判0写挂了，数据挺强，卡成70。T2正解就别说了，连暴力都不好写。索性弃坑做T3。标解行列式，有点像矩阵树。T3乱搞了一个KMP和一个Manacher，写完发现公用变量名了…调出*。按水50分写，最后因为常数得了40。70+0+40=110pts Day4T1nlogn二合一。后面nlogn的lcm会做，水20部分分，30的暴力打错了…标解前半段是平衡树维护做到nlogn，不过我下来看std发现可以值域线段树水过，反正是删排名为k的数。这样比平衡树快而且好写。T2小学奥数。我没有推公式，直接打了一个30x30的表就把规律看出来了。水过。T3看起来像是北京讲的群论。不过貌似不太会推。索性打暴力水20。20+100+20=140pts Day5YJQ的题目顺序huaji题。滚粗勒。T1没推出公式…暴力滚粗T2没思路…暴力滚粗T3不会维护…暴力滚粗T1正解数论错位相减推通项然后逆元搞搞T2变成A走一步B走两步后最短路乱搞T3维护max-min+L-R=0的区间。用单调栈+线段树搞搞即可20+0+30=50pts Day6唯一一次考好。T1主席树套路题。有点卡常，不过把传参移到外面以后就瞬间快了6倍。T2合并石子。不会做nlogn，但是会四边形优化的n^2和升序的贪心。水80pts。正解一个叫g什么的鬼畜算法，证明不详，平衡树维护一种贪心操作。T3网络流，发现直接最小割是有锅的，写了分层暴力+错解最小割。正解把每条边建INF反边后跑最小割。100+80+25=205pts Day8T1推半天没推出来。用基本公式打暴力水60。正解通项是f(x)=φ(x)/2+μ(x)/2。杜教筛可过。T2点分。不会合并信息，没做/QAQ。T3网络流二合一。第二个写了，没写出第一个。贪心打第一个结果出锅了。60+0+35=95pts Day9T1没想到记忆化（我傻逼）打10pts暴力。正解记忆化，复杂度可证是玄学的O(nlogn√Q)。T2是ZCY讲过的原题，树上背包，维护两个DP。我把两个DP打到一起了，互相更新答案，出锅QAQ。T3丧心病狂WF网络流，不会建图没写。10+40=50pts Day10T1貌似可以CDQ但是没推出来。用单调栈写n^2部分分，结果定义了全局变量和局部变量n，以至于传进函数的n是0，然后就没输出…正解CDQ分治。T2应该是DP，但是没推出来，按题目模拟水低保。正解n^3DP，wxh有O(n)的做法，学了学发现很精妙，不过很难想，细节也比较多。T3想到是DP，但是细节太多，而且补集转换的全集不会求。标解DP，细节很多，转移方程一大堆。0+40+30=70pts Day11T1看出来是基环树森林里贪心，不过没调出来，交了n^2暴力，水60pts。正解和我想的一样。T2水题没做起QAQ。暴力打错了，滚粗。T3通讯题会前两个subtask，不会只染两种颜色。正解很精妙，用若干个四位二进制数表示倍增跑多少格，保证能识别三位就认出整个数，target当行位杂色行，上下方位交替杂色行和纯色行。60+0+30=90pts Conclusion本次集训收获还是蛮大的。见识了一些比较新奇的玩意儿。不过考试也暴露出一些水题我想不出的情况，而且有时暴力还打错。另外，我貌似做套路题很上手，但是做一些灵活的题则很被动。需要多训练思维。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2187 Beauty Contest]]></title>
    <url>%2FPOJ2187%20Beauty%20Contest%20%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3%2F</url>
    <content type="text"><![CDATA[Problem Beauty Contest Description贝茜在牛的选美比赛中赢得了冠军”牛世界小姐”。因此,贝西会参观$N$($2\le N\le 50000$)个农场来传播善意。世界将被表示成一个二维平面,每个农场位于一对整数坐标$(x,y)$($-10000\le x,y \le 10000$)。没有两个农场共享相同的一对坐标。尽管贝西沿直线前往下一个农场，但牧场之间的距离可能很大,所以她需要一个手提箱保证在每一段旅程中她有足够吃的食物。她想确定她可能需要旅行的最大可能距离,她要知道她必须带的手提箱的大小。帮助贝西计算农场的最大距离。 Input第$1$行一个整数$n$，第$2\sim n+1$行两个整数$x_i y_i$表示$n$个农场中第$i$个的坐标 Output一行，最远距离的平方 Sample Input1234540 00 11 11 0 Sample Output12 标签：旋转卡壳 Solution平面最远点对。旋转卡壳模板。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 50000using namespace std;template &lt;class T&gt;inline void read(T &amp;x) &#123; x = 0; int c = getchar(), f = 1; for (; !isdigit(c); c = getchar()) if (c == 45) f = -1; for (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');&#125;int n, m;struct pnt &#123; int x, y; int operator * (const pnt &amp;t) const &#123;return x*t.y-y*t.x;&#125; pnt operator - (const pnt &amp;t) const &#123;return (pnt)&#123;x-t.x, y-t.y&#125;;&#125; bool operator &lt; (const pnt &amp;t) const &#123;return x == t.x ? y &lt; t.y : x &lt; t.x;&#125;&#125; p[MAX_N+5], c[MAX_N+5];int sqr(int x) &#123;return x*x;&#125;int dis(pnt a, pnt b) &#123;return sqr(a.x-b.x)+sqr(a.y-b.y);&#125;void ConvexHull() &#123; sort(p+1, p+n+1), c[++m] = p[1], c[++m] = p[2]; for (int i = 3; i &lt;= n; c[++m] = p[i++]) while (m &gt; 1 &amp;&amp; (p[i]-c[m-1])*(c[m]-c[m-1]) &gt;= 0) m--; int t = m; c[++m] = p[n-1]; for (int i = n-2; i; c[++m] = p[i--]) while (m &gt; t &amp;&amp; (p[i]-c[m-1])*(c[m]-c[m-1]) &gt;= 0) m--; m--;&#125;int RotatingCalipers() &#123; if (m == 2) return dis(c[1], c[2]); int a = 1, b = 1; for (int i = 1; i &lt;= m; i++) if (c[i] &lt; c[a]) a = i; for (int i = 1; i &lt;= m; i++) if (c[b] &lt; c[i]) b = i; int ret = dis(c[a], c[b]); for (int sa = a, sb = b; a^sb || b^sa; ret = max(ret, dis(c[a], c[b]))) (c[a%m+1]-c[a])*(c[b%m+1]-c[b]) &lt;= 0 ? a = a%m+1 : b = b%m+1; return ret;&#125;int main() &#123; read(n); for (int i = 1; i &lt;= n; i++) read(p[i].x), read(p[i].y); return ConvexHull(), printf("%d", RotatingCalipers()), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>旋转卡壳</tag>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1930【SHOI2003】Pacman 吃豆豆]]></title>
    <url>%2FBZOJ1930%E3%80%90SHOI2003%E3%80%91Pacman%20%E5%90%83%E8%B1%86%E8%B1%86%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SHOI2003】Pacman 吃豆豆Time Limit: $10 Sec$Memory Limit: $64 MB$ Description两个$PACMAN$吃豆豆。一开始的时候，$PACMAN$都在坐标原点的左下方，豆豆都在右上方。$PACMAN$走到豆豆处就会吃掉它。$PACMAN$行走的路线很奇怪，只能向右走或者向上走，他们行走的路线不可以相交。 请你帮这两个$PACMAN$计算一下，他们俩加起来最多能吃掉多少豆豆。 Input第一行为一个整数$N$，表示豆豆的数目。 接下来 $N$ 行，每行一对正整数，表示第$i$个豆豆的坐标。任意两个豆豆的坐标都不会重合。 Output仅有一行包含一个整数，即两个$PACMAN$加起来最多能吃掉的豆豆数量 Sample Input12345678988 11 55 72 27 84 63 36 4 Sample Output17 HINT$N \le 2000$样例解释 标签：费用流 Solution貌似是可以用$DP$肝的。费用流建模细节挺多。首先可以发现不相交时废话。若穿过则互换名字即可。由于点数很多，所以不能两两连边，发现只需要把按$x$和$y$排序后相邻两点连边即可。首先需要限制每个点的流量，需要将每个点拆成两个点，连边限流。这里由于两条线可以经过同一个点，但贡献只算一个，则需要连两条边，流量均为$1$，而费用则是一条为$1$另一条为$0$。注意源点也需要限制$2$的流量，即需要把源点拆成两个点，中间连流量$2$费用$0$的边。相邻两点间连流量为$2$费用为$0$的边。总结建图：源点拆成两个点$S$和$SS$$S\to SS$ 流量$2$ 费用$0$把每个点拆成$i$和$i’$$SS\to i$ 流量$2$ 费用$0$$i’\to T$ 流量$2$ 费用$0$$i\to i’$ 流量$1$ 费用$1$$i\to i’$ 流量$1$ 费用$0$可连边的相邻两点$i$和$j$间有$i’\to j$ 流量$2$ 费用$0$最后跑大费流即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define MAX_N 5000#define MAX_M 500000#define INF 0x7f7f7f7fusing namespace std;struct P &#123;int x, y;&#125; p[MAX_N+5];int n, s, ss, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mxc;struct node &#123;int v, c, w, nxt;&#125; E[MAX_M+5];void init() &#123;s = 0, ss = n*2+1, t = n*2+2, memset(pr, -1, sizeof pr);&#125;bool cmp (const P &amp;a, const P &amp;b) &#123;return a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;void insert(int u, int v, int c, int w) &#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c, int w) &#123;insert(u, v, c, w), insert(v, u, 0, -w);&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(cr, -1, sizeof cr); memset(d, -1, sizeof d); d[s] = 0, que.push(s), inq[s] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &gt; d[v]) &#123; d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; &#125; &#125; &#125; if (d[t] &lt;= 0) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mxc += d[t]; return true;&#125;int main() &#123; scanf("%d", &amp;n); init(), addedge(s, ss, 2, 0); for (int i = 1; i &lt;= n; i++) addedge(ss, i, 2, 0), addedge(i+n, t, 2, 0); for (int i = 1; i &lt;= n; i++) addedge(i, i+n, 1, 1), addedge(i, i+n, 1, 0); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;p[i].x, &amp;p[i].y); sort(p+1, p+n+1, cmp); for (int i = 1, mi = INF; i &lt;= n; i++, mi = INF) for (int j = i+1; j &lt;= n; j++) if (p[i].y &lt;= p[j].y &amp;&amp; p[j].y &lt;= mi) addedge(i+n, j, 2, 0), mi = p[j].y; while (SPFA()) ; return printf("%d", mxc), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3442 学习小组]]></title>
    <url>%2FBZOJ3442%20%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%84%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem学习小组Time Limit: $5 Sec$Memory Limit: $128 MB$ Description坑校准备鼓励学生参加学习小组。共有$n$个学生，$m$个学习小组，每个学生有一定的喜好，只愿意参加其中的一些学习小组，但是校领导为学生考虑，规定一个学生最多参加$k$个学习小组。财务处的大叔就没那么好了，他想尽量多收钱，因为每个学生参加学习小组都要交一定的手续费，不同的学习小组有不同的手续费。然而，事与愿违，校领导又决定对学习小组组织者进行奖励，若有$a$个学生参加第i个学习小组，那么给这个学习小组组织者奖励$C_i\times a^2$元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱（若为负数，则输出负数）（$支出=总奖励费-总手续费$）。 Input输入有若干行，第一行有三个用空格隔开的正整数$n、m、k$。接下来的一行有$m$个正整数，表示每个$C_i$。第三行有$m$个正整数，表示参加每个学习小组需要交的手续费$F_i$。再接下来有一个$n$行$m$列的矩阵，表若第$i$行$j$列的数字是$1$，则表示第$i$个学生愿意参加第$j$个学习小组，若为$0$，则为不愿意。 Output输出只有一个整数，为最小的支出。 Sample Input1234563 3 11 2 33 2 1111111111 Sample Output1-2 Hint样例解释参与学生最多为$3$，每个学生参加一个学习小组，若有两个学生参加第一个学习小组，一个学生参加第二个学习小组（一定要有人参加第二个学习小组），支出为$-2$，可以证明没有更优的方案了。数据范围与约定$100\%$的数据，$0＜n\le 100，0＜m\le 90，0＜k\le m，0＜Ci\le 10，0＜Fi\le 100$。 标签：费用流 Solution常规费用流建模。建图：每个学生为一个点，每个小组为一个点，共$n+m$个点。对每个学生$p_i$，$S\to p_i$ 流量$k$ 费用$0$ （限制最多选$k$个组）$p_i\to T$ 流量$k-1$ 费用$0$ （限制至少选一个组）对每个组$g_i$，$g_i\to T$ 流量$1$ 费用$C_i\times (2j-1)$ 其中$j\in [1, n]$即当前若有$x$个人，再多一个人会带来$C_i\times (x+1)^2-C_i\times x^2=C_i\times (2x+1)=C_i\times [2(x+1)-1]$的收益学生和组之间则连边 $p_i\to g_j$ 流量$1$ 费用$-F_i$跑小费流即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 50000#define INF 0x7f7f7f7fusing namespace std;int n, m, k, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node &#123;int v, c, w, nxt;&#125; E[MAX_M+5]; int f[MAX_N+5];void init() &#123;s = 0, t = n+m+1, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c, int w) &#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c, int w) &#123;insert(u, v, c, w), insert(v, u, 0, -w);&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) &#123; int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) &#123; d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; &#125; &#125; &#125; if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]; return true;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k), init(); for (int i = 1; i &lt;= n; i++) addedge(s, i, k, 0); for (int i = 1; i &lt;= n; i++) addedge(i, t, k-1, 0); for (int i = 1; i &lt;= m; i++) &#123; int c; scanf("%d", &amp;c); for (int j = 1; j &lt;= n; j++) addedge(i+n, t, 1, c*(2*j-1)); &#125; for (int i = 1; i &lt;= m; i++) scanf("%d", f+i); for (int i = 1; i &lt;= n; i++) &#123; char s[MAX_N]; scanf("%s", s+1); for (int j = 1; j &lt;= m; j++) if (s[j] == '1') addedge(i, j+n, 1, -f[j]); &#125; while (SPFA()) ; return printf("%d", mic), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1283 序列]]></title>
    <url>%2FBZOJ1283%20%E5%BA%8F%E5%88%97%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 序列Time Limit: $10 Sec$ Memory Limit: $162 MB$ Description给出一个长度为$N$的正整数序列$C_i$，求一个子序列，使得原序列中任意长度为$M$的子串中被选出的元素不超过$K(K,M\le 100)$ 个，并且选出的元素之和最大。 Input第$1$行三个数$N,M,K$。 接下来$1$行$N$个正整数表示$C_i$。 Output最大和。 Sample Input1210 5 34 4 4 6 6 6 6 6 4 4 Sample Output130 HINT$20\%$的数据: $N\le 10$。$100\%$的数据：$N\le 1000，K,M\le 100。C_i\le 20000$。 Source$By YM$ 标签：费用流 Solution常规费用流建模。转化题意为：选$K$次，每次选一个子序列，每一次连续$M$个里面只能选一个。对于第$i$个数$C_i$， 如果不选：$i\to i+1$ 流量$K$ 费用$0$ 如果选，则下一个数在$i+M$之后： 1)若$i\in [1, n-m]$：$i\to i+M$ 流量$1$ 费用$C_i$ 2) 若$i\in (n-m, n]$：$i\to T$ 流量$1$ 费用$C_i$ 特别地，有$S\to 1$ 流量$K$ 费用$0$；$N\to T$ 流量$K$ 费用$0$。跑大费流即可。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define MAX_N 2000#define MAX_M 100000#define INF 0x7f7f7f7fusing namespace std;int n, m, k, a[MAX_N+5];int s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node &#123;int v, c, w, nxt;&#125; E[MAX_M+5];void init() &#123;s = 0, t = n+1, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c, int w) &#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c, int w) &#123;insert(u, v, c, w), insert(v, u, 0, -w);&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) &#123; int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) &#123; d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; &#125; &#125; &#125; if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]; return true;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k), init(); addedge(s, 1, k, 0), addedge(n, t, k, 0); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int i = 1; i &lt; n; i++) addedge(i, i+1, k, 0); for (int i = 1; i &lt;= n-m; i++) addedge(i, i+m, 1, -a[i]); for (int i = n-m+1; i &lt;= n; i++) addedge(i, t, 1, -a[i]); while (SPFA()) ; return printf("%d", -mic), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1221【HNOI2001】软件开发]]></title>
    <url>%2FBZOJ1221%E3%80%90HNOI2001%E3%80%91%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%20%E6%8B%86%E7%82%B9%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2001】软件开发Time Limit: $10 Sec$Memory Limit: $162 MB$ Description某软件公司正在规划一项$n$天的软件开发计划，根据开发计划第$i$天需要$n_i$个软件开发人员，为了提高软件开发人员的效率，公司给软件人员提供了很多的服务，其中一项服务就是要为每个开发人员每天提供一块消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。消毒方式有两种，$A$种方式的消毒需要$a$天时间，$B$种方式的消毒需要$b$天（$b&gt;a$），$A$种消毒方式的费用为每块毛巾$f_A$, $B$种消毒方式的费用为每块毛巾$f_B$，而买一块新毛巾的费用为$f$（新毛巾是已消毒的，当天可以使用）；而且$f&gt;f_A&gt;f_B$。公司经理正在规划在这$n$天中，每天买多少块新毛巾、每天送多少块毛巾进行$A$种消毒和每天送多少块毛巾进行$B$种消毒。当然，公司经理希望费用最低。你的任务就是：为该软件公司计划每天买多少块毛巾、每天多少块毛巾进行$A$种消毒和多少毛巾进行$B$种消毒，使公司在这项$n$天的软件开发中，提供毛巾服务的总费用最低。 Input第$1$行为$n,a,b,f,f_A,f_B$. 第$2$行为$n_1,n_2,\cdots,n_n$. （注：$1\le f,f_A,f_B\le 60,1\le n\le 1000$） Output最少费用 Sample Input124 1 2 3 2 18 2 1 6 Sample Output138 标签：拆点费用流 Solution拆点费用流套路题把每天拆成两个点$\frac{X_i}{Y_i}$，表示用过的毛巾和新洗好的毛巾。建图：$S\to X_i$ 容量$n_i$ 费用$0$$Y_i\to T$ 容量$n_i$ 费用$0$$S\to Y_i$ 容量$\infty$ 费用$f$$X_i\to X_i+1$ 容量$\infty$ 费用$0$$X_i\to Y_i+a+1$ 容量$\infty$ 费用$f_A$$X_i\to Y_i+b+1$ 容量$\infty$ 费用$f_B$跑小费流即可 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 2000#define MAX_M 100000#define INF 0x7f7f7f7fusing namespace std;int n, a, b, f, fa, fb, w[MAX_N+5];int s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node &#123;int v, c, w, nxt;&#125; E[MAX_M+5];void init() &#123;s = 0, t = n*2+1, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c, int w) &#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c, int w) &#123;insert(u, v, c, w), insert(v, u, 0, -w);&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) &#123; int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) &#123; d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; &#125; &#125; &#125; if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]*flow; return true;&#125;int main() &#123; scanf("%d%d%d%d%d%d", &amp;n, &amp;a, &amp;b, &amp;f, &amp;fa, &amp;fb), init(); for (int i = 1; i &lt;= n; i++) scanf("%d", w+i); for (int i = 1; i &lt;= n; i++) addedge(s, i, w[i], 0); for (int i = 1; i &lt; n; i++) addedge(i, i+1, INF, 0); for (int i = 1; i &lt;= n; i++) addedge(s, i+n, INF, f); for (int i = 1; i &lt;= n; i++) addedge(i+n, t, w[i], 0); for (int i = 1; i &lt; n-a; i++) addedge(i, i+a+n+1, INF, fa); for (int i = 1; i &lt; n-b; i++) addedge(i, i+b+n+1, INF, fb); while (SPFA()) ; return printf("%d", mic), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3691 游行]]></title>
    <url>%2FBZOJ3691%20%E6%B8%B8%E8%A1%8C%20%E4%BA%8C%E5%88%86%2B%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 游行 ime Limit: $10 Sec$ Memory Limit: $512 MB$ Description每年春季，在某岛屿上都会举行游行活动。在这个岛屿上有$N$个城市，$M$条连接着城市的有向道路。你要安排英雄们的巡游。英雄从城市$s_i$出发，经过若干个城市，到城市$t_i$结束，需要特别注意的是，每个英雄的巡游的$s_i$可以和$t_i$相同，但是必须至少途径2个城市。每次游行你的花费将由3部分构成： 每个英雄游行经过的距离之和，需要特别注意的是，假如一条边被途径了$k$次，那么它对答案的贡献是$k\times c_i$，$c_i$表示这条边的边权。 如果一个英雄的巡游的$s_i$不等于$t_i$，那么会额外增加$C$的费用。因为英雄要打的回到起点。 如果一个城市没有任何一个英雄途经，那么这个城市会很不高兴，需要$C$费用的补偿。 你有无数个的英雄。你要合理安排游行方案，使得费用最小。由于每年，$C$值都是不一样的。所以你要回答$Q$个询问，每个询问都是，当$C$为当前输入数值的时候的答案。 Input第一行正整数$N，M，Q$ 。接下来的$M$行，每行$a_i,b_i,c_i$，表示有一条从$a_i$到$b_i$，边权为$c_i$的有向道路。保证不会有自环，但不保证没有重边。接下来$Q$行，每行一个$C$，表示询问当每次费用为$C$时的最小答案。 Output$Q$行，每行代表一个询问的答案。 Sample Input1234567896 5 31 3 22 3 23 4 24 5 24 6 21510 Sample Output12362132 HINT【样例说明】第一年的时候，$C$只有$1$。我们比较懒所以就不安排英雄出游了，需要支付$6$的费用。第二年的时候，我们可以这么安排：一个英雄$1\to 3\to 4\to 5$，需要付$2+2+2=6$的费用，同时还要花5费用打的回家。再花$5+5$的费用来补偿$2$号城市和$6$号城市。第三年略。【数据范围】对于$100\%$的数据，$2\le N\le 250$, $1\le M\le 30000$, $1\le Q\le 10000$, $1\le c_i\le 10000$, $1\le C\le 10000$。 标签：二分+费用流 Solution比较难想但很奇妙的费用流建模。题目可以转化为：选择若干条带权路径，选择指覆盖终点，所有没被覆盖的点都要付出$C$的代价，每次给定$C$求最小代价。首先用$Floyed$算出多源最短路把每个点拆成入点和出点，建图：$S\to a$ 容量$1$ 费用$0$$a\to b’$ 容量$1$ 费用$dis_{a,b}$$a’\to T$ 容量$1$ 费用$0$每次增广均会有前面未覆盖的点被覆盖，即用增广一次的代价来代替$C$。若增广前代价为$W$，则增广后为$W-C+cost$。记录每次增广增加的费用，可知这个费用是单增的，推得当 $cost &lt; C$ 时，可增广使答案变小，而当 $cost &gt; C$ 时，继续增广会使答案变大。因此对每个询问二分出 $cost &lt; C$ 的分界点计算答案即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 100000#define mid ((l+r)&gt;&gt;1)#define INF 0x3f3f3f3fusing namespace std;int n, m, q, x, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], f[MAX_N+5], g[MAX_N+5];struct node &#123;int v, c, w, nxt;&#125; E[MAX_M+5]; int G[MAX_N+5][MAX_N+5], tot, cost;void init() &#123;s = 0, t = n*2+1, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c, int w) &#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c, int w) &#123;insert(u, v, c, w), insert(v, u, 0, -w);&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d); d[s] = 0, que.push(s), inq[s] = true, memset(cr, -1, sizeof cr); while (!que.empty()) &#123; int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) &#123; d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; &#125; &#125; &#125; if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; cost = d[t]; return true;&#125;int bi_search(int l, int r) &#123;while (l &lt;= r) f[mid] &lt; x ? l = mid+1 : r = mid-1; return g[l-1]+(n-l+1)*x;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q), init(); memset(G, INF, sizeof G); for (int i = 1; i &lt;= n; i++) addedge(s, i, 1, 0), addedge(i+n, t, 1, 0), G[i][i] = 0; for (int i = 0, u, v, c; i &lt; m; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), G[u][v] = min(G[u][v], c); for (int k = 1; k &lt;= n; k++) for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) G[i][j] = min(G[i][j], G[i][k]+G[k][j]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (G[i][j]^INF &amp;&amp; (i^j)) addedge(i, j+n, 1, G[i][j]); while (SPFA()) f[++tot] = cost, g[tot] = f[tot]+g[tot-1]; while (q--) scanf("%d", &amp;x), printf("%d\n", bi_search(0, tot)); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1190【HNOI2007】梦幻岛宝珠]]></title>
    <url>%2FBZOJ1190%E3%80%90HNOI2007%E3%80%91%E6%A2%A6%E5%B9%BB%E5%B2%9B%E5%AE%9D%E7%8F%A0%20%E5%88%86%E5%B1%82DP%2F</url>
    <content type="text"><![CDATA[Problem【HNOI2007】梦幻岛宝珠Time Limit: $10 Sec$Memory Limit: $162 MB$ Description给你N颗宝石，每颗宝石都有重量和价值。要你从这些宝石中选取一些宝石，保证总重量不超过W，且总价值最大，输出最大的总价值。数据范围：$N\le 100，W\le 2^{30}$，且保证每颗宝石的重量可以表示为$a\times 2^b$的形式（其中$a\le 10,b\le 30$） Input输入文件中包含多组数据。每组数据的格式如下：第一行是两个正整数$n$和$W$，$1\le n\le 100,1\le W\le 2^{30}$，分别表示宝石的数目和最多能带走的宝石重量。接下来的$n$行，每行有两个正整数$weight_i$和$value_i$，$1\le weight_i\le 2^{30}, 0\le value_i\le 2^{30}$，分别表示第i颗宝石的重量和价值，且保证$weight_i$能写成$a\times 2^b(1\le a\le 10,0\le b\le 30)$的形式。同一行的两个正整数之间用空格隔开。最后一组数据的后面有两个$-1$，表示文件的结束。这两个$-1$并不代表一组数据，你不需对这组数据输出结果。并且输入文件中数据的组数不超过$20$。 Output对于输入的每组数据，输出一个整数$C$，表示小P最多能带走的宝石的总价值。每个结果整数$C$单独占一行，且保证$C$不会超过$2^{30}$。 Sample Input123456789101112131415161718192021222324252627284 108 95 84 62 54 138 95 84 62 516 75594681393216 55332 7732768 46729360128 407840112 6824576 372768 6033554432 46609916384 31833554432 4660902048 11124576 3509216 21612582912 17476816384 2951024 76-1 -1 Sample Output12314191050650 标签：分层DP Solution$W$很大，不能直接搞。而保证 $weight=a\times 2^b, a\le 10$因而可以按$b$分层后背包。分层后先层内DP出$f[i][j]$表示$2^i$层级内容量为$2^i\times j$的最大价值。然后层间DP求最大值：$f[i][j] = max(f[i][j], f[i][k]+f[i-1][(j-k)\times2+(w&gt;&gt;i-1)\&amp;1])$详见代码。 Code1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define LOG 30#define MAX_N 100using namespace std;int n, m, l, w[MAX_N+5][LOG+5], c[MAX_N+5][LOG], f[LOG+5][MAX_N+5], cnt[LOG+5], s[LOG+5];int main() &#123; while (scanf("%d%d", &amp;n, &amp;m) &amp;&amp; ~n &amp;&amp; ~m) &#123; memset(cnt, 0, sizeof cnt), memset(s, 0, sizeof s), memset(f, 0, sizeof f), l = 0; while (n--) &#123; int x; scanf("%d", &amp;x); int t = 0; while (!(x&amp;1)) t++, x &gt;&gt;= 1; w[t][++cnt[t]] = x, s[t] += x; l = max(l, t), scanf("%d", &amp;c[t][cnt[t]]); &#125; for (int i = 0; i &lt;= l; i++) for (int j = 1; j &lt;= cnt[i]; j++) for (int k = s[i]; k &gt;= w[i][j]; k--) f[i][k] = max(f[i][k], f[i][k-w[i][j]]+c[i][j]); while (m &gt;&gt; l) l++; l--; for (int i = 1; i &lt;= l; i++) &#123; s[i] += (s[i-1]+1)&gt;&gt;1; for (int j = s[i]; ~j; j--) for (int k = 0; k &lt;= j; k++) f[i][j] = max(f[i][j], f[i][j-k]+f[i-1][min(s[i-1], (k&lt;&lt;1)|((m&gt;&gt;(i-1))&amp;1))]); &#125; printf("%d\n", f[l][1]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>分层DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4514【SDOI2016】数字配对]]></title>
    <url>%2FBZOJ4514%E3%80%90SDOI2016%E3%80%91%E6%95%B0%E5%AD%97%E9%85%8D%E5%AF%B9%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 【SDOI2016】数字配对Time Limit: $10 Sec$ Memory Limit: $128 MB$ Description有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。若两个数字 $a_i, a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $\frac{a_i}{a_j}$ 是一个质数，那么这两个数字可以配对，并获得 $c_i\times c_j$ 的价值。一个数字只能参与一次配对，可以不参与配对。在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。 Input第一行一个整数 $n$。第二行 $n$ 个整数 $a_1,a_2,\cdots,a_n$。第三行 $n$ 个整数$b_1,b_2,\cdots,b_n$。第四行 $n$ 个整数 $c_1,c_2,\cdots,c_n$。 Output一行一个数，最多进行多少次配对 Sample Input123432 4 82 200 7-1 -2 1 Sample Output14 HINT$n\le 200，a_i\le 10^9，b_i\le 10^5，∣c_i∣\le 10^5$ 标签：费用流 Solution比较难想的二分图建模。记$f(x)$为$x$分解质因数后的项数（$4=2\times 2$算两项），$\frac{a_i}{a_j}$为质数的充要条件为$f(x)=f(y)+1且y|x$。可知$f(x)$奇偶性相同的一定不能配对，所以可建二分图，$f(x)$为奇在一边，$f(x)$为偶在另一边。两边间连边则看是否有整除条件，流量为$INF$，费用为$c_i\times c_j$。把每个点拆成左右两个点，左边与源点相连，右边与汇点相连，容量为 $b_i$，费用为零。跑费用流每增广一次就判一下是否费用小于 $0$，注意最后退出的时候不要把新加入的流全退完，退一部分至刚好大于等于$0$即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define MAX_N 300#define MAX_M 50000#define INF 1e16using namespace std;typedef long long lnt;int n, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5]; lnt mxf, cur;int a[MAX_N+5], f[MAX_N+5]; lnt b[MAX_N+5], c[MAX_N+5];struct node &#123;int v, nxt; lnt c, w;&#125; E[MAX_M+5];void init() &#123;s = 0, t = n+1, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, lnt c, lnt w) &#123;E[cnt] = (node)&#123;v, pr[u], c, w&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, lnt c, lnt w) &#123;insert(u, v, c, w), insert(v, u, 0, -w);&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inq[MAX_N+5], mrk[MAX_N+5]; lnt d[MAX_N+5]; int cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(cr, -1, sizeof cr), memset(d, 0, sizeof d); memset(mrk, false, sizeof mrk), d[s] = 0, que.push(s), inq[s] = true, mrk[s] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v; lnt c = E[i].c, w = E[i].w; if (c &amp;&amp; (!mrk[v] || d[u]+w &gt; d[v])) &#123; mrk[v] = true, d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; &#125; &#125; &#125; if (!mrk[t]) return false; lnt flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, cur += d[t]*flow; if (cur &lt; 0) &#123;mxf -= cur%d[t] == 0 ? cur/d[t] : cur/d[t]+1; return false;&#125; return true;&#125;int calc(int x) &#123; int ret = 0; for (int i = 2; i &lt;= x; i++) while (!(x%i)) x /= i, ret++; if (x^1) ret++; return ret;&#125;int main() &#123; scanf("%d", &amp;n), init(); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i), f[i] = calc(a[i]); for (int i = 1; i &lt;= n; i++) scanf("%lld", b+i); for (int i = 1; i &lt;= n; i++) scanf("%lld", c+i); for (int i = 1; i &lt;= n; i++) if (f[i]&amp;1) addedge(s, i, b[i], 0); else addedge(i, t, b[i], 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if ((f[i]&amp;1) &amp;&amp; ((f[i] == f[j]+1 &amp;&amp; a[i]%a[j] == 0) || (f[i]+1 == f[j] &amp;&amp; a[j]%a[i] == 0))) addedge(i, j, INF, c[i]*c[j]); while (SPFA()) ; return printf("%lld", mxf), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1877【SDOI2009】晨跑]]></title>
    <url>%2FBZOJ1877%E3%80%90SDOI2009%E3%80%91%E6%99%A8%E8%B7%91%20%E6%8B%86%E7%82%B9%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【SDOI2009】晨跑Time Limit: $4 Sec$Memory Limit: $64 MB$ Description$Elaxia$最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等 等，不过到目前为止，他坚持下来的只有晨跑。 现在给出一张学校附近的地图，这张地图中包含$N$个十字路口和$M$条街道，$Elaxia$只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。$Elaxia$每天从寝室出发 跑到学校，保证寝室编号为$1$，学校编号为$N$。 $Elaxia$的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路 口。$Elaxia$耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。 除了练空手道，$Elaxia$其他时间都花在了学习和找$MM$上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。 Input第一行：两个数$N,M$。表示十字路口数和街道数。接下来$M$行，每行$3$个数$a,b,c$，表示路口$a$和路口$b$之间有条长度为$c$的街道（单向）。 Output两个数，第一个数为最长周期的天数，第二个数为满足最长天数的条件下最短的路程长度。 Sample Input12345678910117 101 2 11 3 12 4 13 4 14 5 14 6 12 5 53 6 65 7 16 7 1 Sample Output12 11 Hint$N\le 200, M\le 20000$。 标签：拆点费用流 Solution拆点费用流套路题。首先要同时考虑天数最长和路程最短两个权，可知要用费用流。看到每个点只经过一次可知要把每个点拆成入点和出点，中间连流量为$1$费用为$0$的边。套路建图后跑费用流即可。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 50000#define INF 0x7f7f7f7fusing namespace std;int n, m, s, t, cnt, pr[MAX_N+5], cr[MAX_N+5], mxf, mic;struct node &#123;int v, c, w, nxt;&#125; E[MAX_M+5];void init() &#123;s = 1, t = n+n, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c, int w) &#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c, int w) &#123;insert(u, v, c, w), insert(v, u, 0, -w);&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inq[MAX_N+5]; int d[MAX_N+5], cr[MAX_N+5]; memset(inq, false, sizeof inq), memset(d, INF, sizeof d), memset(cr, -1, sizeof cr); d[s] = 0, que.push(s), inq[s] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(), inq[u] = false; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; d[u]+w &lt; d[v]) &#123; d[v] = d[u]+w, cr[v] = i; if (!inq[v]) que.push(v), inq[v] = true; &#125; &#125; &#125; if (d[t] == INF) return false; int flow = INF; for (int i = cr[t]; ~i; i = cr[E[i^1].v]) flow = min(flow, E[i].c); for (int i = cr[t]; ~i; i = cr[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; mxf += flow, mic += d[t]; return true;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m), init(); addedge(1, 1+n, INF, 0), addedge(n, n+n, INF, 0); for (int i = 2; i &lt; n; i++) addedge(i, i+n, 1, 0); for (int i = 0, u, v, w; i &lt; m; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;w), addedge(u+n, v, 1, w); while (SPFA()) ; return printf("%d %d", mxf, mic), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4205【FJ2015集训】卡牌配对]]></title>
    <url>%2FBZOJ4205%E3%80%90FJ2015%E9%9B%86%E8%AE%AD%E3%80%91%E5%8D%A1%E7%89%8C%E9%85%8D%E5%AF%B9%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 【FJ2015集训】卡牌配对Time Limit: $20 Sec$ Memory Limit: $512 MB$ Description现在有一种卡牌游戏，每张卡牌上有三个属性值：$A,B,C$。把卡牌分为$X,Y$两类，分别有$n_1,n_2$张。两张卡牌能够配对，当且仅当，存在至多一项属性值使得两张卡牌该项属性值互质，且两张卡牌类别不同。比如一张$X$类卡牌属性值分别是$225,233,101$，一张$Y$类卡牌属性值分别为$115,466,99$。那么这两张牌是可以配对的，因为只有$101$和$99$一组属性互质。游戏的目的是最大化匹配上的卡牌组数，当然每张卡牌只能用一次。 Input数据第一行两个数$n_1$，$n_2$，空格分割。接下来$n_1$行，每行$3$个数，依次表示每张$X$类卡牌的$3$项属性值。接下来$n_2$行，每行$3$个数，依次表示每张$Y$类卡牌的$3$项属性值。 Output输出一个整数：最多能够匹配的数目。 Sample Input123456&gt;2 2&gt;2 2 2&gt;2 5 5&gt;2 2 5&gt;5 5 5&gt; Sample Output12&gt;2&gt; HINT样例中第一张$X$类卡牌和第一张$Y$类卡牌能配对，第二张$X$类卡牌和两张$Y$类卡牌都能配对。所以最佳方案是第一张$X$和第一张$Y$配对，第二张$X$和第二张$Y$配对。对于$100\%$的数据，$n_1,n_2\le 30000$，属性值为不超过$200$的正整数请大胆使用渐进复杂度较高的算法！ 标签：网络流 Solution非常巧妙的一道二分图建模首先考虑暴力建边，显然边数是 $n^2$ 级别的，会同时$MLE$和$TLE$注意到值域只有$200$，可以预处理出所有质数，并且可以发现可匹配的情况只有三种，即$(A,B)$不互质,$(B,C)$不互质,$(C,A)$不互质（这里不互质只两张卡的两种同样属性不互质）。这样总共的不互质即可以匹配的情况共有$46\times 46\times 3$种（$200$内共$46$个质数）对于一张$X$类卡牌$(A,B,C)$，如果一个点$(a,b)$，$a$是$A$的质因子，$b$是$B$的质因子，那么就连一条由卡牌出发到那个点的流量为$1$的边。其他类的类似。$Y$类卡牌的话就连一条点到卡牌的边。源点向每个$X$牌连一条流量为$1$的边，每个$Y$牌向汇点连一条流量为$1$的边。构图后跑最大流即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAX_N 100000#define MAX_M 5000000#define INF 0x7f7f7f7fusing namespace std;int tot = 46, pri[46] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199&#125;;int n, m, s, t, cnt, x[MAX_N+5], y[MAX_N+5], z[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5], d[MAX_N+5];struct node &#123;int v, c, nxt;&#125; E[MAX_M+5]; vector &lt;int&gt; p[205];void init() &#123;s = 0, t = n+m+tot*tot*3+1, cnt = 0, memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c) &#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;void cpy() &#123;for (int i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;void rec() &#123;for (int i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;int Dinic() &#123;int ret = 0; cpy(); while (BFS()) ret += DFS(s, INF), rec(); return ret;&#125;int trans(int i, int j) &#123;return i*tot+j+1;&#125;void build(int u) &#123; int a = x[u], b = y[u], c = z[u]; for (int i = 0; i &lt; (int)p[a].size(); i++) for (int j = 0; j &lt; (int)p[b].size(); j++) if (u &lt;= n) addedge(u, n+m+trans(p[a][i], p[b][j]), 1); else addedge(n+m+trans(p[a][i], p[b][j]), u, 1); for (int i = 0; i &lt; (int)p[a].size(); i++) for (int j = 0; j &lt; (int)p[c].size(); j++) if (u &lt;= n) addedge(u, n+m+trans(p[a][i], p[c][j])+tot*tot, 1); else addedge(n+m+trans(p[a][i], p[c][j])+tot*tot, u, 1); for (int i = 0; i &lt; (int)p[b].size(); i++) for (int j = 0; j &lt; (int)p[c].size(); j++) if (u &lt;= n) addedge(u, n+m+trans(p[b][i], p[c][j])+tot*tot*2, 1); else addedge(n+m+trans(p[b][i], p[c][j])+tot*tot*2, u, 1);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m), init(); for (int i = 1; i &lt;= 200; i++) for (int j = 0; j &lt; tot; j++) if (i%pri[j] == 0) p[i].push_back(j); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d", x+i, y+i, z+i), addedge(s, i, 1), build(i); for (int i = n+1; i &lt;= n+m; i++) scanf("%d%d%d", x+i, y+i, z+i), addedge(i, t, 1), build(i); return printf("%d", Dinic()), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2321【BJ2011集训】星器]]></title>
    <url>%2FBZOJ2321%E3%80%90BJ2011%E9%9B%86%E8%AE%AD%E3%80%91%E6%98%9F%E5%99%A8%20%E7%89%A9%E7%90%86%2F</url>
    <content type="text"><![CDATA[Problem 【BJ2011集训】星器 Time Limit: $1 Sec$ Memory Limit: $128 MB$ Description$Magic Land$上的时间又过了若干世纪……现在，人们谈论着一个传说：从前，他们的祖先来到了一个位于东方的岛屿，那里简直就是另外一个世界。善于分析与构造的$Magic Land$上的人们总是不明白那里的人们是如何不借助精确的实验与计算驱动和操纵魔法。偶然地，一个魔法使（$Magician$）来到了$Magic Land$，在临走的时候留下了一个神奇的盒子，叫做星器（$casket of star$）。虽然不知道这个盒子是做什么的，但是经过了大量的实验和计算后，人们已经清楚它的一些事实： 星器之中有$N\times M$个区域，可看作分成$N$行和$M$列的格子，每个区域之中有若干单位的称为“星”的对象，这个对象的最小单位已经被确定，所以，这个数量总是整数。 魔法使可以驱动星器中位于同一行或同一列的不相邻（有公共边的区域称为相邻的）两个区域中各1单位的“星”，使得它们分别向中心移动1格。 每一次使用2中的方法驱动“星”，将会产生魔力，魔法使会得到这一部分魔力。魔力的量等于这个两个区域之间所间隔的区域数。这样，我们可以用一个$N\times M$的数表来表示星器的状态，比如$N=2$，$M=3$时：当星器为左图的状态时，通过操纵第一行的第$1$和$3$个区域中的“星”（加粗的数字对应的区域），变为右图所示的状态，同时，将产生$1$单位的魔力（因为这两个区域之间恰好隔了$1$个区域）。在经过了进一步的研究之后，人们知道了这个星器最初的状态（$Ini$）以及最终被他们得到时的状态（$Fin$）。你希望知道，星器最多帮助它的拥有者提供了多少的魔力。即：经过一系列上述操作由初态（$Ini$）变为终态（$Fin$），至多产生多少魔力。需要注意的是，显然操作过程中每个区域内“星”的数量不能是负的，即：如果那个区域已经没有“星”了，当然就不能继续操作了。 Input第一行包含两个正整数$N$、$M$表示星器的大小。接下来的$N$行，每行包含$M$个自然数：$Ini_{i,j}$，描绘了初态（$Ini$）。在一个空行后的$N$行，每行包含$M$个自然数：$Fin_{i,j}$，描绘了终态（$Fin$）。 Output输出一个正整数，表示至多产生的魔力。 Sample InputSample Input #1 12345678910115 51 0 0 0 10 0 0 0 00 0 0 0 00 1 0 1 11 0 0 0 00 0 0 0 00 0 0 0 12 0 0 0 10 0 2 0 00 0 0 0 0 Sample Input #21231 410 20 30 400 0 100 0 Sample OutputSample Output #117 Explanation:唯一的一种操作方法是：对第$5$列的两个“星”进行一次操作，产生魔力$2$；对第$1$列的两个“星”进行两次操作，产生魔力$3+1$；对第$4$行的两个“星”进行一次操作，产生魔力$1$；一共产生$7$单位的魔力。Sample Output #2150 HINT【数据规模和约定】 $40\%$的数据中$N \le 2$，如样例$2$； $100\%$的数据中$1 \le N$，$M\le 200$，$Ini_{i,j}, Fin_{i,j}\le 1000$。所有数据保证了至少存在一个操作方法使得星器由初态变为终态，同时保证了初态与终态不是完全相同的。 标签：物理，势能 Solution玄学物理题乱搞发现答案和移动方案无关，且行列独立一个星星的势能为它到左上角格子的距离的平方，使用一次魔法释放的魔力为在$\frac{两个星星势能和改变量}{2}$。计算$\frac{初末状态星星势能改变量之和}{2}$即可。 ##Code12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long lnt;int n, m; lnt s1, s2;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) for (int j = 1, x; j &lt;= m; j++) scanf("%d", &amp;x), s1 += 1LL*(i*i+j*j)*x; for (int i = 1; i &lt;= n; i++) for (int j = 1, x; j &lt;= m; j++) scanf("%d", &amp;x), s2 += 1LL*(i*i+j*j)*x; printf("%lld", (s1-s2)/2); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>物理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1565【NOI2009】植物大战僵尸]]></title>
    <url>%2FBZOJ1565%E3%80%90NOI2009%E3%80%91%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 【NOI2009】植物大战僵尸 ime Limit: 10 Sec Memory Limit: 64 MB Descriptioncenter&gt;/center&gt; Inputcenter&gt;/center&gt; Output仅包含一个整数，表示可以获得的最大能源收入。注意，你也可以选择不进行任何攻击，这样能源收入为$0$。 Sample Input12345673 210 020 0-10 0-5 1 0 0100 1 2 1100 0 Sample Output125 HINT在样例中, 植物$P_{1,1}$可以攻击位置$(0,0)$, $P_{2, 0}$可以攻击位置$(2,1)$。一个方案为，首先进攻$P_{1,1}, P_{0,1}$，此时可以攻击$P_{0,0}$ 。共得到能源收益为$(-5)+20+10 = 25$。注意, 位置$(2,1)$被植物$P_{2,0}$保护，所以无法攻击第$2$行中的任何植物。【数据规模】$20\%$的数据满足$1\le N, M\le 5$；$40\%$的数据满足$1 \le N, M \le10$；$100\%$的数据满足$1\le N\le 20$，$1\le M\le 30$，$-10^4\le Score\le 10^4$ 。 标签：最大权闭合子图，网络流，拓扑 Solution可以发现，如果一个植物能被吃，则要先吃掉它右边的植物和所有攻击范围有它的植物。这样可以形成一个有向图。所得到的最大收入为最大权闭合子图。发现此有向图是可以有环的，而环上的植物一定是不能被吃的。因而先拓扑一遍，标记掉环上的点，然后跑最小割即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MAX_M 1000000#define INF 0x7f7f7f7fusing namespace std;struct node &#123;int v, c, nxt;&#125; E[MAX_M+5]; vector &lt;int&gt; G[MAX_N+5]; bool mrk[MAX_N+5];int n, m, s, t, cnt, sum, c[MAX_N+5], d[MAX_N+5], pr[MAX_N+5], cr[MAX_N+5], into[MAX_N+5];void init() &#123;s = 0, t = n*m+1, cnt = 0; memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c) &#123;E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0); G[u].push_back(v), into[v]++;&#125;void topo() &#123; queue &lt;int&gt; que; mrk[s] = mrk[t] = true; for (int i = s; i &lt;= t; i++) if (!into[i]) que.push(i), mrk[i] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(); if (c[u] &gt; 0) sum += c[u]; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i]; if (mrk[v]) continue; if (!--into[v]) que.push(v), mrk[v] = true; &#125; &#125;&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || ~d[v] || !mrk[v]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1 || !mrk[v]) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123; int ret = 0; for (int i = s; i &lt;= t; i++) cr[i] = pr[i]; while (BFS()) &#123; ret += DFS(s, INF); for (int i = s; i &lt;= t; i++) pr[i] = cr[i]; &#125; return ret;&#125;int trans(int x, int y) &#123;return x*m+y+1;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m), init(); for (int i = 0; i &lt; n; i++) &#123; for (int j = 1; j &lt; m; j++) addedge(trans(i, j), trans(i, j-1), INF); for (int j = 0, a, w, x, y; j &lt; m; j++) &#123; scanf("%d%d", &amp;a, &amp;w), c[trans(i, j)] = a; if (a &gt; 0) addedge(trans(i, j), t, a); else addedge(s, trans(i, j), -a); while (w--) scanf("%d%d", &amp;x, &amp;y), addedge(trans(i, j), trans(x, y), INF); &#125; &#125; return topo(), printf("%d", sum-Dinic()), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF453B Little Pony and Harmony Chest]]></title>
    <url>%2FCF453B%20Little%20Pony%20and%20Harmony%20Chest%20%E7%8A%B6%E5%8E%8BDP%2F</url>
    <content type="text"><![CDATA[Problem Little Pony and Harmony Chest Time limit: $4000 ms$ Memory limit: $262144 kB$ DescriptionPrincess Twilight went to Celestia and Luna’s old castle to research the chest from the Elements of Harmony. A sequence of positive integers $b_i$ is harmony if and only if for every two elements of the sequence their greatest common divisor equals $1$. According to an ancient book, the key of the chest is a harmony sequence bi which minimizes the following expression:$$\sum_{i=1}^{n}{|a_i-b_i|}$$You are given sequence $a_i$, help Princess Twilight to find the key. InputThe first line contains an integer $n (1\le n\le 100)$ — the number of elements of the sequences $a$ and $b$. The next line contains $n$ integers $a_1,a_2,\cdots,a_n (1\le a_i\le 30)$. OutputOutput the key — sequence bi that minimizes the sum described above. If there are multiple optimal sequences, you can output any of them. ExampleInput1251 1 1 1 1 Output11 1 1 1 1 Input1251 6 4 2 8 Output11 5 3 1 8 标签：状压$DP$ Translation题目大意：给出一个$n$个元素的序列$a$，要求找一个$n$个元素的序列$b$，使得$b$中的数两两互质，且要最小化$|a_i-b_i|$之和。 Solution对于互质的条件，发现其相当于每个质因子只能用一次（$1$可以用无限次）。发现$a_i$的范围只有$30$，而如果$b_i\ge 2\times a_i$，则取$1$会更优。因此质因子只可能在$1\sim 60$之间，只有$17$个，可以状压。预处理$1\sim 60$中所有数占用的质因子状态，存在数组$sta[]$中。$f[i][j]$表示当前选到第$i$个数，质因子的选择状态为$j$的最大答案。对于一个数$k$，若 $j\&amp;sta[k]\ne 0$，则不能选。否则有 $f[i+1][j|sta[k]] = max(f[i+1][j|sta[k]], f[i][j]+abs(a[i+1]-k))$对于输出方案，存下转移到$f[i][j]$的状态$g[i][j]$和选的数$h[i][j]$，递归输出即可。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define SZ 17#define MX 60#define MAX_N 100#define INF 0x3f3f3f3fusing namespace std;int pri[SZ] = &#123;2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59&#125;;int n, a[MAX_N+5], f[MAX_N+5][1&lt;&lt;SZ], g[MAX_N+5][1&lt;&lt;SZ], h[MAX_N+5][1&lt;&lt;SZ], sta[MX];void init() &#123; for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt; (1&lt;&lt;SZ); j++) f[i][j] = INF, g[i][j] = h[i][j] = 0; f[0][0] = 0; memset(sta, 0, sizeof sta);&#125;void prt(int i, int j) &#123;if (!i) return; prt(i-1, g[i][j]), printf("%d ", h[i][j]);&#125;int main() &#123; while (~scanf("%d", &amp;n)) &#123; init(); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int i = 2; i &lt; MX; i++) for (int j = 0; j &lt; SZ; j++) if (i%pri[j] == 0) sta[i] |= (1&lt;&lt;j); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; (1&lt;&lt;SZ); j++) &#123; if (f[i][j] == INF) continue; for (int k = 1; k &lt; MX; k++) &#123; if (j&amp;sta[k]) continue; if (f[i+1][j|sta[k]] &gt; f[i][j]+abs(a[i+1]-k)) f[i+1][j|sta[k]] = f[i][j]+abs(a[i+1]-k), g[i+1][j|sta[k]] = j, h[i+1][j|sta[k]] = k; &#125; &#125; int pos = -1, ans = INF; for (int i = 0; i &lt; (1&lt;&lt;SZ); i++) if (f[n][i] &lt; ans) pos = i, ans = f[n][i]; prt(n, pos), puts(""); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CF291D Choosing Capital for Treeland]]></title>
    <url>%2FCF291D%20Choosing%20Capital%20for%20Treeland%20%E6%A0%91%E5%BD%A2DP%2F</url>
    <content type="text"><![CDATA[Problem Choosing Capital for Treeland Time limit: $3000 ms$ Memory limit: $262144 kB$ DescriptionThe country Treeland consists of n cities, some pairs of them are connected with unidirectional roads. Overall there are $n-1$ roads in the country. We know that if we don’t take the direction of the roads into consideration, we can get from any city to any other one.The council of the elders has recently decided to choose the capital of Treeland. Of course it should be a city of this country. The council is supposed to meet in the capital and regularly move from the capital to other cities (at this stage nobody is thinking about getting back to the capital from these cities). For that reason if city a is chosen a capital, then all roads must be oriented so that if we move along them, we can get from city a to any other city. For that some roads may have to be inversed.Help the elders to choose the capital so that they have to inverse the minimum number of roads in the country. InputThe first input line contains integer $n (2\le n\le 2\times 10^5)$ — the number of cities in Treeland. Next $n-1$ lines contain the descriptions of the roads, one road per line. A road is described by a pair of integers $s_i,t_i (1\le s_i,t_i\le n; si\ne ti)$ — the numbers of cities, connected by that road. The $i^{th}$ road is oriented from city $s_i$ to city $t_i$. You can consider cities in Treeland indexed from $1$ to $n$. OutputIn the first line print the minimum number of roads to be inversed if the capital is chosen optimally. In the second line print all possible ways to choose the capital — a sequence of indexes of cities in the increasing order. ExampleInput12332 12 3 Output1202 Input123441 42 43 4 Output1221 2 3 标签：树形$DP$ Translation题目大意：给出一棵由有向边组成的树，要求选一个点使得最小化从它到其余所有点的路径中反向边的条数之和。 Solution首先转化问题为：给出一棵由无向边组成的树，边有权值$0$或$1$($0$为正向，$1$为反向)，要求找一个点使得最小化其到所有点的路径的权值和。特别地，计算某个点时，此点到其父结点的边的边权要异或$1$。第一次$DFS$，定下每边权值，并$DP$出每个点的子树的总权值。第二次$DFS$，按$DFS$序计算答案。对于每个点，$ans=f[fa]+(c == 1 ? -1 : 1)$，其中$fa$为其父结点，$c$为其到父结点的边的边权。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define MAX_N 200000using namespace std;int n, f[MAX_N+5], ans = 1; vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];void addedge(int u, int v, int c) &#123;G[u].push_back(v), E[u].push_back(c);&#125;void DFS1(int u, int fa) &#123; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (v == fa) continue; DFS1(v, u), f[u] += f[v]+c; &#125;&#125;void DFS2(int u, int fa) &#123; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (v == fa) continue; f[v] = f[u]+(c ? -1 : 1), DFS2(v, u); if (f[u] &lt; f[ans] || (f[u] == f[ans] &amp;&amp; u &lt; ans)) ans = u; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), addedge(u, v, 0), addedge(v, u, 1); DFS1(1, 0), DFS2(1, 0); printf("%d\n", f[ans]); for (int i = 1; i &lt;= n; i++) if (f[i] == f[ans]) printf("%d ", i); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>树形DP</tag>
        <tag>CodeForces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1822【JSOI2010】Frozen Nova 冷冻波]]></title>
    <url>%2FBZOJ1822%E3%80%90JSOI2010%E3%80%91Frozen%20Nove%20%E5%86%B7%E5%86%BB%E6%B3%A2%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【JSOI2010】Frozen Nova 冷冻波Time Limit: $10 Sec$Memory Limit: $64 MB$ Description$WJJ$喜欢“魔兽争霸”这个游戏。在游戏中，巫妖是一种强大的英雄，它的技能$Frozen Nova$每次可以杀死一个小精灵。我们认为，巫妖和小精灵都可以看成是平面上的点。 当巫妖和小精灵之间的直线距离不超过$R$，且巫妖看到小精灵的视线没有被树木阻挡（也就是说，巫妖和小精灵的连线与任何树木都没有公共点）的话，巫妖就可以瞬间杀灭一个小精灵。 在森林里有$N$个巫妖，每个巫妖释放$Frozen Nova$之后，都需要等待一段时间，才能再次施放。不同的巫妖有不同的等待时间和施法范围，但相同的是，每次施放都可以杀死一个小精灵。 现在巫妖的头目想知道，若从$0$时刻开始计算，至少需要花费多少时间，可以杀死所有的小精灵？ Input输入文件第一行包含三个整数$N,M,K(N,M,K\le 200)$，分别代表巫妖的数量、小精灵的数量和树木的数量。 接下来$N$行，每行包含四个整数$x, y, r, t$，分别代表了每个巫妖的坐标、攻击范围和施法间隔（单位为秒）。 再接下来$M$行，每行两个整数$x, y$，分别代表了每个小精灵的坐标。 再接下来K行，每行三个整数$x, y, r$，分别代表了每个树木的坐标。 输入数据中所有坐标范围绝对值不超过$10000$，半径和施法间隔不超过$20000$。 Output输出一行，为消灭所有小精灵的最短时间（以秒计算）。如果永远无法消灭所有的小精灵，则输出$-1$。 Sample Input12345672 3 1-100 0 100 3100 0 100 5-100 -10100 10110 115 5 10 Sample Output15 标签：二分+最大流 Solution这种$二分答案+最大流$是常见套路。类似$BZOJ3993$。二分时间，对于每个时间，判断是否足够消灭所有敌人。建模：对于每个巫妖$i$，建边 $s\to i$ 权值为 $\frac{time}{攻击间隔}+1$对于每个精灵$j$，建边 $j\to t$ 权值为 $1$对于每组两个能攻击到的巫妖$a$和精灵$b$，建边 $a\to b$ 权值为 $1$在次图上跑最大流，判断最大流是否等于m，即是否所有小精灵都有匹配的巫妖。预处理每个巫妖和每个小精灵之间是否能看到，即用点到直线距离判断树木$k$所在的圆是否与巫妖所在点和小精灵所在点两点连成线段有交点，有则不能看到。具体见代码。 Code(我预处理的计算几何部分较为复杂，可以参考hzwer的代码，要简洁一些。)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;bits/stdc++.h&gt;#define MAX_N 200#define MAX_M 500000#define INF 0x7f7f7f7fusing namespace std;typedef double dnt;int n, m, k, s, t, mx, cnt, pr[MAX_N*2+5];struct WIZ &#123;int x, y, r, t;&#125; wiz[MAX_N+5];struct ELF &#123;int x, y;&#125; elf[MAX_N+5];struct TRE &#123;int x, y, r;&#125; tre[MAX_N+5];struct EDG &#123;int u, v, c, nxt;&#125; E[MAX_M+5];int d[MAX_N*2+5], cr[MAX_N*2+5];bool mrk[MAX_N+5][MAX_N+5];//---------- Geometry Section ----------//WIZ operator - (WIZ a, TRE b) &#123;WIZ t; t.x = a.x-b.x, t.y = a.y-b.y; return t;&#125;WIZ operator - (TRE a, WIZ b) &#123;WIZ t; t.x = a.x-b.x, t.y = a.y-b.y; return t;&#125;ELF operator - (ELF a, TRE b) &#123;ELF t; t.x = a.x-b.x, t.y = a.y-b.y; return t;&#125;ELF operator - (ELF a, WIZ b) &#123;ELF t; t.x = a.x-b.x, t.y = a.y-b.y; return t;&#125;dnt dot(WIZ a, ELF b) &#123;return a.x*b.x+a.y*b.y;&#125;dnt cross(WIZ a, ELF b) &#123;return a.x*b.y-a.y*b.x;&#125;dnt dis(WIZ a, ELF b) &#123;return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;dnt dis(WIZ a, TRE b) &#123;return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;dnt dis(ELF a, TRE b) &#123;return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));&#125;dnt dis(WIZ a, ELF b, TRE p) &#123; if (dot(a-p, b-p) &gt; 0) return min(dis(a, p), dis(b, p)); return abs(cross(p-a, b-a)/dis(a, b));&#125;bool jud(int x, int y) &#123; if (dis(wiz[x], elf[y]) &gt; wiz[x].r) return false; for (int i = 1; i &lt;= k; i++) if (dis(wiz[x], elf[y], tre[i]) &lt; tre[i].r) return false; return true;&#125;//---------- Network Flow Section ----------//void init() &#123;s = 0, t = n+m+1, cnt = 0; memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c) &#123;E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int &amp;i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123; int ret = 0; for (int i = s; i &lt;= t; i++) cr[i] = pr[i]; while (BFS()) &#123; ret += DFS(s, INF); for (int i = s; i &lt;= t; i++) pr[i] = cr[i]; &#125; return ret;&#125;//---------- Binary Search Section ----------//bool chk(int tans) &#123; init(); for (int i = 1; i &lt;= n; i++) addedge(s, i, tans/wiz[i].t+1); for (int i = 1; i &lt;= m; i++) addedge(i+n, t, 1); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if (mrk[i][j]) addedge(i, j+n, 1); return Dinic() == m;&#125;int bi_search(int l, int r) &#123; int ret = -1; while (l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if (chk(mid)) r = mid-1, ret = mid; else l = mid+1; &#125; return ret;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; i++) scanf("%d%d%d%d", &amp;wiz[i].x, &amp;wiz[i].y, &amp;wiz[i].r, &amp;wiz[i].t), mx = max(wiz[i].t, mx); for (int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;elf[i].x, &amp;elf[i].y); for (int i = 1; i &lt;= k; i++) scanf("%d%d%d", &amp;tre[i].x, &amp;tre[i].y, &amp;tre[i].r); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) mrk[i][j] = jud(i, j); return printf("%d", bi_search(0, m*mx)), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2521【SHOI2010】最小生成树]]></title>
    <url>%2FBZOJ2521%E3%80%90SHOI2010%E3%80%91%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem 【SHOI2010】最小生成树 Time Limit: $10 Sec$ Memory Limit: $128 MB$ Description$Secsa$最近对最小生成树问题特别感兴趣。他已经知道如果要去求出一个$n$个点、$m$条边的无向图的最小生成树有一个$Krustal$算法和另一个$Prim$的算法。另外，他还知道，某一个图可能有多种不同的最小生成树。例如，下面图 $3$中所示的都是图 $2$中的无向图的最小生成树： 当然啦，这些都不是今天需要你解决的问题。$Secsa$想知道对于某一条无向图中的边$AB$，至少需要多少代价可以保证$AB$边在这个无向图的最小生成树中。为了使得$AB$边一定在最小生成树中，你可以对这个无向图进行操作，一次单独的操作是指：先选择一条图中的边 $P_1P_2$，再把图中除了这条边以外的边，每一条的权值都减少$1$。如图 $4$所示就是一次这样的操作： Input输入文件的第一行有$3$个正整数$n$、$m$、$Lab$分别表示无向图中的点数、边数、必须要在最小生成树中出现的$AB$边的标号。接下来$m$行依次描述标号为$1,2,3\cdots, m$的无向边，每行描述一条边。每个描述包含$3$个整数$x$、$y$、$d$，表示这条边连接着标号为$x$、$y$的点，且这条边的权值为$d$。输入文件保证$1\le x,y\le N$,$x\ne y$,且输入数据保证这个无向图一定是一个连通图。 Output输出文件只有一行，这行只有一个整数，即，使得标号为$Lab$边一定出现最小生成树中的最少操作次数。 Sample Input12345674 6 11 2 21 3 21 4 32 3 22 4 43 4 5 Sample Output11 HINT样例就是问题描述中的例子。 1\le n\le 500, 1\le M\le 800,1\le D&lt;10^6$ 标签：最小割 Solution$除边i外其他边权值-1 \iff 边i权值+1$设$id$边连接$u,v$，以$u$为源，$v$为汇，断开$id$边，形成一个网络流图。对于此图中的任意一个割，若此割上的所有边边权均大于$id$边边权，则$id$边必在$MST$中。于是把每条边边权变为“改变到使此边边权大于$id$边边权的代价”，即$W_{id}+1-W_{cur}$，然后跑最小割即可。 Code?12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;#define MAX_N 500#define MAX_M 800#define INF 0x7f7f7f7fusing namespace std;int n, m, id, s, t, tc, cnt, pr[MAX_N+5], d[MAX_N+5];struct node &#123;int u, v, c, nxt;&#125; E[MAX_M*10];struct edge &#123;int u, v, c, id;&#125; e[MAX_M+5];bool cmp(const edge &amp;a, const edge &amp;b) &#123;return a.c &lt; b.c;&#125;void init() &#123;s = e[id].u, t = e[id].v, tc = e[id].c; memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c) &#123;E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123;int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;id); for (int i = 1; i &lt;= m; i++) scanf("%d%d%d", &amp;e[i].u, &amp;e[i].v, &amp;e[i].c), e[i].id = i; init(), sort(e+1, e+m+1, cmp); for (int i = 1; i &lt;= m; i++) if (e[i].id^id) &#123; if (e[i].c &gt; tc) break; addedge(e[i].u, e[i].v, tc-e[i].c+1); addedge(e[i].v, e[i].u, tc-e[i].c+1); &#125; printf("%d", Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3275 Number]]></title>
    <url>%2FBZOJ3275%20Number%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[ProblemNumberTime Limit: $10 Sec$Memory Limit: $128 MB$ Description有$N$个正整数，需要从中选出一些数，使这些数的和最大。若两个数$a,b$同时满足以下条件，则$a,b$不能同时被选 存在正整数$c$，使$a^2+b^2=c^2$ \gcd(a,b)=1$ Input第一行一个正整数$N$，表示数的个数。第二行$N$个正整数$a_1,a_2,\cdots ,a_N$。 Output最大的和。 Sample Input1253 4 5 6 7 Sample Output122 HINT$N\le 3000$。 标签：黑白染色+最小割 Solution两条性质：·奇$^2$+奇$^2$ $\ne$ $X^2 (X\in N^*)$·$\gcd($偶,偶$) \ne 1$∴奇与奇共存，偶与偶共存建模：$S\to$奇 $ : val$，偶$\to T : val$，奇$\to$偶 $: INF$$ans = $ 总权值$-$最小割 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define MAX_N 3000#define INF 2147483647using namespace std;int n, s, t, sum, cnt, a[MAX_N+5], d[MAX_N+5], pr[MAX_N+5];struct node &#123;int u, v, c, nxt;&#125; E[MAX_N*100];int gcd(int x, int y) &#123;return y ? gcd(y, x%y) : x;&#125;void init() &#123;s = 0, t = n+1; memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c) &#123;E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123;int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;bool chk(int i, int j) &#123;return gcd(a[i], a[j]) == 1 &amp;&amp; sqrt(a[i]*a[i]+a[j]*a[j]) == floor(sqrt(a[i]*a[i]+a[j]*a[j]));&#125;int main() &#123; scanf("%d", &amp;n), init(); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i), sum += a[i]; for (int i = 1; i &lt;= n; i++) if (a[i]%2) addedge(s, i, a[i]); else addedge(i, t, a[i]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i]%2 == 1 &amp;&amp; a[j]%2 == 0 &amp;&amp; chk(i, j)) addedge(i, j, INF); return printf("%d", sum-Dinic()), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3158 千钧一发]]></title>
    <url>%2FBZOJ3158%20%E5%8D%83%E9%92%A7%E4%B8%80%E5%8F%91%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem 千钧一发 Time Limit: $10 Sec $ Memory Limit: $512 MB$ Description Input第一行一个正整数$N$。第二行共包括$N$个正整数，第 个正整数表示$A_i$。第三行共包括$N$个正整数，第 个正整数表示$B_i$。 Output共一行，包括一个正整数，表示在合法的选择条件下，可以获得的能量值总和的最大值。 Sample Input12343 4 5 129 8 30 9 Sample Output139 HINT $1\le N\le 1000,1\le A_i,B_i\le 10^6$ 标签：黑白染色+最小割 Solution和$BZOJ3275$差不多两条性质： $奇^2+奇^2 \ne X^2 (X\in \mathbb{N}^*)$ $\gcd(偶,偶) \ne 1$ $\therefore$奇与奇共存，偶与偶共存建模：$S\to 奇, cap=b[i]$，$偶\to T, cap=b[i]$，$奇\to 偶, cap=\infty$$ans = 总权值-最小割$注意判断是否能组成勾股数时平方要开$longlong$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define INF 2147483647using namespace std;int n, s, t, sum, cnt, a[MAX_N+5], b[MAX_N+5], d[MAX_N+5], pr[MAX_N+5];struct node &#123;int u, v, c, nxt;&#125; E[MAX_N*1000];int gcd(int x, int y) &#123;return y ? gcd(y, x%y) : x;&#125;void init() &#123;s = 0, t = n+1; memset(pr, -1, sizeof pr);&#125;void insert(int u, int v, int c) &#123;E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123;int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;bool chk(int i, int j) &#123;return gcd(a[i], a[j]) == 1 &amp;&amp; sqrt(1LL*a[i]*a[i]+1LL*a[j]*a[j]) == floor(sqrt(1LL*a[i]*a[i]+1LL*a[j]*a[j]));&#125;int main() &#123; scanf("%d", &amp;n), init(); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int i = 1; i &lt;= n; i++) scanf("%d", b+i), sum += b[i]; for (int i = 1; i &lt;= n; i++) if (a[i]%2) addedge(s, i, b[i]); else addedge(i, t, b[i]); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) if (a[i]%2 == 1 &amp;&amp; a[j]%2 == 0 &amp;&amp; chk(i, j)) addedge(i, j, INF); return printf("%d", sum-Dinic()), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1475 方格取数]]></title>
    <url>%2FBZOJ1475%20%E6%96%B9%E6%A0%BC%E5%8F%96%E6%95%B0%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem 方格取数 Time Limit: $5 Sec$ Memory Limit: $64 MB$ Description在一个$n\times n$的方格里，每个格子里都有一个正整数。从中取出若干数，使得任意两个取出的数所在格子没有公共边，且取出的数的总和尽量大。 Input第一行一个数$n$（$n\le 30$），接下来$n$行每行$n$个数描述一个方阵 Output仅一个数，即最大和 Sample Input12321 23 5 Sample Output16 标签：黑白染色+最小割 Solution将网格图黑白染色，同色格子间不会冲突。建模：$S\to 黑格 容量val$，$白格\to T 容量val$，$黑格\to 白格 容量\infty$$ans = 总权值-最小割$ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define INF 0x7f7f7f7fusing namespace std;int nxt[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;, sum;int n, m, s, t, cnt, id[35][35], a[MAX_N+5], d[MAX_N+5], pr[MAX_N+5];struct node &#123;int u, v, c, nxt;&#125; E[MAX_N*MAX_N*2];void init() &#123;s = 0, t = m+1; memset(pr, -1, sizeof pr);&#125;void getID() &#123;for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= n; j++) id[i][j] = (i-1)*n+j;&#125;void insert(int u, int v, int c) &#123;E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pr[u], pr[u] = cnt++;&#125;void addedge(int u, int v, int c) &#123;insert(u, v, c), insert(v, u, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; que.push(s); memset(d, -1, sizeof d), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || ~d[v]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pr[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (!c || d[v] != d[u]+1) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123;int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;int main() &#123; scanf("%d", &amp;n), m = n*n, getID(), init(); for (int i = 1; i &lt;= m; i++) scanf("%d", a+i), sum += a[i]; for (int i = 1; i &lt;= m; i++) if ((i-1)%n%2 == (i-1)/n%2) addedge(s, i, a[i]); else addedge(i, t, a[i]); for (int i = 1; i &lt;= m; i++) if ((i-1)%n%2 == (i-1)/n%2)&#123; int x = (i-1)/n+1, y = (i-1)%n+1; for (int j = 0; j &lt; 4; j++) &#123; int nx = x+nxt[j][0], ny = y+nxt[j][1]; if (nx &lt; 1 || nx &gt; n || ny &lt; 1 || ny &gt; n) continue; addedge(id[x][y], id[nx][ny], INF); &#125; &#125; printf("%d", sum-Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4237【JOI2013】稻草人]]></title>
    <url>%2FBZOJ4237%E3%80%90JOI2013%E3%80%91%E7%A8%BB%E8%8D%89%E4%BA%BA%20CDQ%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem 【JOI2013】稻草人 Time Limit: $40 Sec$ Memory Limit: $256 MB$ Description$JOI$村有一片荒地，上面竖着$N$个稻草人，村民们每年多次在稻草人们的周围举行祭典。有一次，$JOI$村的村长听到了稻草人们的启示，计划在荒地中开垦一片田地。和启示中的一样，田地需要满足以下条件：田地的形状是边平行于坐标轴的长方形；左下角和右上角各有一个稻草人；田地的内部(不包括边界)没有稻草人。给出每个稻草人的坐标，请你求出有多少遵从启示的田地的个数 Input第一行一个正整数$N$，代表稻草人的个数接下来$N$行，第$i$行$(1\le i\le N)$包含$2$个由空格分隔的整数$X_i$和$Y_i$，表示第$i$个稻草人的坐标 Output输出一行一个正整数，代表遵从启示的田地的个数 Sample Input1234540 02 23 44 3 Sample Output13 HINT所有满足要求的田地由下图所示：$1\le N\le 2\times 10^5$$0\le X_i\le 10^9(1\le i\le N)$$0\le Y_i\le 10^9(1\le i\le N)$$X_i(1\le i\le N)$互不相同。$Y_i(1\le i\le N)$互不相同。 标签：$CDQ$分治$+$单调栈 Solution暑假听$ZCY$讲过这道题，当时用的是线段树上维护单调栈。发现$CDQ$分治也可以用相同复杂度$A$掉此题，而且还更好写。 首先$CDQ$分治降维，把两维降成一维，即把$y$的限制去掉。先离散化，再按$x$值排序，随后开始分治。对于每次分治，把区间分为两个部分$[l,mid]$和$[mid+1,r]$，把$y$值在两个区间内的分开。然后逐个加入$y$值大于$mid$的点，并维护单调栈，再把所有$x$值小于它且$y$值小于等于$mid$的点加入另一个单调栈，再单调栈上二分找到分界点，统计以此点作为右上角可组成的方形个数。 Code1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define lb lower_boundusing namespace std;typedef long long lnt;int n, mp[2][MAX_N+5]; lnt ans;struct node &#123;int x, y;&#125; p[MAX_N+5], q[MAX_N+5], sta[2][MAX_N+5];bool cmp(const node &amp;a, const node &amp;b) &#123;return a.x &lt; b.x;&#125;void solve(int l, int r) &#123; if (l == r) return; int mid = l+r&gt;&gt;1; int m0 = l, m1 = mid+1, tp0 = 0, tp1 = 0; for (int i = l; i &lt;= r; i++) if (p[i].y &lt;= mid) q[m0++] = p[i]; else q[m1++] = p[i]; memcpy(p+l, q+l, sizeof(node)*(r-l+1)); for (int p0 = l, p1 = mid+1; p1 &lt;= r; ) &#123; while (p0 &lt;= mid &amp;&amp; p[p0].x &lt; p[p1].x) &#123; while (tp0 &amp;&amp; sta[0][tp0].y &lt; p[p0].y) tp0--; sta[0][++tp0] = p[p0], p0++; &#125; while (tp1 &amp;&amp; sta[1][tp1].y &gt; p[p1].y) tp1--; sta[1][++tp1] = p[p1], p1++; ans += tp0-(lb(sta[0]+1, sta[0]+tp0+1, sta[1][tp1-1], cmp)-sta[0])+1; &#125; solve(l, mid), solve(mid+1, r);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;p[i].x, &amp;p[i].y), mp[0][i-1] = p[i].x, mp[1][i-1] = p[i].y; sort(mp[0], mp[0]+n), sort(mp[1], mp[1]+n); int m0 = unique(mp[0], mp[0]+n)-mp[0], m1 = unique(mp[1], mp[1]+n)-mp[1]; for (int i = 1; i &lt;= n; i++) p[i].x = lb(mp[0], mp[0]+m0, p[i].x)-mp[0]+1, p[i].y = lb(mp[1], mp[1]+m1, p[i].y)-mp[1]+1; sort(p+1, p+n+1, cmp), solve(1, n); return printf("%lld", ans), 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>CDQ分治</tag>
        <tag>JOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2599【IOI2011】 Race]]></title>
    <url>%2FBZOJ2599%E3%80%90IOI2011%E3%80%91Race%20%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem 【IOI2011】Race Time Limit: $70 Sec$ Memory Limit: $128 MB$ Description给一棵树,每条边有权.求一条简单路径,权值和等于$K$,且边的数量最小.$N\le 2\times 10^5$, $K\le 10^6$ Input第一行 两个整数 $n, k$第二至$n$行 每行三个整数，表示一条无向边的两端和权值 (注意点的编号从$0$开始) Output一个整数 表示最小边数量，如果不存在这样的路径，输出$-1$ Sample Input12344 30 1 11 2 21 3 4 Sample Output12 标签：点分治 Solution$OI$生涯的第一道$IOI$题（虽然是水题）挺有意思的一道点分治题，把模板稍加变化即可。 用$mi[]$记录每种距离的路径长度的最小值，即$mi[i]$记录距离为$i$的路径的长度的最小值。对于每个点，枚举其所有子结点。当枚举到子结点$v_k$时，将$v_k$的深度加上$v_1\sim v_k-1$中子结点的深度来更新$m_i$数组。计算答案并和$ans$打擂。注意在每个点计算答案时$m_i$值需要重新计算，但此题常数较大，最好不要$memset$，可以再$DFS$一次撤销。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define MAX_L 1000000using namespace std;int n, k, tot, rt, ans;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int s[MAX_N+5], h[MAX_N+5], dis[MAX_N+5], dep[MAX_N+5], mi[MAX_L+5];bool mrk[MAX_N+5];void addedge(int u, int v, int c) &#123;G[u].push_back(v), E[u].push_back(c);&#125;void getrt(int u, int fa) &#123; s[u] = 1, h[u] = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa || mrk[v]) continue; getrt(v, u); s[u] += s[v], h[u] = max(h[u], s[v]); &#125; h[u] = max(h[u], tot-s[u]); if (h[u] &lt; h[rt]) rt = u;&#125;void calc(int u, int fa) &#123; if (dis[u] &lt;= k) ans = min(ans, dep[u]+mi[k-dis[u]]); for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (v == fa || mrk[v]) continue; dep[v] = dep[u]+1, dis[v] = dis[u]+c, calc(v, u); &#125;&#125;void upd(int u, int fa) &#123; if (dis[u] &lt;= k) mi[dis[u]] = min(mi[dis[u]], dep[u]); for (int i = 0; i &lt; (int)G[u].size(); i++) if (G[u][i] != fa &amp;&amp; !mrk[G[u][i]]) upd(G[u][i], u);&#125;void clr(int u, int fa) &#123; if (dis[u] &lt;= k) mi[dis[u]] = n; for (int i = 0; i &lt; (int)G[u].size(); i++) if (G[u][i] != fa &amp;&amp; !mrk[G[u][i]]) clr(G[u][i], u);&#125;void DFS(int u) &#123; mi[0] = 0, mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (mrk[v]) continue; dep[v] = 1, dis[v] = c, calc(v, 0), upd(v, 0); &#125; for (int i = 0; i &lt; (int)G[u].size(); i++) if (!mrk[G[u][i]]) clr(G[u][i], 0); for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i]; if (mrk[v]) continue; rt = 0, tot = s[v], getrt(v, 0), DFS(rt); &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1, u, v, c; i &lt; n; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), u++, v++, addedge(u, v, c), addedge(v, u, c); for (int i = 1; i &lt;= k; i++) mi[i] = n; ans = tot = h[0] = n, getrt(1, 0), DFS(rt); printf("%d", ans == n ? -1 : ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
        <tag>IOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2152 聪聪可可]]></title>
    <url>%2FBZOJ2152%20%E8%81%AA%E8%81%AA%E5%8F%AF%E5%8F%AF%20%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem 聪聪可可 Time Limit: $3 Sec$ Memory Limit: $259 MB$ Description聪聪和可可是兄弟俩，他们俩经常为了一些琐事打起来，例如家中只剩下最后一根冰棍而两人都想吃、两个人都想玩儿电脑（可是他们家只有一台电脑）……遇到这种问题，一般情况下石头剪刀布就好了，可是他们已经玩儿腻了这种低智商的游戏。他们的爸爸快被他们的争吵烦死了，所以他发明了一个新游戏：由爸爸在纸上画$n$个“点”，并用$n-1$条“边”把这$n$个“点”恰好连通（其实这就是一棵树）。并且每条“边”上都有一个数。接下来由聪聪和可可分别随即选一个点（当然他们选点时是看不到这棵树的），如果两个点之间所有边上数的和加起来恰好是$3$的倍数，则判聪聪赢，否则可可赢。聪聪非常爱思考问题，在每次游戏后都会仔细研究这棵树，希望知道对于这张图自己的获胜概率是多少。现请你帮忙求出这个值以验证聪聪的答案是否正确。 Input输入的第$1$行包含$1$个正整数$n$。后面$n-1$行，每行$3$个整数$x$、$y$、$w$，表示$x$号点和$y$号点之间有一条边，上面的数是$w$。 Output以即约分数形式输出这个概率（即“$a/b$”的形式，其中$a$和$b$必须互质。如果概率为$1$，输出“$1/1$”）。 Sample Input1234551 2 11 3 21 4 12 5 3 Sample Output113/25 Hint【样例说明】 $13$组点对分别是$(1,1) (2,2) (2,3) (2,5) (3,2) (3,3) (3,4) (3,5) (4,3) (4,4) (5,2) (5,3) (5,5)$。【数据规模】对于$100\%$的数据，$n\le 2\times 10^4$。 标签：点分治 Solution经典点分治例题。对于每个点，只考虑经过它的符合条件的路径，统计后递归分治左右子树。这样我们只需要计算经过指定点长度为$3$的倍数的路径即可。不难发现我们只需分别统计模$3$余$0,1,2$的一段在指定点的路径条数即可。统计后，设三种余数的条数为$cnt_0$, $cnt_1$, $cnt_2$，则答案为$cnt_0\times cnt_0-cnt_1\times cnt_2\times 2$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;#define MAX_N 200000using namespace std;int n, rt, tot, ans; vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int s[MAX_N+5], h[MAX_N+5], dep[MAX_N+5], cnt[3]; bool mrk[MAX_N+5];void addedge(int u, int v, int c) &#123;G[u].push_back(v), E[u].push_back(c%3);&#125;int gcd(int a, int b) &#123;return b ? gcd(b, a%b) : a;&#125;int frac(int a, int b) &#123;return a/gcd(a, b);&#125;void getrt(int u, int fa) &#123; s[u] = 1, h[u] = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa || mrk[v]) continue; getrt(v, u); s[u] += s[v], h[u] = max(h[u], s[v]); &#125; h[u] = max(h[u], tot-s[u]); if (h[u] &lt; h[rt]) rt = u;&#125;void getdep(int u, int fa) &#123; cnt[dep[u]]++; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (v == fa || mrk[v]) continue; dep[v] = (dep[u]+c)%3, getdep(v, u); &#125;&#125;int calc(int u, int init) &#123; cnt[0] = cnt[1] = cnt[2] = 0; dep[u] = init, getdep(u, 0); return cnt[0]*cnt[0]+cnt[1]*cnt[2]*2;&#125;void DFS(int u) &#123; ans += calc(u, 0), mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (mrk[v]) continue; ans -= calc(v, c), rt = 0, tot = s[v], getrt(v, 0), DFS(rt); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1, u, v, c; i &lt; n; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), addedge(u, v, c), addedge(v, u, c); tot = h[0] = n, getrt(1, 0), DFS(rt); printf("%d/%d", frac(ans, n*n), frac(n*n, ans)); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4151【AMPPZ2014】The Cave]]></title>
    <url>%2FBZOJ4151%E3%80%90AMPPZ2014%E3%80%91The%20Cave%20%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Problem【AMPPZ2014】The CaveTime Limit: $5 Sec$Memory Limit: $256 MB$$Special Judge$ Description给定一棵有$n$个节点的树，相邻两点之间的距离为$1$。请找到一个点$x$，使其满足所有$m$条限制 $a b d$，其中第$i$条限制为$dist_{x,a}+dist_{x,b}\le d$ Input第一行包含一个正整数$t$($1\le t\le 1000$)，表示数据组数。对于每组数据，第一行包含两个正整数$n,m$($2\le n,m\le 3\times 10^5$)，表示点数、限制数。接下来$n-1$行，每行两个正整数$x,y$($1\le x,y\le n$)，表示树上的一条边。接下来$m$行，每行三个正整数$a[i],b[i],d[i]$($1\le a[i],b[i]\le n$, $1\le d[i]\le 6\times 10^5$)，描述一条限制。输入数据保证所有$n$之和不超过 $3\times 10^5$，所有$m$之和也不超过 $3\times 10^5$。 Output输出$t$行。第$i$行输出第$i$组数据的答案，如果无解输出$NIE$，否则输出$TAK$，然后输出$x$，如有多组解，输出任意一组。 Sample Input123456789101112131425 31 22 32 43 51 4 25 5 53 2 13 21 22 31 1 23 3 1 Sample Output12TAK 2NIE 标签：树相关 Solution好题，完全没想到正解。设$1$号节点为根节点。对于每个限制，所求点离$a_i\to b_i$这条路径的距离一定不大于某个数，在根节点确定的情况下，第$i$个限制可转化成所求点到根的距离最大为$max(0,max_{i=1}^{n}{\frac{dep[a_i]+dep[b_i]−d_i}{2}})$以内，其中$dep$表示该点到根节点的距离。这就可以转化成类似一堆已知某个端点的线段求某个交点的问题。于是先取限制距离最大的线段上的点，即离根节点最远的点，然后一路往上跑直到某个点刚好满足限制，对于这个点再判断一下是否满足所有情况即可，总复杂度$O(n+m)$。可参考另一篇写得很清楚的博客：小米狐的博客 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define MAX_N 300000using namespace std;int n, m, a[MAX_N+5], b[MAX_N+5], d[MAX_N+5], pa[MAX_N+5], dep[MAX_N+5];vector &lt;int&gt; G[MAX_N+5];void DFS(int u, int fa) &#123; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa) continue; pa[v] = u, dep[v] = dep[u]+1, DFS(v, u); &#125;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) G[i].clear(); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); dep[1] = 0, DFS(1, 0); int p = 1, mx = 0; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", a+i, b+i, d+i); if ((dep[a[i]]+dep[b[i]]-d[i]+1)/2 &gt; mx) p = a[i], mx = (dep[a[i]]+dep[b[i]]-d[i]+1)/2; &#125; for (; dep[p] &gt; mx; p = pa[p]) ; dep[p] = 0, DFS(p, 0); bool flag = true; for (int i = 1; i &lt;= m; i++) if (dep[a[i]]+dep[b[i]] &gt; d[i]) &#123;flag = false; break;&#125; if (flag) printf("TAK %d\n", p); else puts("NIE"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树相关</tag>
        <tag>AMPPZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1999【NOIp2007】Core树网的核]]></title>
    <url>%2FBZOJ1999%E3%80%90NOIp2007%E3%80%91Core%E6%A0%91%E7%BD%91%E7%9A%84%E6%A0%B8%20%E6%A0%91%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Problem 【NOIp2007】Core树网的核 Time Limit: $10 Sec$ Memory Limit: $64 MB$ Description 设$T=(V, E, W)$ 是一个无圈且连通的无向图（也称为无根树），每条边带有正整数的权，我们称$T$为树网（$treenetwork$），其中$V, E$分别表示结点与边的集合，$W$表示各边长度的集合，并设$T$有$n$个结点。 路径：树网中任何两结点$a,b$都存在唯一的一条简单路径，用$d(a,b)$表示以$a,b$为端点的路径的长度，它是该路径上各边长度之和。我们称$d(a,b)$为$a,b$两结点间的距离。 一点$v$到一条路径$P$的距离为该点与$P$上的最近的结点的距离： $d(v，P)=min_{u在P上}{d(v，u)}$。 树网的直径：树网中最长的路径称为树网的直径。对于给定的树网$T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。 偏心距$ECC(F)$：树网$T$中距路径$F$最远的结点到路径$F$的距离，即 。 任务：对于给定的树网$T=(V, E,W)$和非负整数$s$，求一个路径$F$，它是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过$s$（可以等于$s$），使偏心距$ECC(F)$最小。我们称这个路径为树网$T=(V,E,W)$的核（$Core$）。必要时，$F$可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。 下面的图给出了树网的一个实例。图中，$A-B$与$A-C$是两条直径，长度均为$20$。点$W$是树网的中心，$EF$边的长度为$5$。如果指定$s=11$，则树网的核为路径$DEFG$（也可以取为路径$DEF$），偏心距为$8$。如果指定$s=0$（或$s=1$、$s=2$），则树网的核为结点$F$，偏心距为$12$。 Input包含$n$行： 第$1$行，两个正整数$n$和$s$，中间用一个空格隔开。其中$n$为树网结点的个数，$s$为树网的核的长度的上界。设结点编号依次为$1, 2, \cdots, n$。 从第$2$行到第$n$行，每行给出$3$个用空格隔开的正整数，依次表示每一条边的两个端点编号和长度。例如，“$2 4 7$”表示连接结点$2$与$4$的边的长度为$7$。 所给的数据都是正确的，不必检验。 Output只有一个非负整数，为指定意义下的最小偏心距。 Sample Input123455 21 2 52 3 22 4 42 5 3 Sample Output15 HINT 于$70\%$的数据，$n\le 200000$ 对于$100\%$的数据，$n\le 500000$, $s&lt;2^{31}$, $所有权值&lt;500$似乎$SPOJ$上加强版的数据… 标签：树相关 Solution$BZOJ$上加强了数据。原题跑$O(n^3)Floyed$再枚举可过。首先肯定需要两次$DFS$求直径，求法略。显然，在长度不超过$s$的前提下，链越长越好（这样偏心距小）。在直径两端$l$到$r$上维护尽可能长的链，找到左右端点到直径做右端点的较大值的最小值。然后由链上各个点出发，找到不经过直径上的点抵达的其他点的最大深度。这个最大深度和之前的最小值中较大的就是答案。 Code12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 500000#define INF 0x3f3f3f3fusing namespace std;int n, s, l, r;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int d[MAX_N+5], f[MAX_N+5]; bool mrk[MAX_N+5];void add(int u, int v, int c) &#123;G[u].push_back(v), E[u].push_back(c);&#125;void init() &#123;scanf("%d%d", &amp;n, &amp;s); for (int i = 1, u, v, c; i &lt; n; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), add(u, v, c), add(v, u, c);&#125;void DFS(int u) &#123; for (int i = 0; i &lt; (int)G[u].size(); i++) if (G[u][i]^f[u] &amp;&amp; !mrk[G[u][i]]) d[G[u][i]] = d[u]+E[u][i], f[G[u][i]] = u, DFS(G[u][i]);&#125;void getD() &#123; f[1] = d[1] = 0, DFS(1); for (int i = 1; i &lt;= n; i++) if (!r || d[i] &gt; d[r]) r = i; f[r] = d[r] = 0, DFS(r); for (int i = 1; i &lt;= n; i++) if (!l || d[i] &gt; d[l]) l = i; for (int i = l; i; i = f[i]) mrk[i] = true;&#125;void sol() &#123; int ans = INF; for (int i = l, j = l; i; i = f[i]) &#123; while (f[j] &amp;&amp; d[i]-d[f[j]] &lt;= s) j = f[j]; ans = min(ans, max(d[l]-d[i], d[j])); &#125; for (int i = l; i; i = f[i]) d[i] = 0, DFS(i); for (int i = 1; i &lt;= n; i++) ans = max(ans, d[i]); printf("%d", ans);&#125;int main() &#123;init(), getD(), sol(); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树相关</tag>
        <tag>NOIp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4145【AMPPZ2014】The Prices]]></title>
    <url>%2FBZOJ4145%E3%80%90AMPPZ2014%E3%80%91The%20Prices%20%E7%8A%B6%E5%8E%8BDP%2F</url>
    <content type="text"><![CDATA[Problem 【AMPPZ2014】The Prices Time Limit: $20 Sec$ Memory Limit: $256 MB$ Description你要购买$m$种物品各一件，一共有$n$家商店，你到第$i$家商店的路费为$d[i]$，在第$i$家商店购买第$j$种物品的费用为$c[i][j]$，求最小总费用。 Input第一行包含两个正整数$n,m$($1\le n\le 100$,$1\le m\le 16$)，表示商店数和物品数。接下来$n$行，每行第一个正整数$d[i]$($1\le d[i]\le 10^6$)表示到第$i$家商店的路费，接下来$m$个正整数，依次表示$c[i][j]$($1\le c[i][j]&lt; 10^6$)。 Output一个正整数，即最小总费用。 Sample Input12343 45 7 3 7 92 1 20 3 28 1 20 1 1 Sample Output116 HINT在第一家店买$2$号物品，在第二家店买剩下的物品。 标签：状压$DP$ Solution$M\le 16$，显然是一道状压$DP$。用$f[i][j]$表示考虑$1\sim i$家商店，购买状态为$j$的方案数。套路状压转移即可。 Code12345678910111213141516171819#include &lt;bits/stdc++.h&gt;#define MAX_N 100#define MAX_M 16using namespace std;typedef long long lnt;int n, m, d[MAX_N+5], c[MAX_N+5][MAX_M+5], f[MAX_N+5][(1&lt;&lt;MAX_M)+5];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123;scanf("%d", d+i); for (int j = 1; j &lt;= m; j++) scanf("%d", c[i]+j);&#125; memset(f, 0x3f, sizeof f); f[0][0] = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; (1&lt;&lt;m); j++) f[i][j] = f[i-1][j]+d[i]; for (int k = 1; k &lt;= m; k++) for (int j = 0; j &lt; (1&lt;&lt;m); j++) if ((j&amp;(1&lt;&lt;k-1)) == 0) f[i][j|(1&lt;&lt;k-1)] = min(f[i][j]+c[i][k], f[i][j|(1&lt;&lt;k-1)]); for (int j = 0; j &lt; (1&lt;&lt;m); j++) f[i][j] = min(f[i][j], f[i-1][j]); &#125; printf("%d", f[n][(1&lt;&lt;m)-1]); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
        <tag>AMPPZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4144【AMPPZ2014】Petrol]]></title>
    <url>%2FBZOJ4144%E3%80%90AMPPZ2014%E3%80%91Petrol%20MST%2F</url>
    <content type="text"><![CDATA[Problem 【AMPPZ2014】Petrol Time Limit: $10 Sec$ Memory Limit: $256 MB$ Description给定一个$n$个点、$m$条边的带权无向图，其中有$s$个点是加油站。每辆车都有一个油量上限$b$，即每次行走距离不能超过$b$，但在加油站可以补满。$q$次询问，每次给出$x,y,b$，表示出发点是$x$，终点是$y$，油量上限为$b$，且保证$x$点和$y$点都是加油站，请回答能否从$x$走到$y$。 Input第一行包含三个正整数$n,s,m$($2\le s\le n\le 2\times 10^5$,$1\le m\le 2\times 10^5$)，表示点数、加油站数和边数。第二行包含$s$个互不相同的正整数$c[1],c[2],…cs$，表示每个加油站。接下来$m$行，每行三个正整数$u[i]$,$v[i]$,$d[i]$($1\le u[i],v[i]\le n$,$u[i]\ne v[i]$,$1\le d[i]\le 10^5$)，表示$u[i]$和$v[i]$之间有一条长度为$d[i]$的双向边。接下来一行包含一个正整数$q$($1\le q\le 2\times 10^5$)，表示询问数。接下来$q$行，每行包含三个正整数$x[i],y[i],b[i]$($1\le x[i],y[i]\le n$,$x[i]\ne y[i]$,$1\le b[i]\le 2\times 10^9$)，表示一个询问。 Output输出$q$行。第$i$行输出第$i$个询问的答案，如果可行，则输出$TAK$，否则输出$NIE$。 Sample Input1234567891011126 4 51 5 2 61 3 12 3 23 4 34 5 56 4 541 2 42 6 91 5 96 5 8 Sample Output1234TAKTAKTAKNIE 标签：最短路预处理$+MST$ Solution一道精妙的$MST$题。首先考虑走到一个点，先去离它最近的加油站，回来后再去下一个点肯定比直接去要优。于是用多源最短路预处理出每个点到它最近的加油站的距离，随后给每一条边分别加上它的起点和终点离它们最近加油站的距离。对于询问，先离线下来按$b$值排序，按照边权加入边，用并查集维护。对于每个询问，先将比它的$b$值小的所有边都加入，再询问起点和终点是否联通即可。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define fir first#define sec second#define mp make_pair#define pii pair&lt;int,int&gt;#define MAX_N 200000using namespace std;int n, m, s, c[MAX_N+5], fa[MAX_N+5], dis[MAX_N+5]; vector &lt;pii&gt; G[MAX_N+5];struct edge &#123;int u, v, c; bool operator &lt; (const edge &amp;t) const &#123;return c &lt; t.c;&#125;&#125; E[MAX_N+5];struct query &#123;int id, u, v, c; bool operator &lt; (const query &amp;t) const &#123;return c &lt; t.c;&#125;&#125; Q[MAX_N+5];int getf(int x) &#123;return fa[x] == x ? x : fa[x] = getf(fa[x]);&#125;void Dijkstra() &#123; priority_queue &lt;pii&gt; que; bool mrk[MAX_N+5]; memset(dis, 0x7f, sizeof dis), memset(mrk, false, sizeof mrk); for (int i = 1; i &lt;= s; i++) dis[c[i]] = 0, que.push(mp(-dis[c[i]], c[i])); while (!que.empty()) &#123; int u = que.top().sec; que.pop(); if (mrk[u]) continue; mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i].fir, w = G[u][i].sec; if (dis[u]+w &lt; dis[v]) dis[v] = dis[u]+w, que.push(mp(-dis[v], v)); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;s, &amp;m); for (int i = 1; i &lt;= s; i++) scanf("%d", c+i); for (int i = 1; i &lt;= m; i++) scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].c), G[E[i].u].push_back(mp(E[i].v, E[i].c)), G[E[i].v].push_back(mp(E[i].u, E[i].c)); Dijkstra(); for (int i = 1; i &lt;= m; i++) E[i].c += dis[E[i].u]+dis[E[i].v]; int q; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) Q[i].id = i, scanf("%d%d%d", &amp;Q[i].u, &amp;Q[i].v, &amp;Q[i].c); sort(E+1, E+m+1), sort(Q+1, Q+q+1); for (int i = 1; i &lt;= n; i++) fa[i] = i; bool ans[MAX_N+5]; for (int i = 1, j = 1; i &lt;= q; i++) &#123; for (int u, v; j &lt;= m &amp;&amp; E[j].c &lt;= Q[i].c; j++) if ((u = getf(E[j].u)) != (v = getf(E[j].v))) fa[u] = v; ans[Q[i].id] = getf(Q[i].u) == getf(Q[i].v); &#125; for (int i = 1; i &lt;= q; i++) puts(ans[i] ? "TAK" : "NIE"); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>最短路</tag>
        <tag>AMPPZ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1468 Tree]]></title>
    <url>%2FBZOJ1468%20Tree%20%E7%82%B9%E5%88%86%E6%B2%BB%2F</url>
    <content type="text"><![CDATA[Problem Tree Time Limit: $10 Sec$ Memory Limit: $64 MB$ Description给你一棵树以及这棵树上边的距离.问有多少对点它们两者间的距离小于等于$K$ Input$N$（$N\le 40000$） 接下来$n-1$行边描述管道，按照题目中写的输入 接下来是$K$ Output一行，有多少对点之间的距离小于等于$K$ Sample Input1234567871 6 13 6 3 9 3 5 7 4 1 3 2 4 20 4 7 2 10 Sample Output15 标签：点分治 Solution点分治板题。对于每个点，我们计算穿过它的路径的条数。这个值等于它的子树中所有深度之和小于$k$的点对数，可以双指针搞一搞。但这样两个在同一儿子内的点对会算重，所以需要减去它的每个儿子的子树中深度之和小于$k-c$的点对数，其中$c$为它到此儿子的距离。这也可以双指针搞一搞。对于每次分治，我们都要找到当前子树的重心，以保证复杂度为$O(n\log(n))$。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;#define MAX_N 40000using namespace std;int n, k, rt, s[MAX_N+5], h[MAX_N+5], d[MAX_N+5], tot, ans;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5], dep; bool mrk[MAX_N+5];void addedge(int u, int v, int c) &#123;G[u].push_back(v), E[u].push_back(c);&#125;void getrt(int u, int fa) &#123; s[u] = 1, h[u] = 0; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa || mrk[v]) continue; getrt(v, u), s[u] += s[v], h[u] = max(h[u], s[v]); &#125; h[u] = max(h[u], tot-s[u]); if (h[u] &lt; h[rt]) rt = u;&#125;void getdep(int u, int fa) &#123; dep.push_back(d[u]), s[u] = 1; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (v == fa || mrk[v]) continue; d[v] = d[u]+c, getdep(v, u), s[u] += s[v]; &#125;&#125;int calc(int u, int init) &#123; dep.clear(), d[u] = init, getdep(u, 0), sort(dep.begin(), dep.end()); int ret = 0; for (int l = 0, r = (int)dep.size()-1; l &lt; r; ) dep[l]+dep[r] &lt;= k ? ret += r-l++ : r--; return ret;&#125;void DFS(int u) &#123; ans += calc(u, 0), mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (mrk[v]) continue; ans -= calc(v, c), h[0] = tot = s[v], getrt(v, rt = 0), DFS(rt); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1, u, v, c; i &lt; n; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), addedge(u, v, c), addedge(v, u, c); scanf("%d", &amp;k); h[0] = tot = n, getrt(1, 0); DFS(rt); printf("%d", ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>树分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3632 外太空旅行]]></title>
    <url>%2FBZOJ3632%20%E5%A4%96%E5%A4%AA%E7%A9%BA%E6%97%85%E8%A1%8C%20%E9%9A%8F%E6%9C%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem 外太空旅行 Time Limit: $5 Sec$ Memory Limit: $128 MB$ Description在人类的触角伸向银河系的边缘之际，普通人上太空旅行已经变得稀松平常了。某理科试验班有$n$个人，现在班主任要从中选出尽量多的人去参加一次太空旅行活动。可是$n$名同学并不是和平相处的。有的人，比如小$A$和小$B$整天狼狈为奸，是好朋友；但还有的人，比如杜鲁门和赫鲁晓夫就水火不相容。这$n$名同学，由于是理科生，都非常的理性，所以“朋友的朋友就是朋友”和“敌人的朋友就是敌人”这两句话对这些同学无效。换句话说，有可能小$A$和小$B$是朋友，小$B$和小$C$是朋友，但是小$A$和小$C$两人势如水火。任意两个人之间要不就是敌人，要不就是朋友。因为在太空船上发生人员斗殴事件是很恶劣也很危险的，因此选出来参加旅行活动的同学必须互相之间都是朋友。你的任务就是确定最多可以选多少人参加旅行。 Input第一行一个整数$n$($1\le n\le 50$)。所有的同学按照$1\sim n$编号。接下来若干行，每行两个用空格隔开的整数$a, b$ ($1\le a,b\le n$)，表示$a$和$b$是朋友。注意：如果一个数对$(x,y)$或者$(y,x)$没有在文件中出现，那么编号为$x$和$y$的两个同学就是敌人。 Output仅仅一个数，即最多可以选多少人参加活动。 Sample Input1234541 22 33 11 4 Sample Output13 说明：选编号为$1,2,3$的同学参加，他们互相都是朋友。 标签：最大团，随机化 Solution一道随机化最大团的裸题。每次随机出一个$1\sim n$的乱序排列，按照排列顺序贪心，这样随机$10^5$次取最大值即可。 Code12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;#define MAX_N 50#define BOUND 100000using namespace std;int n, seq[MAX_N+5], ans;bool G[MAX_N+5][MAX_N+5], mrk[MAX_N+5];int calc() &#123; memset(mrk, false, sizeof mrk); int ret = 0; for (int i = 1; i &lt;= n; i++) if (!mrk[seq[i]]) &#123; ret++, mrk[seq[i]] = true; for (int j = i+1; j &lt;= n; j++) if (!G[seq[i]][seq[j]]) mrk[seq[j]] = true; &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); int u, v; while (~scanf("%d%d", &amp;u, &amp;v)) G[u][v] = G[v][u] = true; for (int i = 1; i &lt;= n; i++) seq[i] = i; for (int i = 0; i &lt; BOUND; i++) random_shuffle(seq+1, seq+n+1), ans = max(ans, calc()); printf("%d", ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>随机化</tag>
        <tag>最大团</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4148【AMPPZ2014】Pillars]]></title>
    <url>%2FBZOJ4148%E3%80%90AMPPZ2014%E3%80%91Pillars%20%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[Problem 【AMPPZ2014】Pillars Time Limit: $5 Sec$ Memory Limit: $256 MB$ $Special Judge$ Description给定一个$n\times m$的矩形，其中有f个$2\times 2$的障碍物，其中任意两个障碍物中心之间的欧几里得距离至少为$6$，且每个障碍物的中心到边缘的距离至少为$3$。请找到一条从左下角$(1,1)$出发经过所有没有障碍物的点各一次的且最后回到左下角的回路。 Input第一行包含三个整数$n,m,f$($1\le n,m\le 1000$且$n,m$都为偶数)。接下来$f$行，每行两个整数$x,y$($1\le x&lt;n$, $1\le y&lt;m$)，表示该障碍物左下角的坐标。 Output如果无解，输出$NIE$，否则第一行输出$TAK$，第二行输出方案。方案包含$n\times m-4\times f$个字符，第$i$个字符表示第$i$步的移动方向，用$G$表示上，$D$表示下，$L$表示左，$P$表示右。 Sample Input12312 6 23 39 3 Sample Output12TAKPPPPPPPPPPPGGGLDDLLLLLGPPGLLLDDLLLGGGPPPPPPPPPPGLLLLLLLLLLLDDDDD Hint 标签：构造 Solution一道很适合构造入门的题。我看了$Claris$的题解才想出来。首先不考虑障碍，构造出一个走过全部格子的走法。由于$n$和$m$均为偶数，一定有解。然后考虑障碍，对障碍四周的格子的方向进行修改。由于两个障碍间距离至少为$3$，故任两个障碍不会影响，只会有两大类。具体构造方法参见代码。 Code12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define MAX_N 1000using namespace std;int n, m, f; char s[MAX_N+5][MAX_N+5];int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;f); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) s[i][j] = i&amp;1 ? 'D' : 'G'; for (int i = 1; i &lt;= n; i++) &#123; if (i^n) s[i][1] = 'P'; if ((i^1) &amp;&amp; (i&amp;1)) s[i][2] = 'L'; if (!(i&amp;1)) s[i][m] = 'L'; &#125; for (int i = 0; i &lt; f; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); if (x&amp;1) s[x][y+2] = 'P', s[x+1][y-1] = 'L', s[x+1][y+2] = 'P', s[x+2][y+3] = 'L'; else if (y^3) s[x][y-1] = 'P', s[x+1][y-1] = 'P', s[x+1][y+2] = 'L', s[x+2][y-2] = 'L'; else s[x][1] = 'G', s[x][2] = 'P', s[x+1][2] = 'D', s[x+1][5] = 'L'; &#125; puts("TAK"); for (int x = 1, y = 1, lft = n*m-4*f; lft; lft--) &#123; putchar(s[x][y]); if (s[x][y] == 'P') x++; else if (s[x][y] == 'L') x--; else if (s[x][y] == 'G') y++; else y--; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>AMPPZ</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2396 神奇的矩阵]]></title>
    <url>%2FBZOJ2396%20%E7%A5%9E%E5%A5%87%E7%9A%84%E7%9F%A9%E9%98%B5%20%E9%9A%8F%E6%9C%BA%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Problem 神奇的矩阵 Time Limit: $5 Sec$ Memory Limit: $512 MB$ Description给出三个行数和列数均为$N$的矩阵$A$、$B$、$C$，判断$A\times B=C$是否成立。 Input题目可能包含若干组数据。对于每组数据，第一行一个数$N$，接下来给出三个$N\times N$的矩阵，依次为$A$、$B$、$C$三个矩阵。 Output对于每组数据，若$A\times B=C$成立，则输出$Yes$，否则$No$。每个答案占一行。 Sample Input1234122100 Sample Output1No HINT对于$90\%$的数据，$N$不超过$100$；对于$100\%$的数据，$N$不超过$1000$，矩阵中的数字大于等于$0$小于$1000$，数据组数不超过$5$组。 标签：矩阵乘法，随机化 Solution挺巧妙的一道随机化题。首先考虑直接乘，由于$N\le 1000$，而矩乘是$O(n^3)$，肯定会$TLE$。我们发现矩阵太大了，那么我们就要压缩矩阵，把这样一个正方形的矩阵压缩为一个行矩阵或列矩阵。我们先随机出一个$1\times n$的列矩阵$R$，这样$A\times B\times R=A\times (B\times R)$，将结果与$C\times R$比较。这样乘法的复杂度就降为$O(n^2)$，比较复杂度为$O(n)$，总复杂度为$O(n^2)$。如果觉得随机一次不保险，还可以多随机几次，不过只随一次也很容易过。 Code123456789101112131415161718192021222324252627#include &lt;bits/stdc++.h&gt;#define MAX_N 1000#define MOD 1000000007using namespace std;int n;struct Matrix &#123; int r, c; long long ele[MAX_N][MAX_N]; inline Matrix operator * (const Matrix &amp;x) const &#123; Matrix ret; memset(ret.ele, 0, sizeof(ret.ele)); for (int i = 0; i &lt; (ret.r = r); i++) for (int j = 0; j &lt; (ret.c = x.c); j++) for (int k = 0; k &lt; c; k++) ret.ele[i][j] = (ret.ele[i][j]+ele[i][k]*x.ele[k][j])%MOD; return ret; &#125;&#125; A, B, C, R;int main() &#123; while (scanf("%d", &amp;n)) &#123; A.r = A.c = n; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%lld", &amp;A.ele[i][j]); B.r = B.c = n; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%lld", &amp;B.ele[i][j]); C.r = C.c = n; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) scanf("%lld", &amp;C.ele[i][j]); srand(19260817); R.r = n, R.c = 1; for (int i = 0; i &lt; n; i++) R.ele[i][0] = rand()*rand()%MOD; A = A*(B*R), C = C*R; bool flag = true; for (int i = 0; i &lt; n; i++) flag &amp;= (A.ele[i][0] == C.ele[i][0]); puts(flag ? "Yes" : "No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4152【AMPPZ2014】The Captain]]></title>
    <url>%2FBZOJ4152%E3%80%90AMPPZ2014%E3%80%91The%20Captain%20%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[Problem 【AMPPZ2014】The Captain Time Limit: $20 Sec$ Memory Limit: $256 MB$ Description给定平面上的$n$个点，定义$(x1,y1)$到$(x2,y2)$的费用为$min(|x1-x2|,|y1-y2|)$，求从$1$号点走到$n$号点的最小费用。 Input第一行包含一个正整数$n$($2\le n\le 2\times 10^5$)，表示点数。接下来$n$行，每行包含两个整数$x[i]$,$y[i]$($0\le x[i],y[i]\le 10^9$)，依次表示每个点的坐标。 Output一个整数，即最小费用。 Sample Input12345652 21 14 57 16 7 Sample Output12 标签：最短路径 Solution一道比较基础的最短路变形。不难发现，在一个凸壳上，如果走任意一条弦，显然没有直接沿着凸壳走优。所以分别按$x$和$y$排两次序，相邻点连边，可得到一个图。在此图上跑最短路即可。注意，此题卡$SPFA$（大佬：不错啊，卡错误算法天经地义~） Code1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;#define MAX_N 200000#define fir first#define sec second#define mp make_pair#define pli pair&lt;lnt,int&gt;using namespace std;typedef long long lnt;int n; lnt dis[MAX_N+5];vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];struct node &#123;int id, x, y;&#125; p[MAX_N+5];bool cmpx(const node &amp;a, const node &amp;b) &#123;return a.x &lt; b.x;&#125;bool cmpy(const node &amp;a, const node &amp;b) &#123;return a.y &lt; b.y;&#125;void addedgex(int u, int v, int a, int b) &#123;G[u].push_back(v), E[u].push_back(p[b].x-p[a].x);&#125;void addedgey(int u, int v, int a, int b) &#123;G[u].push_back(v), E[u].push_back(p[b].y-p[a].y);&#125;void Dijkstra() &#123; memset(dis, 0x7f, sizeof dis), dis[1] = 0; priority_queue &lt;pli&gt; que; que.push(mp(0LL, 1)); bool mrk[MAX_N+5]; memset(mrk, false, sizeof mrk); while (!que.empty()) &#123; int u = que.top().sec; que.pop(); if (mrk[u]) continue; mrk[u] = true; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i]; lnt c = E[u][i]; if (mrk[v] || dis[u]+c &gt; dis[v]) continue; dis[v] = dis[u]+c, que.push(mp(-dis[v], v)); &#125; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) p[i].id = i, scanf("%d%d", &amp;p[i].x, &amp;p[i].y); sort(p+1, p+n+1, cmpx); for (int i = 1; i &lt; n; i++) addedgex(p[i].id, p[i+1].id, i, i+1), addedgex(p[i+1].id, p[i].id, i, i+1); sort(p+1, p+n+1, cmpy); for (int i = 1; i &lt; n; i++) addedgey(p[i].id, p[i+1].id, i, i+1), addedgey(p[i+1].id, p[i].id, i, i+1); Dijkstra(); printf("%lld", dis[n]); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>AMPPZ</tag>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NOIp2017提高组总结]]></title>
    <url>%2FNOIp2017%E6%8F%90%E9%AB%98%E7%BB%84%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[NOIp2017滚粗记Day0周五上午，想到下午就要去考场了，就不刷题了吧。毕竟前一周我已把历年NOIp真题刷完了（个别太早的题没做）。于是就打了打板。当时觉得没什么可复习的了，于是就只打了树剖、线筛和tarjan的板。接着颓了一会儿纸牌和扫雷。aziint此时正在写一道点双连通分量的题解，突然意识到我几种无向图连通分量（割点和桥）还没复习。赶快去看了看博客。一个上午就没了。下午到考场。吃饭前简略看了看树分治。晚上开会的时候又想到欧拉图还没复习，好多年没考过了，赶快看看，免得真考到了。 Day1刚上场就被T1搞得一脸懵逼。蛤？数论题放D1T1？或者说结论题？推了半小时exGCD，果断弃坑。由于先前没读T2（T2题面太长太烦不想读），气氛挺紧张。还好这时我先看了T2而没跳到T3，读完T2发现好简单，索性栈模拟。码到一半发现貌似栈上东西挺多，突然意识到可以递归模拟，肯定好写得多。不过没管，都码了2/3了，索性码完。水完T2倒回来看T1，打了一个20x20的表，把不互质的情况去掉，发现规律很显然，不就是(a-1)*(b-1)-1吗？赶快水掉。T3看到后觉得难度不算太大。发现可以最短路预处理+DP做。这时还没想到拆点，只想到一个带50大常数的容斥。考场上思维没那么开阔，打了容斥DP，调了半小时才过样例。大样例貌似T了，跑了5秒看没出结果我就没管了。回去看T2，总觉得T2会出锅，多出了几组自测小数据，好像没锅。（？）考完后发现T3的容斥有些问题，遇到正环会死循环（因为我采用的是类似SPFA的DP顺序，而容斥的时候没及时清零）。成绩出来后才发现T2只有50分。崩溃地发现把字符串转数字码错了…12for (int i = 0; i &lt; strlen(s); i++) ret = ret*10+s[i]-'0'; //正确代码for (int i = 0; i &lt; strlen(s); i++) ret = ret*10+i-'0'; //我考试时写的，脑抽无极限... 最后只好100+50+20=170滚粗 Day2拿到题目，担心Day1简单Day2会很难，结果看到T1就打消了顾虑。T1是难得的大水题啊，直接并查集水过。T2看到数据范围n&lt;=12就想到了状压DP，但想得不够深，始终在想如何存存下一棵子树的形态。后来又想到了哈夫曼树的贪心，没注意到此题的顺序和贪心顺序是反的，打了一个错误的贪心，花了一个半小时，还自己把自己卡死了。水了40的树DP部分分。T3显然是数据结构题，看到就有种Splay的感觉。但是我Splay板都打不熟，而Splay又是省选内容，再加上时间不太够，就没打Splay。先水了30分的裸暴力，又用BIT+二分写了20分的x=1的情况…结果二分的时候更新打错了。最后100+40+30=170滚粗 ##总结两天合起来是340分。尴尬而耻辱的分数段，毕竟我当场估分时450，因为三道题打错而挂了110分。其实也是自己的锅。十连测阶段我光顾着改题，代码能力有所下滑。这在冬令营之前一定要补起来，虽然我今年大概是进不了冬令营的了。此耻明年必报。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LG1155【NOIp2008】双栈排序]]></title>
    <url>%2FLG1155%E3%80%90NOIp2008%E3%80%91%E5%8F%8C%E6%A0%88%E6%8E%92%E5%BA%8F%20%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9F%93%E8%89%B2%2F</url>
    <content type="text"><![CDATA[Problem【NOIp2008】双栈排序题目描述$Tom$最近在研究一个有趣的排序问题。如图所示，通过$2$个栈$S_1$和$S_2$，$Tom$希望借助以下$4$种操作实现将输入序列升序排序。操作$a$: 如果输入序列不为空，将第一个元素压入栈$S_1$操作$b$: 如果栈$S_1$不为空，将$S_1$栈顶元素弹出至输出序列操作$c$: 如果输入序列不为空，将第一个元素压入栈$S_2$操作$d$: 如果栈$S_2$不为空，将$S_2$栈顶元素弹出至输出序列如果一个$1\sim n$的排列$P$可以通过一系列操作使得输出序列为$1,2,\cdots(n-1),n$，$Tom$就称$P$是一个“可双栈排序排列”。例如$(1,3,2,4)$就是一个“可双栈排序序列”，而$(2,3,4,1)$不是。下图描述了一个将$(1,3,2,4)$排序的操作序列：$&lt;a,c,c,b,a,d,d,b&gt;$ 当然，这样的操作序列有可能有几个，对于上例$(1,3,2,4)$，$&lt;a,c,c,b,a,d,d,b&gt;$是另外一个可行的操作序列。$Tom$希望知道其中字典序最小的操作序列是什么。 输入输出格式输入格式：输入文件$twostack.in$的第一行是一个整数$n$。第二行有$n$个用空格隔开的正整数，构成一个$1\sim n$的排列。输出格式：输出文件$twostack.out$共一行，如果输入的排列不是“可双栈排序排列”，输出数字$0$；否则输出字典序最小的操作序列，每两个操作之间用空格隔开，行尾没有空格。 输入输出样例输入样例$#1$：1241 3 2 4 输出样例$#1$：1a b a a b b a b 输入样例$#2$：1242 3 4 1 输出样例$#2$：10 输入样例$#3$：1232 3 1 输出样例$#3$：1a c a b b d 说明$30\%$的数据满足： $n\le10$$50\%$的数据满足： $n\le 50$$100\%$的数据满足： $n\le 1000$ 标签：二分图染色 Solution一道很有意思的联赛题。对于任意两数$i,j,k$，若有$i&lt;j&lt;k,a_k&lt;a_i&lt;a_j$，为了使$a_k$最先出栈，那么$a_i$和$a_j$一定在$a_k$之后出栈，若顺次放进同一个栈，那么$a_j$必然在$a_i$之前出栈，不满足题意。因此遇到这种情况$a_i$和$a_j$一定分别放入两个栈中。据此，只要存在$i&lt;j&lt;k$，有$a_k&lt;a_i&lt;a_j$，那么$a_i$和$a_j$一定在不同栈中。这样就构成了一个二分图。扫描一遍，确定那些数对不能在同一栈中，确定互斥关系。若不能构成二分图，那么就不可排序。否则在判断过程中染色，确定不同数在哪个栈中，模拟排序过程，每次等到当前排到的数进栈后把能出栈的都出栈。 Code1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;#define MAX_N 1000using namespace std;vector &lt;int&gt; G[MAX_N+5];int n, a[MAX_N+5], mi[MAX_N+5], col[MAX_N+5];void DFS(int u) &#123; for (auto v : G[u]) &#123; if (!col[v]) col[v] = -col[u], DFS(v); if (col[u] == col[v]) &#123;puts("0"); exit(0);&#125; &#125;&#125;void prt() &#123; int cur = 1; stack &lt;int&gt; sa, sb; for (int i = 1; i &lt;= n; i++) &#123; if (col[i] == 1) putchar('a'), putchar(' '), sa.push(a[i]); else putchar('c'), putchar(' '), sb.push(a[i]); for (; !sa.empty() &amp;&amp; sa.top() == cur; sa.pop(), cur++) putchar('b'), putchar(' '); for (; !sb.empty() &amp;&amp; sb.top() == cur; sb.pop(), cur++) putchar('d'), putchar(' '); for (; !sa.empty() &amp;&amp; sa.top() == cur; sa.pop(), cur++) putchar('b'), putchar(' '); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); mi[n+1] = 0x3f3f3f3f; for (int i = n; i; i--) mi[i] = min(a[i], mi[i+1]); for (int i = 1; i &lt;= n; i++) for (int j = i+1; j &lt;= n; j++) if (a[i] &lt; a[j] &amp;&amp; mi[j+1] &lt; a[i]) G[i].push_back(j), G[j].push_back(i); for (int i = 1; i &lt;= n; i++) if (!col[i]) col[i] = 1, DFS(i); prt(); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>NOIp</tag>
        <tag>LG</tag>
        <tag>二分图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LG1967【NOIp2013】货车运输]]></title>
    <url>%2FLG1967%E3%80%90NOIp2013%E3%80%91%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%20LCA%2F</url>
    <content type="text"><![CDATA[Problem货车运输题目描述$A$ 国有 $n$ 座城市，编号从 $1$ 到 $n$，城市之间有 $m$ 条双向道路。每一条道路对车辆都有重量限制，简称限重。现在有 $q$ 辆货车在运输货物， 司机们想知道每辆车在不超过车辆限重的情况下，最多能运多重的货物。 输入输出格式输入格式：输入文件名为 $truck.in$。输入文件第一行有两个用一个空格隔开的整数 $n$, $m$，表示 $A$ 国有 $n$ 座城市和 $m$ 条道路。 接下来 $m$ 行每行 $3$ 个整数 $x$、 $y$、 $z$，每两个整数之间用一个空格隔开，表示从 $x$ 号城市到 $y$ 号城市有一条限重为 $z$ 的道路。注意： $x$ 不等于 $y$，两座城市之间可能有多条道路 。接下来一行有一个整数 $q$，表示有 $q$ 辆货车需要运货。接下来 $q$ 行，每行两个整数 $x$、$y$，之间用一个空格隔开，表示一辆货车需要从 $x$ 城市运输货物到 $y$ 城市，注意： $x$ 不等于 $y$ 。输出格式：输出文件名为 $truck.out$。输出共有 $q$ 行，每行一个整数，表示对于每一辆货车，它的最大载重是多少。如果货车不能到达目的地，输出$-1$。 输入输出样例输入样例$#1$：123456784 31 2 42 3 33 1 131 31 41 3 输出样例$#1$：1233-13 说明对于 $30\%$的数据，$0 &lt; n &lt; 1000$，$0 &lt; m &lt; 10000$，$0 &lt; q&lt; 1000$；对于 $60\%$的数据，$0 &lt; n &lt; 1000$，$0 &lt; m &lt; 50000$，$0 &lt; q&lt; 1000$；对于 $100\%$的数据，$0 &lt; n &lt; 10000$，$0 &lt; m &lt; 50000$，$0 &lt; q&lt; 30000$，$0 \le z \le 100000$。 标签：$MST$，$LCA$ Solution$LCA$经典例题。为了使得货车走过的路径上最小权最大，又要使其能到任意两点，那么该图可以缩减成一棵树，为了保证最优解，该树采用原图的最大生成树。对于一次询问，在最大生成树上跑两点的$LCA$，倍增统计路径最小值即可。不错的板题 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAX_N 10000#define MAX_M 50000#define INF 2147483647using namespace std;int n, m, q, cnt;int first[MAX_N+5], d[MAX_N+5], p[MAX_N+5][15], f[MAX_N+5][15];int father[MAX_N+5];bool vis[MAX_N+5];struct Edge &#123; int from, to, c, next;&#125;;Edge G[MAX_M], edge[MAX_M+5];inline int read() &#123; int ret = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret*10+ch-'0', ch = getchar(); return ret;&#125;bool cmp (const Edge &amp;a, const Edge &amp;b) &#123; return a.c &gt; b.c;&#125;void Add(int u, int v, int x) &#123; cnt++; edge[cnt].to = v; edge[cnt].c = x; edge[cnt].next = first[u]; first[u] = cnt;&#125;int get_father(int cur) &#123; if (father[cur] != cur) father[cur] = get_father(father[cur]); return father[cur];&#125;void Kruskal() &#123; sort(G, G+m, cmp); for (int i = 1; i &lt;= n; i++) father[i] = i; for (int i = 0; i &lt; m; i++) &#123; int u = get_father(G[i].from), v = get_father(G[i].to); if (u != v) &#123; father[u] = v; Add(G[i].from, G[i].to, G[i].c); Add(G[i].to, G[i].from, G[i].c); &#125; &#125;&#125;void DFS(int u) &#123; vis[u] = true; for (int i = 1; (1&lt;&lt;i) &lt;= d[u]; i++) &#123; p[u][i] = p[p[u][i-1]][i-1]; f[u][i] = min(f[u][i-1], f[p[u][i-1]][i-1]); &#125; for (int i = first[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (!vis[v]) &#123; d[v] = d[u]+1; p[v][0] = u; f[v][0] = edge[i].c; DFS(v); &#125; &#125;&#125;int LCA(int a, int b) &#123; int ret = INF, i, j; if (d[a] &lt; d[b]) swap(a, b); for (i = 0; (1&lt;&lt;i) &lt;= d[a]; i++) &#123;&#125; i--; for (j = i; j &gt;= 0; j--) &#123; if (d[a]-(1&lt;&lt;j) &gt;= d[b]) &#123; ret = min(ret, f[a][j]); a = p[a][j]; &#125; &#125; if (a == b) return ret; for (j = i; j &gt;= 0; j--) &#123; if (p[a][j] != p[b][j]) &#123; ret = min(ret, min(f[a][j], f[b][j])); a = p[a][j]; b = p[b][j]; &#125; &#125; return min(ret, min(f[a][0], f[b][0]));&#125;int main() &#123; memset(f, 127, sizeof(f)); n = read(), m = read(); for (int i = 0; i &lt; m; i++) &#123; G[i].from = read(), G[i].to = read(), G[i].c = read(); &#125; Kruskal(); for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; father[i] == i) &#123; DFS(i); &#125; &#125; q = read(); for (int i = 0; i &lt; q; i++) &#123; int a, b; a = read(), b = read(); if (get_father(a) != get_father(b)) &#123; printf("-1\n"); &#125; else &#123; printf("%d\n", LCA(a, b)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>LCA</tag>
        <tag>MST</tag>
        <tag>NOIp</tag>
        <tag>LG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4565【HAOI2016】字符合并]]></title>
    <url>%2FBZOJ4565%E3%80%90HAOI2016%E3%80%91%E5%AD%97%E7%AC%A6%E5%90%88%E5%B9%B6%20%E7%8A%B6%E5%8E%8BDP%2F</url>
    <content type="text"><![CDATA[Problem 【HAOI2016】字符合并 Time Limit: $20 Sec$ Memory Limit: $256 MB$ Description有一个长度为 $n$ 的 $01$ 串，你可以每次将相邻的 $k$ 个字符合并，得到一个新的字符并获得一定分数。得到的新字符和分数由这 $k$ 个字符确定。你需要求出你能获得的最大分数。 Input第一行两个整数$n$，$k$。接下来一行长度为$n$的$01$串，表示初始串。接下来$2^k$行，每行一个字符$c_i$和一个整数$w_i$，$c_i$表示长度为$k$的$01$串连成二进制后按从小到大顺序得到的第$i$种合并方案得到的新字符，$w_i$表示对应的第$i$种方案对应获得的分数。$1\le n\le 300$, $0\le c_i\le 1$, $w_i\ge 1$, $k\le 8$ Output输出一个整数表示答案 Sample Input1234563 21011 101 100 201 30 Sample Output140 标签：状压DP Solution这显然是一道状压$DP$（$k\le 8$）考虑用$f[i][j][k]$表示将字符序列$[i, j]$表示为状态$k$的最大分数。初始状态为$f[i][i][s[i]] = 0$ ($1\le i\le n$)转移则将$[i, j]$斩成两半$[i, mid]$和$[mid+1, j]$，$f[i][j][k&lt;&lt;1] = max{f[i][mid][k]+f[mid+1][j][0]}$，$f[i][j][k&lt;&lt;1|1] = max{f[i][mid][k]+f[mid+1][j][1]}$。特别需要注意的是，当$(j-i)|(m-1)$时（$m$为题目中的$k$），会刚好变为一个字符，因此不能像上面那样递推，应为$f[i][j][0] = max{f[i][j][sta]+w[sta]}$($0\le sta&lt;(1&lt;&lt;m)$且$sta$可为$0$)，$f[i][j][1] = max{f[i][j][sta]+w[sta]}$($0\le sta&lt;(1&lt;&lt;m)$且$sta$可为$0$)。 Code12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_K 8#define MAX_N 300using namespace std;typedef long long lnt;char str[MAX_N+5];int n, m, s[MAX_N+5], c[1&lt;&lt;MAX_K];lnt w[1&lt;&lt;MAX_K], f[MAX_N+5][MAX_N+5][1&lt;&lt;MAX_K];void upd(lnt &amp;a, lnt b) &#123;if (a &lt; b) a = b;&#125;int main() &#123; scanf("%d%d%s", &amp;n, &amp;m, str), memset(f, -1, sizeof(f)); for (int i = 0; i &lt; (1&lt;&lt;m); i++) scanf("%d%lld", c+i, w+i); for (int i = 1; i &lt;= n; i++) s[i] = str[i-1]-'0', f[i][i][s[i]] = 0; for (int l = 2; l &lt;= n; l++) for (int s = 1, t = s+l-1; t &lt;= n; t = ++s+l-1) &#123; int tar = l-1; while (tar &gt;= m) tar -= m-1; for (int mid = t-1; mid &gt;= s; mid -= m-1) for (int sta = 0; sta &lt; (1&lt;&lt;tar); sta++) &#123; if (~f[s][mid][sta] &amp;&amp; ~f[mid+1][t][0]) upd(f[s][t][sta&lt;&lt;1], f[s][mid][sta]+f[mid+1][t][0]); if (~f[s][mid][sta] &amp;&amp; ~f[mid+1][t][1]) upd(f[s][t][sta&lt;&lt;1|1], f[s][mid][sta]+f[mid+1][t][1]); &#125; if (tar == m-1) &#123; lnt g[2]; g[0] = g[1] = -1; for (int sta = 0; sta &lt; (1&lt;&lt;m); sta++) if (~f[s][t][sta]) upd(g[c[sta]], f[s][t][sta]+w[sta]); f[s][t][0] = g[0], f[s][t][1] = g[1]; &#125; &#125; lnt ans = 0; for (int i = 0; i &lt; (1&lt;&lt;m); i++) ans = max(ans, f[1][n][i]); printf("%lld", ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4491 我也不知道题目名字是什么]]></title>
    <url>%2FBZOJ4491%20%E6%88%91%E4%B9%9F%E4%B8%8D%E7%9F%A5%E9%81%93%E9%A2%98%E7%9B%AE%E5%90%8D%E5%AD%97%E6%98%AF%E4%BB%80%E4%B9%88%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem 我也不知道题目名字是什么 Time Limit: $10 Sec$ Memory Limit: $512 MB$ Description给定一个序列$A[i]$，每次询问$l,r$，求$[l,r]$内最长子串，使得该子串为不上升子串或不下降子串 Input第一行$n$，表示$A$数组有多少元素接下来一行为$n$个整数$A[i]$接下来一个整数$Q$，表示询问数量接下来$Q$行，每行$2$个整数$l, r$ Output对于每个询问，求$[l,r]$内最长子串，使得该子串为不上升子串或不下降子串 Sample Input1234567891 2 3 4 5 6 5 4 351 61 72 71 95 9 Sample Output1234566564 //样例解释五个询问分别对应$[1,6][1,6][2,6][1,6][6,9]$ HINT$N,Q\le 50000$ Source $By$ 一个读错题的沙茶 标签：线段树 Solution稍有变形的基础线段树。对于每个区间，维护其从左端开始的最长上升升下降序列、从右端开始的最长上升或下降序列、左端点键值、右端点键值、区间中最长序列长度、区间中最长上升序列长度、区间中最长下降序列长度，共$9$个值。然后$updata$和$downtag$注意写法即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define MAX_N 50000using namespace std;int n, m; struct node &#123;int lup, rup, ldn, rdn, lc, rc, l, mxup, mxdn;&#125; tr[(MAX_N&lt;&lt;2)+5];node update(node a, node b) &#123; node ret; ret.l = a.l+b.l, ret.lc = a.lc, ret.rc = b.rc; ret.lup = a.lup; if (a.lup == a.l &amp;&amp; a.rc &lt;= b.lc) ret.lup = a.l+b.lup; ret.ldn = a.ldn; if (a.ldn == a.l &amp;&amp; a.rc &gt;= b.lc) ret.ldn = a.l+b.ldn; ret.rup = b.rup; if (b.rup == b.l &amp;&amp; a.rc &lt;= b.lc) ret.rup = a.rup+b.l; ret.rdn = b.rdn; if (b.rdn == b.l &amp;&amp; a.rc &gt;= b.lc) ret.rdn = a.rdn+b.l; ret.mxup = max(a.mxup, b.mxup), ret.mxdn = max(a.mxdn, b.mxdn); if (a.rc &lt;= b.lc) ret.mxup = max(ret.mxup, a.rup+b.lup); if (a.rc &gt;= b.lc) ret.mxdn = max(ret.mxdn, a.rdn+b.ldn); return ret;&#125;void build(int v, int s, int t) &#123; if (s == t) &#123; scanf("%d", &amp;tr[v].lc), tr[v].rc = tr[v].lc; tr[v].lup = tr[v].rup = tr[v].ldn = tr[v].rdn = tr[v].l = tr[v].mxup = tr[v].mxdn = 1; return; &#125; int mid = s+t&gt;&gt;1; build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t); tr[v] = update(tr[v&lt;&lt;1], tr[v&lt;&lt;1|1]);&#125;node query(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v]; int mid = s+t&gt;&gt;1; node ls, rs; bool fl = false, fr = false; if (l &lt;= mid) ls = query(v&lt;&lt;1, s, mid, l, r), fl = true; if (r &gt;= mid+1) rs = query(v&lt;&lt;1|1, mid+1, t, l, r), fr = true; return fl ? (fr ? update(ls, rs) : ls) : rs;&#125;int main() &#123; scanf("%d", &amp;n), build(1, 1, n); scanf("%d", &amp;m); while (m--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); node ans = query(1, 1, n, l, r); printf("%d\n", max(ans.mxup, ans.mxdn)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1087【SCOI2005】互不侵犯King]]></title>
    <url>%2FBZOJ1087%E3%80%90SCOI2005%E3%80%91%E4%BA%92%E4%B8%8D%E4%BE%B5%E7%8A%AFKing%20%E7%8A%B6%E5%8E%8BDP%2F</url>
    <content type="text"><![CDATA[Problem 【SCOI2005】互不侵犯King ime Limit: $10 Sec$ Memory Limit: $162 MB$ Description在$N\times N$的棋盘里面放$K$个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共$8$个格子。 Input只有一行，包含两个数$N$, $K$ ($1 \le N \le 9$, $0 \le K \le N^2$) Output方案数。 Sample Input13 2 Sample Output116 标签：状压$DP$ Solution状压$DP$的基础题。对于每个国王，不难发现它放与不放只与当行和前一行有关，而它放完后的影响只作用于当行和后一行。而$N\le 9$于是考虑状压$DP$，$f[i][j][k]$表示当前考虑到第$i$行，共用了$j$个国王，第$i$行状态为$k$的方案数。那么$k$和前一行的状态$k’$是否冲突可以用$k$、$k&lt;&lt;1$、$k&gt;&gt;1$与$k’$取$\&amp;$得到。时间复杂度$O(n^2\times 2^k\times 2^k)$。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long lnt;int n, k, cnt[100], sta[1000], tot;lnt f[10][1000][1000], ans; bool mrk[1000];void init() &#123; for (int i = 0; i &lt; (1&lt;&lt;n); i++) &#123; if (i&amp;(i&lt;&lt;1)) continue; mrk[i] = true, sta[tot++] = i; for (int j = i; j; j &gt;&gt;= 1) cnt[i] += (j&amp;1); f[1][cnt[i]][i] = 1; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k), init(); for (int i = 2; i &lt;= n; i++) for (int j = 0; j &lt;= k; j++) for (int p = 0; p &lt; tot; p++) &#123; int cur = sta[p]; if (cnt[cur] &gt; j) continue; for (int q = 0; q &lt; tot; q++) &#123; int lst = sta[q]; if ((cur&amp;lst) || ((cur&lt;&lt;1)&amp;lst) || ((cur&gt;&gt;1)&amp;lst)) continue; f[i][j][cur] += f[i-1][j-cnt[cur]][lst]; &#125; &#125; for (int i = 0; i &lt; tot; i++) ans += f[n][k][sta[i]]; printf("%lld", ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>状压DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4721【NOIp2016】蚯蚓]]></title>
    <url>%2FBZOJ4721%E3%80%90NOIp2016%E3%80%91%E8%9A%AF%E8%9A%93%20%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[Problem 【NOIp2016】蚯蚓 题目描述本题中，我们将用符号$[c]$表示对$c$向下取整，例如：$[3.0] = [3.1] = [3.9] = 3$。蛐蛐国最近蚯蚓成灾了！隔壁跳蚤国的跳蚤也拿蚯蚓们没办法，蛐蛐国王只好去请神刀手来帮他们消灭蚯蚓。蛐蛐国里现在共有$n$只蚯蚓（$n$为正整数)。每只蚯蚓拥有长度，我们设第$i$只蚯蚓的长度为$a_i$$(i=1,2,\cdots,n)$，并保证所有的长度都是非负整数（即:可能存在长度为$0$的蚯蚓）。每一秒，神刀手会在所有的蚯蚓中，准确地找到最长的那一只（如有多个则任选一个）将其切成两半。神刀手切开蚯蚓的位置由常数$p$(是满足$0&lt;p&lt;1$的有理数)决定，设这只蚯蚓长度为$x$，神刀手会将其切成两只长度分别为$[p\cdot x]$和$x-[p\cdot x]$的蚯蚓。特殊地，如果这两个数的其中一个等于$0$，则这个长度为$0$的蚯蚓也会被保留。此外，除了刚刚产生的两只新蚯蚓，其余蚯蚓的长度都会增加$q$(是一个非负整常数)。蛐蛐国王知道这样不是长久之计，因为蚯蚓不仅会越来越多，还会越来越长。蛐蛐国王决定求助于一位有着洪荒之力的神秘人物，但是救兵还需要$m$秒才能到来……($m$为非负整数）蛐蛐国王希望知道这$m$秒内的战况。具体来说，他希望知道： $m$秒内，每一秒被切断的蚯蚓被切断前的长度（有$m$个数） $m$秒后，所有蚯蚓的长度（有$n+m$个数)。 蛐蛐国王当然知道怎么做啦！但是他想考考你…… 输入输出格式输入格式：第一行包含六个整数$n,m,q,u,v,t$，其中：$n,m,q$的意义见【问题描述】；$u,v,t$均为正整数；你需要自己计算$p=\frac{u}{v}$(保证$0&lt;u&lt;v$)；$t$是输出参数，其含义将会在【输出格式】中解释。第二行包含$n$个非负整数，为$a_1,a_2,\cdots a_n$，即初始时$n$只蚯蚓的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。保证$1\le n\le 10^5$，$0&lt;m\le 7*10^6$，$0\le u&lt;v\le 10^9$，$0\le q\le 200$，$1\le t\le 71$，$0&lt;a_i\le 10^8$。输出格式：第一行输出$[\frac{m}{t}]$个整数，按时间顺序，依次输出第$t$秒，第$2t$秒，第$3t$秒……被切断蚯蚓（在被切断前）的长度。第二行输出$[\frac{n+m}{t}]$个整数，输出$m$秒后蚯蚓的长度；需要按从大到小的顺序，依次输出排名第$t$，第$2t$，第$3t$……的长度。同一行中相邻的两个数之间，恰好用一个空格隔开。即使某一行没有任何数需要 输出，你也应输出一个空行。请阅读样例来更好地理解这个格式。 输入输出样例输入样例$#1$：123 7 1 1 3 13 3 2 输出样例$#1$：123 4 4 4 5 5 66 6 6 5 5 4 4 3 2 2 输入样例$#2$：123 7 1 1 3 23 3 2 输出样例$#2$：124 4 56 5 4 3 2 输入样例$#3$：123 7 1 1 3 93 3 2 输出样例$#3$：12//空行2 说明【样例解释$1$】在神刀手到来前：$3$只蚯蚓的长度为$3,3,2$。$1$秒后：一只长度为$3$的蚯蚓被切成了两只长度分别为$1$和$2$的蚯蚓，其余蚯蚓的长度增加了$1$。最终$4$只蚯蚓的长度分别为$(1,2),4,3$。括号表示这个位置刚刚有一只蚯蚓被切断$2$秒后：一只长度为$4$的蚯蚓被切成了$1$和$3$。$5$只蚯蚓的长度分别为：$2,3,(1,3),4$。$3$秒后：一只长度为$4$的蚯蚓被切断。$6$只蚯蚓的长度分别为：$3,4,2,4,(1,3)$。$4$秒后：一只长度为$4$的蚯蚓被切断。$7$只蚯蚓的长度分别为：$4,(1,3),3,5,2,4$。$5$秒后：一只长度为$5$的蚯蚓被切断。$8$只蚯蚓的长度分别为：$5,2,4,4,(1,4),3,5$。$6$秒后：一只长度为$5$的蚯蚓被切断。$9$只蚯蚓的长度分别为：$(1,4),3,5,5,2,5,4,6$。$7$秒后：一只长度为$6$的蚯蚓被切断。$10$只蚯蚓的长度分别为：$2,5,4,6,6,3,6,5,(2,4)$。所以，$7$秒内被切断的蚯蚓的长度依次为$3,4,4,4,5,5,6$。$7$秒后，所有蚯蚓长度从大到小排序为$6,6,6,5,5,4,4,3,2,2$。【样例解释$2$】这个数据中只有$t=2$与上个数据不同。只需在每行都改为每两个数输出一个数即可。虽然第一行最后有一个$6$没有被输出，但是第二行仍然要重新从第二个数再开始输出。【样例解释$3$】这个数据中只有$t=9$与上个数据不同。注意第一行没有数要输出，但也要输出一个空行。 标签：队列 Solution本题很巧妙，把基础数据结构玩出了新花样。观察发现每次选最长的一只进行操作，那么可以直接用一个大根堆维护，每次取出最大数，把它按要求操作后变成两个，并放回堆中。但每次操作会使数量增大$1$，而$m$最大为$7\times 10^6$，那么最后取出时会$TLE$。其实，大根堆的$\log$是可以去掉的。考虑每次取出最大数后进行的操作，易知产生的两个数一定比最大数小。令$i&lt;j$，则第$i$轮取出的最大数显然大于第j轮取出的最大数，那么新切出的较长的蚯蚓一定比以前切出的所有较长蚯蚓要短，较短蚯蚓也是一样，这样如果把原蚯蚓、切出的较长蚯蚓、切出的较短蚯蚓分开存放，那么先存进去的蚯蚓一定比后存进去的蚯蚓长，这就是一个天然的优先队列。那么用三个队列维护，每次取三个队首中的最大值进行操作，得到的两个数分别存到对应的两个队列中即可。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 100000#define INF 2147483647using namespace std;typedef long long lnt;int n, m, q, t; lnt u, v;int la, lb, lc, ra, rb, rc;lnt qa[MAX_N+5], qb[MAX_N*100+5], qc[MAX_N*100+5];bool cmp(const lnt &amp;a, const lnt &amp;b) &#123;return a &gt; b;&#125;lnt choose() &#123; lnt l1 = -INF, l2 = -INF, l3 = -INF; if (la &lt;= ra) l1 = qa[la]; if (lb &lt;= rb) l2 = qb[lb]; if (lc &lt;= rc) l3 = qc[lc]; lnt ret = max(l1, max(l2, l3)); if (ret == l1) la++; else if (ret == l2) lb++; else lc++; return ret;&#125;int main() &#123; scanf("%d%d%d%lld%lld%d", &amp;n, &amp;m, &amp;q, &amp;u, &amp;v, &amp;t); for (int i = 1; i &lt;= n; i++) scanf("%lld", qa+i); sort(qa+1, qa+n+1, cmp); la = 1, ra = n, lb = 1, rb = 0, lc = 1, rc = 0; for (int i = 1; i &lt;= m; i++) &#123; lnt cur = choose()+(i-1)*q; if (!(i%t)) printf("%lld ", cur); lnt l1 = cur*u/v, l2 = cur-l1; if (l1 &gt; l2) swap(l1, l2); qb[++rb] = l1-(lnt)i*q, qc[++rc] = l2-(lnt)i*q; &#125; printf("\n"); for (int i = 1; i &lt;= n+m; i++) &#123;lnt cur = choose()+m*q; if (!(i%t)) printf("%lld ", cur);&#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>NOIp</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1046【HAOI2007】上升序列]]></title>
    <url>%2FBZOJ1046%E3%80%90HAOI2007%E3%80%91%E4%B8%8A%E5%8D%87%E5%BA%8F%E5%88%97%20DP%2F</url>
    <content type="text"><![CDATA[Problem 【HAOI2007】上升序列 ime Limit: $10 Sec$ Memory Limit: $162 MB$ Description对于一个给定的$S={a_1,a_2,a_3,\cdots,a_n}$,若有$P={a_{x_1},a_{x_2},a_{x_3},\cdots,a_{x_m}}$,满足($x_1 &lt; x_2 &lt; \cdots&lt; x_m$)且($a_{x_1} &lt; a_{x_2} &lt; \cdots &lt; a_{x_m}$)。那么就称$P$为$S$的一个上升序列。如果有多个$P$满足条件，那么我们想求字典序最小的那个。任务给出$S$序列，给出若干询问。对于第$i$个询问，求出长度为$L_i$的上升序列，如有多个，求出字典序最小的那个（即首先$x_1$最小，如果不唯一，再看$x_2$最小……），如果不存在长度为$L_i$的上升序列，则输出$Impossible$. Input第一行一个$N$，表示序列一共有$N$个元素第二行$N$个数，为$a_1,a_2,\cdots,a_n$ 第三行一个$M$，表示询问次数。下面接$M$行每行一个数$L$，表示要询问长度为$L$的上升序列。$N\le 10000$，$M\le 1000$ Output对于每个询问，如果对应的序列存在，则输出，否则输出$Impossible$. Sample Input12345663 4 1 2 3 63645 Sample Output123Impossible1 2 3 6Impossible 标签：$DP$ Solution一道$LIS$的变形。显然需要先预处理出每个数向后能组成的$LIS$的最大长度。对于每次询问，从前往后取，一旦某数字的$LIS$最大长度比$len$大，则此数可加入答案。顺序构造即可。 Code12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 10000using namespace std;int n, m, k, a[MAX_N+5], f[MAX_N+5];void print() &#123; for (int i = 1, pre = 0; i &lt;= n; i++) if (f[i] &gt;= k &amp;&amp; a[i] &gt; pre) &#123; printf("%d", a[i]), pre = a[i]; if (--k) printf(" "); else break; &#125; if (k) printf("Impossible"); printf("\n");&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;a[i]), f[i] = 1; for (int i = n; i &gt;= 1; i--) for (int j = i+1; j &lt;= n; j++) if (a[i] &lt; a[j]) f[i] = max(f[i], f[j]+1); scanf("%d", &amp;m); while (m--) scanf("%d", &amp;k), print(); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4720【NOIp2016】换教室]]></title>
    <url>%2FBZOJ4720%E3%80%90NOIp2016%E3%80%91%E6%8D%A2%E6%95%99%E5%AE%A4%20%E6%9C%9F%E6%9C%9BDP%2F</url>
    <content type="text"><![CDATA[Problem 【NOIp2016】换教室 题目描述对于刚上大学的牛牛来说，他面临的第一个问题是如何根据实际情况申请合适的课程。在可以选择的课程中，有 $2n$ 节课程安排在 $n$ 个时间段上。在第 $i$（$1\le i\le n$）个时间段上，两节内容相同的课程同时在不同的地点进行，其中，牛牛预先被安排在教室 $c_i$ 上课，而另一节课程在教室 $d_i$ 进行。在不提交任何申请的情况下，学生们需要按时间段的顺序依次完成所有的 $n$ 节安排好的课程。如果学生想更换第 $i$ 节课程的教室，则需要提出申请。若申请通过，学生就可以在第 $i$ 个时间段去教室 $d_i$ 上课，否则仍然在教室 $c_i$ 上课。由于更换教室的需求太多，申请不一定能获得通过。通过计算，牛牛发现申请更换第 $i$ 节课程的教室时，申请被通过的概率是一个已知的实数 $k_i$ ，并且对于不同课程的申请，被通过的概率是互相独立的。学校规定，所有的申请只能在学期开始前一次性提交，并且每个人只能选择至多 $m$ 节课程进行申请。这意味着牛牛必须一次性决定是否申请更换每节课的教室，而不能根据某些课程的申请结果来决定其他课程是否申请；牛牛可以申请自己最希望更换教室的 $m$ 门课程，也可以不用完这 $m$ 个申请的机会，甚至可以一门课程都不申请。因为不同的课程可能会被安排在不同的教室进行，所以牛牛需要利用课间时间从一间教室赶到另一间教室。牛牛所在的大学有 $v$ 个教室，有 $e$ 条道路。每条道路连接两间教室，并且是可以双向通行的。由于道路的长度和拥堵程度不同，通过不同的道路耗费的体力可能会有所不同。 当第 $i$（$1\le i\le n-1$）节课结束后，牛牛就会从这节课的教室出发，选择一条耗费体力最少的路径前往下一节课的教室。现在牛牛想知道，申请哪几门课程可以使他因在教室间移动耗费的体力值的总和的期望值最小，请你帮他求出这个最小值。 输入输出格式输入格式：第一行四个整数 $n,m,v,e$。$n$ 表示这个学期内的时间段的数量；$m$ 表示牛牛最多可以申请更换多少节课程的教室；$v$ 表示牛牛学校里教室的数量；$e$表示牛牛的学校里道路的数量。第二行 $n$ 个正整数，第 $i（1\le i\le n）$个正整数表示 $c_i$ ，即第 $i$ 个时间段牛牛被安排上课的教室；保证 $1\le c_i \le v$。第三行 $n$ 个正整数，第 $i（1\le i\le n）$个正整数表示 $d_i$ ，即第 $i$ 个时间段另一间上同样课程的教室；保证 $1\le d_i\le v$。第四行 $n$ 个实数，第 $i（1\le i\le n）$个实数表示 $k_i$ ，即牛牛申请在第 $i$ 个时间段更换教室获得通过的概率。保证 $0\le k_i \le 1$。接下来 $e$ 行，每行三个正整数 $a_j$, $b_j$,$w_j$，表示有一条双向道路连接教室 $a_j$, $b_j$，通过这条道路需要耗费的体力值是 $w_j$；保证 $1\le a_j, b_j \le v$，$1\le w_j\le 100$。保证$1\le n\le 2000$，$0\le m\le 2000$，$1\le v\le 300$，$0\le e\le 90000$。保证通过学校里的道路，从任何一间教室出发，都能到达其他所有的教室。保证输入的实数最多包含 $3$ 位小数。 输出格式：输出一行，包含一个实数，四舍五入精确到小数点后恰好$2$位，表示答案。你的输出必须和标准输出完全一样才算正确。测试数据保证四舍五入后的答案和准确答案的差的绝对值不大于$4\times 10^{-3}$。（如果你不知道什么是浮点误差，这段话可以理解为：对于大多数的算法，你可以正常地使用浮点数类型而不用对它进行特殊的处理） 输入输出样例输入样例#1：12345673 2 3 32 1 21 2 10.8 0.2 0.5 1 2 51 3 32 3 1 输出样例#1：12.80 提示 道路中可能会有多条双向道路连接相同的两间教室。 也有可能有道路两端连接的是同一间教室。 请注意区分n,m,v,e的意义, n不是教室的数量, m不是道路的数量。 标签：期望$DP$ Solution期望题，有点超纲。考虑$DP$。$f[i][j][0/1]$表示选到第$i$个时间段，换了$j$节课，这节课是否换的期望。那么可以枚举是否换成功的情况进行转移。具体见代码。$DP$方程挺长，但还是比较好想的。 Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_V 300#define MAX_N 2000#define INF 0x3f3f3f3fusing namespace std;typedef double dnt;int n, m, v, e;int c[MAX_N+5], d[MAX_N+5]; dnt k[MAX_N+5];int dis[MAX_V+5][MAX_V+5]; dnt f[MAX_N+5][MAX_N+5][2];void Floyed() &#123; for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) dis[i][j] = i == j ? 0 : INF; for (int i = 0, x, y, z; i &lt; e; i++) scanf("%d%d%d", &amp;x, &amp;y, &amp;z), dis[x][y] = dis[y][x] = min(dis[x][y], z); for (int k = 1; k &lt;= v; k++) for (int i = 1; i &lt;= v; i++) for (int j = 1; j &lt;= v; j++) dis[i][j] = min(dis[i][j], dis[i][k]+dis[k][j]);&#125;void DP() &#123; for (int i = 1; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) for (int k = 0; k &lt;= 1; k++) f[i][j][k] = INF; f[1][0][0] = f[1][1][1] = 0; for (int i = 2; i &lt;= n; i++) for (int j = 0; j &lt;= min(m, i); j++) &#123; f[i][j][0] = min(f[i-1][j][0]+dis[c[i-1]][c[i]], f[i-1][j][1]+dis[d[i-1]][c[i]]*k[i-1]+dis[c[i-1]][c[i]]*(1-k[i-1])); if (j) f[i][j][1] = min(f[i-1][j-1][0]+dis[c[i-1]][d[i]]*k[i]+dis[c[i-1]][c[i]]*(1-k[i]), f[i-1][j-1][1]+dis[c[i-1]][c[i]]*(1-k[i-1])*(1-k[i])+dis[c[i-1]][d[i]]*(1-k[i-1])*k[i]+dis[d[i-1]][c[i]]*k[i-1]*(1-k[i])+dis[d[i-1]][d[i]]*k[i-1]*k[i]); &#125;&#125;dnt MIN() &#123;dnt ret = INF; for (int j = 0; j &lt;= m; j++) for (int k = 0; k &lt; 2; k++) ret = min(ret, f[n][j][k]); return ret;&#125;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;v, &amp;e); for (int i = 1; i &lt;= n; i++) scanf("%d", c+i); for (int i = 1; i &lt;= n; i++) scanf("%d", d+i); for (int i = 1; i &lt;= n; i++) scanf("%lf", k+i); Floyed(), DP(), printf("%.2lf", MIN()); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>NOIp</tag>
        <tag>期望DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4034【HAOI2015】树上操作]]></title>
    <url>%2FBZOJ4034%E3%80%90HAOI2015%E3%80%91%E6%A0%91%E4%B8%8A%E6%93%8D%E4%BD%9C%20%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%2F</url>
    <content type="text"><![CDATA[Problem 【HAOI2015】树上操作 Time Limit: $10 Sec$ Memory Limit: $256 MB$ Description有一棵点数为 $N$ 的树，以点 $1$ 为根，且树点有边权。然后有 $M$ 个操作，分为三种：操作 $1$ ：把某个节点 $x$ 的点权增加 $a$ 。操作 $2$ ：把某个节点 $x$ 为根的子树中所有点的点权都增加 $a$ 。操作 $3$ ：询问某个节点 $x$ 到根的路径中所有点的点权和。 Input第一行包含两个整数 $N, M$ 。表示点数和操作数。接下来一行 $N$ 个整数，表示树中节点的初始权值。接下来 $N-1$ 行每行三个正整数 $fr, to$ ， 表示该树中存在一条边 $(fr, to)$ 。再接下来 $M$ 行，每行分别表示一次操作。其中第一个数表示该操作的种类$(1\sim 3)$ ，之后接这个操作的参数$(x 或者 x a)$ 。 Output对于每个询问操作，输出该询问的答案。答案之间用换行隔开。 Sample Input12345678910115 51 2 3 4 51 21 42 32 53 31 2 13 52 1 23 3 Sample Output1236913 HINT 对于 $100\%$ 的数据， $N,M\le 10^5$ ，且所有输入数据的绝对值都不会超过 $10^6$ 。 标签：树链剖分 Solution这是一道$DFS$序的裸题。可以$DFS$序$+$树状数组区间修改单点查询(差分)搞定。但为了写板我码了个树剖。反正是裸题。不多说。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define MAX_N 100000using namespace std;typedef long long lnt;vector &lt;int&gt; G[MAX_N+5];int n, m, rt, c[MAX_N+5], sz[MAX_N+5];int dep[MAX_N+5], fa[MAX_N+5], son[MAX_N+5];int into[MAX_N+5], outo[MAX_N+5], top[MAX_N+5], ind;lnt seg[(MAX_N&lt;&lt;2)+5], tag[(MAX_N&lt;&lt;2)+5];void DFS(int u) &#123; sz[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa[u]) continue; dep[v] = dep[u]+1, fa[v] = u, DFS(v), sz[u] += sz[v]; if (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v; &#125;&#125;void DFS(int u, int tp) &#123; top[u] = tp, into[u] = ++ind; if (son[u]) DFS(son[u], tp); for (int i = 0, v; i &lt; G[u].size(); i++) &#123;v = G[u][i]; if ((v^fa[u]) &amp;&amp; (v^son[u])) DFS(v, v);&#125; outo[u] = ind;&#125;void updata(int v) &#123;seg[v] = seg[v&lt;&lt;1]+seg[v&lt;&lt;1|1];&#125;void downtag(int v, int s, int t) &#123; if (!tag[v]) return; int mid = s+t&gt;&gt;1; seg[v&lt;&lt;1] += tag[v]*(mid-s+1), seg[v&lt;&lt;1|1] += tag[v]*(t-mid); tag[v&lt;&lt;1] += tag[v], tag[v&lt;&lt;1|1] += tag[v], tag[v] = 0;&#125;void modify(int v, int s, int t, int l, int r, lnt x) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123;seg[v] += x*(t-s+1), tag[v] += x; return;&#125; int mid = s+t&gt;&gt;1; downtag(v, s, t); if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, x); updata(v); return;&#125;lnt query(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) return seg[v]; int mid = s+t&gt;&gt;1; lnt ret = 0; downtag(v, s, t); if (l &lt;= mid) ret += query(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) ret += query(v&lt;&lt;1|1, mid+1, t, l, r); updata(v); return ret;&#125;void solve1(int p, lnt x) &#123;modify(1, 1, n, into[p], into[p], x);&#125;void solve2(int p, lnt x) &#123;modify(1, 1, n, into[p], outo[p], x);&#125;void solve3(int p) &#123; lnt ans = 0; while (top[p] != rt) ans += query(1, 1, n, into[top[p]], into[p]), p = fa[top[p]]; ans += query(1, 1, n, into[rt], into[p]); printf("%lld\n", ans);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m), rt = 1; for (int i = 1; i &lt;= n; i++) scanf("%d", c+i); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); DFS(rt), DFS(rt, rt); for (int i = 1; i &lt;= n; i++) modify(1, 1, n, into[i], into[i], c[i]); while (m--) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123;int p; lnt x; scanf("%d%lld", &amp;p, &amp;x), solve1(p, x);&#125; if (opt == 2) &#123;int p; lnt x; scanf("%d%lld", &amp;p, &amp;x), solve2(p, x);&#125; if (opt == 3) &#123;int p; scanf("%d", &amp;p), solve3(p);&#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1026【SCOI2009】Windy数]]></title>
    <url>%2FBZOJ1026%E3%80%90SCOI2009%E3%80%91Windy%E6%95%B0%20%E6%95%B0%E4%BD%8DDP%2F</url>
    <content type="text"><![CDATA[Problem 【SCOI2009】windy数Time Limit: $1 Sec$Memory Limit: $162 MB$ Description$windy$定义了一种$windy$数。不含前导零且相邻两个数字之差至少为$2$的正整数被称为$windy$数。 $windy$想知道，在$A$和$B$之间，包括$A$和$B$，总共有多少个$windy$数？ Input包含两个整数，$A,B$。 Output一个整数 Sample Input【输入样例一】11 10 【输入样例二】125 50 Sample Output【输出样例一】19 【输出样例二】120 HINT【数据规模和约定】 $100\%$的数据，满足 $1\le A \le B \le 2\times 10^9$ 。 标签：数位$DP$ Solution非常经典的一道数位$DP$题。也是多少$OIer$数位$DP$入门的第一题啊… 先预处理出$DP$数组，其中$f[i][j]$从左往右第$i$位为$j$的$windy$数的个数。对于询问，分别计算$[1, A-1]$和$[1, B]$中的$windy$数的个数，即在预处理的表中按位查询，统计答案后相减即可。 Code1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;int f[15][15];int abs(int x) &#123;return x &gt;= 0 ? x : -x;&#125;int calc(int x) &#123; int len = 0, n[15], t = x, ret = 0; while (t) n[++len] = t%10, t /= 10; for (int i = 1; i &lt; len; i++) for (int j = 1; j &lt;= 9; j++) ret += f[i][j]; for (int i = len; i; i--) &#123; for (int j = (i == len ? 1 : 0); j &lt; n[i]; j++) if (i == len || abs(j-n[i+1]) &gt;= 2) ret += f[i][j]; if (i &lt; len &amp;&amp; abs(n[i+1]-n[i]) &lt; 2) break; &#125; return ret;&#125;int main() &#123; for (int i = 0; i &lt;= 9; i++) f[1][i] = 1; for (int i = 1; i &lt;= 10; i++) for (int j = 0; j &lt;= 9; j++) &#123; for (int k = 0; k &lt;= j-2; k++) f[i+1][k] += f[i][j]; for (int k = j+2; k &lt;= 9; k++) f[i+1][k] += f[i][j]; &#125; int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%d", calc(r+1)-calc(l)); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1833【ZJOI2010】count数字计数]]></title>
    <url>%2FBZOJ1833%E3%80%90ZJOI2010%E3%80%91count%E6%95%B0%E5%AD%97%E8%AE%A1%E6%95%B0%20%E6%95%B0%E4%BD%8DDP%2F</url>
    <content type="text"><![CDATA[Problem 【ZJOI2010】count 数字计数 Time Limit: $3 Sec$ Memory Limit: $64 MB$ Description给定两个正整数$a$和$b$，求在$[a,b]$中的所有整数中，每个数码$(digit)$各出现了多少次。 Input输入文件中仅包含一行两个整数$a$、$b$，含义如上所述。 Output输出文件中包含一行$10$个整数，分别表示$0\sim 9$在$[a,b]$中出现了多少次。 Sample Input11 99 Sample Output19 20 20 20 20 20 20 20 20 20 HINT$30\%$的数据中，$a\le b\le 10^6$$100\%$的数据中，$a\le b\le 10^{12}$ 标签：数位$DP$ Solution$BZOJ$上最简单的数位$DP$，比$Windy$数还水。预处理数组$f$，其中$f[i][j]$表示第i位为$j$的数共多少个。对于每次查询，找$[1, a]$和$[1,b]$中$0\sim 9$出现的次数，按位在$f$数组上查，相减即可。可以用结构体重载运算符，这样一个算式不用写十遍。 Code12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long lnt;lnt a, b, pow[20];struct node &#123;lnt c[10];&#125; f[20][10];node operator + (node a, node b) &#123;node ret; for (int i = 0; i &lt; 10; i++) ret.c[i] = a.c[i]+b.c[i]; return ret;&#125;void init() &#123;pow[1] = 1; for (int i = 2; i &lt;= 15; i++) pow[i] = pow[i-1]*10;&#125;node calc(lnt x) &#123; node ret; for (int i = 0; i &lt; 10; i++) ret.c[i] = 0; if (!x) &#123;ret.c[0] = 1; return ret;&#125; int len = 15; while (x &lt; pow[len]) len--; for (int i = 1; i &lt; len; i++) for (int j = 1; j &lt; 10; j++) ret = ret+f[i][j]; ret.c[0]++; int cur = x/pow[len]; for (int i = 1; i &lt; cur; i++) ret = ret+f[len][i]; x %= pow[len], ret.c[cur] += x+1; for (int i = len-1; i; i--) &#123; cur = x/pow[i]; for (int j = 0; j &lt; cur; j++) ret = ret+f[i][j]; x %= pow[i], ret.c[cur] += x+1; &#125; return ret;&#125;int main() &#123; init(), scanf("%lld%lld", &amp;a, &amp;b); for (int i = 0; i &lt; 10; i++) f[1][i].c[i] = 1; for (int i = 2; i &lt;= 12; i++) for (int j = 0; j &lt; 10; j++) for (int k = 0; k &lt; 10; k++) f[i][k] = f[i][k]+f[i-1][j], f[i][k].c[k] += pow[i-1]; node ansa = calc(a-1), ansb = calc(b); for (int i = 0; i &lt; 10; i++) &#123;printf("%lld", ansb.c[i]-ansa.c[i]); if (i != 9) printf(" ");&#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
        <tag>数位DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1860【ZJOI2006】Mahjong麻将]]></title>
    <url>%2FBZOJ1860%E3%80%90ZJOI2006%E3%80%91Mahjong%E9%BA%BB%E5%B0%86%20DP%2F</url>
    <content type="text"><![CDATA[Problem 【ZJOI2006】Mahjong麻将 Time Limit: $1 Sec$ Memory Limit: $64 MB$ Description很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：普通麻将有砣、索、万三种类型的牌，每种牌有$1\sim 9$个数字，其中相同的牌每个有四张，例如$1砣\sim 9砣$，$1索\sim 9索$，$1万\sim 9万$各$4$张，所以共$36\times 3=108$张牌。胡牌时每人有$14$张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是$1\sim 100$而每种数字的牌各有$100$张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！刺激归刺激，但是拿多了怎么胡牌呢？超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。 Input第一行一个整数$N$（$N\le 100$），表示玩了$N$次超级麻将。 接下来$N$行，每行$100$个数$a_1,a_2,\cdots a_{100}$，描述每次玩牌手中各种牌的数量。$a_i$表示数字为$i$的牌有$a_i$张。（$0\le a_i\le 100$） Output输出$N$行，若胡了则输出$Yes$，否则输出$No$，注意区分$Yes$、$No$的大小写！ Sample Input123432 4 0 0 0 0 0 …… 0（一共98个0）2 4 2 0 0 0 0 …… 0（一共97个0）2 3 2 0 0 0 0 …… 0（一共97个0） Sample Output123YesYesNo 标签:$DP$ Solution一道比较常规的$DP$。记得另外一道省选麻将题可以贪心做，但此题不行，没有贪心策略。考虑动态规划。发现一个数的牌数只可能影响它前后三个连续数的牌数（毕竟顺子只能三个连续），设$f[i][j][k][0/1]$表示把前$i$中数字取完，取完之前数字为$i-1$的共$j$张，为$i$的共$k$张，$0/1$表示是否取了对子，能否有取法。那么根据不同情况，可以从取二对子、三对子、四对子、顺子的情况转移过来。除了方程特判有点多，还是挺好写的。 Code1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;int a[105]; bool f[105][105][105][2];int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; memset(f, false, sizeof f), f[0][0][0][0] = true; for (int i = 1; i &lt;= 100; i++) scanf("%d", a+i); for (int i = 1; i &lt;= 100; i++) for (int j = 0; j &lt;= a[i-1]; j++) for (int k = 0; k &lt;= a[i]; k++) &#123; if (k &gt;= 2) f[i][j][k][1] |= f[i][j][k-2][0]; if (k &gt;= 3) f[i][j][k][0] |= f[i][j][k-3][0]; if (k &gt;= 3) f[i][j][k][1] |= f[i][j][k-3][1]; if (k &gt;= 4) f[i][j][k][0] |= f[i][j][k-4][0]; if (k &gt;= 4) f[i][j][k][1] |= f[i][j][k-4][1]; if (j &gt;= k &amp;&amp; a[i-2] &gt;= k) f[i][j][k][0] |= f[i-1][(i &gt;= 2 ? a[i-2] : 0)-k][j-k][0]; if (j &gt;= k &amp;&amp; a[i-2] &gt;= k) f[i][j][k][1] |= f[i-1][(i &gt;= 2 ? a[i-2] : 0)-k][j-k][1]; &#125; printf("%s\n", f[100][a[99]][a[100]][1] ? "Yes" : "No"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1033【ZJOI2007】杀蚂蚁]]></title>
    <url>%2FBZOJ1033%E3%80%90ZJOI2007%E3%80%91%E6%9D%80%E8%9A%82%E8%9A%81%20%E6%A8%A1%E6%8B%9F%2F</url>
    <content type="text"><![CDATA[Problem 【ZJOI2008】杀蚂蚁 Description最近，佳佳迷上了一款好玩的小游戏：$antbuster$。游戏规则非常简单：在一张地图上，左上角是蚂蚁窝，右下角是蛋糕，蚂蚁会源源不断地从窝里爬出来，试图把蛋糕搬回蚂蚁窝。而你的任务，就是用原始资金以及杀蚂蚁获得的奖金造防御塔，杀掉这些试图跟你抢蛋糕的蚂蚁~下附一张游戏截图： &lt;\center&gt;为了拿到尽可能高的分数，佳佳设计了很多种造塔的方案，但在尝试了其中的一小部分后，佳佳发现，这个游戏实在是太费时间了。为了节省时间，佳佳决定写个程序，对于每一种方案，模拟游戏进程，根据效果来判断方案的优劣。根据自己在游戏中积累的一些经验，以及上网搜到的一些参数，佳佳猜了蚂蚁爬行的算法，并且假设游戏中的蚂蚁也是按这个规则选择路线： 1. 每一秒钟开始的时候，蚂蚁都在平面中的某个整点上。如果蚂蚁没有扛着蛋糕，它会在该点留下 2 单位的信息素，否则它会留下 5 单位的信息素。然后蚂蚁会在正北、正南、正东、正西四个方向中选择一个爬过去。 2. 选择方向的规则是：首先，爬完一个单位长度后到达的那个点上，不能有其他蚂蚁或是防御塔，并且那个点不能是蚂蚁上一秒所在的点（除非上一个时刻蚂蚁就被卡住，且这个时刻它仍无法动），当然，蚂蚁也不会爬出地图的边界（我们定义这些点为不可达点）。如果此时有多个选择，蚂蚁会选择信息素最多的那个点爬过去。 3. 如果此时仍有多种选择，蚂蚁先面向正东，如果正东不是可选择的某个方向，它会顺时针转90°，再次判断，如果还不是，再转 90°...直到找到可以去的方向。 4. 如果将每只蚂蚁在洞口出现的时间作为它的活动时间的第 1 秒，那么每当这只蚂蚁的活动时间秒数为 5 的倍数的时候，它先按规则 1~3 确定一个方向，面对该方向后逆时针转 90°，若它沿当前方向会走到一个不可达点，它会不停地每次逆时针转 90°，直到它面对着一个可达的点，这样定下的方向才是蚂蚁最终要爬去的方向。 5. 如果蚂蚁的四周都是不可达点，那么蚂蚁在这一秒内会选择停留在当前点。下一秒判断移动方向时，它上一秒所在点为其当前停留的点。 6. 你可以认为蚂蚁在选定方向后，瞬间移动到它的目标点，这一秒钟剩下的时间里，它就停留在目标点。 7. 蚂蚁按出生的顺序移动，出生得比较早的蚂蚁先移动。 然后，是一些有关地图的信息： 1. 每一秒，地图所有点上的信息素会损失 1 单位，如果那个点上有信息素的话。 2. 地图上某些地方是炮台。炮台的坐标在输入中给出。 3. 地图的长、宽在输入中给出，对于n*m的地图，它的左上角坐标为(0,0)，右下角坐标为(n,m)。蚂蚁洞的位置为(0,0)，蛋糕的位置为(n,m)。 4. 你可以把蚂蚁看做一个直径为 1 单位的圆，圆心位于蚂蚁所在的整点。 5. 游戏开始时，地图上没有蚂蚁，每个点上的信息素含量均为 0。 一些有关炮塔的信息： 1. 炮塔被放置在地图上的整点处。 2. 为了简单一些，我们认为这些炮塔都是激光塔。激光塔的射速是 1 秒/次，它的攻击伤害为 d/次，攻击范围为 r。你可以认为每秒蚂蚁移动完毕后，塔才开始攻击。并且，只有当代表蚂蚁的圆的圆心与塔的直线距离不超过 r 时，塔才算打得到那只蚂蚁。 3. 如果一只蚂蚁扛着蛋糕，那么它会成为 target，也就是说，任何打得到它的塔的炮口都会对准它。如果蛋糕好好地呆在原位，那么每个塔都会挑离它最近的蚂蚁进行攻击，如果有多只蚂蚁，它会选出生较早的一只。 4. 激光塔有个比较奇怪的特性：它在选定了打击目标后，只要目标在其射程内，塔到目标蚂蚁圆心的连线上的所有蚂蚁（这里“被打到”的判定变成了表示激光的线段与表示蚂蚁的圆有公共点）都会被打到并损 d 格血，但激光不会穿透它的打击目标打到后面的蚂蚁。 5. 尽管在真实游戏中，塔是可以升级的，但在这里我们认为塔的布局和等级就此定了下来，不再变动。 再介绍一下蚂蚁窝： 1. 如果地图上的蚂蚁不足 6 只，并且洞口没有蚂蚁，那么窝中每秒会爬出一只蚂蚁，直到地图上的蚂蚁数为 6 只。 2. 刚出生的蚂蚁站在洞口。3. 每只蚂蚁有一个级别，级别决定了蚂蚁的血量，级别为 k 的蚂蚁的血量为[4*1.1^k]。每被塔打一次，蚂蚁的血减少 d。注意，血量为 0 的蚂蚁仍能精力充沛地四处乱爬，只有一只蚂蚁的血被打成负数时，它才算挂了。 3. 蚂蚁的级别是这样算的：前 6 只出生的蚂蚁是 1 级，第 7~12 只是 2 级，依此类推。 最后给出关于蛋糕的介绍： 1. 简单起见，你可以认为此时只剩最后一块蛋糕了。如果有蚂蚁走到蛋糕的位置，并且此时蛋糕没有被扛走，那么这只蚂蚁就扛上了蛋糕。蚂蚁被打死后蛋糕归位。 2. 如果一只扛着蛋糕的蚂蚁走到蚂蚁窝的位置，我们就认为蚂蚁成功抢到了蛋糕，游戏结束。 3. 蚂蚁扛上蛋糕时，血量会增加[该蚂蚁出生时血量/2]，但不会超过上限。 整理一下 1 秒钟内发生的事件： 1. 1 秒的最初，如果地图上蚂蚁数不足 6，一只蚂蚁就会在洞口出生。 2. 接着，蚂蚁们在自己所在点留下一些信息素后，考虑移动。先出生的蚂蚁先移动。 3. 移动完毕后，如果有蚂蚁在蛋糕的位置上并且蛋糕没被拿走，它把蛋糕扛上，血量增加，并在这时被所有塔设成 target。 4. 然后所有塔同时开始攻击。如果攻击结束后那只扛着蛋糕的蚂蚁挂了，蛋糕瞬间归位。 5. 攻击结束后，如果发现扛蛋糕的蚂蚁没死并在窝的位置，就认为蚂蚁抢到了蛋糕。游戏也在此时结束。 6. 最后，地图上所有点的信息素损失 1 单位。所有蚂蚁的年龄加 1。 7. 漫长的 1 秒到此结束。 Input输入的第一行是 $2$ 个用空格隔开的整数， $n$、$m$，分别表示了地图的长和宽。第二行是 $3$ 个用空格隔开的整数， $s$、 $d$、 $r$，依次表示炮塔的个数、单次攻击伤害以及攻击范围。接下来 $s$ 行，每行是 $2$ 个用空格隔开的整数 $x$、 $y$，描述了一个炮塔的位置。当然，蚂蚁窝的洞口以及蛋糕所在的位置上一定没有炮塔。最后一行是一个正整数 $t$，表示我们模拟游戏的前 $t$ 秒钟。 Output如果在第 $t$ 秒或之前蚂蚁抢到了蛋糕，输出一行“$Game over after x seconds$”，其中$x$为游戏结束的时间，否则输出“$The game is going on$”。如果游戏在 $t$ 秒或之前结束，输出游戏结束时所有蚂蚁的信息，否则输出 $t$ 秒后所有蚂蚁的信息。格式如下：第一行是 $1$ 个整数 $s$，表示此时活着的蚂蚁的总数。接下来 $s$ 行，每行 $5$ 个整数，依次表示一只蚂蚁的年龄（单位为秒）、等级、当前血量，以及在地图上的位置$(a,b)$。输出按蚂蚁的年龄递减排序。 Sample Input12343 51 1 22 25 Sample Output1234567The game is going on55 1 3 1 44 1 3 0 43 1 3 0 32 1 3 0 21 1 4 0 1 Hint样例说明：$3\times 5$的地图，有$1$个单次伤害为$1$、攻击范围为$2$的激光炮塔，它的位置为$(2,2)$，模拟游戏的前$5$秒。$5$秒内有$5$只蚂蚁出生，都是向东爬行，其中第$1\sim 4$只在路过$(0,2)$点时被激光塔伤了$1$格血。在第$5$秒的时候，最早出生的蚂蚁按移动规则$1\sim 3$本来该向东移动，但由于规则$4$的作用，它在发现向北和向西移动都会到达不可达点后，最终选择了向南移动。数据说明：$100\%$的数据满足$1\le n,m\le 8$，$s\le 20$，$t\le 2\times 10^5$ 如果觉得此题面不好看，请戳这里：https://www.zybuluo.com/Jerusalem/note/221811如果做得无聊了，可以玩玩：http://wanga.me/2794 标签：大模拟 Solution这是那种“做一做，一个下午就没了”的恶心题。我从上午十一点开做，足足做到晚上七点半才做完。恶心~ 大模拟，题面已经比较清楚了。坑点如下： 蚂蚁既是一个点，也是一个直径为$1$的圆（注意，是直径！）即在判断一个炮台和一只蚂蚁的距离时，应取圆心与炮台距离，但在判断一只蚂蚁是否会被炮台顺带打到，即在打目标蚂蚁的路径上时，应判断激光直线是否与圆有交点。 新出生的蚂蚁刚从蚁巢里出来时，要标记$(0,0)$为有物体，否则回来的蚂蚁会和它重在一起。 若当前蚂蚁出生的时间为$t$，则其年龄为$t-1$。 寻找移动方向时，应先按规则$1\sim 3$选择下一个位置。如果出生时间为$5$的倍数，则应该逆时针（注意，是逆时针）旋转，并且找到一个可行方向就走过去，不考虑信息素多少。 所有炮台是一起开炮，所以应该先把所有炮台的目标确定后，再统一扣蚂蚁的生命值。这样会出现蚂蚁生命在同一秒内被扣成负数还要继续扣的情况，这样就是正确的。 Extra Samples贡献几组数据，可自测： Sample #1Input12345674 44 10 51 12 21 22 11000 Output12345678Game over after 831 seconds6110 49 86 2 388 49 26 0 177 49 286 3 158 50 29 0 022 50 419 4 310 50 469 3 2 Sample #2Input12346 41 10000 102 2256 Output12The game is going on0 Sample #3Input1234 70 0 060200 Output12345678Game over after 60200 seconds660199 1 4 0 060198 1 4 2 660197 1 4 4 760196 1 4 2 160195 1 4 3 560194 1 4 4 5 Sample #4Input1234567892 56 1 30 11 11 31 42 32 4200000 Output12345678The game is going on615311 86 13525 1 512518 86 10203 0 59447 87 12495 0 46371 87 13461 0 33295 87 14586 0 2219 87 15873 1 2 Code（$BZOJ$上$A$了，洛谷上死活$WA$一个点，不知道为什么）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define EPS 1e-5using namespace std;typedef double dnt;int n, m, s, d, r, cnt, num, tar = -1;vector &lt;int&gt; living; int information[10][10];bool lose = false, cake = true, is_taken[10][10];int nxt[4][2] = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;int calc_lim_blood(int k) &#123;dnt ret = 4; while (k--) ret *= 1.1; return (int)floor(ret);&#125;struct Ant &#123; int x, y, id, px, py; bool has_cake; int cur_blood, lim_blood, level, age; void birth(int _id) &#123; living.push_back(id = _id), num++, has_cake = false; x = y = age = 0, px = py = -1, level = id/6+1; cur_blood = lim_blood = calc_lim_blood(level), is_taken[x][y] = true; &#125; void dead() &#123; num--; int pos; for (pos = 0; pos &lt; (int)living.size(); pos++) if (living[pos] == id) break; for (; pos &lt; (int)living.size()-1; pos++) living[pos] = living[pos+1]; living.erase(living.end()-1); if (has_cake) cake = true, tar = -1; is_taken[x][y] = false; &#125; void recover() &#123;cur_blood = min(cur_blood+(int)floor(lim_blood/2), lim_blood);&#125; void hurt() &#123;cur_blood -= d;&#125; void left_information() &#123;information[x][y] += has_cake ? 5 : 2;&#125; pair &lt;int, int&gt; choose_direction() &#123; int nx = -1, ny = -1, cur; for (int i = 0; i &lt; 4; i++) &#123; int tx = x+nxt[i][0], ty = y+nxt[i][1]; if (tx &lt; 0 || tx &gt; n || ty &lt; 0 || ty &gt; m) continue; if (is_taken[tx][ty] || (tx == px &amp;&amp; ty == py)) continue; if (nx == -1 &amp;&amp; ny == -1) nx = tx, ny = ty; else if (information[tx][ty] &gt; information[nx][ny]) nx = tx, ny = ty; &#125; if ((age+1)%5 == 0) &#123; if (nx == x &amp;&amp; ny == y+1) nx = ny = -1, cur = 0; if (nx == x+1 &amp;&amp; ny == y) nx = ny = -1, cur = 1; if (nx == x &amp;&amp; ny == y-1) nx = ny = -1, cur = 2; if (nx == x-1 &amp;&amp; ny == y) nx = ny = -1, cur = 3; for (int i = cur-1; ~i; i--) &#123; int tx = x+nxt[i][0], ty = y+nxt[i][1]; if (tx &lt; 0 || tx &gt; n || ty &lt; 0 || ty &gt; m) continue; if (is_taken[tx][ty] || (tx == px &amp;&amp; ty == py)) continue; if (nx == -1 &amp;&amp; ny == -1) nx = tx, ny = ty; &#125; for (int i = 3; i &gt;= cur; i--) &#123; int tx = x+nxt[i][0], ty = y+nxt[i][1]; if (tx &lt; 0 || tx &gt; n || ty &lt; 0 || ty &gt; m) continue; if (is_taken[tx][ty] || (tx == px &amp;&amp; ty == py)) continue; if (nx == -1 &amp;&amp; ny == -1) nx = tx, ny = ty; &#125; &#125; return make_pair(nx, ny); &#125; void move() &#123; pair &lt;int, int&gt; np = choose_direction(); if (np.first == -1 &amp;&amp; np.second == -1) np.first = x, np.second = y; is_taken[x][y] = false, is_taken[np.first][np.second] = true; px = x, py = y, x = np.first, y = np.second; &#125; bool can_take_cake() &#123;return x == n &amp;&amp; y == m &amp;&amp; cake;&#125; void take_cake() &#123;if (can_take_cake()) recover(), cake = false, has_cake = true, tar = id;&#125; bool steal_cake() &#123;return x == 0 &amp;&amp; y == 0 &amp;&amp; has_cake;&#125;&#125; ant[2000000]; dnt dis(int x1, int y1, int x2, int y2) &#123;return (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);&#125; dnt getcos(int x1, int y1, int x2, int y2, int x3, int y3) &#123; int a1 = x1-x2, b1 = y1-y2, a2 = x3-x2, b2 = y3-y2; return (a1*a2+b1*b2)/(dnt)(sqrt(dis(x1, y1, x2, y2))*sqrt(dis(x3, y3, x2, y2))); &#125; bool reach(int tarid, int inid, int x, int y) &#123; dnt cos1 = getcos(ant[inid].x, ant[inid].y, x, y, ant[tarid].x, ant[tarid].y); dnt cos2 = getcos(ant[inid].x, ant[inid].y, ant[tarid].x, ant[tarid].y, x, y); if (cos1 &lt; EPS || cos2 &lt; EPS) return false; dnt t = sqrt(dis(ant[inid].x, ant[inid].y, x, y))*sqrt(1.0-cos1*cos1); return t-0.5 &lt; EPS; &#125;struct Laser &#123; int x, y; int dist(int id) &#123;return (x-ant[id].x)*(x-ant[id].x)+(y-ant[id].y)*(y-ant[id].y);&#125; void build(int _x, int _y) &#123;x = _x, y = _y, is_taken[x][y] = true;&#125; bool can_hit(int id) &#123;return (x-ant[id].x)*(x-ant[id].x)+(dnt)(y-ant[id].y)*(y-ant[id].y) &lt;= r*r;&#125; int choose_target() &#123; if (~tar &amp;&amp; can_hit(tar)) return tar; int ret = -1; for (int i = 0, cur = living[i]; i &lt; (int)living.size(); cur = living[++i]) if (can_hit(cur)) if (ret == -1 || dist(ret) &gt; dist(cur)) ret = cur; return ret; &#125; void attack() &#123; int id = choose_target(); if (id == -1) return; for (int i = 0; i &lt; (int)living.size(); i++) if (reach(id, living[i], x, y)) ant[living[i]].hurt(); &#125;&#125; laser[10];void add_age() &#123;for (int i = 0; i &lt; (int)living.size(); i++) ant[living[i]].age++;&#125;void lose_information() &#123;for (int i = 0; i &lt;= n; i++) for (int j = 0; j &lt;= m; j++) information[i][j] -= (information[i][j] &gt; 0);&#125;bool game_over() &#123;for (int i = 0; i &lt; (int)living.size(); i++) if (ant[living[i]].steal_cake()) return true; return false;&#125;bool per_second(int t) &#123; if (num &lt; 6 &amp;&amp; !is_taken[0][0]) ant[cnt].birth(cnt), cnt++; for (int i = 0; i &lt; (int)living.size(); i++) ant[living[i]].left_information(); for (int i = 0; i &lt; (int)living.size(); i++) ant[living[i]].move(); for (int i = 0; i &lt; (int)living.size(); i++) ant[living[i]].take_cake(); for (int i = 0; i &lt; s; i++) laser[i].attack(); for (int i = 0, cur; i &lt; (int)living.size(); i++) &#123;cur = living[i]; if (ant[cur].cur_blood &lt; 0) ant[cur].dead(), i--;&#125; if (game_over()) &#123;printf("Game over after %d seconds\n", t), lose = true; return false;&#125; add_age(), lose_information(); return true;&#125;void output() &#123; printf("%d\n", num); for (int i = 0, cur = living[i]; i &lt; (int)living.size(); cur = living[++i]) printf("%d %d %d %d %d\n", ant[cur].age, ant[cur].level, ant[cur].cur_blood, ant[cur].x, ant[cur].y);&#125;int main() &#123; scanf("%d%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;d, &amp;r); for (int i = 0, x, y; i &lt; s; i++) scanf("%d%d", &amp;x, &amp;y), laser[i].build(x, y); int t; scanf("%d", &amp;t); for (int i = 1; i &lt;= t; i++) if (!per_second(i)) break; if (!lose) printf("The game is going on\n"); output(); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ4325【NOIp2015】斗地主]]></title>
    <url>%2FBZOJ4325%E3%80%90NOIp2015%E3%80%91%E6%96%97%E5%9C%B0%E4%B8%BB%20%E6%90%9C%E7%B4%A2%2B%E8%B4%AA%E5%BF%83%2F</url>
    <content type="text"><![CDATA[Problem 斗地主 Time Limit: $30 Sec$ Memory Limit: $1024 MB$ Description牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的$A$到$K$加上大小王的共$54$张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：$3&lt;4&lt;5&lt;6&lt;7&lt;8&lt;9&lt;10&lt;J&lt;Q&lt;K&lt;A&lt;2&lt;小王&lt;大王$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由$n$张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下： Input第一行包含用空格隔开的$2$个正整数$T,N$，表示手牌的组数以及每组手牌的张数。接下来$T$组数据，每组数据$N$行，每行一个非负整数对$A_i,B_i$，表示一张牌，其中$A_i$表示牌的数码，$B_i$表示牌的花色，中间用空格隔开。特别的，我们用1来表示数码A，$11$表示数码$J$，$12$表示数码$Q$，$13$表示数码$K$；黑桃、红心、梅花、方片分别用$1\sim 4$来表示；小王的表示方法为$01$，大王的表示方法为$02$。 Output共$T$行，每行一个整数，表示打光第$T$组手牌的最少次数。 Sample Input1234567891 87 48 49 110 411 15 11 41 1 Sample Output13 HINT共有$1$组手牌，包含$8$张牌：方片$7$，方片$8$，黑桃$9$，方片$10$，黑桃$J$，黑桃$5$，方片$A$以及黑桃$A$。可以通过打单顺子（方片$7$，方片$8$，黑桃$9$，方片$10$，黑桃$J$），单张牌（黑桃$5$）以及对子牌（黑桃$A$以及方片$A$）在$3$次内打光。 $T\le 10$, $N\le 23$ UOJ传送门：http://uoj.ac/problem/147 标签:爆搜+贪心 Solution题面看起来挺吓人，做起来却比较容易，特别是代码复杂度不高（毕竟做了恶心的猪国杀作铺垫）。发现确定顺子之后，其他所有牌都可以贪心取，从耗费牌数多的往牌数少的取。用一个$DFS$作大框架，在$DFS$到每一层（即每次取一组顺子）的前后用贪心算出当前不再取顺子而直接贪心取的总次数，打擂即可。 Code（貌似这个代码只能过原数据，加强版因为“有几个相同的王不能组成对子”这一$bug$，我的代码过不了，要加特判）1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#define SIZE 14#define INF 2147483647using namespace std;int n, ans, c[SIZE];void init() &#123;ans = INF; for (int i = 0; i &lt; SIZE; i++) c[i] = 0;&#125;void modify(int l, int r, int x) &#123;for (int i = l; i &lt;= r; i++) c[i] += x;&#125;int calc() &#123; int c1, c2, c3, c4, ret; c1 = c2 = c3 = c4 = ret = 0; for (int i = 0; i &lt; SIZE; i++) c1 += (c[i] == 1), c2 += (c[i] == 2), c3 += (c[i] == 3), c4 += (c[i] == 4); while (c2 &gt;= 2 &amp;&amp; c4 &gt;= 1) c2 -= 2, c4 -= 1, ret++; while (c2 &gt;= 1 &amp;&amp; c3 &gt;= 1) c2 -= 1, c3 -= 1, ret++; while (c1 &gt;= 2 &amp;&amp; c4 &gt;= 1) c1 -= 2, c4 -= 1, ret++; while (c2 &gt;= 1 &amp;&amp; c4 &gt;= 1) c2 -= 1, c4 -= 1, ret++; while (c1 &gt;= 1 &amp;&amp; c3 &gt;= 1) c1 -= 1, c3 -= 1, ret++; return ret+c1+c2+c3+c4;&#125;void DFS(int stp) &#123; int lft = calc(); bool flag = false; if (stp &gt; ans) return; ans = min(ans, stp+lft); for (int l = 2; l+1 &lt; SIZE; l++) &#123; int tr = l; while (c[tr] &gt;= 3 &amp;&amp; tr &lt; SIZE) tr++; if (--tr-l+1 &lt; 2) continue; flag = true; for (int r = tr; r &gt;= l+1; r--) modify(l, r, -3), DFS(stp+1), modify(l, r, 3); &#125; for (int l = 2; l+2 &lt; SIZE; l++) &#123; int tr = l; while (c[tr] &gt;= 2 &amp;&amp; tr &lt; SIZE) tr++; if (--tr-l+1 &lt; 3) continue; flag = true; for (int r = tr; r &gt;= l+2; r--) modify(l, r, -2), DFS(stp+1), modify(l, r, 2); &#125; for (int l = 2; l+4 &lt; SIZE; l++) &#123; int tr = l; while (c[tr] &gt;= 1 &amp;&amp; tr &lt; SIZE) tr++; if (--tr-l+1 &lt; 5) continue; flag = true; for (int r = tr; r &gt;= l+4; r--) modify(l, r, -1), DFS(stp+1), modify(l, r, 1); &#125; lft = calc(), ans = min(ans, stp+lft);&#125;int main() &#123; int T; scanf("%d%d", &amp;T, &amp;n); while (T--) &#123; init(); for (int i = 0, a, b; i &lt; n; i++) scanf("%d%d", &amp;a, &amp;b), a = a == 1 ? 13 : (a == 0 ? 0 : a-1), c[a]++; DFS(0), printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>NOIp</tag>
        <tag>搜索</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ728 Desert King]]></title>
    <url>%2FPOJ2728%20Desert%20King%20%E4%BA%8C%E5%88%86%2BMST%2F</url>
    <content type="text"><![CDATA[ProblemDesert KingDescriptionDavid the Great has just become the king of a desert country. To win the respect of his people, he decided to build channels all over his country to bring water to every village. Villages which are connected to his capital village will be watered. As the dominate ruler and the symbol of wisdom in the country, he needs to build the channels in a most elegant way.After days of study, he finally figured his plan out. He wanted the average cost of each mile of the channels to be minimized. In other words, the ratio of the overall cost of the channels to the total length must be minimized. He just needs to build the necessary channels to bring water to all the villages, which means there will be only one way to connect each village to the capital.His engineers surveyed the country and recorded the position and altitude of each village. All the channels must go straight between two villages and be built horizontally. Since every two villages are at different altitudes, they concluded that each channel between two villages needed a vertical water lifter, which can lift water up or let water flow down. The length of the channel is the horizontal distance between the two villages. The cost of the channel is the height of the lifter. You should notice that each village is at a different altitude, and different channels can’t share a lifter. Channels can intersect safely and no three villages are on the same line.As King David’s prime scientist and programmer, you are asked to find out the best solution to build the channels. InputThere are several test cases. Each test case starts with a line containing a number $N (2 \le N \le 1000)$, which is the number of villages. Each of the following $N$ lines contains three integers, $x$, $y$ and $z$ $(0\le x, y &lt; 10^4, 0 \le z &lt; 10^7)$. $(x, y)$ is the position of the village and $z$ is the altitude. The first village is the capital. A test case with $N = 0$ ends the input, and should not be processed. OutputFor each test case, output one line containing a decimal number, which is the minimum ratio of overall cost of the channels to the total length. This number should be rounded three digits after the decimal point. Sample Input12345640 0 00 1 11 1 21 0 30 Sample Output11.000 Translation题目大意：给出$n$个村庄和$n^2$条路，以及每条路的长度和代价，要求选出一棵生成树使得其路径总代价除以路径总长度最小。 标签：最优比例生成树，二分答案，$MST$ Solution本题是最优比例生成树的裸题。熟悉二分答案的套路。 注意到如果一个答案$x$可作为平均值，那么比x大的所有答案均可作为平均值，问题具有二分性于是二分答案，即最后的平均值，对于每个答案，构造最小生成树判断可行性，具体如下：对于第$i$条边，长度为$l_i$，代价为$c_i$，那么将此边的权值设为$w_i=c_i-l_i*tans$，跑一遍最小生成树，如果总权值小于$0$，则有可行解。注意此题为稠密图，应用$Prime$。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define MAX_N 1000using namespace std;int n;double map[MAX_N+5][MAX_N+5], val[MAX_N+5][MAX_N+5];struct Point &#123;double x, y, h;&#125; p[MAX_N+5];double calc(double x1, double y1, double x2, double y2) &#123;return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));&#125;bool check(double t) &#123; double ret = 0; double dis[MAX_N+5]; bool vis[MAX_N+5]; memset(dis, 127, sizeof(dis)); memset(vis, 0, sizeof(vis)); dis[1] = 0; for (int i = 0; i &lt; n; i++) &#123; int tv = 0; for (int j = 1; j &lt;= n; j++) if (!vis[j] &amp;&amp; (!tv || dis[j] &lt; dis[tv])) tv = j; vis[tv] = 1, ret += dis[tv]; for (int j = 1; j &lt;= n; j++) if (!vis[j]) dis[j] = min(dis[j], val[tv][j]-map[tv][j]*t); &#125; return ret &lt; 0;&#125;double bi_search() &#123; double l = 0, r = 1e5, mid; while (abs(l-r) &gt; 1e-6) &#123; mid = (l+r)/2; if (check(mid)) r = mid; else l = mid; &#125; return mid;&#125;int main() &#123; while (scanf("%d", &amp;n) &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; i++) scanf("%lf%lf%lf", &amp;p[i].x, &amp;p[i].y, &amp;p[i].h); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= i; j++) map[i][j] = map[j][i] = calc(p[i].x, p[i].y, p[j].x, p[j].y), val[i][j] = val[j][i] = abs(p[i].h-p[j].h); printf("%.3f\n", bi_search()); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>二分答案</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1821【JSOI2010】Group部落划分]]></title>
    <url>%2FBZOJ1821%E3%80%90JSOI2010%E3%80%91Group%E9%83%A8%E8%90%BD%E5%88%92%E5%88%86%20MST%2F</url>
    <content type="text"><![CDATA[Problem 【JSOI2010】Group 部落划分 Group Time Limit: $10 Sec$ Memory Limit: $64 MB$ Description聪聪研究发现，荒岛野人总是过着群居的生活，但是，并不是整个荒岛上的所有野人都属于同一个部落，野人们总是拉帮结派形成属于自己的部落，不同的部落之间则经常发生争斗。只是，这一切都成为谜团了——聪聪根本就不知道部落究竟是如何分布的。 不过好消息是，聪聪得到了一份荒岛的地图。地图上标注了$N$个野人居住的地点（可以看作是平面上的坐标）。我们知道，同一个部落的野人总是生活在附近。我们把两个部落的距离，定义为部落中距离最近的那两个居住点的距离。聪聪还获得了一个有意义的信息——这些野人总共被分为了$K$个部落！这真是个好消息。聪聪希望从这些信息里挖掘出所有部落的详细信息。他正在尝试这样一种算法： 对于任意一种部落划分的方法，都能够求出两个部落之间的距离，聪聪希望求出一种部落划分的方法，使靠得最近的两个部落尽可能远离。 例如，下面的左图表示了一个好的划分，而右图则不是。请你编程帮助聪聪解决这个难题。 Input第一行包含两个整数$N$和$K$($1\le N\le 1000$,$1&lt; K\le N$)，分别代表了野人居住点的数量和部落的数量。接下来$N$行，每行包含两个正整数$x,y$，描述了一个居住点的坐标($0\le x, y\le10000$) Output输出一行，为最优划分时，最近的两个部落的距离，精确到小数点后两位。 Sample Input123454 20 00 11 11 0 Sample Output11.00 标签：$MST$ Solution此题是$MST$的一个简单变形。本题要求分为$k$个部落，即在生成树上拆$k-1$条边。使得其最小距离最大，可以$kruskal$贪心向下选，选到剩$k-1$条边为止。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#define MAX_N 1000using namespace std;typedef double dnt;struct node &#123;int u, v; dnt c;&#125; E[MAX_N*MAX_N+50];bool cmp (const node &amp;a, const node &amp;b) &#123;return a.c &lt; b.c;&#125;int n, k, cnt, x[MAX_N+5], y[MAX_N+5], fa[MAX_N+5];void init() &#123;for (int i = 1; i &lt;= n; i++) fa[i] = i;&#125;dnt dist(int a, int b) &#123;return (dnt)sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));&#125;int getf(int c) &#123;return fa[c] == c ? c : fa[c] = getf(fa[c]);&#125;dnt Kruskal() &#123; sort(E, E+cnt, cmp); for (int i = 0, tot = 0; i &lt; cnt; i++) &#123; int u = getf(E[i].u), v = getf(E[i].v); if (u != v) fa[u] = v, tot++; if (tot &gt; n-k) return E[i].c; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k), init(); for (int i = 1; i &lt;= n; i++) scanf("%d%d", &amp;x[i], &amp;y[i]); for (int i = 1; i &lt;= n; i++) for (int j = i+1; j &lt;= n; j++) E[cnt++] = (node)&#123;i, j, dist(i, j)&#125;; printf("%.2lf", Kruskal()); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>图论</tag>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3228 Gold Transportation]]></title>
    <url>%2FPOJ3228%20Gold%20Transportation%20MST%2F</url>
    <content type="text"><![CDATA[ProblemGold TransportationTime Limit: $2000MS$Memory Limit: $65536K$ DescriptionRecently, a number of gold mines have been discovered in Zorroming State. To protect this treasure, we must transport this gold to the storehouses as quickly as possible. Suppose that the Zorroming State consists of N towns and there are M bidirectional roads among these towns. The gold mines are only discovered in parts of the towns, while the storehouses are also owned by parts of the towns. The storage of the gold mine and storehouse for each town is finite. The truck drivers in the Zorroming State are famous for their bad temper that they would not like to drive all the time and they need a bar and an inn available in the trip for a good rest. Therefore, your task is to minimize the maximum adjacent distance among all the possible transport routes on the condition that all the gold is safely transported to the storehouses. InputThe input contains several test cases. For each case, the first line is integer $N$$(1\le N\le 200)$. The second line is $N$ integers associated with the storage of the gold mine in every towns .The third line is also $N$ integers associated with the storage of the storehouses in every towns .Next is integer $M$$(0\le M\le \frac{(n-1)\times n}{2})$.Then M lines follow. Each line is three integers $x$, $y$ and $d$$(1\le x,y\le N, 0&lt;d\le 10^4)$, means that there is a road between $x$ and $y$ for distance of $d$. $N=0$ means end of the input. OutputFor each case, output the minimum of the maximum adjacent distance on the condition that all the gold has been transported to the storehouses or “No Solution”. Sample Input123456789101143 2 0 00 0 3 361 2 41 3 101 4 122 3 62 4 83 4 50 Sample Output16 Translation题目大意：有$n$个村庄，每个村庄有一个黄金矿和一个仓库，求一棵生成树森林，使得每棵生成树上的黄金矿都可被这棵生成树上的仓库存下，并且森林中最大边权最小。 标签：$MST$ Solution一个简单的$MST$变形。用$Kruskal$从大到小贪心选边，每加一条边就$O(n)$判断森林中是否所有点所在的树都可以“自给自足”。总时间复杂度$O(mn)$，即$O(n^3)$。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 200#define MAX_M 20000using namespace std;int n, m, f[MAX_N+5], s[MAX_N+5];struct node &#123;int u, v, c;&#125; E[MAX_M+5];bool cmp(const node &amp;a, const node &amp;b) &#123;return a.c &lt; b.c;&#125;int getf(int x) &#123;if (f[x] == x) return x; int tmp = getf(f[x]); s[tmp] += s[x], s[x] = 0; return f[x] = tmp;&#125;bool chk() &#123;for (int i = 1; i &lt;= n; i++) if (f[i] == i &amp;&amp; s[i] &lt; 0) return false; return true;&#125;int main() &#123; while (scanf("%d", &amp;n) &amp;&amp; n) &#123; for (int i = 1; i &lt;= n; i++) f[i] = i, s[i] = 0; for (int i = 1, x; i &lt;= n; i++) scanf("%d", &amp;x), s[i] -= x; for (int i = 1, x; i &lt;= n; i++) scanf("%d", &amp;x), s[i] += x; scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) scanf("%d%d%d", &amp;E[i].u, &amp;E[i].v, &amp;E[i].c); sort(E, E+m, cmp); bool flag = false; for (int i = 0; i &lt; m; i++) &#123; int u = getf(E[i].u), v = getf(E[i].v); if (u != v) f[u] = v, s[v] += s[u], s[u] = 0; if (chk()) &#123;flag = true, printf("%d\n", E[i].c); break;&#125; &#125; if (!flag) printf("No Solution\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>MST</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3993【SDOI2015】星际战争]]></title>
    <url>%2FBZOJ3993%E3%80%90SDOI2015%E3%80%91%E6%98%9F%E9%99%85%E6%88%98%E4%BA%89%20%E4%BA%8C%E5%88%86%2B%E6%9C%80%E5%A4%A7%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 【SDOI2015】星际战争 Time Limit: $10 Sec$ Memory Limit: $128 MBSec$ $Special Judge$ Description$3333$年，在银河系的某星球上，$X$军团和$Y$军团正在激烈地作战。在战斗的某一阶段，$Y$军团一共派遣了$N$个巨型机器人进攻$X$军团的阵地，其中第$i$个巨型机器人的装甲值为$A_i$。当一个巨型机器人的装甲值减少到$0$或者以下时，这个巨型机器人就被摧毁了。$X$军团有$M$个激光武器，其中第i个激光武器每秒可以削减一个巨型机器人$B_i$的装甲值。激光武器的攻击是连续的。这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。$Y$军团看到自己的巨型机器人被$X$军团一个一个消灭，他们急需下达更多的指令。为了这个目标，$Y$军团需要知道$X$军团最少需要用多长时间才能将$Y$军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。 Input第一行，两个整数，$N$、$M$。第二行，$N$个整数，$A_1$、$A_2$ $\cdots$ $A_N$。第三行，$M$个整数，$B_1$、$B_2$ $\cdots$ $B_M$。接下来的$M$行，每行$N$个整数，这些整数均为$0$或者$1$。这部分中的第$i$行的第$j$个整数为$0$表示第$i$个激光武器不可以攻击第$j$个巨型机器人，为$1$表示第$i$个激光武器可以攻击第$j$个巨型机器人。 Output一行，一个实数，表示$X$军团要摧毁$Y$军团的所有巨型机器人最少需要的时间。输出结果与标准答案的绝对误差不超过$10^{-3}$即视为正确。 Sample Input123452 23 104 60 11 1 Sample Output11.300000 HINT【样例说明】战斗开始后的前$0.5$秒，激光武器$1$攻击$2$号巨型机器人，激光武器$2$攻击$1$号巨型机器人。$1$号巨型机器人被完全摧毁，$2$号巨型机器人还剩余$8$的装甲值；接下来的$0.8$秒，激光武器$1$、$2$同时攻击$2$号巨型机器人。$2$号巨型机器人被完全摧毁。于全部的数据，$1\le N,M\le 50$，$1\le A_i\le 10^5$，$1\le B_i\le 10^3$，输入数据保证$X$军团一定能摧毁$Y$军团的所有巨型机器人 标签：二分答案+网络流 Solution如果直接处理这个问题，会发现限制有点多，不太好处理。考虑二分答案。二分最少时间，那么每个激光炮在此时间内可造成的伤害就可以算出，这时只需判断合理分配这些伤害能否使敌方团灭。发现可以建图跑最大流判断。从源点$S$向所有激光炮连边，容量为此激光炮可造成的总伤害。从所有机器人向汇点$T$连边，容量为机器人血量。从每个激光炮向其所可以造成伤害的所有机器人连边，容量为$\infty$，这样跑一遍最大流，判断是否等于所有机器人的总血量即可。建图可以不用全部新建，只用在开始的时候建一个图，二分判断时将所有$S$到激光炮的边容量改成$B_i\times tans$即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define MAX_N 100#define EPS 1e-8#define INF 0x3f3f3f3f#define mid (l+r)/2using namespace std;typedef double dnt;struct node &#123;int v, nxt; dnt c;&#125; E[MAX_N*MAX_N*5+500]; dnt sum;int n, m, s, t, a[MAX_N+5], b[MAX_N+5], mrk[MAX_N+5][MAX_N+5], pre[MAX_N+5], d[MAX_N+5], cnt;void init() &#123;memset(pre, -1, sizeof(pre)), cnt = 0, s = 0, t = n+m+1;&#125;void insert(int u, int v, dnt c) &#123;E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++;&#125;void build() &#123; init(); for (int i = 1; i &lt;= n; i++) insert(i, t, a[i]), insert(t, i, 0), sum += a[i]; for (int i = 1; i &lt;= m; i++) insert(s, i+n, INF), insert(i+n, s, 0); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) if (mrk[i][j]) insert(i+n, j, INF), insert(j, i+n, 0);&#125;bool BFS() &#123; queue &lt;int&gt; que; memset(d, -1, sizeof(d)); que.push(s), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v; if (E[i].c &lt;= EPS || ~d[v]) continue; d[v] = d[u]+1; que.push(v); &#125; &#125; return ~d[t];&#125;dnt DFS(int u, dnt flow) &#123; if (u == t) return flow; dnt ret = 0; for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v; if (E[i].c &lt;= EPS || d[v] != d[u]+1) continue; dnt tmp = DFS(v, min(flow, E[i].c)); E[i].c -= tmp, E[i^1].c += tmp, ret += tmp, flow -= tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;bool chk(dnt tans) &#123; for (int i = 0; i &lt; cnt; i += 2) E[i].c += E[i^1].c, E[i^1].c = 0; for (int i = pre[s]; ~i; i = E[i].nxt) E[i].c = (dnt)b[E[i].v-n]*tans; dnt tot = 0; while (BFS()) tot += DFS(s, INF); return fabs(tot-sum) &lt;= EPS;&#125;dnt bi_search(dnt l, dnt r) &#123; dnt ret = -1; for (int i = 0; i &lt; 100; i++) if (chk(mid)) ret = r = mid; else l = mid; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int i = 1; i &lt;= m; i++) scanf("%d", b+i); for (int i = 1; i &lt;= m; i++) for (int j = 1; j &lt;= n; j++) scanf("%d", &amp;mrk[i][j]); build(), printf("%.5lf", bi_search(0, INF)); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1972 【SDOI2010】 猪国杀]]></title>
    <url>%2FBZOJ1972%E3%80%90SDOI2010%E3%80%91%E7%8C%AA%E5%9B%BD%E6%9D%80%2F</url>
    <content type="text"><![CDATA[Problem 【SDOI2010】猪国杀 Time Limit: $1 Sec$ Memory Limit: $64 MB$ 题目描述 Description 概述《猪国杀》是一种多猪牌类回合制游戏，一共有三种角色：主猪，忠猪，反猪。 每局游戏主猪有且只有一只，忠猪和反猪可以有多只，每只猪扮演一种角色。 游戏目的：·主猪（$MP$）：自己存活的情况下消灭所有的反猪。 ·忠猪（ZP）：不惜一切保护主猪，胜利条件与主猪相同。 ·反猪（FP）：杀死主猪。 游戏过程：·游戏开始时候，每个玩家手里都会有$4$张牌，且体力上限和初始体力都是$4$。 ·开始游戏时，从主猪开始，按照逆时针方向（数据中就是按照编号从1,2,3..n,1..的顺序）依次行动。 ·每个玩家自己的回合可以分为2个阶段： ·摸牌阶段： ·从牌堆顶部摸两张牌，依次放到手牌的最右边。 ·出牌阶段： ·你可以使用0张到任意张牌，每次使用牌的时候都使用最靠左的能够使用的牌。 ·当然，要满足如下规则： ·1.如果没有猪哥连弩，每个出牌阶段只能使用一次“杀”来攻击。 ·2.任何牌被使用后被弃置（武器是装备上）。 ·被弃置的牌以后都不能再用，即与游戏无关。 各种牌介绍：·每张手牌用一个字母表示，字母代表牌的种类。 ·基本牌： 『桃(P)』： ·在自己的回合内，如果自己的体力值不等于体力上限，那么使用一个桃可以为自己补充一点体力，否则不能使用桃。 ·桃只能对自己使用。 ·在自己的回合外，如果自己的血变为0或者更低，那么也可以使用。 『杀(K)』： ·在自己的回合内，对攻击范围内除自己以外的一名角色使用。 ·如果没有被『闪』抵消，则造成1点伤害。无论有无武器，杀的攻击范围都是1。 『闪(D)』： ·当你受到杀的攻击时，可以弃置一张闪来抵消杀的效果。 ·锦囊牌： 『决斗(F)』： ·出牌阶段，对除自己以外任意一名角色使用，由目标角色先开始，自己和目标角色轮流弃置一张杀，首先没有杀可弃的一方受到1点伤害，另一方视为此伤害的来源。 『南猪入侵(N)』： ·出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置一张杀，否则受到1点伤害。 『万箭齐发(W)』： ·和南猪入侵类似，不过要弃置的不是杀而是闪。 『无懈可击(J)』： ·在目标锦囊生效前抵消其效果。 ·每次有一张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会。 ·效果： ·用于决斗时，决斗无效并弃置。 ·用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对一个角色产生效果）。 ·用于无懈可击时，成为目标的无懈可击被无效。 ·装备牌： 『猪哥连弩(Z)』： ·武器，攻击范围1，出牌阶段你可以使用任意张杀。 ·同一时刻最多只能装一个武器。 ·如果先前已经有了一把武器，那么之后再装武器的话，会弃置以前的武器来装现在的武器。 特殊事件及概念解释：·伤害来源： ·杀、南猪入侵、万箭齐发的伤害来源均是使用该牌的猪。 ·决斗的伤害来源如上。 ·距离： ·两只猪的距离定义为沿着逆时针方向间隔的猪数＋1。即初始时1和2的距离为1，但是2和1的距离就是n-1。 ·注意一个角色的死亡会导致一些猪距离的改变； ·玩家死亡： ·如果该玩家的体力降到0或者更低，并且自己手中没有足够的桃使得自己的体力值回到1，那么就死亡了。 ·死亡后所有的牌（装备区，手牌区）被弃置。 ·奖励与惩罚： ·反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸三张牌。 ·忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置。 ·注意，一旦达成胜利条件，游戏立刻结束，因此即使会摸3张牌或者还有牌可以用也不用执行了。 几种行为：·献殷勤： ·使用无懈可击挡下南猪入侵、万箭齐发、决斗。 ·使用无懈可击抵消表敌意。 ·表敌意： ·对某个角色使用杀、决斗。 ·使用无懈可击抵消献殷勤。 ·跳忠： ·即通过行动表示自己是忠猪。 ·跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意。 ·跳反： ·即通过行动表示自己是反猪。 ·跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤。 ·忠猪不会跳反，反猪也不会跳忠。 ·不管是忠猪还是反猪，能够跳必然跳。 行动准则：·共性： ·每个角色如果手里有桃且生命值未满，那么必然吃掉。 ·有南猪入侵、万箭齐发、必然使用。 ·有装备必然装上。 ·受到杀时，有闪必然弃置。 ·响应南猪入侵或者万箭齐发时候，有杀/闪必然弃置。 ·不会对未表明身份的猪献殷勤（包括自己）。 ·特性： ·主猪： ·主猪会认为没有跳身份，且用南猪入侵/万箭齐发对自己造成伤害的猪是类反猪（没伤害到不算，注意类反猪并没有表明身份），如果之后跳了，那么主猪会重新认识这只猪。 ·对于每种表敌意的方式，对逆时针方向能够执行到的第一只类反猪或者已跳反猪表；如果没有，那么就不表敌意。 ·决斗时会不遗余力弃置杀。 ·如果能对已经跳忠的猪或自己献殷勤，那么一定献。 ·如果能够对已经跳反的猪表敌意，那么一定表。 ·忠猪： ·对于每种表敌意的方式，对逆时针方向能够执行到的第一只已经跳反的猪表，如果没有，那么就不表敌意。 ·决斗时，如果对方是主猪，那么不会弃置杀，否则，会不遗余力弃置杀。 ·如果有机会对主猪或者已经跳忠的猪献殷勤，那么一定献。 ·反猪： ·对于每种表敌意的方式，如果有机会则对主猪表，否则，对逆时针方向能够执行到的第一只已经跳忠的猪表，如果没有，那么就不表敌意。 ·决斗时会不遗余力弃置杀。 ·如果有机会对已经跳反的猪献殷勤，那么一定献。 现在，我们已经知道每只猪的角色、手牌，还有牌堆初始情况，并且假设每个角色会按照如下的行为准则进行游戏，你需要做的就是告诉小猪$iPig$最后的结果。限于$iPig$只会用$P++$语言写$A+B$，他请你用$Pigcal(Pascal)$、$P(C)$或$P++(C++)$语言来帮他预测最后的结果。 输入描述 Input Description输入文件第一行包含两个正整数$n$($2\le n\le 10$)和$m$($m\le 2000$)，分别代表玩家数和牌堆中牌的数量。数据保证牌的数量够用。接下来$n$行，每行$5$个字符串，依次表示对第$i$只猪的角色和初始$4$张手牌描述。编号为$1$的肯定是主猪。再接下来一行，一共$m$个字符串，按照从牌堆顶部到牌堆底部的顺序描述每张牌。所有的相邻的两个字符串都严格用$1$个空格隔开，行尾没有多余空格。输出描述 Output Description输出数据第一行包含一个字符串代表游戏结果。如果是主猪胜利，那么输出$MP$，否则输出$FP$。数据保证游戏总会结束。接下来$n$行，第$i$行是对第$i$只猪的手牌描述（注意只需要输出手牌），按照手牌从左往右的顺序输出，相邻两张牌用一个空格隔开，行末尾没有多余空格。如果这只猪已阵亡，那么只要输出$DEAD$即可。注意如果要输出手牌而没有手牌的话，那么只需输出一个空行。 样例数据 Sample Data Sample Input #1 123453 10MP D D F FZP N N N DFP J J J JF F D D J J F F K D Sample Output #11234FPDEADDEADJ J J J J J D 数据范围及提示 Data Size &amp; Hint样例$1$说明：第一回合主猪没有目标可以表敌意；接下来忠猪使用了$3$张南猪入侵，主猪掉了$3$点体力，并认为该角色为类反猪，$3$号角色尽管手里有无懈可击，但是因为自己未表明身份，所以同样不能对自己用，乖乖掉$3$点体力；下一回合反猪无牌可出；接下来主猪对着类反猪爆发，使用$4$张决斗，忠猪死亡，结果主猪弃掉所有牌；下来反猪摸到一张杀直接杀死主猪获胜。数据说明：一共$20$组测试数据，每个点$5$分。$10\%$的数据没有锦囊牌，另外$20\%$的数据没有无懈可击。 如果觉得此题面不好看，请戳这里：https://mubu.com/doc/2707815814591da4 标签：模拟 Solution本题是大模拟，题面很恶心，又长又绕，根本无法概括，不过读懂以后按序操作还是比较容易的。坑点如下： 如果牌堆中没牌了，那么需要不断的摸取最后一张牌 无懈可击的使用：可以用来帮助身份已明且和自己一伙的人抵挡南猪入侵、万箭齐发、决杀等效果，或者帮助其抵消对方无懈可击的效果。一旦使出无懈可击即可表明自己的身份，表明身份后类反猪的身份会随之消失。注意无懈可击的使用顺序是从锦囊牌的出牌者开始按照逆时针的顺序进行出牌的。 一只猪死亡后立刻退场，不会再进行任何操作，所有手牌弃置。如果此时游戏结束，那么一切操作都暂停。 出完一张牌后（除桃）需要重新扫描所有的手牌，因为每次出牌可能会导致不同的猪身份的改变，进而前面跳过的牌可能有机会打出。 寻找打出杀得下家时要跳过已经死亡的猪。 打出决斗，无论最后是否生效，即认为身份表面。对于主猪对忠猪发起的决斗，忠猪乖乖掉血。 奉献几组样例，可以自测： Sample #1Input123453 10MP D D F FZP N N N DFP J J J JF F D D J J F F K D Output1234FPDEADDEADJ J J J J J D Sample #2Input12345675 10MP W D F KZP N N D DFP F W W KZP K K N DFP K D P WJ K W K D N N K J N Output12345MPF NDDEADDEAD Sample #3Input123453 4MP J J K NZP J D K WFP P N P KJ J K W Output123MPK KDEAD Sample #4Input123453 10MP W D J WZP J P D NFP N D F FJ D N N F J J D K W Output123MPD J DDEAD Sample #5Input123453 1MP D N F KZP F W F NFP D N N DK Output1234MPKF K KDEAD Code注释版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 10#define MAX_M 2000using namespace std;int n, m, Type[MAX_N+5]; //真实身份（1主公 2忠臣 3反贼）int lft; bool GameOver; //剩余反贼、游戏结束标记char Heap[MAX_M*2+5]; int CurPos; //牌堆int bef[MAX_M*5+5], nxt[MAX_M*5+5], cnt; char c[MAX_M*5+5]; //手牌char Draw() &#123;CurPos = CurPos == m ? m : CurPos+1; return Heap[CurPos];&#125; //摸牌void Attack(int, int); void Duel(int, int); void Invade(int); void Arrow(int);struct Player &#123; int id, Sta; //编号、目前身份（0没跳 1类反 2跳忠 3跳反） int head, tail, now, tp; //手牌链表 int cntWX, cntA, cntP, cntS; //手中无懈可击、杀、桃、闪的数量 int blood, atk, pre, suc; //血量、首要攻击目标、存活的上一头猪、存活的下一头猪 bool dead, equip; //是否死亡、是否装备连弩 void Bonus() &#123; //奖励 c[++cnt] = Draw(), bef[cnt] = tail; if (head == 0) head = tail = cnt; else nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; &#125; void Punish() &#123; //惩罚 head = tail = now = cntWX = cntA = cntP = cntS = 0, equip = false; &#125; void DrawSession() &#123; //摸牌阶段 c[++cnt] = Draw(), bef[cnt] = tail; if (head == 0) head = tail = cnt; else nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; &#125; void Use(int x) &#123; //使用一张牌 if (c[x] == 'J') cntWX--; if (c[x] == 'K') cntA--; if (c[x] == 'P') cntP--; if (c[x] == 'D') cntS--; if (x == head &amp;&amp; x == tail) head = tail = 0; else if (x == head) head = nxt[x], bef[nxt[x]] = 0; else if (x == tail) tail = bef[x], nxt[bef[x]] = 0; else bef[nxt[x]] = bef[x], nxt[bef[x]] = nxt[x]; &#125; char GetNxt() &#123; //返回下一张牌 if (!now) return 0; tp = now, now = nxt[now]; return c[tp]; &#125; int findWX() &#123; //找下一张无懈可击 now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'J') return tp; return 0; &#125; int findA() &#123; //找下一张杀 now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'K') return tp; return 0; &#125; int findP() &#123; //找下一张桃 now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'P') return tp; return 0; &#125; int findS() &#123; //找下一张闪 now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'D') return tp; return 0; &#125; bool tryWX() &#123; //尝试出无懈可击 if (cntWX) &#123;Use(findWX()); return true;&#125; return false; &#125; bool tryA() &#123; //尝试出杀 if (cntA) &#123;Use(findA()); return true;&#125; return false; &#125; bool tryS() &#123; //尝试出闪 if (cntS) &#123;Use(findS()); return true;&#125; return false; &#125; bool tryP() &#123; //尝试出桃 if (cntP) &#123;Use(findP()); return true;&#125; return false; &#125; void Round() &#123; DrawSession(); now = head; bool atked = false; char tmp; while ((tmp = GetNxt()) &amp;&amp; !GameOver) &#123; //cout &lt;&lt; tmp &lt;&lt; " "; if (tmp == 'D' || tmp == 'J') continue; if (tmp == 'K' &amp;&amp; atk == suc &amp;&amp; (!atked || equip)) &#123; Use(tp), Attack(id, atk), now = head, atked = true; if (GameOver) return; &#125; if (tmp == 'P' &amp;&amp; blood != 4) Use(tp), blood++; if (tmp == 'F') &#123; if (!atk) continue; Use(tp); if (Type[id] == 3) Duel(id, 1); else Duel(id, atk); now = head; if (GameOver || dead) return; &#125; if (tmp == 'N') &#123; Use(tp), Invade(id), now = head; if (GameOver) return; &#125; if (tmp == 'W') &#123; Use(tp), Arrow(id), now = head; if (GameOver) return; &#125; if (tmp == 'Z') Use(tp), equip = true, now = head; &#125; //cout &lt;&lt; endl; &#125; void Output() &#123; if (dead) &#123;printf("DEAD\n"); return;&#125; for (; head; head = nxt[head]) if (head == tail) cout &lt;&lt; c[head]; else cout &lt;&lt; c[head] &lt;&lt; ' '; printf("\n"); &#125;&#125; pig[MAX_N+5];void FindAtk(int x) &#123; int y = pig[x].suc; if (Type[x] == 1) &#123; while (y != x) &#123; if (pig[y].Sta == 1 || pig[y].Sta == 3) &#123; pig[x].atk = y; return; &#125; y = pig[y].suc; &#125; pig[x].atk = 0; &#125; if (Type[x] == 2) &#123; while (y != x) &#123; if (pig[y].Sta == 3) &#123; pig[x].atk = y; return; &#125; y = pig[y].suc; &#125; pig[x].atk = 0; &#125; if (Type[x] == 3) &#123; while (y != x) &#123; if (Type[y] == 1 || pig[y].Sta == 2) &#123; pig[x].atk = y; return; &#125; y = pig[y].suc; &#125; pig[x].atk = 0; &#125;&#125;void Maintain() &#123; int x = pig[1].suc; FindAtk(1); while (x != 1) FindAtk(x), x = pig[x].suc;&#125;void Kill(int x, int y) &#123; //杀死对方 pig[y].dead = true; if (Type[y] == 1) &#123;GameOver = true; return;&#125; if (Type[y] == 3) &#123; if (--lft == 0) &#123;GameOver = true; return;&#125; pig[x].Bonus(); &#125; if (Type[x] == 1 &amp;&amp; Type[y] == 2) pig[x].Punish(); int PRE = pig[y].pre, SUC = pig[y].suc; pig[PRE].suc = SUC, pig[SUC].pre = PRE; Maintain();&#125;void Hurt(int x, int y) &#123; //命中对方 if (--pig[y].blood == 0) if (pig[y].tryP()) pig[y].blood++; else Kill(x, y);&#125;void Attack(int x, int y) &#123; //杀 if (Type[x] != 1 &amp;&amp; pig[x].Sta &lt; 2) &#123; if (Type[y] == 3) pig[x].Sta = 2; else pig[x].Sta = 3; Maintain(); &#125; if (!pig[y].tryS()) Hurt(x, y);&#125;bool WXcycle(int st, bool YType) &#123; //无懈可击 int last = st, x = st; bool ORI = YType; if (YType == (Type[x] == 3) &amp;&amp; pig[x].tryWX()) &#123; last = x, YType ^= 1; if (pig[x].Sta &lt;= 2) pig[x].Sta = 3-YType, Maintain(); &#125; x = pig[x].suc; while (x != last) &#123; if (YType == (Type[x] == 3) &amp;&amp; pig[x].tryWX()) &#123; last = x, YType ^= 1; if (pig[x].Sta &lt;= 2) pig[x].Sta = 3-YType, Maintain(); &#125; x = pig[x].suc; &#125; return ORI != YType;&#125;void Duel(int x, int y) &#123; //决斗 if (Type[x] != 1 &amp;&amp; pig[x].Sta &lt; 2) &#123; if (Type[y] == 3) pig[x].Sta = 2; else pig[x].Sta = 3; Maintain(); &#125; if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) &#123; if (WXcycle(x, 0)) return; &#125; else &#123; if (WXcycle(x, 1)) return; &#125; if (Type[x] == 1 &amp;&amp; Type[y] == 2) Hurt(x, y); else for (;;) &#123; if (!pig[y].tryA()) &#123;Hurt(x, y); return;&#125; if (!pig[x].tryA()) &#123;Hurt(y, x); return;&#125; &#125;&#125;void Invade(int x) &#123; //南猪入侵 int y = pig[x].suc; while (y != x) &#123; if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) &#123; if (WXcycle(x, 0)) &#123;y = pig[y].suc; continue;&#125; &#125; else &#123; if (WXcycle(x, 1)) &#123;y = pig[y].suc; continue;&#125; &#125; if (!pig[y].tryA()) &#123; Hurt(x, y); if (GameOver) return; if (y == 1 &amp;&amp; pig[x].Sta == 0) pig[x].Sta = 1, Maintain(); &#125; y = pig[y].suc; &#125;&#125;void Arrow(int x) &#123; //万箭齐发 int y = pig[x].suc; while (y != x) &#123; if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) &#123; if (WXcycle(x, 0)) &#123;y = pig[y].suc; continue;&#125; &#125; else &#123; if (WXcycle(x, 1)) &#123;y = pig[y].suc; continue;&#125; &#125; if (!pig[y].tryS()) &#123; Hurt(x, y); if (GameOver) return; if (y == 1 &amp;&amp; pig[x].Sta == 0) pig[x].Sta = 1, Maintain(); &#125; y = pig[y].suc; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); char s[2]; int tot = 0; for (int i = n; i &gt; 1; i--) pig[i].pre = i-1; pig[1].pre = n; for (int i = 1; i &lt; n; i++) pig[i].suc = i+1; pig[n].suc = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", s); if (s[0] == 'M') Type[i] = 1; if (s[0] == 'Z') Type[i] = 2; if (s[0] == 'F') Type[i] = 3, lft++; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; &#125; for (int i = 1; i &lt;= m; i++) scanf("%s", s), Heap[++tot] = s[0]; m = tot; Maintain(); for (int i = 1; i &lt;= n; i++) pig[i].id = i, pig[i].blood = 4, pig[i].DrawSession(), pig[i].DrawSession(); for (int cur = 1; !GameOver; cur = pig[cur].suc) pig[cur].Round(); printf("%s\n", pig[1].dead ? "FP" : "MP"); for (int i = 1; i &lt;= n; i++) pig[i].Output(); return 0;&#125; 压行版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 10#define MAX_M 2000using namespace std;int n, m, Type[MAX_N+5], lft, CurPos, cnt; bool GameOver;char Heap[MAX_M*2+5], c[MAX_M*5+5]; int bef[MAX_M*5+5], nxt[MAX_M*5+5];char Draw() &#123;CurPos = CurPos == m ? m : CurPos+1; return Heap[CurPos];&#125;void Attack(int, int); void Duel(int, int); void Invade(int); void Arrow(int);struct Player &#123; int id, Sta, head, tail, now, tp, cntWX, cntA, cntP, cntS, blood, atk, pre, suc; bool dead, equip; void Bonus() &#123; c[++cnt] = Draw(), bef[cnt] = tail; if (head == 0) head = tail = cnt; else nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; &#125; void Punish() &#123;head = tail = now = cntWX = cntA = cntP = cntS = 0, equip = false;&#125; void DrawSession() &#123; c[++cnt] = Draw(), bef[cnt] = tail; if (head == 0) head = tail = cnt; else nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; c[++cnt] = Draw(), bef[cnt] = tail; nxt[tail] = cnt, tail = cnt; if (c[cnt] == 'J') cntWX++; if (c[cnt] == 'K') cntA++; if (c[cnt] == 'P') cntP++; if (c[cnt] == 'D') cntS++; &#125; void Use(int x) &#123; if (c[x] == 'J') cntWX--; if (c[x] == 'K') cntA--; if (c[x] == 'P') cntP--; if (c[x] == 'D') cntS--; if (x == head &amp;&amp; x == tail) head = tail = 0; else if (x == head) head = nxt[x], bef[nxt[x]] = 0; else if (x == tail) tail = bef[x], nxt[bef[x]] = 0; else bef[nxt[x]] = bef[x], nxt[bef[x]] = nxt[x]; &#125; char GetNxt() &#123;if (!now) return 0; tp = now, now = nxt[now]; return c[tp];&#125; int findWX() &#123;now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'J') return tp; return 0;&#125; int findA() &#123;now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'K') return tp; return 0;&#125; int findP() &#123;now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'P') return tp; return 0;&#125; int findS() &#123;now = head; char tmp; while (tmp = GetNxt()) if (tmp == 'D') return tp; return 0;&#125; bool tryWX() &#123;if (cntWX) &#123;Use(findWX()); return true;&#125; return false;&#125; bool tryA() &#123;if (cntA) &#123;Use(findA()); return true;&#125; return false;&#125; bool tryS() &#123;if (cntS) &#123;Use(findS()); return true;&#125; return false;&#125; bool tryP() &#123;if (cntP) &#123;Use(findP()); return true;&#125; return false;&#125; void Round() &#123; DrawSession(); now = head; bool atked = false; char tmp; while ((tmp = GetNxt()) &amp;&amp; !GameOver) &#123; if (tmp == 'D' || tmp == 'J') continue; if (tmp == 'K' &amp;&amp; atk == suc &amp;&amp; (!atked || equip)) &#123;Use(tp), Attack(id, atk), now = head, atked = true; if (GameOver) return;&#125; if (tmp == 'P' &amp;&amp; blood != 4) Use(tp), blood++; if (tmp == 'F') &#123; if (!atk) continue; Use(tp); if (Type[id] == 3) Duel(id, 1); else Duel(id, atk); now = head; if (GameOver || dead) return; &#125; if (tmp == 'N') &#123;Use(tp), Invade(id), now = head; if (GameOver) return;&#125; if (tmp == 'W') &#123;Use(tp), Arrow(id), now = head; if (GameOver) return;&#125; if (tmp == 'Z') Use(tp), equip = true, now = head; &#125; &#125; void Output() &#123; if (dead) &#123;printf("DEAD\n"); return;&#125; for (; head; head = nxt[head]) if (head == tail) cout &lt;&lt; c[head]; else cout &lt;&lt; c[head] &lt;&lt; ' '; printf("\n"); &#125;&#125; pig[MAX_N+5];void FindAtk(int x) &#123; int y = pig[x].suc; if (Type[x] == 1) &#123; while (y != x) &#123;if (pig[y].Sta == 1 || pig[y].Sta == 3) &#123;pig[x].atk = y; return;&#125; y = pig[y].suc;&#125; pig[x].atk = 0; &#125; if (Type[x] == 2) &#123; while (y != x) &#123;if (pig[y].Sta == 3) &#123;pig[x].atk = y; return;&#125; y = pig[y].suc;&#125; pig[x].atk = 0; &#125; if (Type[x] == 3) &#123; while (y != x) &#123;if (Type[y] == 1 || pig[y].Sta == 2) &#123;pig[x].atk = y; return;&#125; y = pig[y].suc;&#125; pig[x].atk = 0; &#125;&#125;void Maintain() &#123;int x = pig[1].suc; FindAtk(1); while (x != 1) FindAtk(x), x = pig[x].suc;&#125;void Kill(int x, int y) &#123; pig[y].dead = true; if (Type[y] == 1) &#123;GameOver = true; return;&#125; if (Type[y] == 3) &#123;if (--lft == 0) &#123;GameOver = true; return;&#125; pig[x].Bonus();&#125; if (Type[x] == 1 &amp;&amp; Type[y] == 2) pig[x].Punish(); int PRE = pig[y].pre, SUC = pig[y].suc; pig[PRE].suc = SUC, pig[SUC].pre = PRE; Maintain();&#125;void Hurt(int x, int y) &#123;if (--pig[y].blood == 0) if (pig[y].tryP()) pig[y].blood++; else Kill(x, y);&#125;void Attack(int x, int y) &#123; if (Type[x] != 1 &amp;&amp; pig[x].Sta &lt; 2) &#123; if (Type[y] == 3) pig[x].Sta = 2; else pig[x].Sta = 3; Maintain(); &#125; if (!pig[y].tryS()) Hurt(x, y);&#125;bool WXcycle(int st, bool YType) &#123; int last = st, x = st; bool ORI = YType; if (YType == (Type[x] == 3) &amp;&amp; pig[x].tryWX()) &#123;last = x, YType ^= 1; if (pig[x].Sta &lt;= 2) pig[x].Sta = 3-YType, Maintain();&#125; x = pig[x].suc; while (x != last) &#123; if (YType == (Type[x] == 3) &amp;&amp; pig[x].tryWX()) &#123;last = x, YType ^= 1; if (pig[x].Sta &lt;= 2) pig[x].Sta = 3-YType, Maintain();&#125; x = pig[x].suc; &#125; return ORI != YType;&#125;void Duel(int x, int y) &#123; if (Type[x] != 1 &amp;&amp; pig[x].Sta &lt; 2) &#123;if (Type[y] == 3) pig[x].Sta = 2; else pig[x].Sta = 3; Maintain();&#125; if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) &#123;if (WXcycle(x, 0)) return;&#125; else &#123;if (WXcycle(x, 1)) return;&#125; if (Type[x] == 1 &amp;&amp; Type[y] == 2) Hurt(x, y); else for (;;) &#123;if (!pig[y].tryA()) &#123;Hurt(x, y); return;&#125; if (!pig[x].tryA()) &#123;Hurt(y, x); return;&#125;&#125;&#125;void Invade(int x) &#123; int y = pig[x].suc; while (y != x) &#123; if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) &#123;if (WXcycle(x, 0)) &#123;y = pig[y].suc; continue;&#125;&#125; else &#123;if (WXcycle(x, 1)) &#123;y = pig[y].suc; continue;&#125;&#125; if (!pig[y].tryA()) &#123; Hurt(x, y); if (GameOver) return; if (y == 1 &amp;&amp; pig[x].Sta == 0) pig[x].Sta = 1, Maintain(); &#125; y = pig[y].suc; &#125;&#125;void Arrow(int x) &#123; int y = pig[x].suc; while (y != x) &#123; if (Type[y] == 1 || pig[y].Sta &gt;= 2) if (Type[y] == 1 || pig[y].Sta == 2) &#123;if (WXcycle(x, 0)) &#123;y = pig[y].suc; continue;&#125;&#125; else &#123;if (WXcycle(x, 1)) &#123;y = pig[y].suc; continue;&#125;&#125; if (!pig[y].tryS()) &#123; Hurt(x, y); if (GameOver) return; if (y == 1 &amp;&amp; pig[x].Sta == 0) pig[x].Sta = 1, Maintain(); &#125; y = pig[y].suc; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); char s[2]; int tot = 0; for (int i = n; i &gt; 1; i--) pig[i].pre = i-1; pig[1].pre = n; for (int i = 1; i &lt; n; i++) pig[i].suc = i+1; pig[n].suc = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", s); if (s[0] == 'M') Type[i] = 1; if (s[0] == 'Z') Type[i] = 2; if (s[0] == 'F') Type[i] = 3, lft++; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; scanf("%s", s); Heap[++tot] = s[0]; &#125; for (int i = 1; i &lt;= m; i++) scanf("%s", s), Heap[++tot] = s[0]; m = tot; Maintain(); for (int i = 1; i &lt;= n; i++) pig[i].id = i, pig[i].blood = 4, pig[i].DrawSession(), pig[i].DrawSession(); for (int cur = 1; !GameOver; cur = pig[cur].suc) pig[cur].Round(); printf("%s\n", pig[1].dead ? "FP" : "MP"); for (int i = 1; i &lt;= n; i++) pig[i].Output(); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4757 Tree]]></title>
    <url>%2FHDU4757%20Tree%20LCA%2B%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96Trie%2F</url>
    <content type="text"><![CDATA[Problem 【LCA+可持久化Trie】Tree DescriptionZero and One are good friends who always have fun with each other.This time, they decide to do something on a tree which is a kind of graph that there is only one path from node to node. First, Zero will give One an tree and every node in this tree has a value. Then, Zero will ask One a series of queries. Each query contains three parameters: $x$, $y$, $z$ which mean that he want to know the maximum value produced by $z$ $xor$ each value on the path from node $x$ to node $y$ (include node $x$, node $y$). Unfortunately, One has no idea in this question. So he need you to solve it. InputThere are several test cases and the cases end with $EOF$. For each case:The first line contains two integers $n(1\le n\le 10^5)$ and $m(1\le m\le 10^5)$, which are the amount of tree’s nodes and queries, respectively.The second line contains $n$ integers $a[1..n]$ and $ai$ is the value on the $i^{th}$ node.The next $n–1$ lines contains two integers $u$ $v$, which means there is an connection between $u$ and $v$.The next m lines contains three integers $x$ $y$ $z$, which are the parameters of Zero’s query. OutputFor each query, output the answer. Sample Input1234563 21 2 21 22 31 3 12 3 2 Sample Output1230 Translation题目大意：给出一棵树，求两点$x,y$间树上链路中的数异或$z$得到的最大结果。 标签：$LCA+可持久化Trie$ Solution最大异或和上树…有异或，一个经典的解法就是建一棵$01$字典树，然后贪心跑一遍，尽量选和给出数当前位不同的数。对于树上的此类问题，可以把$Trie$树可持久化，对于每个点，存它到根节点的路径上所有数的$Trie$树，这样是有前缀和性质的，求$LCA$后作差即可求出链路上的数。可持久化方法和主席树差不多。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#define MAX_N 100000#define MAX_D 15using namespace std;int n, m, cnt, c[MAX_N+5], root[MAX_N+5];int anc[MAX_N+5][MAX_D+5], dep[MAX_N+5];bool vis[MAX_N+5];vector &lt;int&gt; G[MAX_N+5];struct node &#123;int ls, rs, size;&#125; trie[MAX_N*20+500];void init() &#123; root[0] = cnt = 0; memset(root, 0, sizeof(root)); memset(anc, 0, sizeof(anc)); memset(dep, 0, sizeof(dep)); memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n; i++) G[i].clear();&#125;void DFS(int u) &#123; vis[u] = true; for (int i = 1; (1&lt;&lt;i) &lt;= dep[u]; i++) anc[u][i] = anc[anc[u][i-1]][i-1]; for (int i = 0; i &lt; G[u].size(); i++) if (!vis[G[u][i]]) anc[G[u][i]][0] = u, dep[G[u][i]] = dep[u]+1, DFS(G[u][i]);&#125;int LCA(int a, int b) &#123; int i, j; if (dep[a] &lt; dep[b]) swap(a, b); for (i = 0; (1&lt;&lt;i) &lt;= dep[a]; i++) ; i--; for (j = i; j &gt;= 0; j--) if (dep[a]-(1&lt;&lt;j) &gt;= dep[b]) a = anc[a][j]; if (a == b) return a; for (j = i; j &gt;= 0; j--) if (anc[a][j] != anc[b][j]) a = anc[a][j], b = anc[b][j]; return anc[a][0];&#125;void insert(int v, int o, int val, int range) &#123; trie[v] = trie[o]; if (range == 0) &#123;trie[v].size++; return;&#125; int x = val/range; if (x == 0) insert(trie[v].ls = ++cnt, trie[o].ls, val%range, range/2); else insert(trie[v].rs = ++cnt, trie[o].rs, val%range, range/2); trie[v].size = trie[trie[v].ls].size+trie[trie[v].rs].size;&#125;void build(int u) &#123; root[u] = ++cnt; insert(root[u], root[anc[u][0]], c[u], (1&lt;&lt;MAX_D)); for (int i = 0; i &lt; G[u].size(); i++) if (G[u][i] != anc[u][0]) build(G[u][i]);&#125;int query(int v1, int v2, int v3, int v4, int x, int range) &#123; if (range == 0) return 0; int tmp1 = trie[trie[v1].ls].size+trie[trie[v2].ls].size-trie[trie[v3].ls].size-trie[trie[v4].ls].size; int tmp2 = trie[trie[v1].rs].size+trie[trie[v2].rs].size-trie[trie[v3].rs].size-trie[trie[v4].rs].size; if (x/range == 0) &#123; if (tmp2) return range+query(trie[v1].rs, trie[v2].rs, trie[v3].rs, trie[v4].rs, x%range, range/2); else return query(trie[v1].ls, trie[v2].ls, trie[v3].ls, trie[v4].ls, x%range, range/2); &#125; else &#123; if (tmp1) return range+query(trie[v1].ls, trie[v2].ls, trie[v3].ls, trie[v4].ls, x%range, range/2); else return query(trie[v1].rs, trie[v2].rs, trie[v3].rs, trie[v4].rs, x%range, range/2); &#125;&#125;int main() &#123; while (scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; init(); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123;int u, v; scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u);&#125; DFS(1); build(1); while (m--) &#123; int u, v, x, lca; scanf("%d%d%d", &amp;u, &amp;v, &amp;x); lca = LCA(u, v); printf("%d\n", query(root[u], root[v], root[lca], root[anc[lca][0]], x, (1&lt;&lt;MAX_D))); &#125; for (int i = 1; i &lt;= cnt; i++) trie[i].ls = trie[i].rs = trie[i].size = 0; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>LCA</tag>
        <tag>HDU</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1070【SCOI2007】修车]]></title>
    <url>%2FBZOJ1070%E3%80%90SCOI2007%E3%80%91%E4%BF%AE%E8%BD%A6%20%E8%B4%B9%E7%94%A8%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 【SCOI2007】修车 Time Limit: $1 Sec$ Memory Limit: $128 MB$ Description同一时刻有$N$位车主带着他们的爱车来到了汽车维修中心。维修中心共有$M$位技术人员，不同的技术人员对不同的车进行维修所用的时间是不同的。现在需要安排这$M$位技术人员所维修的车及顺序，使得顾客平均等待的时间最小。说明：顾客的等待时间是指从他把车送至维修中心到维修完毕所用的时间。 Input第一行有两个$m,n$，表示技术人员数与顾客数。 接下来$n$行，每行$m$个整数。第$i+1$行第$j$个数表示第$j$位技术人员维修第$i$辆车需要用的时间$T$。 Output最小平均等待时间，答案精确到小数点后$2$位。 Sample Input1232 23 21 4 Sample Output11.50 HINT 据范围: $2\le M\le 9$, $1\le N\le 60$, $1\le T\le 1000$ 标签：费用流 Solution此题建模是费用流中常见的拆点建模。把每个技术人员拆成$n$个点，第$k$个点代表着此工作人员修的倒数第$k$辆车对答案的贡献。对于每个顾客，如果他倒数第$k$个修车，花费$t$的时间，会对答案产生$t\times k$的贡献。因此从每个顾客向每个技术人员的$n$个点连边，容量为$1$，花费为$t\times k$，然后跑费用流即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 10000#define MAX_M 200000#define INF 2147483647using namespace std;int n, m, s, t, ans, a[65][10];int pre[MAX_N+5], cnt;struct node &#123;int v, c, w, nxt;&#125; E[MAX_M+5];void init() &#123;s = 0, t = n*m+n+1, cnt = 0; memset(pre, -1, sizeof(pre));&#125;void insert(int u, int v, int c, int w) &#123; E[cnt].v = v, E[cnt].c = c, E[cnt].w = w, E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0, E[cnt].w =-w, E[cnt].nxt = pre[v], pre[v] = cnt++;&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inque[MAX_N+5]; int dis[MAX_N+5], pree[MAX_N+5]; memset(inque, false, sizeof(inque)), memset(pree, -1, sizeof(pree)); for (int i = s; i &lt;= t; i++) dis[i] = INF; dis[s] = 0, que.push(s), inque[s] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(), inque[u] = false; for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c, w = E[i].w; if (c &amp;&amp; dis[u]+w &lt; dis[v]) &#123; dis[v] = dis[u]+w, pree[v] = i; if (!inque[v]) que.push(v), inque[v] = true; &#125; &#125; &#125; if (dis[t] == INF) return false; int flow = INF; for (int i = pree[t]; ~i; i = pree[E[i^1].v]) flow = min(flow, E[i].c); for (int i = pree[t]; ~i; i = pree[E[i^1].v]) E[i].c -= flow, E[i^1].c += flow; ans += dis[t]; return true;&#125;int main() &#123; scanf("%d%d", &amp;m, &amp;n), init(); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) scanf("%d", &amp;a[i][j]); for (int i = 1; i &lt;= n; i++) insert(s, i, 1, 0); for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= n; k++) insert(i, j*n+k, 1, a[i][j]*k); for (int j = 1; j &lt;= m; j++) for (int k = 1; k &lt;= n; k++) insert(j*n+k, t, 1, 0); while (SPFA()) ; printf("%.2lf", (double)ans/n); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2466 【中山市选2009】树]]></title>
    <url>%2FBZOJ2466%E3%80%90%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892009%E3%80%91%E6%A0%91%20%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%2F</url>
    <content type="text"><![CDATA[Problem 【中山市选2009】树 Time Limit: $10 Sec$ Memory Limit: $128 MB$ Description图论中的树为一个无环的无向图。给定一棵树，每个节点有一盏指示灯和一个按钮。如果节点的按扭被按了，那么该节点的灯会从熄灭变为点亮（当按之前是熄灭的），或者从点亮到熄灭（当按之前是点亮的），并且该节点的直接邻居也发生同样的变化。开始的时候，所有的指示灯都是熄灭的。请编程计算最少要按多少次按钮，才能让所有节点的指示灯变为点亮状态。 Input输入文件有多组数据。输入第一行包含一个整数$n$，表示树的节点数目。每个节点的编号从$1$到$n$。输入接下来的$n–1$行，每一行包含两个整数$x$，$y$，表示节点$x$和$y$之间有一条无向边。当输入$n$为$0$时，表示输入结束。 Output对于每组数据，输出最少要按多少次按钮，才能让所有节点的指示灯变为点亮状态。每一组数据独占一行。 Sample Input123431 21 30 Sample Output11 HINT 对于$100\%$的数据，满足$1\le n\le100$。 标签：高斯消元 Solution将所有节点按的次数设为$x_1\sim x_n$，会得到一个线性异或方程组。这时可以$bitset+高消$水过。 不懂高消可以戳这里：http://www.cppblog.com/menjitianya/archive/2014/06/08/207226.html Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;bitset&gt;#define MAX_N 100using namespace std;int n, x[MAX_N+5], num[MAX_N+5], cnt;bitset &lt;MAX_N+5&gt; f[MAX_N+5];void init() &#123;cnt = 0; for (int i = 1; i &lt;= n; i++) f[i].reset(), f[i][i] = f[i][n+1] = 1;&#125;void gauss() &#123; int cur = 1; for (int i = 1, tmp; i &lt;= n; i++) &#123; for (tmp = cur; tmp &lt;= n; tmp++) if (f[tmp][i] == 1) break; if (tmp &gt; n) &#123;num[cnt++] = i; continue;&#125; swap(f[cur], f[tmp]); for (int j = 1; j &lt;= n; j++) if (j != cur &amp;&amp; f[j][i]) f[j] ^= f[cur]; cur++; &#125;&#125;int calc(int sta) &#123; int ret = 0; for (int i = 1; i &lt;= n; i++) x[i] = f[i][n+1]; for (int i = 0; i &lt; cnt; i++) &#123; if (!(sta&amp;(1&lt;&lt;i))) continue; ret++; for (int j = 1; j &lt;= n; j++) if (f[j][num[i]]) x[j] ^= 1; &#125; for (int i = 1; i &lt;= n; i++) ret += x[i]; return ret;&#125;int main() &#123; while (scanf("%d", &amp;n) &amp;&amp; n != 0) &#123; init(); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), f[u][v] = f[v][u] = 1; gauss(); int ans = n; for (int sta = 0; sta &lt; (1&lt;&lt;cnt); sta++) ans = min(ans, calc(sta)); printf("%d\n", ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1001【BJOI2006】狼抓兔子]]></title>
    <url>%2FBZOJ1001%E3%80%90BJOI2006%E3%80%91%E7%8B%BC%E6%8A%93%E5%85%94%E5%AD%90%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem【BJOI2006】狼抓兔子Time Limit: $15 Sec$Memory Limit: $162 MB$ Description现在小朋友们最喜欢的”喜羊羊与灰太狼”,话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对一个网格的地形：左上角点为$(1,1)$,右下角点为$(N,M)$.有以下三种类型的道路 $(x,y)\Leftrightarrow(x+1,y)$ $(x,y)\Leftrightarrow(x,y+1)$ $(x,y)\Leftrightarrow(x+1,y+1)$ 道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的. 左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角$(1,1)$的窝里，现在它们要跑到右下解$(N,M)$的窝中去，狼王开始伏击些兔子.当然为了保险起见，如果一条道路上最多通过的兔子数为$K$，狼王需要安排同样数量的K只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦. Input第一行为$N,M$.表示网格的大小，$N,M$均小于等于$1000$.接下来分三部分第一部分共$N$行，每行$M-1$个数，表示横向道路的权值.第二部分共$N-1$行，每行$M$个数，表示纵向道路的权值.第三部分共$N-1$行，每行$M-1$个数，表示斜向道路的权值.输入文件保证不超过$10MB$ Output输出一个整数，表示参与伏击的狼的最小数量. Sample Input123456783 45 6 44 3 17 5 35 6 7 88 7 6 55 5 56 6 6 Sample Output114 HINT2015.4.16新加数据一组，可能会卡掉从前可以过的程序。 标签:网络流 Solution此题是裸的网络流，看看数据范围，再看看时限，很容易发现直接$Dinnic$最小割可过。其实还可以用对偶图上跑最短路做，貌似特判有点多，不太好写，但是要快一些，艹榜可用。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#define INF 0x7fffffffusing namespace std;struct node &#123;int v, c, nxt;&#125; E[12000005];int n, m, pre[1000005], d[1000005], cnt;void init() &#123;cnt = 0, memset(pre, -1, sizeof(pre));&#125;void insert(int u, int v, int c) &#123; E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0, E[cnt].nxt = pre[v], pre[v] = cnt++;&#125;bool BFS() &#123; memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(1), d[1] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (~d[v] || !c) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return d[n*m] != -1;&#125;int DFS(int u, int flow) &#123; if (u == n*m) return flow; int ret = 0; for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (d[u]+1 != d[v] || !c) continue; int tmp = DFS(v, min(flow, c)); flow -= tmp, ret += tmp, E[i].c -= tmp, E[i^1].c += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123;int ret = 0; while (BFS()) ret += DFS(1, INF); return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m), init(); for (int i = 1; i &lt;= n; i++) for (int j = 1, x; j &lt; m; j++) scanf("%d", &amp;x), insert(m*(i-1)+j, m*(i-1)+j+1, x), insert(m*(i-1)+j+1, m*(i-1)+j, x); for (int i = 1; i &lt; n; i++) for (int j = 1, x; j &lt;= m; j++) scanf("%d", &amp;x), insert(m*(i-1)+j, m*i+j, x), insert(m*i+j, m*(i-1)+j, x); for (int i = 1; i &lt; n; i++) for (int j = 1, x; j &lt; m; j++) scanf("%d", &amp;x), insert(m*(i-1)+j, m*i+j+1, x), insert(m*i+j+1, m*(i-1)+j, x); printf("%d", Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1997 Planer]]></title>
    <url>%2FBZOJ1997%E3%80%90HNOI2010%E3%80%91Planer%202-SAT%2F</url>
    <content type="text"><![CDATA[Problem 传送门：http://www.lydsy.com/JudgeOnline/problem.php?id=1997 标签：2-SAT，并查集 Solution本题和$POJ3207$没什么区别…只是刚做$POJ3207$时是复习$2-SAT$，所以写了$tarjan$，然而某天碰到这题突然想到了并查集。貌似此题可以种类并查集$trick$过。把每条线段拆成两个点，代表从里面连和外面连，对于相交线段$a,b$，一定有$a$和$b$不同时在里面或外面，于是$merge(a, b’)$, $merge(a’, b)$。这样合并时判断是否有$i$, $i’$在同一集中即可。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 200#define MAX_M 10000using namespace std;int n, m, p[MAX_N+5], l[MAX_M+5], r[MAX_M+5], fa[MAX_M*2+5];void init() &#123;for (int i = 0; i &lt; 2*m; i++) fa[i] = i;&#125;int getf(int x) &#123;return fa[x] == x ? x : fa[x] = getf(fa[x]);&#125;void merge(int a, int b) &#123;a = getf(a), b = getf(b); if (a != b) fa[a] = b;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;n, &amp;m), init(); bool flag = true; for (int i = 0; i &lt; m; i++) scanf("%d%d", &amp;l[i], &amp;r[i]); for (int i = 0, x; i &lt; n; i++) scanf("%d", &amp;x), p[x] = i; for (int i = 0; i &lt; m; i++) l[i] = p[l[i]], r[i] = p[r[i]]; for (int i = 0; i &lt; m; i++) if (l[i] &gt; r[i]) swap(l[i], r[i]); for (int i = 1; i &lt; m; i++) for (int j = 0; j &lt; i; j++) if ((l[i] &lt; l[j] &amp;&amp; r[i] &gt; l[j] &amp;&amp; r[i] &lt; r[j]) || (l[i] &gt; l[j] &amp;&amp; l[i] &lt; r[j] &amp;&amp; r[i] &gt; r[j])) merge(i*2, j*2+1), merge(i*2+1, j*2); for (int i = 0; i &lt; m; i++) flag &amp;= (getf(i*2) != getf(i*2+1)); printf("%s\n", flag ? "YES" : "NO"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>2-SAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ3207 Ikki's Story IV - Panda's Trick]]></title>
    <url>%2FPOJ3207%20Ikki's%20Story%20IV%20-%20Panda's%20Trick%202-SAT%2F</url>
    <content type="text"><![CDATA[ProblemIkki’s Story IV - Panda’s TrickDescriptionliympanda, one of Ikki’s friend, likes playing games with Ikki. Today after minesweeping with Ikki and winning so many times, he is tired of such easy games and wants to play another game with Ikki.liympanda has a magic circle and he puts it on a plane, there are n points on its boundary in circular border: $0, 1, 2, \cdots , n-1$. Evil panda claims that he is connecting m pairs of points. To connect two points, liympanda either places the link entirely inside the circle or entirely outside the circle. Now liympanda tells Ikki no two links touch inside/outside the circle, except on the boundary. He wants Ikki to figure out whether this is possible…Despaired at the minesweeping game just played, Ikki is totally at a loss, so he decides to write a program to help him. InputThe input contains exactly one test case.In the test case there will be a line consisting of of two integers: $n$ and $m$ $(n \le 1,000, m \le 500)$. The following $m$ lines each contain two integers $a_i$ and $b_i$, which denote the endpoints of the $i^{th}$ wire. Every point will have at most one link. OutputOutput a line, either “panda is telling the truth…” or “the evil panda is lying again”. Sample Input1234 20 13 2 Sample Output1panda is telling the truth... 标签：$2-SAT$ Translation题目大意：$n$个数排成一圈，给出若干条两点间的线段，可以在圈内连，也可在圈外连，问能否使得无相交线段（端点相交不算） Solution本题是$2-SAT$的判定裸题。把每条线段拆成两个点，即第$i$条为$i$和$i’$，分别代表$i$在圈内和在圈外。若线段$a$和$b$相交，则连边$a\to b’$，$a’\to b$，这样跑一个$tarjan$再判断$i$和$i’$是否在一个联通块内即可判断是否有冲突。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define MAX_M 500using namespace std;int n, m, x[MAX_M+5], y[MAX_M+5];int dfn[MAX_M*2+5], low[MAX_M*2+5], id[MAX_M*2+5], index, cnt;vector &lt;int&gt; G[MAX_M*2+5];stack &lt;int&gt; sta;bool insta[MAX_M*2+5];void tarjan(int u) &#123; dfn[u] = low[u] = ++index; sta.push(u), insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (insta[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; cnt++; for (int i = sta.top(); ; i = sta.top()) &#123; id[i] = cnt; sta.pop(); if (i == u) break; &#125; &#125;&#125;void build() &#123; for (int i = 2; i &lt;= m; i++) for (int j = 1; j &lt; i; j++) if ((x[i] &lt;= x[j] &amp;&amp; y[i] &gt;= x[j] &amp;&amp; y[i] &lt;= y[j]) || (x[i] &gt;= x[j] &amp;&amp; x[i] &lt;= y[j] &amp;&amp; y[i] &gt;= y[j])) G[i].push_back(j+m), G[j].push_back(i+m), G[i+m].push_back(j), G[j+m].push_back(i);&#125;bool check() &#123; for (int i = 1; i &lt;= m; i++) if (id[i] == id[i+m]) return false; return true;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;x[i], &amp;y[i]); if (x[i] &gt; y[i]) swap(x[i], y[i]); &#125; build(); for (int i = 1; i &lt;= m*2; i++) if (!dfn[i]) tarjan(i); if (check()) printf("panda is telling the truth...\n"); else printf("the evil panda is lying again\n"); return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>2-SAT</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[201701001-08总结]]></title>
    <url>%2F20171001-08%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[长沙雅礼中学2017国庆训练滚粗记 兴致勃勃地去，遍体鳞伤地回…… 八场考试爆六场，水题全都没做起…… Day 1上午三道水题T1好简单，数轴上画圆，转化成线段覆盖。然而我并没有看出来~,,ԾㅂԾ,,~T2T3在哪里见过一样…突然意识到是暑假讲过的题。T2线段树套路题。并没有想起来正解，考完意识到是傻逼暴力修改。T3数位DP，搞方程一小时没肝出来。 中午颓颓颓 下午讲YSY讲DP花了一个半小时把上午的题改了，成功跳过了DP基础部分。后面的题挺有意思。发现若干道FindStr讲过的题和BZOJ原题。最后一道没听懂。 晚上讲了三道难题，听得半懂，口胡AC Day 2上午两道水题+一道数论T1显然是DP，撸方程一个半小时没肝出来，果断打了BFT2肯定图论，没想出正解，打了一个DFS分层，加上若干剪枝优化，并没骗到分T3乍一看容斥或莫比乌斯反演…等等这是NOIp模拟啊…果断放掉推反演，搞半天打了BF。结果标解是反演…ヾ(≧へ≦)〃又水了低保分 中午颓颓颓 下午YSY讲数论先改了一个半小时题，发现YSY把我会的都讲完了。接着就开始讲莫比乌斯反演等省选内容。出发后第一次怀疑这不是NOIp集训… 晚上讲了三道有意思的题，口胡AC Day 3上午一道原题+两道正常题T1一看是线段树，感觉好熟悉，应该是原题，然后就忘了标解了…考完YY说这题我当时给他讲过，他印象可深了。然而我作为讲题人居然忘了…对我的智商和记忆力深表怀疑。此题正解：弱智线段树x26，卡常。T2显然是DP，然而题目叙述不清楚，一半的人都读错了（including孔爷），读错之后太复杂，根本无法推DP，所以暴力也错了，怀疑样例耗掉半小时…T3是二进制题，可能会用字典树或者bitset，博弈逻辑搅半天，并未发现那个看似复杂的操作就是循环移位。忘了异或的套路，时间不够打了BF。 中午颓颓颓 下午YSY讲贪心分治今天很正常，大概是NOIp难度。发现几道做过的题。出发后第一次有了NOIp集训营的感觉而非省选集训营。 晚上讲题人的“水题选讲”难度定位在省选+三道数论恶心题，推公式几大页PPT，完全没懂。安慰自己，省选之前不会有这些鬼东西。 Day 4上午两道水题+一道原题T1裸约瑟夫，结果忘了当时初二自己是怎么推递推式的了…T2树状数组，虽然被题面旁边的少女骚扰了半天，还是很快发现这是道水题，树状数组打出来。结果忘写IObuf，被毒瘤出题人卡常…T3是经典DP题，然而我并没有做过，考试也没想到，只会求最大值不会输出方案。看到正解觉得好憋屈，方程都一样，就是没时间想回溯输出了。 中午颓颓颓 下午雅礼学长讲搜索题目也很正常，大多就是剪枝启发式之类。出发后第二次也是最后一次有了NOIp集训营的感觉。 晚上由于端午没讲题颓颓颓 Day 5上午三道正常题T1图上DP，很好推，但是转移忘写位运算，强行把复杂度写丑了…T2字符串，可以证明不会有无解，所以随机化乱搞。当时并没有想到，于是倒着暴力搜，居然过了…WTFT3是树形DP，但是比较难想，而且复杂度会爆。并没有写出来。下午讲题才发现这个DP有最优策略，退化成贪心。 中午颓颓颓 下午听WHX讲数论听到一半果断改题。至于原因吗…完全听不懂，除了基础能懂以外，全都不会用。这已经有省选+的难度了。最后居然讲起了神技Min-Max容斥…WHX还超时一小时，强行占吃饭时间讲了线性代数/(ㄒoㄒ)/~~ 晚上听杂题今天的题比较正常，NOIp+难度，可以听懂，没太大问题 Day 6上午三道省选-题T1看到“最小距离最大值”就去想二分答案，结果复杂度还是爆了，强行加了个优化，把最好复杂度优化了。本来以为会GG，结果居然过了。出题人表示很诧异，此题正解prime生成树T2知道是DP，但就是没推出方程。时间不够了，果断打BF。T3看表达式应该是斜率凸包，但是在树上维护凸包我只会暴力弹栈，复杂度跟暴力差不多，于是打了BF。考完看到打暴力弹栈被卡得跟裸暴力一样的同学觉得自己赚了。 中午颓颓颓 下午听WHX讲杂题题目很好，思维很巧妙，涨姿势了。懒癌一题没听懂，其他题大概懂了，口胡AC。 晚上讲三道AtCoder题前两题能听懂，比较巧妙。最后一道分形，很有意思，半懂半懂。 Day 7上午三道数学题，预测到自己肯定GGT1期望题，不太好证明，但是打表很好发现规律，然而我考试并没有打表。T2DP题，考虑漏了情况，打了个贪心，然后自己把自己卡掉了…T3看到三维凸包+期望就知道没搞。考完出题人说这套题比前两天简单…蛤？ 中午颓颓颓 下午听WHX讲图论一开始挺简单，但是开始讲定理就懵了。倒是听懂了若干道网络流建模题。 晚上三道杂题发现一道YJQ讲过的博弈论原题，其他题目比较正常 Day 8上午三道NOIp+题目出题人在P1说题目按字典序排序，结果我一来就挑了最难的题做…然后GGT1按边DFS，拆掉返祖边，然后树形DPT2AtCoder智商题，先转化然后DP，连转换都没想到T3结论题，没推出结论，也没找规律，GG 中午颓颓颓 下午听h10讲几何都懂了，但是不会写，而且旋转卡壳和半平面交是NOIp内容吗？懵逼ing 晚上听了四道杂题大概都懂了，但是只能口胡AC。唯一一道能写的在BZOJ上是权限题… Conclusion八天爆六天，成功滚粗…看来九月份没停课还是很要命的，完全没了做题的感觉，没怎么深入地想。十月份慢慢复习调整，把学FFT和后缀自动机的计划再往后推一推。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【福利】洛谷模板汇总]]></title>
    <url>%2F%E6%B4%9B%E8%B0%B7%E6%A8%A1%E6%9D%BF%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[Graph TheoryDisjoint Set123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#define MAX_N 10000using namespace std;int n, m, f, x, y, father[MAX_N+5];int getfather(int v) &#123; if (father[v] == v) &#123; return v; &#125; father[v] = getfather(father[v]); return father[v];&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; f &gt;&gt; x &gt;&gt; y; if (f == 1) &#123; int f1 = getfather(x); int f2 = getfather(y); if (f1 != f2) &#123; father[f1] = f2; &#125; &#125; else &#123; int f1 = getfather(x); int f2 = getfather(y); if (f1 != f2) &#123; cout &lt;&lt; "N" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "Y" &lt;&lt; endl; &#125; &#125; &#125; return 0;&#125; Minimum Spanning TreeKruskal12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 5000#define MAX_M 200000using namespace std;struct node &#123; int u, v, l;&#125; edge[MAX_M+5];int n, m, tot = 0;int father[MAX_N+5];bool comp(const node &amp;a, const node &amp;b) &#123; return a.l &lt; b.l;&#125;int getfather(int v) &#123; if (father[v] == v) &#123; return v; &#125; father[v] = getfather(father[v]); return father[v];&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; edge[i].u &gt;&gt; edge[i].v &gt;&gt; edge[i].l; &#125; sort(edge, edge+m, comp); for (int i = 1; i &lt;= n; i++) father[i] = i; int flag = n-1; for (int i = 0; i &lt; m; i++) &#123; int f1 = getfather(edge[i].u); int f2 = getfather(edge[i].v); if (f1 != f2) &#123; father[f1] = f2; tot += edge[i].l; flag--; &#125; if (flag == 0) break; &#125; if (flag == 0) &#123; cout &lt;&lt; tot; &#125; else &#123; cout &lt;&lt; "orz"; &#125; return 0;&#125; Prim1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define MAX_N 5000#define INF 2147483647using namespace std;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int n, m, dis[MAX_N+5], tot; bool col[MAX_N+5];void addedge(int u, int v, int c) &#123;G[u].push_back(v), E[u].push_back(c);&#125;void Prim() &#123; for (int i = 1; i &lt;= n; i++) dis[i] = INF; dis[1] = 0; for (int i = 1, u = -1; i &lt;= n; i++, u = -1) &#123; for (int j = 1; j &lt;= n; j++) if (!col[j] &amp;&amp; (u == -1 || dis[u] &gt; dis[j])) u = j; col[u] = true, tot += dis[u]; for (int j = 0; j &lt; (int)G[u].size(); j++) &#123; int v = G[u][j], c = E[u][j]; if (!col[v] &amp;&amp; dis[v] &gt; c) dis[v] = c; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0, u, v, c; i &lt; m; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), addedge(u, v, c), addedge(v, u, c); Prim(); printf("%d", tot); return 0;&#125; Shortest PathDijkstra1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;#define MAX_N 10000#define INF 2147483647#define pii pair &lt;int, int&gt;#define mp make_pair#define fir first#define sec secondusing namespace std;int n, m, s, dis[MAX_N+5];vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];void addedge(int u, int v, int c) &#123;G[u].push_back(v), E[u].push_back(c);&#125;void Dijkstra() &#123; for (int i = 1; i &lt;= n; i++) dis[i] = INF; dis[s] = 0; priority_queue &lt;pii&gt; que; que.push(mp(0, s)); while (!que.empty()) &#123; int u = que.top().sec, d = que.top().fir; que.pop(); if (dis[u] != -d) continue; for (int i = 0; i &lt; (int)G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (dis[u]+c &gt;= dis[v]) continue; dis[v] = dis[u]+c, que.push(mp(-dis[v], v)); &#125; &#125;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;s); for (int i = 0, u, v, c; i &lt; m; i++) scanf("%d%d%d", &amp;u, &amp;v, &amp;c), addedge(u, v, c); Dijkstra(); for (int i = 1; i &lt;= n; i++) printf("%d ", dis[i]); return 0;&#125; SPFA1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_M 500000#define MAX_N 10000#define INF 2147483647using namespace std;struct node &#123; int v, len, next; node() &#123; v = len = next = 0; &#125;&#125; edge[MAX_M+5];int n, m, s;int first[MAX_N+5], cnt = 0;int dis[MAX_N+5];void insert(int u, int v, int l) &#123; cnt++; edge[cnt].v = v; edge[cnt].len = l; edge[cnt].next = first[u]; first[u] = cnt;&#125;void SPFA() &#123; for (int i = 1; i &lt;= n; i++) &#123; dis[i] = INF; &#125; int que[MAX_N*20+5], mark[MAX_N+5]; int head = 0, tail = 1; memset(mark, 0, sizeof(mark)); que[1] = s; mark[s] = 1; dis[s] = 0; while (head &lt;= tail) &#123; head++; for (int tmp = first[que[head]]; tmp; tmp = edge[tmp].next) &#123; if (dis[que[head]]+edge[tmp].len &lt; dis[edge[tmp].v]) &#123; dis[edge[tmp].v] = dis[que[head]]+edge[tmp].len; if (mark[edge[tmp].v] == 0) &#123; mark[edge[tmp].v] = 1; tail++; que[tail] = edge[tmp].v; &#125; &#125; &#125; mark[que[head]] = 0; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; memset(first, 0, sizeof(first)); int u, v, l; for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; l; insert(u, v, l); &#125; SPFA(); for (int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; dis[i] &lt;&lt; " "; &#125; return 0;&#125; Tarjan1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define MAX_N 100000using namespace std;int n, m, c[MAX_N+5], f[MAX_N+5];int dfn[MAX_N+5], low[MAX_N+5], col[MAX_N+5], val[MAX_N+5], ind, cnt;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];stack &lt;int&gt; sta;bool insta[MAX_N+5];void tarjan(int u) &#123; dfn[u] = low[u] = ++ind, sta.push(u), insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (insta[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; cnt++; for (int i = sta.top(); ; i = sta.top()) &#123; col[i] = cnt, val[cnt] += c[i], insta[i] = false; sta.pop(); if (u == i) break; &#125; &#125;&#125;int DFS(int u) &#123; if (f[u]) return f[u]; int mx = 0; for (int i = 0; i &lt; E[u].size(); i++) mx = max(mx, DFS(E[u][i])); return f[u] = val[u]+mx;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); while (m--) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; u++) &#123; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (col[u] == col[v]) continue; E[col[u]].push_back(col[v]); &#125; &#125; int ans = 0; for (int i = 1; i &lt;= cnt; i++) if (!f[i]) ans = max(ans, DFS(i)); printf("%d", ans); return 0;&#125; Cur Vertex1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 100000#define MAX_M 200000using namespace std;struct Edge &#123; int v, next;&#125; edge[MAX_M+5];int first[MAX_N+5], flag[MAX_N+5], num[MAX_N+5], low[MAX_N+5];int n, m, cnt = 0;void insert(int u, int v, int pos) &#123; edge[pos].next = first[u]; edge[pos].v = v; first[u] = pos;&#125;void dfs(int cur, int father) &#123; int child = 0; num[cur] = low[cur] = ++cnt; for (int tmp = first[cur]; tmp; tmp = edge[tmp].next) &#123; if (!num[edge[tmp].v]) &#123; child++; dfs(edge[tmp].v, cur); low[cur] = min(low[cur], low[edge[tmp].v]); if (low[edge[tmp].v] &gt;= num[cur]) &#123; flag[cur] = 1; &#125; &#125; else if (num[edge[tmp].v] &lt; num[cur] &amp;&amp; edge[tmp].v != father) &#123; low[cur] = min(low[cur], num[edge[tmp].v]); &#125; &#125; if (father == -1 &amp;&amp; child == 1) &#123; flag[cur] = 0; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int u, v; cin &gt;&gt; u &gt;&gt; v; insert(u, v, i*2+1); insert(v, u, i*2+2); &#125; int tot = 0; for (int i = 1; i &lt;= n; i++) &#123; if (!num[i]) &#123; dfs(i, -1); &#125; if (flag[i]) &#123; tot++; &#125; &#125; cout &lt;&lt; tot &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) &#123; if (flag[i]) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; &#125; return 0;&#125; Lowest Common AncestorMultiplication12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 500000using namespace std;struct Edge &#123; int next, to;&#125; edge[(MAX_N&lt;&lt;1)+5];int n, m, s, x, y, cnt;int d[MAX_N+5], p[MAX_N+5][25], first[MAX_N+5];bool vis[MAX_N+5];inline int read() &#123; int ret = 0; char ch = getchar(); while (ch &lt; '0' || ch &gt; '9') ch = getchar(); while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') ret = ret*10+ch-'0', ch = getchar(); return ret;&#125;void INSERT(int a, int b) &#123; edge[++cnt].next = first[a]; edge[cnt].to = b; first[a] = cnt;&#125;void DFS(int u) &#123; vis[u] = true; for (int i = 1; (1&lt;&lt;i) &lt;= n; i++) &#123; if ((1&lt;&lt;i) &lt;= d[u]) &#123; p[u][i] = p[p[u][i-1]][i-1]; &#125; &#125; for (int i = first[u]; i; i = edge[i].next) &#123; int v = edge[i].to; if (!vis[v]) &#123; d[v] = d[u]+1; p[v][0] = u; DFS(v); &#125; &#125;&#125;int LCA(int a, int b) &#123; int i, j; if (d[a] &lt; d[b]) swap(a, b); for (i = 0; (1&lt;&lt;i) &lt;= d[a]; i++) &#123;&#125; i--; for (j = i; j &gt;= 0; j--) &#123; if (d[a]-(1&lt;&lt;j) &gt;= d[b]) &#123; a = p[a][j]; &#125; &#125; if (a == b) &#123; return a; &#125; for (j = i; j &gt;= 0; j--) &#123; if (p[a][j] != p[b][j]) &#123; a = p[a][j]; b = p[b][j]; &#125; &#125; return p[a][0];&#125;int main() &#123; n = read(), m = read(), s = read(); for (int i = 1; i &lt; n; i++) &#123; x = read(), y = read(); INSERT(x, y); INSERT(y, x); &#125; DFS(s); for (int i = 0; i &lt; m; i++) &#123; x = read(), y = read(); cout &lt;&lt; LCA(x, y) &lt;&lt; endl; &#125; return 0;&#125; TreeChainDivision12345678910111213141516171819202122232425262728#include &lt;bits/stdc++.h&gt;#define MAX_N 500000using namespace std;vector &lt;int&gt; G[MAX_N+5];int n, m, r, dep[MAX_N+5], sz[MAX_N+5];int fa[MAX_N+5], son[MAX_N+5], top[MAX_N+5];void DFS(int u) &#123; sz[u] = 1; for (auto v : G[u]) &#123; if (v == fa[u]) continue; fa[v] = u, dep[v] = dep[u]+1, DFS(v), sz[u] += sz[v]; if (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v; &#125;&#125;void DFS(int u, int tp) &#123; top[u] = tp; if (son[u]) DFS(son[u], tp); for (auto v : G[u]) if ((v^fa[u]) &amp;&amp; (v^son[u])) DFS(v, v);&#125;int LCA(int u, int v) &#123; while (top[u]^top[v]) if (dep[top[u]] &gt; dep[top[v]]) u = fa[top[u]]; else v = fa[top[v]]; return dep[u] &lt; dep[v] ? u : v;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;r); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); DFS(r), DFS(r, r); while (m--) &#123;int u, v; scanf("%d%d", &amp;u, &amp;v); printf("%d\n", LCA(u, v));&#125; return 0;&#125; Negative Loop12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define MAX_N 200000#define SIZE 25000000using namespace std;int f; char BUF[SIZE], *buf = BUF;inline void read(int &amp;x) &#123; bool flag = 0; while (*buf &lt; 48) if (*buf++ == 45) flag = 1; x = 0; while (*buf &gt; 32) x = x*10+*buf++-48; x = flag ? -x : x;&#125;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];int dis[MAX_N+5];bool insta[MAX_N+5], flag;void init(int n) &#123; flag = false; for (int i = 1; i &lt;= n; i++) G[i].clear(), E[i].clear(); memset(dis, 0, sizeof(dis)), memset(insta, false, sizeof(insta));&#125;void DFS(int u) &#123; insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i], c = E[u][i]; if (dis[u]+c &gt;= dis[v]) continue; if (insta[v] || flag) &#123;flag = true; break;&#125; dis[v] = dis[u]+c, DFS(v); &#125; insta[u] = false;&#125;int main() &#123; f = fread(BUF, 1, SIZE, stdin); int T; read(T); while (T--) &#123; int n, m; read(n), read(m); init(n); while (m--) &#123; int u, v, c; read(u), read(v), read(c); G[u].push_back(v), E[u].push_back(c); if (c &gt;= 0) G[v].push_back(u), E[v].push_back(c); &#125; for (int i = 1; i &lt;= n; i++) &#123;DFS(i); if (flag) break;&#125; if (flag) printf("YE5\n"); else printf("N0\n"); &#125; return 0;&#125; Network Flow1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 10000#define MAX_M 100000#define INF 2147483647using namespace std;struct node &#123; int v, c, next;&#125; E[MAX_M*2+5];int first[MAX_N+5], cnt;int n, m, s, t;int d[MAX_N+5];void init() &#123; cnt = 0; memset(first, -1, sizeof(first));&#125;void insert(int u, int v, int c) &#123; E[cnt].v = v, E[cnt].c = c; E[cnt].next = first[u]; first[u] = cnt++;&#125;bool BFS() &#123; memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s); d[s] = 0; while (!que.empty()) &#123; int u = que.front(); for (int i = first[u]; i != -1; i = E[i].next) &#123; int v = E[i].v; if (E[i].c &amp;&amp; d[v] == -1) &#123; que.push(v); d[v] = d[u]+1; &#125; &#125; que.pop(); &#125; return d[t] != -1;&#125;int DFS(int u, int flow) &#123; if (u == t) &#123; return flow; &#125; int ret = 0; for (int i = first[u]; i != -1; i = E[i].next) &#123; int v = E[i].v; if (E[i].c &amp;&amp; d[u]+1 == d[v]) &#123; int tmp = DFS(v, min(flow, E[i].c)); flow -= tmp, E[i].c -= tmp, ret += tmp; E[i^1].c += tmp; if (flow == 0) break; &#125; &#125; if (ret == 0) d[u] = -1; return ret;&#125;int main() &#123; init(); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; for (int i = 0; i &lt; m; i++) &#123; int u, v, c; cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; insert(u, v, c); insert(v, u, 0); &#125; int ans = 0; while (BFS()) &#123; ans += DFS(s, INF); &#125; cout &lt;&lt; ans; return 0;&#125; Minimum Cost Maximum Flow123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 5000#define MAX_M 50000#define INF 2147483647using namespace std;int n, m, s, t, tot, ans;int pre[MAX_N+5], match[MAX_N+5], cnt;struct node &#123;int u, v, c, w, nxt;&#125; E[MAX_M*2+MAX_N*2+5];void init() &#123;cnt = 0; memset(pre, -1, sizeof(pre));&#125;void insert(int u, int v, int c, int w) &#123;E[cnt].u = u, E[cnt].v = v, E[cnt].c = c, E[cnt].w = w, E[cnt].nxt = pre[u], pre[u] = cnt++;&#125;bool SPFA() &#123; queue &lt;int&gt; que; bool inque[MAX_N+5]; int dis[MAX_N+5], pree[MAX_N+5]; memset(inque, false, sizeof(inque)); for (int i = 1; i &lt;= n; i++) dis[i] = INF; memset(pree, -1, sizeof(pree)); dis[s] = 0, que.push(s), inque[s] = true; while (!que.empty()) &#123; int u = que.front(); for (int i = pre[u]; i != -1; i = E[i].nxt) &#123; int v = E[i].v; if (E[i].c &amp;&amp; dis[u]+E[i].w &lt; dis[v]) &#123; dis[v] = dis[u]+E[i].w, pree[v] = i; if (!inque[v]) que.push(v), inque[v] = true; &#125; &#125; que.pop(), inque[u] = false; &#125; if (dis[t] == INF) return false; int flow = INF; for (int i = pree[t]; i != -1; i = pree[E[i].u]) flow = min(flow, E[i].c); for (int i = pree[t]; i != -1; i = pree[E[i].u]) E[i].c -= flow, E[i^1].c += flow; tot += flow, ans += dis[t]*flow; return true;&#125;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); init(); for (int i = 0; i &lt; m; i++) &#123; int u, v, c, w; scanf("%d%d%d%d", &amp;u, &amp;v, &amp;c, &amp;w); insert(u, v, c, w), insert(v, u, 0, -w); &#125; while (SPFA()) ; printf("%d %d", tot, ans); return 0;&#125; Bipartite MatchingHungary123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#define MAX_N 1000using namespace std;int n, m, e, match[MAX_N+5], cnt;vector &lt;int&gt; G[MAX_N+5];bool vis[MAX_N+5];bool DFS(int u) &#123; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!vis[v]) &#123; vis[v] = true; if (!match[v] || DFS(match[v])) &#123; match[v] = u; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; e; int a, b; for (int i = 0; i &lt; e; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if (a &gt; n || b &gt; m) continue; G[a].push_back(b); &#125; for (int i = 1; i &lt;= n; i++) &#123; memset(vis, false, sizeof(vis)); if (DFS(i)) &#123; cnt++; &#125; &#125; cout &lt;&lt; cnt; return 0;&#125; Dinic12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 2000#define MAX_M 1000000#define INF 2147483647using namespace std;int n, m, s, t, n1, n2;int pre[MAX_N+5], tmp[MAX_N+5], d[MAX_N+5], cnt;struct node &#123;int v, c, nxt;&#125; E[MAX_M*2+MAX_N*2+5];void init() &#123;cnt = 0; s = 0, t = n; memset(pre, -1, sizeof(pre));&#125;void insert(int u, int v, int c) &#123;E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++;&#125;bool BFS() &#123; memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); for (int i = pre[u]; i != -1; i = E[i].nxt) &#123; int v = E[i].v; if (E[i].c &amp;&amp; d[v] == -1) &#123; d[v] = d[u]+1; que.push(v); &#125; &#125; que.pop(); &#125; return d[t] != -1;&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int &amp;i = pre[u]; i != -1; i = E[i].nxt) &#123; int v = E[i].v; if (E[i].c &amp;&amp; d[u]+1 == d[v]) &#123; int tmp = DFS(v, min(flow, E[i].c)); E[i].c -= tmp, E[i^1].c += tmp, flow -= tmp, ret += tmp; if (!flow) break; &#125; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123; int ret = 0; for (int i = 0; i &lt;= n; i++) tmp[i] = pre[i]; while (BFS()) &#123; ret += DFS(s, INF); for (int i = 0; i &lt;= n; i++) pre[i] = tmp[i]; &#125; return ret;&#125;int main() &#123; scanf("%d%d%d", &amp;n1, &amp;n2, &amp;m); n = n1+n2+1; init(); for (int i = 1; i &lt;= n1; i++) insert(s, i, 1), insert(i, s, 0); for (int i = n1+1; i &lt;= n1+n2; i++) insert(i, t, 1), insert(t, i, 0); for (int i = 0; i &lt; m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); if (u &gt; n1 || v &gt; n2) continue; insert(u, n1+v, 1), insert(n1+v, u, 0); &#125; printf("%d", Dinic()); return 0;&#125; Math TheoryGauss Elimination123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 100#define EXP 1e-7using namespace std;typedef double fnt;int n; vector &lt;fnt&gt; f[MAX_N+5]; fnt ans[MAX_N+5];bool gauss() &#123; for (int i = 1, tmp; i &lt;= n; i++) &#123; for (tmp = i; tmp &lt;= n; tmp++) if (f[tmp][i] &lt;= -EXP || f[tmp][i] &gt;= EXP) break; if (tmp &gt; n) return false; swap(f[i], f[tmp]); for (int j = 1; j &lt;= n; j++) &#123; fnt div = f[j][i]/f[i][i]; if (j == i) continue; for (int k = i; k &lt;= n+1; k++) f[j][k] -= f[i][k]*div; &#125; &#125; for (int i = 1; i &lt;= n; i++) ans[i] = f[i][n+1]/f[i][i]; return true;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; f[i].push_back(0); for (int j = 1; j &lt;= n+1; j++) &#123; fnt x; scanf("%lf", &amp;x); f[i].push_back(x); &#125; &#125; if (gauss()) for (int i = 1; i &lt;= n; i++) printf("%.2lf\n", ans[i]); else printf("No Solution"); return 0;&#125; Inverse12345678910111213#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 3000000using namespace std;typedef long long lnt;lnt inv[MAX_N+5];void init(int n, lnt p) &#123;inv[0] = inv[1] = 1; for (int i = 2; i &lt;= n; i++) inv[i] = (p-p/i*inv[p%i]%p)%p;&#125;int main() &#123; int n; lnt p; scanf("%d%lld", &amp;n, &amp;p); init(n, p); for (int i = 1; i &lt;= n; i++) printf("%lld\n", inv[i]); return 0;&#125; Linear Basis123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 50using namespace std;typedef long long lnt;int n; lnt base[MAX_N+5], pow[MAX_N+5];int main() &#123; scanf("%d", &amp;n); pow[0] = 1; for (int i = 1; i &lt;= MAX_N; i++) pow[i] = pow[i-1]*2; for (int i = 1; i &lt;= n; i++) &#123; lnt x; scanf("%lld", &amp;x); for (int j = MAX_N; j &gt;= 0; j--) if (pow[j]&amp;x) &#123; if (base[j]) x ^= base[j]; else &#123;base[j] = x; break;&#125; &#125; &#125; lnt ans = 0; for (int i = MAX_N; i &gt;= 0; i--) if ((ans^pow[i]) &gt; ans) ans ^= base[i]; printf("%lld", ans); return 0;&#125; Lucas123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_P 100000using namespace std;typedef long long lnt;lnt f[MAX_P+5] = &#123;1&#125;;void init(lnt p) &#123;for (int i = 1; i &lt;= MAX_P; i++) f[i] = f[i-1]*i%p;&#125;lnt FLT(lnt x, lnt p) &#123; lnt ret = 1; x %= p; for (int k = p-2; k; k &gt;&gt;= 1) ret = k%2 ? ret*x%p : ret, x = x*x%p; return ret;&#125;lnt lucas(lnt n, lnt m, lnt p) &#123;return m ? (n%p &gt;= m%p ? f[n%p]*FLT(f[m%p]*f[n%p-m%p], p)*lucas(n/p, m/p, p)%p : 0) : 1;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; lnt n, m, p; scanf("%lld%lld%lld", &amp;n, &amp;m, &amp;p); init(p), printf("%lld\n", lucas(n+m, min(n, m), p)%p); &#125; return 0;&#125; Matrix Fast Power12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 100#define MOD 1000000007using namespace std;int n;struct Matrix &#123; long long ele[MAX_N][MAX_N]; inline Matrix operator * (const Matrix &amp;x) const &#123; Matrix ret; memset(ret.ele, 0, sizeof(ret.ele)); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) for (int k = 0; k &lt; n; k++) ret.ele[i][j] = (ret.ele[i][j]+ele[i][k]*x.ele[k][j])%MOD; return ret; &#125;&#125;;Matrix Power(Matrix a, long long k) &#123; if (k == 1) return a; Matrix ret = Power(a, k/2); if (k%2) return a*ret*ret; return ret*ret;&#125;int main() &#123; long long k; Matrix a; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; n; j++) cin &gt;&gt; a.ele[i][j]; a = Power(a, k); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) cout &lt;&lt; a.ele[i][j] &lt;&lt; " "; cout &lt;&lt; endl; &#125; return 0;&#125; Prime Sieve12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 10000000using namespace std;int n, m;bool IsPrime[MAX_N+5];int pri[MAX_N+5], cnt = 0;void FindPrime() &#123; IsPrime[0] = IsPrime[1] = false; for (int i = 2; i &lt;= n; i++) &#123; if (IsPrime) &#123; pri[cnt++] = i; &#125; for (int j = 0; j &lt; cnt; j++) &#123; if (i*pri[j] &gt; n) break; IsPrime[i*pri[j]] = false; if (i%pri[j] == 0) break; &#125; &#125;&#125;int main() &#123; memset(IsPrime, true, sizeof(IsPrime)); cin &gt;&gt; n; FindPrime(); cin &gt;&gt; m; for (int i = 0; i &lt; m; i++) &#123; int x; cin &gt;&gt; x; if (IsPrime[x]) &#123; cout &lt;&lt; "Yes" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "No" &lt;&lt; endl; &#125; &#125; return 0;&#125; Trigeminal Search1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int n;double s, t;double a[14];double calc(double x) &#123; double tot = 0, tmp = 1; for (int i = 0; i &lt;= n; i++) &#123; tot += tmp*a[i]; tmp *= x; &#125; return tot;&#125;void f(double l, double r) &#123; if (abs(r-l) &lt;= 0.000001) &#123; printf("%.5f", l); return; &#125; double ml = (2*l+r)/3, mr = (l+2*r)/3; if (calc(ml) &gt; calc(mr)) &#123; f(l, mr); &#125; else &#123; f(ml, r); &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; s &gt;&gt; t; for (int i = n; i &gt;= 0; i--) &#123; cin &gt;&gt; a[i]; &#125; f(s, t); return 0;&#125; Data StructureHeap1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;int n, heap[1000000+5], size = 0;void insert(int x) &#123; size++; heap[size] = x; int current = size; int father = current/2; while (father &gt; 0 &amp;&amp; heap[father] &gt; heap[current]) &#123; swap(heap[father], heap[current]); current = father; father = current/2; &#125;&#125;void pop() &#123; heap[1] = heap[size]; size--; int current = 1; int child = current*2; if (child &lt; size &amp;&amp; heap[child] &gt; heap[child+1]) child++; while (child &lt;= size &amp;&amp; heap[current] &gt; heap[child]) &#123; swap(heap[current], heap[child]); current = child; child = 2*current; if (child &lt; size &amp;&amp; heap[child] &gt; heap[child+1]) child++; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int f; cin &gt;&gt; f; if (f == 1) &#123; int x; cin &gt;&gt; x; insert(x); &#125; else if (f == 2) &#123; cout &lt;&lt; heap[1] &lt;&lt; endl; &#125; else &#123; pop(); &#125; &#125; return 0;&#125; Mergeable Heap123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 100000using namespace std;struct node &#123;int val, dis, ls, rs;&#125; heap[MAX_N+5];int n, m, fa[MAX_N+5];int getf(int x) &#123;return fa[x] == x ? fa[x] : getf(fa[x]);&#125;int merge(int a, int b) &#123; if (!a || !b) return a^b; if (heap[a].val &gt; heap[b].val || (heap[a].val == heap[b].val &amp;&amp; a &gt; b)) swap(a, b); heap[a].rs = merge(heap[a].rs, b), fa[heap[a].rs] = a; if (heap[heap[a].rs].dis &gt; heap[heap[a].ls].dis) swap(heap[a].ls, heap[a].rs); heap[a].dis = heap[a].rs == 0 ? 0 : heap[heap[a].rs].dis+1; return a;&#125;int pop(int a) &#123; int l = heap[a].ls, r = heap[a].rs; heap[a].ls = heap[a].rs = heap[a].val = 0, fa[l] = l, fa[r] = r; return merge(l, r);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;heap[i].val), fa[i] = i; while (m--) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y), x = getf(x), y = getf(y); if (heap[x].val &amp;&amp; heap[y].val &amp;&amp; x != y) merge(x, y); &#125; if (opt == 2) &#123; int x; scanf("%d", &amp;x), x = getf(x); if (!heap[x].val) printf("-1\n"); else printf("%d\n", heap[x].val), pop(x); &#125; &#125; return 0;&#125; Binary Indexed Tree112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 500000using namespace std;int n, m;int tree[MAX_N+5];int lowbit(int x) &#123; return x&amp;(-x);&#125;void modify(int pos, int x) &#123; while (pos &lt;= n) &#123; tree[pos] += x; pos += lowbit(pos); &#125;&#125;long long query(int t) &#123; long long tot = 0; while (t &gt; 0) &#123; tot += tree[t]; t -= lowbit(t); &#125; return tot;&#125;int main() &#123; memset(tree, 0, sizeof(tree)); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; int tmp; cin &gt;&gt; tmp; modify(i, tmp); &#125; for (int i = 0; i &lt; m; i++) &#123; int f, a, b; cin &gt;&gt; f &gt;&gt; a &gt;&gt; b; if (f == 1) &#123; modify(a, b); &#125; else &#123; cout &lt;&lt; query(b)-query(a-1) &lt;&lt; endl; &#125; &#125; return 0;&#125; 212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 500000using namespace std;int n, m;int tree[MAX_N+5];int lowbit(int x) &#123; return x&amp;(-x);&#125;void modify(int pos, int x) &#123; while (pos &lt;= n) &#123; tree[pos] += x; pos += lowbit(pos); &#125;&#125;long long query(int pos) &#123; long long tot = 0; while (pos &gt; 0) &#123; tot += tree[pos]; pos -= lowbit(pos); &#125; return tot;&#125;int main() &#123; memset(tree, 0, sizeof(tree)); cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) &#123; int x; cin &gt;&gt; x; modify(i, x); modify(i+1, -x); &#125; for (int i = 0; i &lt; m; i++) &#123; int f; cin &gt;&gt; f; if (f == 1) &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify(l, x); modify(r+1, -x); &#125; else &#123; int x; cin &gt;&gt; x; cout &lt;&lt; query(x) &lt;&lt; endl; &#125; &#125; return 0;&#125; Segment Tree112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 100000using namespace std;int n, k;long long tree[MAX_N*4+50], tag[MAX_N*4+50];void updata(int v) &#123; tree[v] = tree[v*2]+tree[v*2+1];&#125;void downtag(int v, int s, int t) &#123; tag[v*2] += tag[v]; tag[v*2+1] += tag[v]; int m = (s+t)/2; tree[v*2] += tag[v]*(m-s+1); tree[v*2+1] += tag[v]*(t-m); tag[v] = 0;&#125;void modify(int v, int s, int t, int l, int r, int x) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; tree[v] += x*(t-s+1); tag[v] += x; return; &#125; int m = (s+t)/2; downtag(v, s, t); if (l &lt;= m) &#123; modify(v*2, s, m, l, r, x); &#125; if (r &gt;= m+1) &#123; modify(v*2+1, m+1, t, l, r, x); &#125; updata(v);&#125;void build(int v, int s, int t) &#123; if (s == t) &#123; cin &gt;&gt; tree[v]; return; &#125; int m = (s+t)/2; build(v*2, s, m); build(v*2+1, m+1, t); updata(v);&#125;long long query(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; return tree[v]; &#125; int m = (s+t)/2; downtag(v, s, t); long long ret = 0; if (l &lt;= m) &#123; ret += query(v*2, s, m, l, r); &#125; if (r &gt;= m+1) &#123; ret += query(v*2+1, m+1, t, l, r); &#125; updata(v); return ret;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; build(1, 1, n); for (int i = 0; i &lt; k; i++) &#123; int f, l, r, x; cin &gt;&gt; f; if (f == 1) &#123; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify(1, 1, n, l, r, x); &#125; else &#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(1, 1, n, l, r) &lt;&lt; endl; &#125; &#125; return 0;&#125; 2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 100000#define ll long longusing namespace std;int n, m;ll p;ll tree[MAX_N*4+5], mul[MAX_N*4+5], add[MAX_N*4+5];void updata(int v) &#123; tree[v] = (tree[v*2]+tree[v*2+1])%p;&#125;void downtag(int v, int s, int t, int mid) &#123; if (mul[v] == 1 &amp;&amp; add[v] == 0) return; mul[v*2] = mul[v*2]*mul[v]%p; add[v*2] = (add[v*2]*mul[v]%p+add[v])%p; tree[v*2] = (tree[v*2]*mul[v]%p+add[v]*(ll)(mid-s+1)%p)%p; mul[v*2+1] = mul[v*2+1]*mul[v]%p; add[v*2+1] = (add[v*2+1]*mul[v]%p+add[v])%p; tree[v*2+1] = (tree[v*2+1]*mul[v]%p+add[v]*(ll)(t-mid)%p)%p; mul[v] = 1; add[v] = 0; return;&#125;void create(int v, int s, int t) &#123; mul[v] = 1; add[v] = 0; if (s == t) &#123; cin &gt;&gt; tree[v]; tree[v] %= p; return; &#125; int mid = (s+t)/2; create(v*2, s, mid); create(v*2+1, mid+1, t); updata(v);&#125;void modify1(int v, int s, int t, int l, int r, int x) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; add[v] = (add[v]+(ll)x)%p; tree[v] = (tree[v]+(ll)x*(ll)(t-s+1)%p)%p; return; &#125; int mid = (s+t)/2; downtag(v, s, t, mid); if (l &lt;= mid) &#123; modify1(v*2, s, mid, l, r, x); &#125; if (r &gt;= mid+1) &#123; modify1(v*2+1, mid+1, t, l, r, x); &#125; updata(v);&#125;void modify2(int v, int s, int t, int l, int r, int x) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; mul[v] = mul[v]*(ll)x%p; add[v] = add[v]*(ll)x%p; tree[v] = tree[v]*(ll)x%p; return; &#125; int mid = (s+t)/2; downtag(v, s, t, mid); if (l &lt;= mid) &#123; modify2(v*2, s, mid, l, r, x); &#125; if (r &gt;= mid+1) &#123; modify2(v*2+1, mid+1, t, l, r, x); &#125; updata(v);&#125;ll query(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; return tree[v]; &#125; int mid = (s+t)/2; ll ret = 0; downtag(v, s, t, mid); if (l &lt;= mid) &#123; ret = (ret+query(v*2, s, mid, l, r))%p; &#125; if (r &gt;= mid+1) &#123; ret = (ret+query(v*2+1, mid+1, t, l, r))%p; &#125; updata(v); return ret;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; create(1, 1, n); for (int i = 0; i &lt; m; i++) &#123; int f; cin &gt;&gt; f; if (f == 1) &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify2(1, 1, n, l, r, x%p); &#125; else if (f == 2) &#123; int l, r, x; cin &gt;&gt; l &gt;&gt; r &gt;&gt; x; modify1(1, 1, n, l, r, x%p); &#125; else &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; query(1, 1, n, l, r) &lt;&lt; endl; &#125; &#125; return 0;&#125; Sparse Table1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAX_N 100000using namespace std;int n, m, num[MAX_N+5], mx[MAX_N+5][20];void setTable() &#123; for (int i = 1; i &lt;= n; i++) mx[i][0] = num[i]; for (int j = 1; (1&lt;&lt;j) &lt;= n; j++) for (int i = 1; i+(1&lt;&lt;j)-1 &lt;= n; i++) mx[i][j] = max(mx[i][j-1], mx[i+(1&lt;&lt;j-1)][j-1]);&#125;int query(int l, int r) &#123; int range = (int)(log(r-l+1)/log(2)); return max(mx[l][range], mx[r-(1&lt;&lt;range)+1][range]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;num[i]); setTable(); while (m--) &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%d\n", query(l, r)); &#125; return 0;&#125; Chairman Tree1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#define MAX_N 200000using namespace std;int n, m, num[MAX_N+5], hash[MAX_N+5], tot, root[MAX_N+5], cnt;struct pre &#123;int id, val;&#125; p[MAX_N+5];bool cmp (const pre &amp;a, const pre &amp;b) &#123;return a.val &lt; b.val;&#125;struct node &#123;int ls, rs, val;&#125; tr[MAX_N*50];void updata(int v) &#123;tr[v].val = tr[tr[v].ls].val+tr[tr[v].rs].val;&#125;void build(int v, int s, int t) &#123; if (s == t) return; int mid = s+t&gt;&gt;1; tr[v].ls = ++cnt, tr[v].rs = ++cnt; build(tr[v].ls, s, mid), build(tr[v].rs, mid+1, t);&#125;void modify(int v, int o, int s, int t, int x) &#123; tr[v] = tr[o]; if (s == t) &#123;tr[v].val++; return;&#125; int mid = s+t&gt;&gt;1; if (x &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, x); else modify(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, x); updata(v);&#125;int query(int v1, int v2, int s, int t, int k) &#123; if (s == t) return s; int mid = s+t&gt;&gt;1, tmp = tr[tr[v2].ls].val-tr[tr[v1].ls].val; if (k &lt;= tmp) return query(tr[v1].ls, tr[v2].ls, s, mid, k); else return query(tr[v1].rs, tr[v2].rs, mid+1, t, k-tmp);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) p[i].id = i, scanf("%d", &amp;p[i].val); sort(p+1, p+n+1, cmp); for (int i = 1; i &lt;= n; i++) &#123;if (p[i].val != p[i-1].val || i == 1) hash[++tot] = p[i].val; num[p[i].id] = tot;&#125; root[0] = ++cnt, build(root[0], 1, tot); for (int i = 1; i &lt;= n; i++) root[i] = ++cnt, modify(root[i], root[i-1], 1, tot, num[i]); while (m--) &#123; int l, r, k; scanf("%d%d%d", &amp;l, &amp;r, &amp;k); printf("%d\n", hash[query(root[l-1], root[r], 1, tot, k)]); &#125; return 0;&#125; Treap12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#define MAX_N 100000using namespace std;struct TNode &#123; TNode* s[2]; int val, k, size; TNode() &#123;&#125; TNode(int _val, TNode* _s) &#123;val = _val, s[0] = s[1] = _s, k = rand(), size = 1;&#125; void updata() &#123;size = s[0]-&gt;size+s[1]-&gt;size+1;&#125;&#125; nil, tr[MAX_N+5], *null, *root, *cnt;typedef TNode* P_TNode;void init() &#123; srand(19260817); nil = TNode(0, NULL), null = &amp;nil; null-&gt;s[0] = null-&gt;s[1] = null, null-&gt;size = 0; cnt = tr, root = null;&#125;P_TNode newnode(int val) &#123; *cnt = TNode(val, null); return cnt++;&#125;P_TNode merge(P_TNode a, P_TNode b) &#123; if (a == null) return b; if (b == null) return a; if (a-&gt;k &gt; b-&gt;k) &#123;a-&gt;s[1] = merge(a-&gt;s[1], b), a-&gt;updata(); return a;&#125; if (a-&gt;k &lt;= b-&gt;k) &#123;b-&gt;s[0] = merge(a, b-&gt;s[0]), b-&gt;updata(); return b;&#125;&#125;void split(P_TNode v, int val, P_TNode &amp;ls, P_TNode &amp;rs) &#123; if (v == null) &#123;ls = rs = null; return;&#125; if (val &lt; v-&gt;val) &#123;rs = v; split(rs-&gt;s[0], val, ls, rs-&gt;s[0]);&#125; if (val &gt;= v-&gt;val) &#123;ls = v; split(ls-&gt;s[1], val, ls-&gt;s[1], rs);&#125; v-&gt;updata();&#125;void insert(int val) &#123; P_TNode ls, rs; split(root, val, ls, rs); root = merge(merge(ls, newnode(val)), rs);&#125;void remove(int val) &#123; P_TNode ls, mids, rs; split(root, val-1, ls, rs); split(rs, val, mids, rs); root = merge(ls, merge(merge(mids-&gt;s[0], mids-&gt;s[1]), rs));&#125;int get_rank(int val) &#123; P_TNode ls, rs; split(root, val-1, ls, rs); int ret = ls-&gt;size+1; root = merge(ls, rs); return ret;&#125;int get_kth(P_TNode v, int k) &#123; if (k &lt;= v-&gt;s[0]-&gt;size) return get_kth(v-&gt;s[0], k); if (k &gt; v-&gt;s[0]-&gt;size+1) return get_kth(v-&gt;s[1], k-v-&gt;s[0]-&gt;size-1); return v-&gt;val;&#125;int get_nearest(P_TNode v, int sn) &#123; while (v-&gt;s[sn] != null) v = v-&gt;s[sn]; return v-&gt;val;&#125;int predecessor(int val) &#123; P_TNode ls, rs; split(root, val-1, ls, rs); int ret = get_nearest(ls, 1); root = merge(ls, rs); return ret;&#125;int successor(int val) &#123; P_TNode ls, rs; split(root, val, ls, rs); int ret = get_nearest(rs, 0); root = merge(ls, rs); return ret;&#125;int main() &#123; init(); int n, opt, x; scanf("%d", &amp;n); while (n--) &#123; scanf("%d%d", &amp;opt, &amp;x); if (opt == 1) insert(x); if (opt == 2) remove(x); if (opt == 3) printf("%d\n", get_rank(x)); if (opt == 4) printf("%d\n", get_kth(root, x)); if (opt == 5) printf("%d\n", predecessor(x)); if (opt == 6) printf("%d\n", successor(x)); &#125; return 0;&#125; SplayNormal1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;bits/stdc++.h&gt;#define INF 0x7f7f7f7f#define flag (cur-&gt;fa-&gt;fa!=tar&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;struct SplayNode &#123; SplayNode *s[2], *fa; int val, w, sz; void updata() &#123;sz = w+(s[0]?s[0]-&gt;sz:0)+(s[1]?s[1]-&gt;sz:0);&#125;&#125;;struct SplayTree &#123; SplayNode* rt; SplayNode* newnode(int _val) &#123; SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = _val, v-&gt;w = v-&gt;sz = 1; return v; &#125; SplayTree() &#123; rt = newnode(-INF), rt-&gt;s[1] = newnode(INF); rt-&gt;s[1]-&gt;fa = rt, rt-&gt;updata(); &#125; void rotate(SplayNode* v, bool sn) &#123; SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); &#125; void splay(SplayNode* cur, SplayNode* tar) &#123; while (cur != tar &amp;&amp; cur-&gt;fa != tar) &#123; bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); &#125; if (cur-&gt;fa == tar) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); if (tar == rt) rt = cur; &#125; SplayNode* predecessor(int _val) &#123; SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt; cur-&gt;val]) if (cur-&gt;val &lt; _val) cpy = cur; return cpy; &#125; SplayNode* successor(int _val) &#123; SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt;= cur-&gt;val]) if (cur-&gt;val &gt; _val) cpy = cur; return cpy; &#125; void insert(int _val) &#123; SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); if (suc-&gt;s[0]) suc-&gt;s[0]-&gt;w++, suc-&gt;s[0]-&gt;sz++; else suc-&gt;s[0] = newnode(_val), suc-&gt;s[0]-&gt;fa = suc; suc-&gt;updata(), rt-&gt;updata(); &#125; void remove(int _val) &#123; SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); suc-&gt;s[0]-&gt;w--, suc-&gt;s[0]-&gt;sz--; if (!suc-&gt;s[0]-&gt;w) suc-&gt;s[0] = NULL; suc-&gt;updata(), rt-&gt;updata(); &#125; int get_rank(int _val) &#123; SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); if (suc == NULL) return rt-&gt;sz; return rt-&gt;sz-suc-&gt;sz; &#125; SplayNode* get_kth(SplayNode* v, int k) &#123; int lsz = v-&gt;s[0] ? v-&gt;s[0]-&gt;sz : 0; if (k &lt;= lsz) return get_kth(v-&gt;s[0], k); if (k &gt; lsz+v-&gt;w) return get_kth(v-&gt;s[1], k-lsz-v-&gt;w); return v; &#125;&#125; BBST;int main() &#123; int n, opt, x; scanf("%d", &amp;n); while (n--) &#123; scanf("%d%d", &amp;opt, &amp;x); if (opt == 1) BBST.insert(x); if (opt == 2) BBST.remove(x); if (opt == 3) printf("%d\n", BBST.get_rank(x)); if (opt == 4) printf("%d\n", BBST.get_kth(BBST.rt, x+1)-&gt;val); if (opt == 5) printf("%d\n", BBST.predecessor(x)-&gt;val); if (opt == 6) printf("%d\n", BBST.successor(x)-&gt;val); &#125; return 0;&#125; Reverse123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define INF 0x7f7f7f7f#define flag (cur-&gt;fa-&gt;fa!=tar&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;struct SplayNode &#123; SplayNode *s[2], *fa; int val, w, sz; bool rev; void updata() &#123;sz = w+(s[0]?s[0]-&gt;sz:0)+(s[1]?s[1]-&gt;sz:0);&#125; void downtag() &#123; if (!rev) return; rev = false, swap(s[0], s[1]); if (s[0]) s[0]-&gt;rev ^= 1; if (s[1]) s[1]-&gt;rev ^= 1; &#125;&#125;;struct SplayTree &#123; SplayNode* rt; SplayNode* newnode(int _val) &#123; SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = _val, v-&gt;sz = v-&gt;w = 1; v-&gt;rev = false; return v; &#125; SplayTree(int n) &#123; rt = newnode(-INF), rt-&gt;s[1] = newnode(INF); rt-&gt;s[1]-&gt;fa = rt, rt-&gt;updata(); for (int i = 1; i &lt;= n; i++) insert(i); &#125; void rotate(SplayNode* v, bool sn) &#123; SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); &#125; void splay(SplayNode* cur, SplayNode* tar) &#123; while (cur != tar &amp;&amp; cur-&gt;fa != tar) &#123; bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); &#125; if (cur-&gt;fa == tar) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); if (tar == rt) rt = cur; &#125; SplayNode* predecessor(int _val) &#123; SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt; cur-&gt;val]) if (cur-&gt;val &lt; _val) cpy = cur; return cpy; &#125; SplayNode* successor(int _val) &#123; SplayNode *cur = rt, *cpy = rt; for (; cur; cur = cur-&gt;s[_val &gt;= cur-&gt;val]) if (cur-&gt;val &gt; _val) cpy = cur; return cpy; &#125; void insert(int _val) &#123; SplayNode* pre = predecessor(_val); SplayNode* suc = successor(_val); splay(pre, rt), splay(suc, rt-&gt;s[1]); if (suc-&gt;s[0]) suc-&gt;s[0]-&gt;w++, suc-&gt;s[0]-&gt;sz++; else suc-&gt;s[0] = newnode(_val), suc-&gt;s[0]-&gt;fa = suc; suc-&gt;updata(), rt-&gt;updata(); &#125; void reverse(int l, int r) &#123; SplayNode *nl = get_kth(rt, l), *nr = get_kth(rt, r+2); splay(nl, rt), splay(nr, rt-&gt;s[1]), nr-&gt;s[0]-&gt;rev ^= 1; &#125; SplayNode* get_kth(SplayNode* v, int k) &#123; v-&gt;downtag(); int lsz = v-&gt;s[0] == NULL ? 0 : v-&gt;s[0]-&gt;sz; if (k &lt;= lsz) return get_kth(v-&gt;s[0], k); if (k &gt; lsz+v-&gt;w) return get_kth(v-&gt;s[1], k-lsz-v-&gt;w); return v; &#125; void output(SplayNode* v) &#123; if (v == NULL) return; v-&gt;downtag(), output(v-&gt;s[0]); if (v-&gt;val != -INF &amp;&amp; v-&gt;val != INF) printf("%d ", v-&gt;val); output(v-&gt;s[1]); &#125;&#125;;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); SplayTree BBST(n); for (int i = 1, l, r; i &lt;= m; i++) scanf("%d%d", &amp;l, &amp;r), BBST.reverse(l, r); return BBST.output(BBST.rt), 0;&#125; Tree Chain Division123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 100000using namespace std;int n, m, r, p, ind;vector &lt;int&gt; G[MAX_N+5];int c[MAX_N+5];int dep[MAX_N+5], fa[MAX_N+5], size[MAX_N+5], son[MAX_N+5];int top[MAX_N+5], dfn[MAX_N+5], last[MAX_N+5];int seg[(MAX_N&lt;&lt;2)+5], tag[(MAX_N&lt;&lt;2)+5];void DFS1(int u) &#123; size[u] = 1; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa[u]) continue; dep[v] = dep[u]+1; fa[v] = u; DFS1(v); size[u] += size[v]; if (!son[u] || size[son[u]] &lt; size[v]) son[u] = v; &#125;&#125;void DFS2(int u, int tp) &#123; top[u] = tp, dfn[u] = ++ind; if (son[u]) DFS2(son[u], tp); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa[u] || v == son[u]) continue; DFS2(v, v); &#125; last[u] = ind;&#125;void updata(int v) &#123;seg[v] = (seg[v&lt;&lt;1]+seg[v&lt;&lt;1|1])%p;&#125;void downtag(int v, int s, int t) &#123; if (!tag[v]) return; int mid = s+t&gt;&gt;1; seg[v&lt;&lt;1] = (seg[v&lt;&lt;1]+tag[v]*(mid-s+1))%p; seg[v&lt;&lt;1|1] = (seg[v&lt;&lt;1|1]+tag[v]*(t-mid))%p; tag[v&lt;&lt;1] = (tag[v&lt;&lt;1]+tag[v])%p; tag[v&lt;&lt;1|1] = (tag[v&lt;&lt;1|1]+tag[v])%p; tag[v] = 0;&#125;void modify(int v, int s, int t, int l, int r, int x) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123;seg[v] = (seg[v]+x*(t-s+1))%p, tag[v] = (tag[v]+x)%p; return;&#125; downtag(v, s, t); int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, x); updata(v);&#125;int query(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) return seg[v]; downtag(v, s, t); int mid = s+t&gt;&gt;1, ret = 0; if (l &lt;= mid) ret = (ret+query(v&lt;&lt;1, s, mid, l, r))%p; if (r &gt;= mid+1) ret = (ret+query(v&lt;&lt;1|1, mid+1, t, l, r))%p; updata(v); return ret;&#125;void solve1(int x, int y, int z) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); modify(1, 1, n, dfn[top[x]], dfn[x], z); x = fa[top[x]]; &#125; modify(1, 1, n, min(dfn[x], dfn[y]), max(dfn[x], dfn[y]), z);&#125;int solve2(int x, int y) &#123; int ret = 0; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); ret = (ret+query(1, 1, n, dfn[top[x]], dfn[x]))%p; x = fa[top[x]]; &#125; ret = (ret+query(1, 1, n, min(dfn[x], dfn[y]), max(dfn[x], dfn[y])))%p; return ret;&#125;void solve3(int x, int z) &#123;modify(1, 1, n, dfn[x], last[x], z);&#125;int solve4(int x) &#123;return query(1, 1, n, dfn[x], last[x]);&#125;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;r, &amp;p); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; DFS1(r); DFS2(r, r); for (int i = 1; i &lt;= n; i++) modify(1, 1, n, dfn[i], dfn[i], c[i]); while (m--) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int x, y, z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); solve1(x, y, z); &#125; if (opt == 2) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", solve2(x, y)); &#125; if (opt == 3) &#123; int x, z; scanf("%d%d", &amp;x, &amp;z); solve3(x, z); &#125; if (opt == 4) &#123; int x; scanf("%d", &amp;x); printf("%d\n", solve4(x)); &#125; &#125; return 0;&#125; Link-Cut Tree1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;bits/stdc++.h&gt;#define MAX_N 300000#define INF 0x7f7f7f7f#define flag (!tar(cur-&gt;fa-&gt;fa)&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)using namespace std;struct SplayNode &#123; SplayNode *s[2], *fa; int val, sum; bool rev; void updata() &#123;sum = val^(s[0]?s[0]-&gt;sum:0)^(s[1]?s[1]-&gt;sum:0);&#125; void downtag() &#123; if (fa &amp;&amp; (fa-&gt;s[0] == this || fa-&gt;s[1] == this)) fa-&gt;downtag(); if (rev &amp;&amp; s[0]) swap(s[0]-&gt;s[0], s[0]-&gt;s[1]), s[0]-&gt;rev ^= 1; if (rev &amp;&amp; s[1]) swap(s[1]-&gt;s[0], s[1]-&gt;s[1]), s[1]-&gt;rev ^= 1; rev = false; &#125;&#125; *tr[MAX_N+5];struct LinkCutTree &#123; SplayNode* newnode(int _val) &#123; SplayNode* v = new SplayNode; v-&gt;s[0] = v-&gt;s[1] = v-&gt;fa = NULL; v-&gt;val = v-&gt;sum = _val, v-&gt;rev = 0; return v; &#125; SplayNode* get_rt(SplayNode* v) &#123;for (; v-&gt;fa; v = v-&gt;fa) ; return v;&#125; bool tar(SplayNode* v) &#123;return (v&amp;&amp;v-&gt;fa==NULL)||(v&amp;&amp;v-&gt;fa-&gt;s[0]!=v&amp;&amp;v-&gt;fa-&gt;s[1]!=v);&#125; LinkCutTree(int n) &#123;for (int i=1,_val;i&lt;=n;i++) scanf("%d", &amp;_val), tr[i]=newnode(_val);&#125; void rotate(SplayNode* v, bool sn) &#123; SplayNode* f = v-&gt;fa; f-&gt;s[sn^1] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa; if (f-&gt;s[sn^1]) f-&gt;s[sn^1]-&gt;fa = f; if (v-&gt;fa &amp;&amp; !tar(f)) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[1]] = v; v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata(); &#125; void splay(SplayNode* cur) &#123; cur-&gt;downtag(); while (!tar(cur) &amp;&amp; !tar(cur-&gt;fa)) &#123; bool sn = cur-&gt;fa-&gt;s[1] == cur; if flag rotate(cur-&gt;fa, sn^1); rotate(cur, sn^1); &#125; if (!tar(cur) &amp;&amp; tar(cur-&gt;fa)) rotate(cur, cur-&gt;fa-&gt;s[0] == cur); cur-&gt;updata(); &#125; void access(SplayNode* cur) &#123; for (SplayNode* cpy = NULL; cur; cpy = cur, cur = cur-&gt;fa) splay(cur), cur-&gt;s[1] = cpy, cur-&gt;updata(); &#125; void mroot(SplayNode* v) &#123; access(v), splay(v); swap(v-&gt;s[0], v-&gt;s[1]), v-&gt;rev ^= 1; &#125; void link(SplayNode* u, SplayNode* v) &#123; if (get_rt(u) == get_rt(v)) return; mroot(u), u-&gt;fa = v; &#125; void cut(SplayNode* u, SplayNode* v) &#123; if (u == v || get_rt(u) != get_rt(v)) return; mroot(u), access(v), splay(v); if (v-&gt;s[0] == u) u-&gt;fa = v-&gt;s[0] = NULL, v-&gt;updata(); &#125; void modify(SplayNode* v, int _val) &#123; splay(v), v-&gt;val = _val, v-&gt;updata(); &#125; int query(SplayNode* u, SplayNode* v) &#123; mroot(u), access(v), splay(v); return v-&gt;sum; &#125;&#125;;int main() &#123; int n, m; scanf("%d%d", &amp;n, &amp;m); LinkCutTree LCT(n); while (m--) &#123; int opt, x, y; scanf("%d%d%d", &amp;opt, &amp;x, &amp;y); if (opt == 0) printf("%d\n", LCT.query(tr[x], tr[y])); if (opt == 1) LCT.link(tr[x], tr[y]); if (opt == 2) LCT.cut(tr[x], tr[y]); if (opt == 3) LCT.modify(tr[x], y); &#125; return 0;&#125; StringKnuth-Morris-Pratt Algorithm12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#define MAX_M 1000using namespace std;int next[MAX_M];void CalcNext(string&amp; s) &#123; int m = s.length(); int begin = 1, matched = 0; while (begin+matched &lt; m) &#123; if (s[begin+matched] == s[matched]) &#123; matched++; next[begin+matched-1] = matched; &#125; else &#123; if (matched == 0) &#123; begin++; &#125; else &#123; begin += matched-next[matched-1]; matched = next[matched-1]; &#125; &#125; &#125;&#125;void KMP(string&amp; T, string&amp; P) &#123; int n = T.length(), m = P.length(); int begin = 0, matched = 0; while (begin &lt;= n-m) &#123; if (matched &lt; m &amp;&amp; T[begin+matched] == P[matched]) &#123; matched++; if (matched == m) &#123; cout &lt;&lt; begin+1 &lt;&lt; endl; &#125; &#125; else &#123; if (matched == 0) &#123; begin++; &#125; else &#123; begin += matched-next[matched-1]; matched = next[matched-1]; &#125; &#125; &#125;&#125;int main() &#123; string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; CalcNext(s2); KMP(s1, s2); for (int i = 0; i &lt; s2.length(); i++) &#123; cout &lt;&lt; next[i] &lt;&lt; " "; &#125; return 0;&#125; Manacher12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_L 11000000using namespace std;char s[MAX_L*2+5];int f[MAX_L*2+5];int manacher (char* s0) &#123; int len = strlen(s0); for (int i = 0; i &lt; len; i++) s[i*2+1] = '#', s[i*2+2] = s0[i]; s[len = len*2+1] = '#'; int pos = 0, r = 0, ret = 0; for (int i = 1; i &lt;= len; i++) &#123; f[i] = (i &lt; r) ? min(f[2*pos-i], r-i) : 1; while (i-f[i] &gt;= 1 &amp;&amp; i+f[i] &lt;= len &amp;&amp; s[i-f[i]] == s[i+f[i]]) f[i]++; if (i+f[i] &gt; r) pos = i, r = i+f[i]; ret = max(ret, f[i]-1); &#125; return ret;&#125;int main() &#123; char s0[MAX_L+5]; scanf("%s", s0); printf("%d\n", manacher(s0)); return 0;&#125; Aho-Corasick Automation12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define DICNUM 26#define MAX_LETTER 10500#define MAX_LENGTH 1000000using namespace std;char P[155][75], T[MAX_LENGTH+5];int root = 1, cnt, trie[MAX_LETTER+5][DICNUM], fail[MAX_LETTER+5], end[MAX_LETTER+5], tot[155];void init() &#123; memset(P, 0, sizeof(P)), memset(T, 0, sizeof(T)), memset(tot, 0, sizeof(tot)); for (int i = 1; i &lt;= cnt; i++) memset(trie[i], 0, sizeof(trie[i])), fail[i] = end[i] = 0; cnt = 1;&#125;void insert(int id, char s[]) &#123; int cur = 1, len = strlen(s); for (int i = 0; i &lt; len; cur = trie[cur][s[i++]-'a']) if (!trie[cur][s[i]-'a']) trie[cur][s[i]-'a'] = ++cnt; end[cur] = id;&#125;void SetFail() &#123; queue &lt;int&gt; que; que.push(root); while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = 0; i &lt; DICNUM; i++) if (trie[u][i]) fail[trie[u][i]] = trie[fail[u]][i], que.push(trie[u][i]); else trie[u][i] = trie[fail[u]][i]; &#125;&#125;void query() &#123; int cur = root, index, len = strlen(T); for (int i = 0; i &lt; len; i++) &#123; index = T[i]-'a'; while (!trie[cur][index]) cur = fail[cur]; cur = trie[cur][index]; for (int j = cur; j; j = fail[j]) tot[end[j]]++; &#125;&#125;int main() &#123; int n; for (int i = 0; i &lt; DICNUM; i++) trie[0][i] = root; while (scanf("%d", &amp;n) &amp;&amp; n) &#123; init(); for (int i = 1; i &lt;= n; i++) scanf("%s", P[i]), insert(i, P[i]); SetFail(), scanf("%s", T), query(); int ans = 0; for (int i = 1; i &lt;= n; i++) ans = max(ans, tot[i]); printf("%d\n", ans); for (int i = 1; i &lt;= n; i++) if (tot[i] == ans) printf("%s\n", P[i]); &#125; return 0;&#125; Hash Table1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#define size 15000using namespace std;int n, cnt = 0;string tmp;string hash[size];int calc(string&amp; index) &#123; int ret = 0; for (int i = 0; i &lt; index.length(); i++) &#123; ret = (ret*256+index[i]+128)%size; &#125; return ret;&#125;bool search(string&amp; index, int&amp; pos) &#123; pos = calc(index); while (hash[pos] != "" &amp;&amp; hash[pos] != index) &#123; pos = (pos+1)%size; &#125; if (hash[pos] == index) &#123; return true; &#125; else &#123; return false; &#125;&#125;int insert(string&amp; index) &#123; int pos; if (search(index, pos)) &#123; return 0; &#125; else &#123; hash[pos] = index; return 1; &#125;&#125;int main() &#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; cnt += insert(tmp); &#125; cout &lt;&lt; cnt &lt;&lt; endl; return 0;&#125; Suffix Array12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 1000000using namespace std;int n; char ch[MAX_N+5];int s[MAX_N+5], sa[MAX_N+5], tx[MAX_N+5], ty[MAX_N+5], cnt[MAX_N+5], rank[MAX_N+5];int trans(char c) &#123; if (c &gt;= '0' &amp;&amp; c &lt;= '9') return c-'0'+1; if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z') return c-'A'+11; if (c &gt;= 'a' &amp;&amp; c &lt;= 'z') return c-'a'+37;&#125;void getSA() &#123; int *x = tx, *y = ty; int DICNUM = 63; for (int i = 1; i &lt;= n; i++) cnt[x[i] = s[i]]++; for (int i = 2; i &lt;= DICNUM; i++) cnt[i] += cnt[i-1]; for (int i = n; i; i--) sa[cnt[x[i]]--] = i; for (int h = 1; h &lt;= n; h &lt;&lt;= 1) &#123; int c = 0; for (int i = n-h+1; i &lt;= n; i++) y[++c] = i; for (int i = 1; i &lt;= n; i++) if (sa[i] &gt; h) y[++c] = sa[i]-h; memset(cnt, 0, sizeof(cnt)); for (int i = 1; i &lt;= n; i++) cnt[x[i]]++; for (int i = 2; i &lt;= DICNUM; i++) cnt[i] += cnt[i-1]; for (int i = n; i; i--) sa[cnt[x[y[i]]]--] = y[i]; swap(x, y), c = 0, x[sa[1]] = ++c; for (int i = 2; i &lt;= n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i-1]] &amp;&amp; y[sa[i]+h] == y[sa[i-1]+h]) ? c : ++c; DICNUM = c; if (c == n) break; &#125;&#125;int main() &#123; scanf("%s", ch); n = strlen(ch); for (int i = 0; i &lt; n; i++) s[i+1] = trans(ch[i]); getSA(); printf("%d", sa[1]); for (int i = 2; i &lt;= n; i++) printf(" %d", sa[i]); return 0;&#125; Suffix Automation12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 1000000using namespace std;typedef long long lnt;struct node &#123;int ch[26], par, len;&#125; SAM[MAX_N*2+500];int sz, root, last, cnt[MAX_N*2+500], dfn[MAX_N*2+500], f[MAX_N*2+500];int newnode(int _len) &#123;SAM[++sz].len = _len; return sz;&#125;void init() &#123;sz = 0, root = last = newnode(0);&#125;void extend(int c) &#123; int p = last, np = newnode(SAM[p].len+1); last = np, f[np] = 1; for (; p &amp;&amp; !SAM[p].ch[c]; p = SAM[p].par) SAM[p].ch[c] = np; if (!p) SAM[np].par = root; else &#123; int q = SAM[p].ch[c]; if (SAM[q].len == SAM[p].len+1) SAM[np].par = q; else &#123; int nq = newnode(SAM[p].len+1); memcpy(SAM[nq].ch, SAM[q].ch, sizeof(SAM[q].ch)); SAM[nq].par = SAM[q].par, SAM[q].par = SAM[np].par = nq; for (; p &amp;&amp; SAM[p].ch[c] == q; p = SAM[p].par) SAM[p].ch[c] = nq; &#125; &#125;&#125;int main() &#123; char s[MAX_N+5]; init(), scanf("%s", s); int l = strlen(s); for (int i = 0; i &lt; l; i++) extend(s[i]-'a'); for (int i = 1; i &lt;= sz; i++) cnt[SAM[i].len]++; for (int i = 1; i &lt;= l; i++) cnt[i] += cnt[i-1]; for (int i = 1; i &lt;= sz; i++) dfn[cnt[SAM[i].len]--] = i; for (int i = 1; i &lt;= sz; i++) cout &lt;&lt; dfn[i] &lt;&lt; " "; cout &lt;&lt; endl; lnt ans = 0; for (int i = sz; i &gt;= 1; i--) &#123; int p = dfn[i]; f[SAM[p].par] += f[p]; if (f[p] &gt; 1) ans = max(ans, (lnt)f[p]*SAM[p].len); &#125; printf("%lld", ans); return 0;&#125;]]></content>
      <tags>
        <tag>数论数学</tag>
        <tag>图论</tag>
        <tag>数据结构</tag>
        <tag>字符串</tag>
        <tag>LG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1787【AHOI2008】Meet紧急集合]]></title>
    <url>%2FBZOJ1787%E3%80%90AHOI2008%E3%80%91Meet%E7%B4%A7%E6%80%A5%E9%9B%86%E5%90%88%20LCA%2F</url>
    <content type="text"><![CDATA[Problem 【AHOI2008】Meet 紧急集合 Description欢乐岛上有个非常好玩的游戏，叫做“紧急集合”。在岛上分散有$N$个等待点，有$N-1$条道路连接着它们，每条道路都连接某两个等待点，且通过这些道路可以走遍所有的等待点，通过道路从一点到另一点要花费一个游戏币。参加游戏的三人一组，开始的时候，所有人员均任意分散在各个等待点上（每个点同时允许多个人等待），每个人均带有足够多的游戏币（用于支付使用道路的花费）、地图（标明等待点之间道路连接的情况）以及对讲机（用于和同组的成员联系）。当集合号吹响后，每个成员之间迅速联系，了解到自己组所有成员所在的等待点后，迅速在$N$个等待点中确定一个集合点，组内所有成员将在该集合点集合，集合所用花费最少的组将是游戏的赢家。小可可和他的朋友邀请你一起参加这个游戏，有你来选择集合点，聪明的你能够完成这个任务，帮助小可可赢得游戏吗？ Input第一行两个正整数$N$和$M$（$N\le 5\times 10^5$，$M\le 5\times 10^5$），之间用一个空格隔开。分别表示等待点的个数（等待点也从$1$到$N$进行编号）和获奖所需完成的集合次数。随后有$N-1$行，每行两个正整数$A$和$B$，之间用空格隔开，表示编号为$A$和编号为$B$的等待点之间有一条路。接着还有$M$行，每行用三个正整数表示某次集合前小可可、小可可的朋友以及你所在的等待点的编号。 Output一共有$M$行，每行两个数$P$和$C$，用一个空格隔开。其中第$i$行表示第$i$次集合点选择在编号为$P$的等待点，集合总共的花费是$C$个游戏币。 Sample Input123456789106 41 22 32 44 55 64 5 66 3 12 4 46 6 6 Sample Output12345 22 54 16 0 HINT$40\%$的数据中，$N\le 2000$，$M\le 2000$$100\%$的数据中，$N\le 500000$，$M\le 500000$ 标签：$LCA$ Solution对于每组询问，找出三个点中两两的$lca$，这三个$lca$中必然至少有两个相同。找出那个不同的$lca$，以它为集合点，算出距离，一定最小。原理可见$zhber$博客：http://www.cnblogs.com/zhber/p/4116388.html Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 500000using namespace std;int n, m, fa[MAX_N+5][35], dep[MAX_N+5];vector &lt;int&gt; G[MAX_N+5];void DFS(int u) &#123; for (int i = 1; i &lt;= 30; i++) if (dep[u] &gt;= (1&lt;&lt;i)) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v == fa[u][0]) continue; fa[v][0] = u, dep[v] = dep[u]+1, DFS(v); &#125;&#125;int LCA(int a, int b) &#123; if (dep[a] &lt; dep[b]) swap(a, b); for (int i = 30; i &gt;= 0; i--) if (dep[a]-(1&lt;&lt;i) &gt;= dep[b]) a = fa[a][i]; if (a == b) return a; for (int i = 30; i &gt;= 0; i--) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];&#125;int calc(int a, int b) &#123;int c = LCA(a, b); return dep[a]+dep[b]-2*dep[c];&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1, u, v; i &lt; n; i++) scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v), G[v].push_back(u); DFS(1); while (m--) &#123; int a, b, c; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); int lca = LCA(a, b)^LCA(a, c)^LCA(b, c); int dis = calc(a, lca)+calc(b, lca)+calc(c, lca); printf("%d %d\n", lca, dis); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>LCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2038 小Z的袜子]]></title>
    <url>%2FBZOJ2038%20%E5%B0%8FZ%E7%9A%84%E8%A2%9C%E5%AD%90%20%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[Problem 小Z的袜子 Description作为一个生活散漫的人，小$Z$每天早上都要耗费很久从一堆五颜六色的袜子中找出一双来穿。终于有一天，小$Z$再也无法忍受这恼人的找袜子过程，于是他决定听天由命……具体来说，小$Z$把这$N$只袜子从$1$到$N$编号，然后从编号$L$到$R$(尽管小$Z$并不在意两只袜子是不是完整的一双，甚至不在意两只袜子是否一左一右，他却很在意袜子的颜色，毕竟穿两只不同色的袜子会很尴尬)。你的任务便是告诉小$Z$，他有多大的概率抽到两只颜色相同的袜子。当然，小$Z$希望这个概率尽量高，所以他可能会询问多个$(L,R)$以方便自己选择。 Input输入文件第一行包含两个正整数$N$和$M$。$N$为袜子的数量，$M$为小$Z$所提的询问的数量。接下来一行包含$N$个正整数$C_i$，其中$C_i$表示第$i$只袜子的颜色，相同的颜色用相同的数字表示。再接下来$M$行，每行两个正整数$L$，$R$表示一个询问。 Output包含$M$行，对于每个询问在一行中输出分数$A/B$表示从该询问的区间$[L,R]$中随机抽出两只袜子颜色相同的概率。若该概率为$0$则输出$0/1$，否则输出的$A/B$必须为最简分数。 Sample Input1234566 41 2 3 3 3 22 61 33 51 6 Sample Output12342/50/11/14/15 Hint【样例解释】询问$1$：共$C_5^2=10$种可能，其中抽出两个$2$有$1$种可能，抽出两个$3$有$3$种可能，概率为$(1+3)/10=4/10=2/5$。询问$2$：共$C_3^2=3$种可能，无法抽到颜色相同的袜子，概率为$0/3=0/1$。询问$3$：共$C_3^2=3$种可能，均为抽出两个3，概率为$3/3=1/1$。【数据规模和约定】$30\%$的数据中 $N,M \le 5000$；$60\%$的数据中 $N,M \le 25000$；$100\%$的数据中 $N,M \le 50000$，$1\le L &lt; R \le N$，$C_i \le N$。 标签：莫队 Solution莫队经典例题。不懂莫队的可以戳这里：http://www.cnblogs.com/hzf-sbit/p/4056874.html简单来说，莫队就是将询问离线，维护双指针，暴力扩展或缩小范围，为了加速，用分块，可以达到$O(n\sqrt{n})$。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAX_N 50000using namespace std;typedef long long ll;int n, m;int col[MAX_N+5], f[MAX_N+5], pos[MAX_N+5];ll gcd(ll a, ll b) &#123;return (b == 0) ? a : gcd(b, a%b);&#125;struct Query &#123; int id, l, r; ll a, b; void reduction() &#123;ll tmp = gcd(a, b); a /= tmp, b /= tmp;&#125;&#125; Q[MAX_N+5];bool cmp_l(const Query &amp;a, const Query &amp;b) &#123;return pos[a.l] &lt; pos[b.l] || (pos[a.l] == pos[b.l] &amp;&amp; a.r &lt; b.r);&#125;bool cmp_id(const Query &amp;a, const Query &amp;b) &#123;return a.id &lt; b.id;&#125;void add(int c, ll &amp;tmp, int x) &#123;tmp += x*2*f[c]+1; f[c] += x;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int magic = (int)sqrt((double)n+0.5); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;col[i]), pos[i] = (i-1)/magic+1; for (int i = 1; i &lt;= m; i++) scanf("%d%d", &amp;Q[i].l, &amp;Q[i].r), Q[i].id = i; sort(Q+1, Q+m+1, cmp_l); ll tmp = 0; int l = 1, r = 0; for (int i = 1; i &lt;= m; i++) &#123; if (l &gt; Q[i].l) &#123;for (int j = l-1; j &gt;= Q[i].l; j--) add(col[j], tmp, 1); l = Q[i].l;&#125; if (r &lt; Q[i].r) &#123;for (int j = r+1; j &lt;= Q[i].r; j++) add(col[j], tmp, 1); r = Q[i].r;&#125; if (l &lt; Q[i].l) &#123;for (int j = l; j &lt; Q[i].l; j++) add(col[j], tmp, -1); l = Q[i].l;&#125; if (r &gt; Q[i].r) &#123;for (int j = r; j &gt; Q[i].r; j--) add(col[j], tmp, -1); r = Q[i].r;&#125; if (Q[i].l == Q[i].r) &#123;Q[i].a = 0, Q[i].b = 1; continue;&#125; Q[i].a = tmp-(Q[i].r-Q[i].l+1), Q[i].b = (ll)(Q[i].r-Q[i].l+1)*(Q[i].r-Q[i].l); Q[i].reduction(); &#125; sort(Q+1, Q+m+1, cmp_id); for (int i = 1; i &lt;= m; i++) printf("%lld/%lld\n", Q[i].a, Q[i].b); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3068 最长回文]]></title>
    <url>%2FHDU3068%20%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%20Manacher%2F</url>
    <content type="text"><![CDATA[Problem 最长回文 Time Limit: $4000/2000 MS (Java/Others)$ Memory Limit: $32768/32768 K (Java/Others)$ Problem Description给出一个只由小写英文字符$a,b,c\cdots y,z$组成的字符串$S$, 求$S$中最长回文串的长度.回文就是正反读都是一样的字符串, 如$aba$, $abba$等 Input输入有多组$case$,不超过$120$组,每组输入为一行小写英文字符$a,b,c\cdots y,z$组成的字符串$S$两组$case$之间由空行隔开(该空行不用处理)字符串长度$len\le 110000$ Output每一行一个整数$x$,对应一组$case$,表示该组$case$的字符串中所包含的最长回文长度. Sample Input12aaaaabab Sample Output1243 标签：$Manacher$ Solution$Manacher$板子题。不懂$Manacher$可以戳这里：https://segmentfault.com/a/1190000003914228简单来说，$Manacher$就是记录以每个位置为中心的回文串的半径长度，这样在后面计算的时候可以根据对称性，利用前面的结果加速，找更长匹配时暴力扩展，复杂度$O(n)$。由于此算法仅能对付长度为奇数的回文串（毕竟你算的是以每个点为中心的回文串），故先在每两个字符间插入一个占位符。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_L 110000using namespace std;char s[MAX_L*2+5];int f[MAX_L*2+5];int manacher (char* s0) &#123; int len = strlen(s0); for (int i = 0; i &lt; len; i++) s[i*2+1] = '#', s[i*2+2] = s0[i]; s[len = len*2+1] = '#'; int pos = 0, r = 0, ret = 0; for (int i = 1; i &lt;= len; i++) &#123; f[i] = (i &lt; r) ? min(f[2*pos-i], r-i) : 1; while (i-f[i] &gt;= 1 &amp;&amp; i+f[i] &lt;= len &amp;&amp; s[i-f[i]] == s[i+f[i]]) f[i]++; if (i+f[i] &gt; r) pos = i, r = i+f[i]; ret = max(ret, f[i]-1); &#125; return ret;&#125;int main() &#123; char s0[MAX_L+5]; while (~scanf("%s", s0)) printf("%d\n", manacher(s0)); return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVa12345 Dynamic len(set(a[L:R]))]]></title>
    <url>%2FUVa12345%20Dynamic%20len(set(a%5BLR%5D))%20%E5%B8%A6%E4%BF%AE%E8%8E%AB%E9%98%9F%2F</url>
    <content type="text"><![CDATA[ProblemDynamic len(set(a[L:R]))DescriptionIn python, we can use len(start(a[L:R])) to calculate the number of distinct values of elements $a[L],a[L + 1], \cdots,a[R-1]$.Tere are some interactive examples that may help you understand how it is done. Remember that the indices of python lists start from $0$.>>>a=[1,2,1,3,2,1,4]>>> print a[1:6][2, 1, 3, 2, 1]>>> print set(a[1:6])set([1, 2, 3])>>> printlen(set(a[1:6]))3>>> a[3]=2>>> printlen(set(a[1:6]))2>>> print len(set(a[3:5]))1Your task is to simulate this process. InputThere will be only one test case. The first line contains two integers $n$ and $m$ $(1\le n,m\le 50,000)$.The next line contains the original list.All the integers are between $1$ and $1,000,000$ (inclusive). The next m lines contain the statementsthat you need to execute.A line formatted as ‘$M$ $x$ $y$’ $(1\le y\le 1,000,000)$ means $a[x] = y$, and a line formatted as ‘$Q$ $x$$y$’ means $print len(set(a[x : y]))$.It is guaranteed that the statements will not cause $index$ $out$ $of$ $range$ error. OutputPrint the simulated result, one line for each query. Sample Input1234567 41 2 1 3 2 1 4Q 1 6M 3 2Q 1 6Q 3 5 Sample Output123321 标签：带修莫队 Translation题目大意：给出一个长为$n$的序列，有$m$个操作，分为两类： $Q$ $a$ $b$ 询问此序列$a\sim b$位间有多少种不同数 $M$ $a$ $b$ 将第$a$位改为$b$。 Solution本题数据范围只有五万，一看就是带根号的算法，可以$O(n\sqrt{n})$莫队水过。我们发现$Q$操作是标准莫队，但$M$操作是修改，因而需用带修莫队。带修莫队即在普通莫队的双指针种再加一个指针，指向时间。对于离线后询问建的扩展，如果是同一时间，就直接移动双指针；如果是不同时间，就先暴力移动时间指针，然后再移双指针即可。暴力出奇迹~~~ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define MAX_N 50000#define MAX_C 1000000using namespace std;int n, m, tmp, col[MAX_N+5];int cnt[MAX_C+5], pos[MAX_N+5], lst[MAX_N+5], ans[MAX_N+5];bool mark[MAX_N+5];struct Modify &#123;int pos, x, pre;&#125; M[MAX_N+5];struct Query &#123;int l, r, id, ts;&#125; Q[MAX_N+5];bool cmp(const Query &amp;a, const Query &amp;b) &#123; return pos[a.l] &lt; pos[b.l] || (pos[a.l] == pos[b.l] &amp;&amp; pos[a.r] &lt; pos[b.r]) || (pos[a.l] == pos[b.l] &amp;&amp; pos[a.r] == pos[b.r] &amp;&amp; a.ts &lt; b.ts);&#125;void add(int x) &#123; if (mark[x]) &#123; cnt[col[x]]--; if (!cnt[col[x]]) tmp--; &#125; else &#123; if (!cnt[col[x]]) tmp++; cnt[col[x]]++; &#125; mark[x] ^= 1;&#125;void change(int x, int y) &#123; if (mark[x]) add(x), col[x] = y, add(x); else col[x] = y;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); int magic = (int)(sqrt((double)n+0.5)); int tot = 0, ind = 0; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;col[i]), lst[i] = col[i], pos[i] = i/magic; for (int i = 1; i &lt;= m; i++) &#123; char opt[2]; int x, y; scanf("%s%d%d", opt, &amp;x, &amp;y); x++; if (opt[0] == 'Q') &#123; Q[++tot].id = tot; Q[tot].l = x, Q[tot].r = y, Q[tot].ts = ind; &#125; else &#123; M[++ind].pos = x, M[ind].x = y, M[ind].pre = lst[x]; lst[x] = y; &#125; &#125; sort(Q+1, Q+tot+1, cmp); int now = 0, l = 1, r = 0; for (int i = 1; i &lt;= tot; i++) &#123; if (now &lt; Q[i].ts) for (int j = now+1; j &lt;= Q[i].ts; j++) change(M[j].pos, M[j].x); if (now &gt; Q[i].ts) for (int j = now; j &gt; Q[i].ts; j--) change(M[j].pos, M[j].pre); if (l &gt; Q[i].l) for (int j = l-1; j &gt;= Q[i].l; j--) add(j); if (r &lt; Q[i].r) for (int j = r+1; j &lt;= Q[i].r; j++) add(j); if (l &lt; Q[i].l) for (int j = l; j &lt; Q[i].l; j++) add(j); if (r &gt; Q[i].r) for (int j = r; j &gt; Q[i].r; j--) add(j); now = Q[i].ts, l = Q[i].l, r = Q[i].r; ans[Q[i].id] = tmp; &#125; for (int i = 1; i &lt;= tot; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>莫队</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1103【POI2007】大都市meg]]></title>
    <url>%2FBZOJ1103%E3%80%90POI2007%E3%80%91%E5%A4%A7%E9%83%BD%E5%B8%82meg%20%E6%A0%91%E4%B8%8A%E5%B7%AE%E5%88%86%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[Problem 【POI2007】大都市megDescription 经济全球化浪潮的影响下,习惯于漫步在清晨的乡间小路的邮递员$Blue Mary$也开始骑着摩托车传递邮件了。不过，她经常回忆起以前在乡间漫步的情景。昔日，乡下有依次编号为$1\sim n$的$n$个小村庄，某些村庄之间有一些双向的土路。从每个村庄都恰好有一条路径到达村庄$1$（即比特堡）。并且，对于每个村庄，它到比特堡的路径恰好只经过编号比它的编号小的村庄。另外，对于所有道路而言，它们都不在除村庄以外的其他地点相遇。在这个未开化的地方，从来没有过高架桥和地下铁道。随着时间的推移，越来越多的土路被改造成了公路。至今，$Blue Mary$还清晰地记得最后一条土路被改造为公路的情景。现在，这里已经没有土路了——所有的路都成为了公路，而昔日的村庄已经变成了一个大都市。 $Blue Mary$想起了在改造期间她送信的经历。她从比特堡出发，需要去某个村庄，并且在两次送信经历的间隔期间,有某些土路被改造成了公路.现在$Blue Mary$需要你的帮助：计算出每次送信她需要走过的土路数目。（对于公路，她可以骑摩托车；而对于土路，她就只好推车了。） Input第一行是一个数$n$ ($1\le n\le 250000$)以下$n-1$行，每行两个整数$a,b$($1\le a &lt; b\le n$)，表示原有一条路连接$a$和$b$以下一行，包含一个整数$m$($1\le m\le 250000$)，表示$Blue Mary$曾经在改造期间送过$m$次信。以下$n+m-1$行，每行有两种格式的若干信息，表示按时间先后发生过的$n+m-1$次事件:若这行为 $A a b$ ($1\le a &lt; b\le n$)，表示将$a$到$b$的土路修为公路。若这行为 $W a$, 则表示$Blue Mary$曾经从比特堡送信到村庄$a$。 Output有m行，每行包含一个整数，表示对应的某次送信时经过的土路数目。 Sample Input123456789101112131451 21 31 44 54W 5A 1 4W 5A 4 5W 5W 2A 1 2A 1 3 Sample Output12342101 标签：树上差分+线段树 Solution考虑树上$RMQ$，以$1$号点为根，对于每个$A u v$，即将$v$的子树的权值全部加一，对于每个$W a$，答案即为$a$点的权值。由于只有子树权值操作，我们可以用树上差分。$c[i]$表示$i$和它的父结点的权值差，这样对于每个$A u v$，即为$c[v]++$，对于每个$W a$，即为$sum(a)$可以直接用树状数组维护，这样编程复杂度更低。 Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#define MAX_N 250000using namespace std;int n, m, tr[MAX_N+5], l[MAX_N+5], r[MAX_N+5], ind;vector &lt;int&gt; G[MAX_N+5];void DFS(int u) &#123; l[u] = ++ind; for (int i = 0; i &lt; G[u].size(); i++) DFS(G[u][i]); r[u] = ind;&#125;void inc(int pos) &#123;for (; pos &lt;= n; pos += pos&amp;-pos) tr[pos]++;&#125;void dec(int pos) &#123;for (; pos &lt;= n; pos += pos&amp;-pos) tr[pos]--;&#125;int sum(int pos) &#123;int ret = 0; for (; pos; pos -= pos&amp;-pos) ret += tr[pos]; return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123;int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v);&#125; DFS(1); for (int i = 2; i &lt;= n; i++) inc(l[i]), dec(r[i]+1); scanf("%d", &amp;m); m += n-1; while (m--) &#123; char opt[1]; scanf("%s", opt); if (opt[0] == 'W') &#123; int x; scanf("%d", &amp;x); printf("%d\n", sum(l[x])); &#125; if (opt[0] == 'A') &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); dec(l[v]), inc(r[v]+1); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>差分</tag>
        <tag>树状数组</tag>
        <tag>POI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170918-24总结]]></title>
    <url>%2F20170918-24%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[半停课第二周，羡慕队长和副队ing前半周颓颓颓，本来说是要复习欧拉图的，做了两道LG的水题，就去挑BZOJ水题了…后半周搞了几道有点意思的题。印象深刻的是BZOJ1012降雨量：线段树题，本来很水，但是若干恶心特判，调一下午。久了没考试，周六跟小班考试，T1推DP颓了两个半小时，居然没写出来，最后写了一道玄学题，得了50分。T3暴力打错，尴尬QAQ~~最后发现T2数据有误（就是我写的玄学题），我竟无言以对发现每周一次考试简直不够，现在调题慢好多，水题竟调两小时…下周停课，复习DS，跟小班考试，慢慢找回感觉吧]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3226【SDOI2008】校门外的区间]]></title>
    <url>%2FBZOJ3226%E3%80%90SDOI2008%E3%80%91%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E5%8C%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[Problem 【SDOI2008】校门外的区间 Time Limit: $10 Sec$ Memory Limit: $128 MB$ Description 受校门外的树这道经典问题的启发，$A$君根据基本的离散数学的知识，抽象出$5$种运算维护集合$S$($S$初始为空)并最终输出$S$。现在，请你完成这道校门外的树之难度增强版——校门外的区间。$5$种运算如下： 编号 表示格式 数学表示 $1$ $U$ $T$ $S\cup T$ $2$ $I$ $T$ $S\cap T$ $3$ $D$ $T$ $S-T$ $4$ $C$ $T$ $S+T$ $5$ $S$ $T$ $S\otimes T$ 基本集合运算如下： 运算 结果 $A\cup B$ ${x\in A$ $or$ $x\in B}$ $A\cap B$ ${x\in A$ $\&amp;\&amp;$ $x\in B}$ $A-B$ ${x\in A$ $\&amp;\&amp;$ $x\notin B}$ $A\otimes B$ $(A-B)\cup(B-A)$ Input输入共$M$行。每行的格式为$X$ $T$，用一个空格隔开，$X$表示运算的种类，$T$为一个区间(区间用$(a,b), (a,b], [a,b), [a,b]$表示)。 Output共一行，即集合$S$，每个区间后面带一个空格。若$S$为空则输出$empty$ $set$。 Sample Input12345U [1,5]D [3,3]S [2,4]C (1,5)I (2,3] Sample Output1(2,3) HINT 对于 $100\%$ 的数据，$0\le a\le b\le 65535$，$1\le M\le 70000$ 标签：线段树 Solution假设只有闭区间，对于每个数，标记其为$1$还是$0$。四种运算对应如下（$modify$为区间修改，$reverse$为区间取反）： $U$ $a,b\Rightarrow modify(a, b, 1)$ $D$ $a,b\Rightarrow modify(a, b, 0)$ $S$ $a,b\Rightarrow reverse(a, b)$ $C$ $a,b\Rightarrow modify(0, a-1, 0), modify(b+1, n, 0), reverse(a, b)$ $I$ $a,b\Rightarrow modify(0, a-1, 0), modify(b+1, n, 0)$ 再考虑加入开区间，开区间看作对应$.5$的闭区间。即将$(4, 7)$看作$[4.5, 6.5]$。为了存$.5$的小数，我们将所有区间均乘$2$，即$(4, 7)$变为$[9, 13]$。又考虑到有$0$的区间，因而对于所有区间两端点再加$2$，即$(4,7)$变为$[11, 15]$。最后用线段树维护即可。对于输出，$O(n\log(n))$扫一遍，找出每个数是$1$还是$0$，然后合并区间，双指针跑。本题细节较多，写的时候得小心。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#define n (65536*2+1)using namespace std;struct node &#123;int val, tag, rev;&#125; tr[n*4+500];void build(int v, int s, int t) &#123; tr[v].tag = -1; if (s == t) return; int mid = s+t&gt;&gt;1; build(v&lt;&lt;1, s, mid), build(v&lt;&lt;1|1, mid+1, t);&#125;void downtag(int v, int s, int t) &#123; if (s == t) &#123;if (~tr[v].tag) tr[v].val = tr[v].tag; tr[v].val ^= tr[v].rev, tr[v].tag = -1, tr[v].rev = 0; return;&#125; if (~tr[v].tag) tr[v&lt;&lt;1].tag = tr[v&lt;&lt;1|1].tag = tr[v].tag, tr[v&lt;&lt;1].rev = tr[v&lt;&lt;1|1].rev = 0; tr[v&lt;&lt;1].rev ^= tr[v].rev, tr[v&lt;&lt;1|1].rev ^= tr[v].rev; tr[v].tag = -1, tr[v].rev = 0;&#125;int query(int v, int s, int t, int p) &#123; downtag(v, s, t); if (s == t) return tr[v].val; int mid = s+t&gt;&gt;1; return p &lt;= mid ? query(v&lt;&lt;1, s, mid, p) : query(v&lt;&lt;1|1, mid+1, t, p);&#125;void modify(int v, int s, int t, int l, int r, int x) &#123; if (s &gt; t) return; downtag(v, s, t); if (s &gt;= l &amp;&amp; t &lt;= r) &#123;tr[v].tag = x; return;&#125; int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify(v&lt;&lt;1, s, mid, l, r, x); if (r &gt;= mid+1) modify(v&lt;&lt;1|1, mid+1, t, l, r, x);&#125;void reverse(int v, int s, int t, int l, int r) &#123; if (s &gt; t) return; downtag(v, s, t); if (s &gt;= l &amp;&amp; t &lt;= r) &#123;tr[v].rev ^= 1; return;&#125; int mid = s+t&gt;&gt;1; if (l &lt;= mid) reverse(v&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) reverse(v&lt;&lt;1|1, mid+1, t, l, r);&#125;int main() &#123; char opt, lbr, rbr; int l, r; build(1, 1, n); while (~scanf("%c %c%d,%d%c\n", &amp;opt, &amp;lbr, &amp;l, &amp;r, &amp;rbr)) &#123; l &lt;&lt;= 1, r &lt;&lt;= 1, l = l+(lbr == '(')+2, r = r-(rbr == ')')+2; if (opt == 'U') modify(1, 1, n, l, r, 1); if (opt == 'I') modify(1, 1, n, 1, l-1, 0), modify(1, 1, n, r+1, n, 0); if (opt == 'D') modify(1, 1, n, l, r, 0); if (opt == 'C') modify(1, 1, n, 1, l-1, 0), modify(1, 1, n, r+1, n, 0), reverse(1, 1, n, l, r); if (opt == 'S') reverse(1, 1, n, l, r); &#125; int st = -1, en = -1; bool flag = false; for (int i = 1; i &lt;= n; i++) &#123; if (query(1, 1, n, i)) &#123; if (st == -1) st = i; en = i; &#125; else &#123; if (~st) &#123; if (flag) printf(" "); else flag = true; printf("%c", (st%2 == 1) ? '(' : '['); printf("%d,%d", st/2-1, (en+1)/2-1); printf("%c", (en%2 == 1) ? ')' : ']'); &#125; st = en = -1; &#125; &#125; if (!flag) printf("empty set"); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1934【SHOI2007】善意的投票]]></title>
    <url>%2FBZOJ1934%E3%80%90SHOI2007%E3%80%91%E5%96%84%E6%84%8F%E7%9A%84%E6%8A%95%E7%A5%A8%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 善意的投票 题目描述幼儿园里有n个小朋友打算通过投票来决定睡不睡午觉。对他们来说，这个问题并不是很重要，于是他们决定发扬谦让精神。虽然每个人都有自己的主见，但是为了照顾一下自己朋友的想法，他们也可以投和自己本来意愿相反的票。我们定义一次投票的冲突数为好朋友之间发生冲突的总数加上和所有和自己本来意愿发生冲突的人数。我们的问题就是，每位小朋友应该怎样投票，才能使冲突数最小？ 输入输出格式输入格式：文件的第一行只有两个整数n，m，保证有2 ≤n ≤300，1 ≤m ≤n(n-1)/2。其中n代表总人数，m代表好朋友的对数。文件第二行有n个整数，第i个整数代表第i个小朋友的意愿，当它为1时表示同意睡觉，当它为0时表示反对睡觉。接下来文件还有m行，每行有两个整数i，j。表示i，j是一对好朋友，我们保证任何两对i，j不会重复。输出格式：只需要输出一个整数，即可能的最小冲突数。 输入输出样例输入样例：123453 31 0 01 21 33 2 输出样例：11 说明2≤n≤300，1≤m≤n(n-1)/2。 标签：网络流，最小割 Solution最小割建图如下：如果本人意见为0，则与源点相连，反之与汇点相连。对于每对朋友关系，互相连边。所有边的容量均为1，跑最大流最小割即可。 原理：对于每个人，如果有朋友与他意见不合，则他要么割自己到源点（汇点）的一条边，要么割与朋友的边，代价等于容量。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 300#define MAX_M MAX_N*(MAX_N-1)*2 #define INF 2147483647using namespace std;int n, m, s, t;int d[MAX_N+5], first[MAX_N+5], cnt;struct node &#123;int v, c, next;&#125; E[MAX_M+5];void Init() &#123; cnt = 0; memset(first, -1, sizeof(first));&#125;void Insert(int u, int v, int c) &#123; E[cnt].v = v, E[cnt].c = c; E[cnt].next = first[u]; first[u] = cnt++;&#125;void AddEdge(int u, int v, int c) &#123; Insert(u, v, c); Insert(v, u, 0);&#125;bool BFS() &#123; memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); for (int i = first[u]; i != -1; i = E[i].next) &#123; int v = E[i].v; if (E[i].c &amp;&amp; d[v] == -1) &#123; d[v] = d[u]+1; que.push(v); &#125; &#125; que.pop(); &#125; return (d[t] != -1);&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = first[u]; i != -1; i = E[i].next) &#123; int v = E[i].v; if (E[i].c &amp;&amp; d[v] == d[u]+1) &#123; int tmp = DFS(v, min(flow, E[i].c)); if (!tmp) continue; flow -= tmp, E[i].c -= tmp; ret += tmp, E[i^1].c += tmp; if (!flow) break; &#125; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123; int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;int main() &#123; Init(); scanf("%d%d", &amp;n, &amp;m); s = 0, t = n+1; for (int i = 1; i &lt;= n; i++) &#123; int f; scanf("%d", &amp;f); if (f == 1) &#123; AddEdge(s, i, 1); &#125; else &#123; AddEdge(i, t, 1); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); AddEdge(u, v, 1); AddEdge(v, u, 1); &#125; printf("%d", Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3144【HZNOI2013】切糕]]></title>
    <url>%2FBZOJ3144%E3%80%90HZNOI2013%E3%80%91%E5%88%87%E7%B3%95%20%E6%9C%80%E5%B0%8F%E5%89%B2%2F</url>
    <content type="text"><![CDATA[Problem 切糕 Description经历千辛万苦小$A$得到了一块切糕，切糕的形状是长方体，小$A$打算拦腰将切糕切成两半分给小$B$。出于美观考虑，小$A$希望切面能尽量光滑且和谐。于是她找到你，希望你能帮她找出最好的切割方案。出于简便考虑，我们将切糕视作一个长$P$，宽$Q$，高$R$的长方体点阵。我们将位于第$z$层中第$x$行，第$y$列上的点称为$(x,y,z)$，它有一个非负的不和谐值$v(x,y,z)$。一个合法的切面满足以下两个条件： 与每个纵轴有且仅有一个交点。即切面是一个函数$f(x,y)$，对于所有$1≤x≤P$，$1≤y≤Q$，我们需指定一个切割点$f(x,y)$，且 $1≤f(x,y)≤R$。 切面需要一定的光滑性要求，即相邻纵轴上的切割点不能相距太远。对于所有 $1\le x,x’\le P$ 和 $1\le y,y’\le Q$，若 $|x-x’|+|y-y’|=1$，则 $|f(x,y)-f(x’,y’)|\le D$, 其中$D$是给定的一个非负整数。 能有许多切面满足上面的条件，小$A$希望找出总的切割点上的不和谐值最小的那个，即$\sum_{x=1}^{P}\sum_{y=1}^{Q} v(x,y,f(x,y))$最小。 Input第一行是三个正整数$P,Q,R$，表示切糕的长$P$、 宽$Q$、高$R$。第二行有一个非负整数$D$，表示光滑性要求。接下来是$R$个$P$行$Q$列的矩阵，第$z$个矩阵的第$x$行第$y$列是$v(x,y,z) (1\le x\le P, 1\le y\le Q, 1\le z\le R)$。$100\%$的数据满足$P,Q,R\le 40$，$0\le D\le R$，且给出的所有的不和谐值不超过$1000$。Output仅包含一个整数，表示在合法基础上最小的总不和谐值。 Sample Input1234562 2 2 1 6 16 12 62 6 Sample Output16 Hint最佳切面的f为f(1,1)=f(2,1)=2,f(1,2)=f(2,2)=1 标签：网络流，最小割 Solution建模神题。建图：建$r+1$层，每层$p\times q$的图，相邻两竖边建模如下 (图片转载自Zarxdy34)这样如果割掉红边，右边割的边必须在绿边下面才能有流。所以割的边就限制在绿边上面了。因此这样一来，下界就满足了。对于上界，右边的几个点反过来同种方式建边（图中只画了左侧的边） Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_A 40#define MAX_N 70000#define MAX_M 300000#define INF 2147483647using namespace std;int s, t, id[MAX_A+5][MAX_A+5][MAX_A+5];int move[2][4] = &#123;&#123;0, 1, 0, -1&#125;, &#123;1, 0, -1, 0&#125;&#125;;struct Edge &#123;int v, c, nxt;&#125; E[MAX_M+5];int pre[MAX_N+5], d[MAX_N+5], cnt, num;queue &lt;int&gt; que;void init() &#123;cnt = num = 0; memset(pre, -1, sizeof(pre));&#125;void insert(int u, int v, int c) &#123; E[cnt].v = v, E[cnt].c = c; E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0; E[cnt].nxt = pre[v], pre[v] = cnt++;&#125;bool BFS() &#123; memset(d, -1, sizeof(d)); while (!que.empty()) que.pop(); d[s] = 0, que.push(s); while (!que.empty()) &#123; int u = que.front(); for (int i = pre[u]; i != -1; i = E[i].nxt) if (E[i].c &amp;&amp; d[E[i].v] == -1) d[E[i].v] = d[u]+1, que.push(E[i].v); que.pop(); &#125; return d[t] != -1;&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pre[u]; i != -1; i = E[i].nxt) &#123; int v = E[i].v; if (E[i].c &amp;&amp; d[u]+1 == d[v]) &#123; int tmp = DFS(v, min(flow, E[i].c)); E[i].c -= tmp, E[i^1].c += tmp; flow -= tmp, ret += tmp; if (!flow) break; &#125; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123; int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;int main() &#123; init(); int a, b, h, d; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;h, &amp;d); for (int i = 1; i &lt;= h+1; i++) for (int j = 1; j &lt;= a; j++) for (int k = 1; k &lt;= b; k++) id[i][j][k] = ++num; s = 0, t = ++num; for (int j = 1; j &lt;= a; j++) for (int k = 1; k &lt;= b; k++) insert(s, id[1][j][k], INF), insert(id[h+1][j][k], t, INF); for (int i = 1; i &lt;= h; i++) for (int j = 1; j &lt;= a; j++) for (int k = 1; k &lt;= b; k++) &#123; int c; scanf("%d", &amp;c); insert(id[i][j][k], id[i+1][j][k], c); &#125; for (int i = d+1; i &lt;= h+1; i++) for (int j = 1; j &lt;= a; j++) for (int k = 1; k &lt;= b; k++) &#123; int x, y; for (int l = 0; l &lt; 4; l++) if (id[i][x = j+move[0][l]][y = k+move[1][l]]) insert(id[i][j][k], id[i-d][x][y], INF); &#125; printf("%d", Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1015【JSOI2008】星球大战]]></title>
    <url>%2FBZOJ1015%E3%80%90JSOI2008%E3%80%91%E6%98%9F%E7%90%83%E5%A4%A7%E6%88%98%20%E7%A6%BB%E7%BA%BF%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Problem 【JSOI2008】星球大战 题目描述很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治者整个星系。某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通快的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。 输入输出格式输入格式：输入文件第一行包含两个整数，$N (1\le N\le 2\times M)$ 和$M (1\le M\le 2\times 10^5)$，分别表示星球的数目和以太隧道的数目。星球用$0\sim N-1$的整数编号。接下来的$M$行，每行包括两个整数$X, Y$，其中（$0\le X,Y&lt;N$且$X\ne Y$），表示星球$X$和星球$Y$之间有以太隧道。注意所有的以太隧道都是双向的。接下来一行是一个整数$K$，表示帝国计划打击的星球个数。接下来的$K$行每行一个整数$X$，满足$0\le X&lt;N$，表示帝国计划打击的星球编号。帝国总是按输入的顺序依次摧毁星球的。输出格式：输出文件的第一行是开始时星球的连通块个数。接下来的$K$行，每行一个整数，表示经过该次打击后现存星球的连通块个数。 输入输出样例输入样例：12345678910111213141516171819208 130 11 66 55 00 61 22 33 44 57 17 27 63 6516357 输出样例：123456111233 标签：离线并查集 Solution并查集水题。因为只会删边，不会增边，因此我们从最后时刻往前面模拟，每次加边（从最后一条边往前加），加边后输出联通块个数即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#define MAX_N 400000#define MAX_M 200000using namespace std;int n, m, k, cnt;int f[MAX_N+5], mark[MAX_N+5], opt[MAX_N+5];vector &lt;int&gt; edge[MAX_N+5];stack &lt;int&gt; ans;int find(int v) &#123; if (f[v] == v) return v; return f[v] = find(f[v]);&#125;void merge(int v) &#123; if (mark[v]) cnt++; for (int i = 0; i &lt; edge[v].size(); i++) &#123; int u = edge[v][i]; if (mark[u]) continue; int anc1 = find(v); int anc2 = find(u); if (anc1 != anc2) cnt--, f[anc1] = anc2; &#125; mark[v] = 0;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; m; i++) &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); edge[x].push_back(y); edge[y].push_back(x); &#125; for (int i = 0; i &lt; n; i++) f[i] = i; scanf("%d", &amp;k); for (int i = 1; i &lt;= k; i++) &#123; scanf("%d", &amp;opt[i]); mark[opt[i]] = 1; &#125; cnt = n-k; for (int i = 0; i &lt; n; i++) if (!mark[i]) merge(i); ans.push(cnt); for (int i = k; i &gt;= 1; i--) &#123; merge(opt[i]); ans.push(cnt); &#125; while (!ans.empty()) &#123; printf("%d\n", ans.top()); ans.pop(); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数据结构</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1189【HNOI2007】紧急疏散evacuate]]></title>
    <url>%2FBZOJ1189%E3%80%90HNOI2007%E3%80%91%E7%B4%A7%E6%80%A5%E7%96%8F%E6%95%A3evacuate%20%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88%2B%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 【HNOI2007】紧急疏散evacuate Time Limit: $10 Sec$ Memory Limit: $128 MB$ Description发生了火警，所有人员需要紧急疏散！假设每个房间是一个$N\times M$的矩形区域。每个格子如果是’$.$’，那么表示这是一块空地；如果是’$X$’，那么表示这是一面墙，如果是’$D$’，那么表示这是一扇门，人们可以从这儿撤出房间。已知门一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散的时候，每一秒钟每个人都可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上就没有人数限制了（也就是说每块空地可以同时站无数个人）。但是，由于门很窄，每一秒钟只能有一个人移动到门的位置，一旦移动到门的位置，就表示他已经安全撤离了。现在的问题是：如果希望所有的人安全撤离，最短需要多少时间？或者告知根本不可能。 Input输入文件第一行是由空格隔开的一对正整数$N$与$M$，$3\le N\le 20$，$3\le M\le 20$，以下$N$行$M$列描述一个$N\times M$的矩阵。其中的元素可为字符’$.$’, ‘$X$’和’$D$’，且字符间无空格。 Output只有一个整数K，表示让所有人安全撤离的最短时间，如果不可能撤离，那么输出’$impossible$’（不包括引号）。 Sample Input1234565 5XXXXXX...DXX.XXX..XXXXDXX Sample Output13 HINT 2015.1.12新加数据一组，鸣谢1756500824*$C++$语言请用$scanf(“\%s”,s)$读入！ 标签：二分答案+网络流 SOlution这题真坑逼，调了两小时。坑点已用红色加粗。 首先我们可以很容易地想到需要以每个门为起点$BFS$，记录每个点到每个门的距离是多少。然后二分答案，对于当前答案$tans$，建图如下：从源点向每个有人的点连容量为$1$的边，从每个门向汇点连容量为$tans$的边。然后对于每个人，枚举每个门，如果这个人到某个门的距离小于等于$tans$，那么这个人一定会在$tans$时限内到达这个门前，所以我们从这个人向这个门连一条容量为$1$的边。跑一遍最大流，如果流量等于人数，则可行。写出来就是这样：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_N 500#define MAX_M 400000#define INF 2147483647using namespace std;int n, m, s, t, id[20][20], ind, tot, num, pre[MAX_N+5], cnt; char map[20][20];vector &lt;int&gt; G[MAX_N+5], exi; int dis[MAX_N+5][MAX_N+5]; bool vis[MAX_N+5];int nxt[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;struct node &#123;int v, c, nxt;&#125; E[MAX_M+5];void init() &#123;cnt = 0; s = 0, t = n*m+1; memset(pre, -1, sizeof(pre));&#125;void insert(int u, int v, int c) &#123; E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0, E[cnt].nxt = pre[v], pre[v] = cnt++;&#125;char gc(int x) &#123;return map[(x-1)/m][(x-1)%m];&#125;void BFS(int beg, int k) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n*m; i++) dis[i][k] = INF; queue &lt;int&gt; que; dis[beg][k] = 0, que.push(beg), vis[beg] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (vis[v] || gc(v) != '.') continue; dis[v][k] = dis[u][k]+1, que.push(v), vis[v] = true; &#125; &#125;&#125;int d[MAX_N+5];bool BFS() &#123; memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v; if (~d[v] || !E[i].c) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (d[v] != d[u]+1 || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp, flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;bool check(int tans) &#123; init(); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') insert(s, id[i][j], 1); for (int k = 0; k &lt; exi.size(); k++) insert(exi[k], t, tans); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') for (int k = 0; k &lt; exi.size(); k++) if (dis[id[i][j]][k] &lt;= tans) insert(id[i][j], exi[k], 1); int ret = 0; while (BFS()) ret += DFS(s, INF); return ret == num;&#125;int bi_search(int l, int r) &#123; int ret; while (l &lt;= r) &#123; int mid = l+r&gt;&gt;1; if (check(mid)) ret = mid, r = mid-1; else l = mid+1; &#125; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) id[i][j] = ++ind; for (int i = 0; i &lt; n; i++) scanf("%s", map[i]); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) for (int k = 0; k &lt; 4; k++) &#123; int x = i+nxt[k][0], y = j+nxt[k][1]; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || map[i][j] == 'X' || map[x][y] == 'X') continue; G[id[i][j]].push_back(id[x][y]); &#125; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') num++; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == 'D') exi.push_back(id[i][j]); for (int i = 0; i &lt; exi.size(); i++) BFS(exi[i], i); int ans = bi_search(0, m*n); if (ans &lt; m*n) printf("%d", ans); else printf("impossible"); return 0;&#125; 然而$WA$掉了。原因很简单：某位神犇出了一组数据： 4 5XXDXX X . XX . . . XXXDXX ns=3 然而用刚刚的方法做答案是$2$。这是因为$(3, 2)$和$(3, 4)$都在$2$时刻到达$(4, 3)$的门前，两个人分别过需要多一秒钟。$QAQ$~这里我们需要另一种建模方式：首先源点向所有人连容量为$1$的边，然后把每个门拆成$tans$个点，如果某人到某门的时间为$t$，则从这个人向这个人的第$t$到$tans$个点都连容量为$1$的边。最后把每个门的$tans$个点向汇点连容量为$1$的边即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;queue&gt;#define MAX_N 50000#define MAX_M 1000000#define INF 2147483647using namespace std;int n, m, s, t, id[20][20], ind, tot, num, pre[MAX_N+5], cnt; char map[20][20];vector &lt;int&gt; G[MAX_N+5], exi; int dis[MAX_N+5][500]; bool vis[MAX_N+5];int nxt[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;;struct node &#123;int v, c, nxt;&#125; E[MAX_M+5];void init() &#123;cnt = 0; s = 0, t = MAX_N; memset(pre, -1, sizeof(pre));&#125;void insert(int u, int v, int c) &#123; E[cnt].v = v, E[cnt].c = c, E[cnt].nxt = pre[u], pre[u] = cnt++; E[cnt].v = u, E[cnt].c = 0, E[cnt].nxt = pre[v], pre[v] = cnt++;&#125;char gc(int x) &#123;return map[(x-1)/m][(x-1)%m];&#125;void BFS(int beg, int k) &#123; memset(vis, false, sizeof(vis)); for (int i = 1; i &lt;= n*m; i++) dis[i][k] = INF; queue &lt;int&gt; que; dis[beg][k] = 0, que.push(beg), vis[beg] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (vis[v] || gc(v) != '.') continue; dis[v][k] = dis[u][k]+1, que.push(v), vis[v] = true; &#125; &#125;&#125;int d[MAX_N+5];bool BFS() &#123; memset(d, -1, sizeof(d)); queue &lt;int&gt; que; que.push(s), d[s] = 0; while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v; if (~d[v] || !E[i].c) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return ~d[t];&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int i = pre[u]; ~i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (d[v] != d[u]+1 || !c) continue; int tmp = DFS(v, min(flow, c)); E[i].c -= tmp, E[i^1].c += tmp, flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;bool check(int tans) &#123; init(); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') insert(s, id[i][j], 1); for (int k = 0; k &lt; exi.size(); k++) for (int l = 1; l &lt;= tans; l++) insert(n*m+l*exi.size()+k, t, 1); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') for (int k = 0; k &lt; exi.size(); k++) if (dis[id[i][j]][k] &lt;= tans) for (int l = dis[id[i][j]][k]; l &lt;= tans; l++) insert(id[i][j], n*m+l*exi.size()+k, 1); int ret = 0; while (BFS()) ret += DFS(s, INF); return ret == num;&#125;int bi_search(int l, int r) &#123; int ret; while (l &lt;= r) &#123; int mid = l+r&gt;&gt;1; if (check(mid)) ret = mid, r = mid-1; else l = mid+1; &#125; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) id[i][j] = ++ind; for (int i = 0; i &lt; n; i++) scanf("%s", map[i]); for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) for (int k = 0; k &lt; 4; k++) &#123; int x = i+nxt[k][0], y = j+nxt[k][1]; if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || map[i][j] == 'X' || map[x][y] == 'X') continue; G[id[i][j]].push_back(id[x][y]); &#125; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == '.') num++; for (int i = 0; i &lt; n; i++) for (int j = 0; j &lt; m; j++) if (map[i][j] == 'D') exi.push_back(id[i][j]); for (int i = 0; i &lt; exi.size(); i++) BFS(exi[i], i); int ans = bi_search(0, m*n); if (ans &lt; m*n) printf("%d", ans); else printf("impossible"); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1008【HNOI2008】越狱]]></title>
    <url>%2FBZOJ1008%E3%80%90HNOI2008%E3%80%91%E8%B6%8A%E7%8B%B1%20%E8%A1%A5%E9%9B%86%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[Problem 【HNOI2008】越狱 &lt;补集转换&gt; Time Limit: $1 Sec$ Memory Limit: $162 MB$ Description监狱有连续编号为$1\sim N$的$N$个房间，每个房间关押一个犯人，有$M$种宗教，每个犯人可能信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。 Input输入两个整数$M$，$N$ 。 Output可能越狱的状态数，答案模$100003$ 。 Sample Input12 3 Sample Output16 HINT$6$种状态为$(000),(001),(011),(100),(110),(111)$$1\le M\le 10^8,1\le N\le10^{12}$ 标签：补集转换 Solution考虑到补集转换，这道题就是一水题。总共有$M^N$种方案，其中不能发生越狱的有$M*(M-1)^{N-1}$种方案，快速幂求出，相减即可。注意处理负数。 Code123456789101112131415#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MOD 100003using namespace std;typedef long long lnt;lnt PowerMod(lnt a, lnt b) &#123; if (b == 1) return a%MOD; lnt ret = PowerMod(a, b/2); return b&amp;1 ? a%MOD*ret%MOD*ret%MOD : ret*ret%MOD;&#125;int main() &#123; lnt m, n; scanf("%lld%lld", &amp;m, &amp;n); printf("%lld", ((PowerMod(m, n)-m%MOD*PowerMod(m-1, n-1))%MOD+MOD)%MOD); return 0;&#125;]]></content>
      <tags>
        <tag>组合数学</tag>
        <tag>补集转换</tag>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>数论数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1066【SCOI2007】蜥蜴]]></title>
    <url>%2FBZOJ1066%E3%80%90SCOI2007%E3%80%91%E8%9C%A5%E8%9C%B4%20%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[Problem 【SCOI2007】蜥蜴 Description在一个$r$行$c$列的网格地图中有一些高度不同的石柱，一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。 每行每列中相邻石柱的距离为$1$，蜥蜴的跳跃距离是$d$，即蜥蜴可以跳到平面距离不超过$d$的任何一个石柱上。石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减$1$（如果仍然落在地图内部，则到达的石柱高度不变），如果该石柱原来高度为$1$，则蜥蜴离开后消失。以后其他蜥蜴不能落脚。任何时刻不能有两只蜥蜴在同一个石柱上。 Input输入第一行为三个整数$r$，$c$，$d$，即地图的规模与最大跳跃距离。以下$r$行为石竹的初始状态，$0$表示没有石柱，$1\sim 3$表示石柱的初始高度。以下$r$行为蜥蜴位置，“$L$”表示蜥蜴，“$.$”表示没有蜥蜴。 Output输出仅一行，包含一个整数，即无法逃离的蜥蜴总数的最小值。 Sample Input12345678910115 8 20000000002000000003211000200000000000000..................LLLL.................. Sample Output11 HINT $100\%$的数据满足：$1\le r, c\le 20$, $1\le d\le 4$ 标签：网络流 Solution简单的拆点建模题。从源点向每个有蜥蜴的点连容量为$1$的边，从每个能跳出去的点向汇点连容量为$\infty$的边。对于石笋高度，把每个点拆成两个点，它们间的边容量为石笋高度，若位置$(i, j)$可跳到$(p, q)$，则从$(i, j)$的第二个点向$(p, q)$的第一个点连容量为$\infty$的边。最后跑最大流即可。点数少，都懒得用边表了，直接用邻接矩阵 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 20#define INF 2147483647using namespace std;int n, m, r, s, t, cnt, tot, id[MAX_N+5][MAX_N+5], map[MAX_N*MAX_N*2+5][MAX_N*MAX_N*2+5];char a[MAX_N+5][MAX_N+5], b[MAX_N+5][MAX_N+5];void build(int x, int y) &#123; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) if ((i != x || j != y) &amp;&amp; (a[i][j] != '0') &amp;&amp; r*r &gt;= (x-i)*(x-i)+(y-j)*(y-j)) map[id[x][y]+1][id[i][j]] = INF;&#125;int d[MAX_N*MAX_N*2+5];bool BFS() &#123; queue &lt;int&gt; que; memset(d, -1, sizeof(d)); d[s] = 0, que.push(s); while (!que.empty()) &#123; int u = que.front(); que.pop(); for (int v = 0; v &lt;= cnt; v++) &#123; if (d[v] != -1 || !map[u][v]) continue; d[v] = d[u]+1, que.push(v); &#125; &#125; return d[t] != -1;&#125;int DFS(int u, int flow) &#123; if (u == t) return flow; int ret = 0; for (int v = 0; v &lt;= cnt; v++) &#123; if (d[v] != d[u]+1 || !map[u][v]) continue; int tmp = DFS(v, min(flow, map[u][v])); map[u][v] -= tmp, map[v][u] += tmp, flow -= tmp, ret += tmp; if (!flow) break; &#125; if (!ret) d[u] = -1; return ret;&#125;int Dinic() &#123; int ret = 0; while (BFS()) ret += DFS(s, INF); return ret;&#125;int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;r); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", a[i]+1); for (int j = 1; j &lt;= m; j++) &#123; if (a[i][j] == '0') continue; id[i][j] = cnt+1, map[cnt+1][cnt+2] = a[i][j]-'0', cnt += 2; &#125; &#125; s = 0, t = ++cnt; for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", b[i]+1); for (int j = 1; j &lt;= m; j++) &#123; if (b[i][j] == 'L') tot++, map[s][id[i][j]] = 1; if (i-r &lt; 1 || i+r &gt; n || j-r &lt; 1 || j+r &gt; m) map[id[i][j]+1][t] = INF; if (a[i][j] != '0') build(i, j); &#125; &#125; printf("%d", tot-Dinic()); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU4348 To The Moon]]></title>
    <url>%2FHDU4348%20To%20The%20Moon%20%E5%B8%A6%E4%BF%AE%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem【HDU4348】To The MoonTime Limit: $4000/2000 MS (Java/Others)$Memory Limit: $65536/65536 K (Java/Others)$ DescriptionTo The Moon is a independent game released in November 2011, it is a role-playing adventure game powered by RPG Maker.The premise of To The Moon is based around a technology that allows us to permanently reconstruct the memory on dying man. In this problem, we’ll give you a chance, to implement the logic behind the scene.You‘ve been given $N$ integers $A[1], A[2],…, A[N]$. On these integers, you need to implement the following operations: $C$ $l$ $r$ $d$: Adding a constant d for every ${A_i | l \le i \le r}$, and increase the time stamp by $1$, this is the only operation that will cause the time stamp increase. $Q$ $l$ $r$: Querying the current sum of ${A_i | l \le i \le r}$. $H$ $l$ $r$ $t$: Querying a history sum of ${A_i | l \le i \le r}$ in time $t$. $B$ $t$: Back to time $t$. And once you decide return to a past, you can never be access to a forward edition anymore. $N, M \le 10^5$, $|A[i]|\le 10^9$, $1\le l\le r\le N$, $|d|\le 10^4$. The system start from time $0$, and the first modification is in time $1$, $t\ge 0$, and won’t introduce you to a future state. Input123n mA1 A2 ... An... (here following the m operations. ) Output1... (for each query, simply print the result. ) Sample Input1234567891011121310 51 2 3 4 5 6 7 8 9 10Q 4 4Q 1 10Q 2 4C 3 6 3Q 2 42 40 0C 1 1 1C 2 2 -1Q 1 2H 1 2 1 Sample Output12345645591501 标签：带修主席树 Translation题目大意：维护一个数据结构，使得其可有四种操作：区间修改，区间求和，某时间的区间和，返回某时间。 Solution很明显这是一道主席树的板子题。不过此题要带区间修改。普通区间修改需要加$tag$，并不断下传。而对于主席树，下传意味着新建节点，可能会$MLE$。所以这里我们暴力一点，直接标记永久化，这样写起来简洁，而且省空间。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 100000using namespace std;struct node &#123;int ls, rs; long long val, tag;&#125; tr[MAX_N*50+5];int n, m;int cnt, now, root[MAX_N+5];void updata(int v, int s, int t) &#123;tr[v].val = tr[tr[v].ls].val+tr[tr[v].rs].val+(long long)(t-s+1)*tr[v].tag;&#125;void build(int v, int s, int t) &#123; tr[v].ls = tr[v].rs = tr[v].tag = tr[v].val = 0; if (s == t) &#123; scanf("%I64d", &amp;tr[v].val); return; &#125; tr[v].ls = ++cnt, tr[v].rs = ++cnt; int mid = s+t&gt;&gt;1; build(tr[v].ls, s, mid); build(tr[v].rs, mid+1, t); updata(v, s, t);&#125;void modify(int v, int o, int s, int t, int l, int r, long long x) &#123; tr[v] = tr[o]; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; tr[v].tag += x; tr[v].val += (long long)(t-s+1)*x; return; &#125; int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, l, r, x); if (r &gt;= mid+1) modify(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, l, r, x); updata(v, s, t);&#125;long long query(int v, int s, int t, int l, int r, long long tot) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v].val+(long long)(t-s+1)*tot; tot += tr[v].tag; int mid = s+t&gt;&gt;1; long long ret = 0; if (l &lt;= mid) ret += query(tr[v].ls, s, mid, l, r, tot); if (r &gt;= mid+1) ret += query(tr[v].rs, mid+1, t, l, r, tot); return ret;&#125;int main() &#123; while(scanf("%d%d", &amp;n, &amp;m) != EOF) &#123; cnt = now = 0; root[now] = ++cnt; build(root[now], 1, n); while (m--) &#123; char ch; cin &gt;&gt; ch; if (ch == 'C') &#123; int l, r; long long d; scanf("%d%d%I64d", &amp;l, &amp;r, &amp;d); now++; root[now] = ++cnt; modify(root[now], root[now-1], 1, n, l, r, d); &#125; if (ch == 'Q') &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%I64d\n", query(root[now], 1, n, l, r, 0LL)); &#125; if (ch == 'H') &#123; int l, r, t; scanf("%d%d%d", &amp;l, &amp;r, &amp;t); printf("%I64d\n", query(root[t], 1, n, l, r, 0LL)); &#125; if (ch == 'B') &#123; int t; scanf("%d", &amp;t); now = t; &#125; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>主席树</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LG1073【NOIp2009】最优贸易]]></title>
    <url>%2FLG1073%E3%80%90NOIp2009%E3%80%91%E6%9C%80%E4%BC%98%E8%B4%B8%E6%98%93%20Tarjan%2BDP%2F</url>
    <content type="text"><![CDATA[PRoblem最优贸易题目描述$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。 输入输出格式输入格式：第一行包含 $2$ 个正整数 $n$ 和 $m$，中间用一个空格隔开，分别表示城市的数目和道路的数目。第二行 $n$ 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 $n$ 个城市的商品价格。接下来 $m$ 行，每行有 $3$ 个正整数，$x$，$y$，$z$，每两个整数之间用一个空格隔开。如果 $z=1$，表示这条道路是城市 $x$ 到城市 $y$ 之间的单向道路；如果 $z=2$，表示这条道路为城市 $x$ 和城市 $y$ 之间的双向道路。输出格式：输出文件 $trade.out$ 共 $1$ 行，包含 $1$ 个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 $0$。 输入输出样例输入样例$#1$：12345675 5 4 3 5 6 1 1 2 1 1 4 1 2 3 2 3 5 1 4 5 2 输出样例$#1$：15 说明数据范围输入数据保证 $1$ 号城市可以到达 $n$ 号城市。对于 $10\%$的数据，$1\le n\le 6$。对于 $30\%$的数据，$1\le n\le 100$。对于 $50\%$的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。对于 $100\%$的数据，$1\le n\le 10^5$，$1\le m\le 5\times 10^5$，$1\le x,y\le n$，$1\le z\le 2$，$1\le 各城市水晶球价格\le 100$。$NOIp\;2009$ 提高组 第三题 标签：$Tarjan$, $DP$ Solution吐槽一下，这人的旅费远大于他赚的差价作为中间商，真是个无脑商人… 首先肯定要缩点，记录每个分量的所有点中价格的最大值和最小值，缩点后$DP$的时候就是$DAG$了，不会有环。接下来是$BFS$同时$DP$。$f[i]$表示从源点走到$i$点，最大差价是多少。初值为$f[i] = max[i]-min[i]$。从源点所在点开始$BFS$，从$u$走到一个点$v$，先更新$min[v]$的值，即$min[v] = min(min[u], min[v])$。然后更新$f[v] = max(max(f[u], f[v]), max[v]-min[v])$，分别指最大价格在从源点到$u$的路径上和最大价格在$v$这个分量里。最后输出终点所在分量的$f$值即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define MAX_N 100000#define INF 2147483647using namespace std;int n, m, c[MAX_N+5], mm[MAX_N+5], mx[MAX_N+5], f[MAX_N+5];int dfn[MAX_N+5], low[MAX_N+5], id[MAX_N+5], ind, cnt;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];stack &lt;int&gt; sta; bool insta[MAX_N+5];void tarjan(int u) &#123; dfn[u] = low[u] = ++ind, sta.push(u), insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (insta[v]) low[u] = min(low[u], dfn[v]); &#125; if (low[u] == dfn[u]) &#123; cnt++, mm[cnt] = INF, mx[cnt] = 0; for (int i = sta.top(); ; i = sta.top()) &#123; id[i] = cnt, mm[cnt] = min(mm[cnt], c[i]), mx[cnt] = max(mx[cnt], c[i]); sta.pop(), insta[i] = false; if (i == u) break; &#125; &#125;&#125;queue &lt;int&gt; que; bool inque[MAX_N+5];void BFS() &#123; for (int i = 1; i &lt;= cnt; i++) f[i] = mx[i]-mm[i]; que.push(id[1]), inque[id[1]] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(), inque[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i]; mm[v] = min(mm[v], mm[u]); f[v] = max(max(f[u], f[v]), mx[v]-mm[v]); if (!inque[v]) que.push(v), inque[v] = true; &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); while (m--) &#123; int u, v, d; scanf("%d%d%d", &amp;u, &amp;v, &amp;d); if (d == 1) G[u].push_back(v); else G[u].push_back(v), G[v].push_back(u); &#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i); for (int u = 1; u &lt;= n; u++) for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (id[u] == id[v]) continue; E[id[u]].push_back(id[v]); &#125; BFS(); printf("%d", f[id[n]]); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>NOIp</tag>
        <tag>LG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1182 【NOI2001】 食物链]]></title>
    <url>%2FPOJ1182%20%E3%80%90NOI2001%E3%80%91%20%E9%A3%9F%E7%89%A9%E9%93%BE%20%E7%A7%8D%E7%B1%BB%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Problem食物链Description动物王国中有三类动物$A,B,C$，这三类动物的食物链构成了有趣的环形。$A$吃$B$，$B$吃$C$，$C$吃$A$。有$N$个动物，以$1\sim N$编号。每个动物都是$A,B,C$中的一种，但是我们并不知道它到底是哪一种。人用两种说法对这$N$个动物所构成的食物链关系进行描述：一种说法是$1\;X\;Y$，表示$X$和$Y$是同类。二种说法是$2\;X\;Y$，表示$X$吃$Y$。人对$N$个动物，用上述两种说法，一句接一句地说出$K$句话，这$K$句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。 当前的话与前面的某些真的话冲突，就是假话； 当前的话中$X$或$Y$比$N$大，就是假话； 当前的话表示$X$吃$X$，就是假话。 你的任务是根据给定的$N（1 \le N \le 50000）$和$K$句话$（0 \le K \le 100000）$，输出假话的总数。 Input第一行是两个整数$N$和$K$，以一个空格分隔。以下$K$行每行是三个正整数 $D$，$X$，$Y$，两数之间用一个空格隔开，其中$D$表示说法的种类。若$D=1$，则表示$X$和$Y$是同类。若$D=2$，则表示$X$吃$Y$。 Output只有一个整数，表示假话的数目。 Sample Input12345678100 71 101 1 2 1 22 2 3 2 3 3 1 1 3 2 3 1 1 5 5 Sample Output13 标签：种类并查集 Solution逻辑推理的题有一部分和并查集有关，此题是种类并查集的经典例题。首先我们把每个动物分成三个点，对于点$i$，点$i$表示第$i$个动物的种类，点$i+n$表示第$i$个动物的食物，点$i+2n$表示第$i$个动物的天敌。这样一来，提供信息：$x$和$y$同类，相当于提供三条信息： $x$、$y$在同一个集中 $x+n$、$y+n$在同一个集中 $x+2n$、$y+2n$在同一个集中 于是我们$merge(x, y), merge(x+n, y+n), merge(x+2n, y+2n)$同理，提供信息：$x$吃$y$，相当于提供三条信息： $x$、$y+2n$在同一个集中 $x+n$、$y$在同一个集中 $x+2n$、$y+n$在同一个集中 于是我们$merge(x, y+2n), merge(x+n, y), merge(x+2n, y+n)$如果在接到信息$x$和$y$同类后，发现$x$和$y+n$同类或$x$和$y+2n$同类，则此信息与先前信息矛盾。因为对称性，我们不用再判断$y$是否和$x+n$或$x+2n$同类。同理可处理$x$吃$y$的情况。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 50000using namespace std;int n, k, f[MAX_N*3+5], cnt = 0;int get(int x) &#123; if (x != f[x]) f[x] = get(f[x]); return f[x];&#125;inline void merge(int x, int y) &#123; int ancx = get(x), ancy = get(y); if (ancx != ancy) f[ancx] = ancy; return;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n*3; i++) f[i] = i; for (int i = 0; i &lt; k; i++) &#123; int s, x, y; scanf("%d%d%d", &amp;s, &amp;x, &amp;y); if (x &gt; n || y &gt; n) &#123; cnt++; continue; &#125; if (s == 1) &#123; if (get(x) == get(y+n) || get(x) == get(y+2*n)) &#123; cnt++; &#125; else &#123; merge(x, y); merge(x+n, y+n); merge(x+2*n, y+2*n); &#125; &#125; else &#123; if (x == y || get(x) == get(y) || get(x) == get(y+n)) &#123; cnt++; &#125; else &#123; merge(x, y+2*n); merge(x+n, y); merge(x+2*n, y+n); &#125; &#125; &#125; printf("%d", cnt); return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>并查集</tag>
        <tag>NOI</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1170 Shopping Offers]]></title>
    <url>%2FPOJ1170%20Shopping%20Offers%20%E4%BA%94%E7%BB%B4DP%2F</url>
    <content type="text"><![CDATA[ProblemShopping OffersDescriptionIn a shop each kind of product has a price. For example, the price of a flower is $2$ ICU (Informatics Currency Units) and the price of a vase is $5$ ICU. In order to attract more customers, the shop introduces some special offers.A special offer consists of one or more product items for a reduced price. Examples: three flowers for $5$ ICU instead of $6$, or two vases together with one flower for $10$ ICU instead of $12$.Write a program that calculates the price a customer has to pay for certain items, making optimal use of the special offers. That is, the price should be as low as possible. You are not allowed to add items, even if that would lower the price.For the prices and offers given above, the (lowest) price for three flowers and two vases is $14$ ICU: two vases and one flower for the reduced price of $10$ ICU and two flowers for the regular price of $4$ ICU. InputYour program is to read from standard input. The first line contains the number $b$ of different kinds of products in the basket $(0 \le b \le 5)$. Each of the next b lines contains three values $c$, $k$, and $p$. The value $c$ is the (unique) product code $(1 \le c \le 999)$. The value $k$ indicates how many items of this product are in the basket $(1 \le k \le 5)$. The value p is the regular price per item $(1 \le p \le 999)$. Notice that all together at most $5\times 5=25$ items can be in the basket. The $b+2^{nd}$ line contains the number $s$ of special offers $(0 \le s \le 99)$. Each of the next $s$ lines describes one offer by giving its structure and its reduced price. The first number n on such a line is the number of different kinds of products that are part of the offer $(1 \le n \le 5)$. The next n pairs of numbers $(c,k)$ indicate that $k$ items $(1 \le k \le 5)$ with product code $c$ $(1 \le c \le 999)$ are involved in the offer. The last number $p$ on the line stands for the reduced price $(1 \le p \le 9999)$. The reduced price of an offer is less than the sum of the regular prices. OutputYour program is to write to standard output. Output one line with the lowest possible price to be paid. Sample Input12345627 3 28 2 521 7 3 52 7 1 8 2 10 Sample Output114 标签：五维$DP$ Translation题目大意：有至多五种物品，给出每一种物品的单价和几种套餐的价格，求买目标物品至少需要多少钱。 Solution这是一道大水题。因为只有五种物品，可以用五维的$dp$来表示，五个维度分别表示五种物品的个数，即$f[i][j][p][q][r]$表示第一种物品取$i$个，第二种物品取$j$个……第五种物品取$r$个至少需要多少钱。把每种物品的单价看作一种只有一个物品的套餐，这样枚举套餐，看能否转移。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 5#define MAX_S 100#define MAX_C 1000#define INF 2147483647using namespace std;int n, m, cnt, basket[MAX_N+5], offer[MAX_S+10][MAX_N+5], v[MAX_S+10], map[MAX_C+5];int f[MAX_N+5][MAX_N+5][MAX_N+5][MAX_N+5][MAX_N+5];int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; int id, num, p; scanf("%d%d%d", &amp;id, &amp;num, &amp;p); map[id] = i, basket[i] = num, offer[cnt][i] = 1, v[cnt++] = p; &#125; scanf("%d", &amp;m); for (int i =0; i &lt; m; i++) &#123; int num, id, k, p; scanf("%d", &amp;num); for (int i = 0; i &lt; num; i++) &#123; scanf("%d%d", &amp;id, &amp;k); offer[cnt][map[id]] = k; &#125; scanf("%d", &amp;p); v[cnt++] = p; &#125; for (int a0 = 0; a0 &lt;= basket[0]; a0++) for (int a1 = 0; a1 &lt;= basket[1]; a1++) for (int a2 = 0; a2 &lt;= basket[2]; a2++) for (int a3 = 0; a3 &lt;= basket[3]; a3++) for (int a4 = 0; a4 &lt;= basket[4]; a4++) &#123; if (a0 == 0 &amp;&amp; a1 == 0 &amp;&amp; a2 == 0 &amp;&amp; a3 == 0 &amp;&amp; a4 == 0) &#123;f[a0][a1][a2][a3][a4] = 0; continue;&#125; f[a0][a1][a2][a3][a4] = INF; for (int i = 0; i &lt; cnt; i++) &#123; if (a0 &lt; offer[i][0] || a1 &lt; offer[i][1] || a2 &lt; offer[i][2] || a3 &lt; offer[i][3] || a4 &lt; offer[i][4]) continue; f[a0][a1][a2][a3][a4] = min(f[a0][a1][a2][a3][a4], f[a0-offer[i][0]][a1-offer[i][1]][a2-offer[i][2]][a3-offer[i][3]][a4-offer[i][4]]+v[i]); &#125; &#125; printf("%d", f[basket[0]][basket[1]][basket[2]][basket[3]][basket[4]]); return 0;&#125;]]></content>
      <tags>
        <tag>DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3110 K大数查询]]></title>
    <url>%2FBZOJ3110%20K%E5%A4%A7%E6%95%B0%E6%9F%A5%E8%AF%A2%20%E6%A0%91%E5%A5%97%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem K大数查询 Description有$N$个位置，$M$个操作。操作有两种，每次操作如果是$1 a b c$的形式表示在第$a$个位置到第$b$个位置，每个位置加入一个数$c$；如果是$2 a b c$形式，表示询问从第$a$个位置到第$b$个位置，第$c$大的数是多少。 Input第一行$N$，$M$接下来$M$行，每行形如$1 a b c$或$2 a b c$ Output输出每个询问的结果 Sample Input1234562 51 1 2 11 1 2 22 1 1 22 1 1 12 1 2 3 Sample Output123121 Hint样例说明第一个操作后位置$1$的数只有$1$，位置$2$的数也只有$1$。第二个操作后位置$1$的数有$1$、$2$，位置$2$的数也有$1$、$2$。第三次询问位置$1$到位置$1$第$2$大的数是$1$。第四次询问位置$1$到位置$1$第$1$大的数是$2$。第五次询问位置$1$到位置$2$第$3$大的数是$1$。数据规模$N,M\le 5\times 10^4$$a\le b\le N$$1$操作中$|c|\le N$$2$操作中$c\le MaxLongint$ 标签：值域线段树套区间线段树 Solution这道题乍一看时主席树，但实际上是树套树。外层值域线段树，内层区间线段树，外层只提供内层的根的位置，真正参与计算的是内层。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 50000using namespace std;typedef long long ll;int n, m, cnt;int root[(MAX_N&lt;&lt;2)+500], ls[MAX_N*16*16+500], rs[MAX_N*16*16+500];ll tr[MAX_N*16*16+500], tag[MAX_N*16*16+500];inline void updata(int v, int s, int t) &#123;tr[v] = tr[ls[v]]+tr[rs[v]]+tag[v]*(ll)(t-s+1);&#125;//内层修改void modify(int &amp;v, int s, int t, int l, int r) &#123; if (!v) v = ++cnt; if (s &gt;= l &amp;&amp; t &lt;= r) &#123;tr[v] += (ll)(t-s+1), tag[v]++; return;&#125; int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify(ls[v], s, mid, l, r); if (r &gt;= mid+1) modify(rs[v], mid+1, t, l, r); updata(v, s, t);&#125;//外层修改void insert(int v, int s, int t, int l, int r, int x) &#123; modify(root[v], 1, n, l, r); if (s == t) return; int mid = s+t&gt;&gt;1; if (x &lt;= mid) insert(v&lt;&lt;1, s, mid, l, r, x); if (x &gt;= mid+1) insert(v&lt;&lt;1|1, mid+1, t, l, r, x);&#125;//内层查询ll calc(int v, int s, int t, int l, int r) &#123; if (!v) return 0; if (s &gt;= l &amp;&amp; t &lt;= r) return tr[v]; int mid = s+t&gt;&gt;1; ll ret = tag[v]*(ll)(min(t, r)-max(s, l)+1); if (l &lt;= mid) ret += calc(ls[v], s, mid, l, r); if (r &gt;= mid+1) ret += calc(rs[v], mid+1, t, l, r); return ret;&#125;//外层查询ll query(int v, int s, int t, int l, int r, int k) &#123; if (s == t) return s; int mid = s+t&gt;&gt;1; ll tmp = calc(root[v&lt;&lt;1|1], 1, n, l, r); if (k &gt;= tmp+1) return query(v&lt;&lt;1, s, mid, l, r, k-tmp); if (k &lt;= tmp) return query(v&lt;&lt;1|1, mid+1, t, l, r, k);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); while (m--) &#123; int opt, a, b, c; scanf("%d%d%d%d", &amp;opt, &amp;a, &amp;b, &amp;c); if (opt == 1) insert(1, 1, n, a, b, c); if (opt == 2) printf("%lld\n", query(1, 1, n, a, b, c)); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>树套树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ2155 Matrix]]></title>
    <url>%2FPOJ2155%20Matrix%20%E6%A0%91%E5%A5%97%E6%A0%91%E4%BA%8C%E7%BB%B4%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[ProblemMatrixTime Limit: $3000MS$Memory Limit: $65536K$ DescriptionGiven an $N\times N$ matrix $A$, whose elements are either $0$ or $1$. $A[i, j]$ means the number in the $i^{th}$ row and $j^{th}$ column. Initially we have $A[i, j] = 0 (1 \le i, j\le&lt; N)$.We can change the matrix in the following way. Given a rectangle whose upper-left corner is $(x_1, y_1)$ and lower-right corner is $(x_2, y_2)$, we change all the elements in the rectangle by using “not” operation (if it is a ‘$0$’ then change it into ‘$1$’ otherwise change it into ‘$0$’). To maintain the information of the matrix, you are asked to write a program to receive and execute two kinds of instructions. $C$ $x_1$ $y_1$ $x_2$ $y_2$ ($1\le x_1\le x_2\le n, 1\le y_1\le y_2\le n$) changes the matrix by using the rectangle whose upper-left corner is $(x_1, y_1)$ and lower-right corner is $(x_2, y_2)$. $Q$ $x$ $y$ ($1\le x, y\le n$) querys $A[x, y]$. InputThe first line of the input is an integer $X (X \le 10) $representing the number of test cases. The following X blocks each represents a test case.The first line of each block contains two numbers $N$ and $T$ ($2 \le N \le 1000$, $1 \le T \le 50000$) representing the size of the matrix and the number of the instructions. The following $T$ lines each represents an instruction having the format “$Q$ $x$ $y$” or “$C$ $x_1$ $y_1$ $x_2$ $y_2$”, which has been described above. OutputFor each querying output one line, which has an integer representing $A[x, y]$.There is a blank line between every two continuous test cases. Sample Input12345678910111212 10C 2 1 2 2Q 2 2C 2 1 2 1Q 1 1C 1 1 2 1C 1 2 1 2C 1 1 2 2Q 1 1C 1 1 2 1Q 2 1 Sample Output12341001 标签：线段树套线段树/二维树状数组 Solution此题最简单的方法是二维树状数组，但因为二维树状数组没太大用，所以练习线段树的树套树。此题用作树套树的模板题再合适不过。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 1000using namespace std;int n, m;int tr[(MAX_N&lt;&lt;2)+5][(MAX_N&lt;&lt;2)+5];void modify_y(int v1, int v2, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; tr[v1][v2] ^= 1; return; &#125; int mid = s+t&gt;&gt;1; if (l &lt;= mid) modify_y(v1, v2&lt;&lt;1, s, mid, l, r); if (r &gt;= mid+1) modify_y(v1, v2&lt;&lt;1|1, mid+1, t, l, r);&#125;void modify_x(int v, int s, int t, int x1, int y1, int x2, int y2) &#123; if (s &gt;= x1 &amp;&amp; t &lt;= x2) &#123; modify_y(v, 1, 1, n, y1, y2); return; &#125; int mid = s+t&gt;&gt;1; if (x1 &lt;= mid) modify_x(v&lt;&lt;1, s, mid, x1, y1, x2, y2); if (x2 &gt;= mid+1) modify_x(v&lt;&lt;1|1, mid+1, t, x1, y1, x2, y2);&#125;int query_y(int v1, int v2, int s, int t, int pos) &#123; if (s == t) return tr[v1][v2]; int mid = s+t&gt;&gt;1; if (pos &lt;= mid) return tr[v1][v2]^query_y(v1, v2&lt;&lt;1, s, mid, pos); else return tr[v1][v2]^query_y(v1, v2&lt;&lt;1|1, mid+1, t, pos);&#125;int query_x(int v, int s, int t, int x, int y) &#123; if (s == t) return query_y(v, 1, 1, n, y); int mid = s+t&gt;&gt;1; if (x &lt;= mid) return query_y(v, 1, 1, n, y)^query_x(v&lt;&lt;1, s, mid, x, y); else return query_y(v, 1, 1, n, y)^query_x(v&lt;&lt;1|1, mid+1, t, x, y);&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; memset(tr, 0, sizeof(tr)); scanf("%d%d", &amp;n, &amp;m); while (m--) &#123; char ch; cin &gt;&gt; ch; if (ch == 'C') &#123; int x1, y1, x2, y2; scanf("%d%d%d%d", &amp;x1, &amp;y1, &amp;x2, &amp;y2); modify_x(1, 1, n, x1, y1, x2, y2); &#125; if (ch == 'Q') &#123; int x, y; scanf("%d%d", &amp;x, &amp;y); printf("%d\n", query_x(1, 1, n, x, y)); &#125; &#125; printf("\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>树套树</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1012【JSOI2008】最大数]]></title>
    <url>%2FBZOJ1012%E3%80%90JSOI2008%E3%80%91%E6%9C%80%E5%A4%A7%E6%95%B0%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem 最大数 题目描述现在请求你维护一个数列，要求提供以下两种操作： 查询操作。 语法：$Q L$功能：查询当前数列中末尾$L$个数中的最大的数，并输出这个数的值。限制：$L$不超过当前数列的长度。 插入操作。 语法：$A n$功能：将$n$加上$t$，其中$t$是最近一次查询操作的答案（如果还未执行过查询操作，则$t=0$），并将所得结果对一个固定的常数$D$取模，将所得答案插入到数列的末尾。限制：$n$是整数（可能为负数）并且在长整范围内。注意：初始时数列是空的，没有一个数。 输入输出格式输入格式：第一行两个整数，$M$和$D$，其中$M$表示操作的个数$(M\le 2\times 10^5)$，$D$如上文中所述，满足$(0&lt;D&lt;2\times 10^9)$接下来的$M$行，每行一个字符串，描述一个具体的操作。语法如上文所述。输出格式：对于每一个查询操作，你应该按照顺序依次输出结果，每个结果占一行。 输入输出样例输入样例：1234565 100A 96Q 1A 97Q 1Q 2 输出样例：123969396 标签：线段树 Solution线段树裸题。记录当前长度$len$，每个结点维护区间最大值，操作$1$为$query(len-L+1, len)$，操作$2$为$modify(++len, (n+t)\%D)$。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 200000#define INF 2000000000#define ll long longusing namespace std;ll tree[MAX_N*4+50];int n, len = 0;void updata(int v) &#123; tree[v] = max(tree[v&lt;&lt;1], tree[v&lt;&lt;1|1]);&#125;void build(int v, int s, int t) &#123; if (s == t) &#123; tree[v] = -INF; return; &#125; int mid = s+t&gt;&gt;1; build(v&lt;&lt;1, s, mid); build(v&lt;&lt;1|1, mid+1, t); updata(v);&#125;void modify(int v, int s, int t, int pos, ll x) &#123; if (s == t) &#123; tree[v] = x; return; &#125; int mid = s+t&gt;&gt;1; if (pos &lt;= mid) &#123; modify(v&lt;&lt;1, s, mid, pos, x); &#125; else &#123; modify(v&lt;&lt;1|1, mid+1, t, pos, x); &#125; updata(v);&#125;ll query(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; return tree[v]; &#125; int mid = s+t&gt;&gt;1; ll ret = -INF; if (l &lt;= mid) &#123; ret = max(ret, query(v&lt;&lt;1, s, mid, l, r)); &#125; if (r &gt;= mid+1) &#123; ret = max(ret, query(v&lt;&lt;1|1, mid+1, t, l, r)); &#125; return ret;&#125;int main() &#123; ll x, prev = 0, mod; char opt; int l; scanf("%d%lld", &amp;n, &amp;mod); build(1, 1, n); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; opt; if (opt == 'A') &#123; scanf("%lld", &amp;x); modify(1, 1, n, ++len, (x%mod+prev)%mod); &#125; else &#123; scanf("%d", &amp;l); prev = query(1, 1, n, len-l+1, len); printf("%lld\n", prev); prev %= mod; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2588 Count on a tree]]></title>
    <url>%2FBZOJ2588%20Count%20on%20a%20tree%20DFS%E5%BA%8F%2BLCA%2B%E5%80%BC%E5%9F%9F%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem Count on a tree Description给定一棵$N$个节点的树，每个点有一个权值，对于$M$个询问$(u,v,k)$，你需要回答$u xor lastans$和$v$这两个节点间第$K$小的点权。其中$lastans$是上一个询问的答案，初始为$0$，即第一个询问的$u$是明文。 Input第一行两个整数$N,M$。第二行有$N$个整数，其中第$i$个整数表示点$i$的权值。后面$N-1$行每行$2$个整数$(x,y)$，表示点$x$到点$y$有一条边。最后$M$行每行$3$个整数$(u,v,k)$，表示一组询问。 Output$M$行，表示每个询问的答案。最后一个询问不输出换行符 Sample Input12345678910111213148 5105 2 9 3 8 5 7 71 21 31 43 53 63 74 82 5 10 5 210 5 311 5 4110 8 2 Sample Output123452891057 Hint $1\le N,M\le 10^5$ 标签：DFS序+LCA+值域主席树 Solution这时一个区间第$k$小的问题，所以可以很自然的想到值域主席树。但是此题将区间移到了树上，在树上套线段树，可以想到$DFS$序和树链剖分。此题应该是$DFS$序。在解区间第$k$小的时候，对于每次询问区间$[a,b]$，我们需要找到$a-1$位置的线段树和$b$位置的线段树，然后递归$query$的时候用个数相减。对于这道题，我们把每个结点到根的那条链作为一个序列，用区间第$k$小的方法存储，然后找到$u$和$v$的$LCA$（假定它为$t$），递归$query$的时候计算左区间数的个数，即$$u结点对应线段树左区间数的个数+v结点\cdots数的个数-t结点\cdots 数的个数-t的父结点\cdots数的个数$$即$tmp = tr[tr[u].ls].val+tr[tr[v].ls].val-tr[tr[t].ls].val-tr[tr[fa[t]].ls].val$。写的时候注意强制在线的操作方式和读入数后先离散化。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#define MAX_N 100000using namespace std;int n, m, c[MAX_N+5];int cnt = 0, root[MAX_N+5];int tot = 0, map[MAX_N+5];int anc[MAX_N+5][25], dep[MAX_N+5];bool vis[MAX_N+500];vector &lt;int&gt; G[MAX_N+500];struct Pre &#123;int id, val;&#125; pre[MAX_N+5];struct TNode &#123;int ls, rs, val;&#125; tr[MAX_N*32+500];bool cmp(const Pre &amp;a, const Pre &amp;b) &#123;return a.val &lt; b.val;&#125;void DFS(int u) &#123; vis[u] = true; for (int i = 1; (1&lt;&lt;i) &lt;= dep[u]; i++) anc[u][i] = anc[anc[u][i-1]][i-1]; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!vis[v]) anc[v][0] = u, dep[v] = dep[u]+1, DFS(v); &#125;&#125;int LCA(int a, int b) &#123; int i, j; if (dep[a] &lt; dep[b]) swap(a, b); for (i = 0; (1&lt;&lt;i) &lt;= dep[a]; i++) ; i--; for (j = i; j &gt;= 0; j--) if (dep[a]-(1&lt;&lt;j) &gt;= dep[b]) a = anc[a][j]; if (a == b) return a; for (j = i; j &gt;= 0; j--) if (anc[a][j] != anc[b][j]) a = anc[a][j], b = anc[b][j]; return anc[a][0];&#125;void init(int &amp;v, int s, int t) &#123; v = ++cnt; if (s == t) return; int mid = s+t&gt;&gt;1; init(tr[v].ls, s, mid); init(tr[v].rs, mid+1, t);&#125;void insert(int v, int o, int s, int t, int val) &#123; tr[v] = tr[o]; if (s == t) &#123;tr[v].val++; return;&#125; int mid = s+t&gt;&gt;1; if (val &lt;= mid) insert(tr[v].ls = ++cnt, tr[o].ls, s, mid, val); else insert(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, val); tr[v].val = tr[tr[v].ls].val+tr[tr[v].rs].val;&#125;void build(int u) &#123; root[u] = ++cnt; insert(root[u], root[anc[u][0]], 1, tot, c[u]); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (v != anc[u][0]) build(v); &#125;&#125;int query(int v1, int v2, int v3, int v4, int s, int t, int k) &#123; if (s == t) return s; int mid = s+t&gt;&gt;1, tmp = tr[tr[v1].ls].val+tr[tr[v2].ls].val-tr[tr[v3].ls].val-tr[tr[v4].ls].val; if (k &lt;= tmp) return query(tr[v1].ls, tr[v2].ls, tr[v3].ls, tr[v4].ls, s, mid, k); return query(tr[v1].rs, tr[v2].rs, tr[v3].rs, tr[v4].rs, mid+1, t, k-tmp);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) pre[i].id = i, scanf("%d", &amp;pre[i].val); sort(pre+1, pre+n+1, cmp); for (int i = 1; i &lt;= n; i++) &#123; if (i == 1 || pre[i].val != pre[i-1].val) map[++tot] = pre[i].val; c[pre[i].id] = tot; &#125; for (int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d%d", &amp;u, &amp;v); G[u].push_back(v), G[v].push_back(u); &#125; DFS(1); init(root[0], 1, tot), build(1); int ans = 0; while (m--) &#123; int u, v, k; scanf("%d%d%d", &amp;u, &amp;v, &amp;k); u ^= ans; int lca = LCA(u, v); ans = map[query(root[u], root[v], root[lca], root[anc[lca][0]], 1, tot, k)]; printf("%d", ans); if (m &gt;= 1) printf("\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>LCA</tag>
        <tag>DFS序</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1179【APIO2009】ATM]]></title>
    <url>%2FBZOJ1179%E3%80%90APOI2009%E3%80%91ATM%20Tarjan%2F</url>
    <content type="text"><![CDATA[Problem ATM Time Limit: $15 Sec$ Memory Limit: $162 MB$ Description$Siruseri$城中的道路都是单向的。不同的道路由路口连接。按照法律规定，在每个路口都设立了一个$Siruseri$银行的$ATM$取款机。令人奇怪的是，$Siruseri$的酒吧都设在路口，虽然并不是每个路口都设有酒吧。$Banditiji$计划实施$Siruseri$有史以来最惊天动地的$ATM$抢劫。他将从市中心出发，沿着单向道路行驶，抢劫所有他途径的$ATM$机，最终他将在一个酒吧庆祝他的胜利。使用高超的黑客技术，他获知了每个$ATM$机中可以掠取的现金数额。他希望你帮助他计算从市中心出发最后到达某酒吧时最多能抢劫的现金数额。他希望你帮助他计算从市中心出发最后到达某个酒吧时最多能抢劫的现金总数。他可以经过同一路口或道路任意多次。但只要他抢劫某个$ATM$机后，该$ATM$机就不会再有钱了。 Input第一行包含两个整数$N$、$M$。$N$表示路口的个数，$M$表示道路条数。接下来$M$行，每行两个整数，这两个整数都在$1$到$N$之间，第$i+1$行的两个整数表示第i条道路的起点和终点的路口编号。接下来$N$行，每行一个整数，按顺序表示每个路口处的$ATM$机中的钱数。接下来一行包含两个整数$S$、$P$，$S$表示市中心的编号，也就是出发的路口。$P$表示酒吧数目。接下来的一行中有$P$个整数，表示$P$个有酒吧的路口的编号 Output输出一个整数，表示$Banditji$从市中心开始到某个酒吧结束所能抢劫的最多的现金总数。 Sample Input1234567891011121314151617186 71 22 33 52 44 12 66 510128161 51 44356 Sample Output147 HINT $30\%$的输入保证$N, M\le 3000$。 $100\%$的输入保证$N, M\le 500000$。每个$ATM$机中可取的钱数为一个非负整数且不超过$4000$。输入数据保证你可以从市中心沿着$Siruseri$的单向的道路到达其中的至少一个酒吧。 标签：$Tarjan$ Solution题面有一种莫名其妙的喜感这道题是我的第一道$APIO$题（虽然是水题），庆祝一下首先，很容易看出要$tarjan$缩点。题目说城市的路是单向边，而且可以经过任意一点任意多次，所以走到强连通分量，这个强连通分量的所有点都可以到达，所有$ATM$机都可以抢。于是我们先缩点，顺带记录每个分量的$ATM$机价值总和，并统计每个分量有没有酒吧，即能否作为停止点。然后跑一遍$SPFA$，找以所有带酒吧的分量为终点的最长路即可。五十行随便写完，数据无坑。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;queue&gt;#define MAX_N 500000using namespace std;int n, m, s, p, c[MAX_N+5], end[MAX_N+5], endc[MAX_N+5], dfn[MAX_N+5], low[MAX_N+5], id[MAX_N+5], sz[MAX_N+5], ind, cnt;vector &lt;int&gt; G[MAX_N+5], E[MAX_N+5];stack &lt;int&gt; sta; bool insta[MAX_N+5];void tarjan(int u) &#123; dfn[u] = low[u] = ++ind, sta.push(u), insta[u] = true; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i]; if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]); else if (insta[v]) low[u] = min(low[u], dfn[v]); &#125; if (dfn[u] == low[u]) &#123; cnt++; for (int i = sta.top(); ; i = sta.top()) &#123; id[i] = cnt, sz[cnt] += c[i], insta[i] = false; sta.pop(); if (i == u) break; &#125; &#125;&#125;queue &lt;int&gt; que; bool inque[MAX_N+5]; int f[MAX_N+5], ans;void SPFA() &#123; f[s] = sz[s], que.push(s), inque[s] = true; while (!que.empty()) &#123; int u = que.front(); que.pop(), inque[u] = false; for (int i = 0; i &lt; E[u].size(); i++) &#123; int v = E[u][i]; if (f[v] &gt; f[u]+sz[v]) continue; f[v] = f[u]+sz[v]; if (!inque[v]) que.push(v), inque[v] = true; if (endc[v]) ans = max(ans, f[v]); &#125; &#125;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); while (m--) &#123;int u, v; scanf("%d%d", &amp;u, &amp;v), G[u].push_back(v);&#125; for (int i = 1; i &lt;= n; i++) scanf("%d", &amp;c[i]); scanf("%d%d", &amp;s, &amp;p); while (p--) &#123;int x; scanf("%d", &amp;x), end[x] = 1;&#125; for (int i = 1; i &lt;= n; i++) if (!dfn[i]) tarjan(i); for (int i = 1; i &lt;= n; i++) endc[id[i]] |= end[i]; for (int u = 1; u &lt;= n; u++) for (int i = 0; i &lt; G[u].size(); i++) &#123;int v = G[u][i]; if (id[u] != id[v]) E[id[u]].push_back(id[v]);&#125; s = id[s], SPFA(); printf("%d", ans); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>APIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ1798【AHOI2009】seq维护序列]]></title>
    <url>%2FBZOJ1798%E3%80%90AHOI2009%E3%80%91%20seq%E7%BB%B4%E6%8A%A4%E5%BA%8F%E5%88%97%20%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem维护序列题目描述老师交给小可可一个维护数列的任务，现在小可可希望你来帮他完成。 有长为$N$的数列，不妨设为$a_1,a_2,\cdots ,a_N$。有如下三种操作形式： $(1)$把数列中的一段数全部乘一个值; $(2)$把数列中的一段数全部加一个值; $(3)$询问数列中的一段数的和，由于答案可能很大，你只需输出这个数模$P$的值。 输入输出格式输入格式第一行两个整数$N$和$P$($1\le P\le 10^9$）。第二行含有N个非负整数,从左到右依次为$a_1,a_2,\cdots ,a_N$, ($0\le a_i\le 10^9,1\le i\le N$)。第三行有一个整数$M$，表示操作总数。从第四行开始每行描述一个操作，输入的操作有以下三种形式： 操作$1$：“$1$ $t$ $g$ $c$”(不含双引号)。表示把所有满足$t\le i\le g$的$a_i$改为$a_i\times c$$ (1\le t\le g\le N,0\le c\le 10^9)$。 操作$2$：“$2$ $t$ $g$ $c$”(不含双引号)。表示把所有满足$t\le i\le g$的$a_i$改为$a_i+c$$ (1\le t\le g\le N,0\le c\le 10^9)$。 操作$3$：“$3$ $t$ $g$”(不含双引号)。询问所有满足$t\le i\le g$的$a_i$的和模$P$的值 $(1\le t\le g\le N)$。 同一行相邻两数之间用一个空格隔开，每行开头和末尾没有多余空格。输出格式对每个操作$3$，按照它在输入中出现的顺序，依次输出一行一个整数表示询问结果。 输入输出样例输入样例：123456787 431 2 3 4 5 6 751 2 5 53 2 42 3 7 93 1 33 4 7 输出样例：1232358 说明【样例说明】初始时数列为$(1,2,3,4,5,6,7)$。经过第$1$次操作后，数列为$(1,10,15,20,25,6,7)$。对第$2$次操作，和为$10+15+20=45$，模$43$的结果是$2$。经过第$3$次操作后，数列为$(1,10,24,29,34,15,16)$对第$4$次操作，和为$1+10+24=35$，模$43$的结果是$35$。对第$5$次操作，和为$29+34+15+16=94$,模$43$的结果是$8$。 标签：线段树 Solution这题就是个线段树的板题，和洛谷的线段树模板$2$没什么区别。区间加、乘，区间求和注意$downtag$时加和乘的优先级，应该先把乘法$tag$乘上加法$tag$传到子结点，然后传乘法$tag$。特别注意：乘法tag下传后应改为1，而不是0！ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_N 100000#define ll long longusing namespace std;int n, m;ll p;ll tree[MAX_N*4+5], mul[MAX_N*4+5], add[MAX_N*4+5];void updata(int v) &#123; tree[v] = (tree[v&lt;&lt;1]+tree[v&lt;&lt;1|1])%p;&#125;void downtag(int v, int s, int t, int mid) &#123; if (mul[v] == 1 &amp;&amp; add[v] == 0) return; mul[v*2] = mul[v*2]*mul[v]%p; add[v*2] = (add[v*2]*mul[v]%p+add[v])%p; tree[v*2] = (tree[v*2]*mul[v]%p+add[v]*(ll)(mid-s+1)%p)%p; mul[v*2+1] = mul[v*2+1]*mul[v]%p; add[v*2+1] = (add[v*2+1]*mul[v]%p+add[v])%p; tree[v*2+1] = (tree[v*2+1]*mul[v]%p+add[v]*(ll)(t-mid)%p)%p; mul[v] = 1; add[v] = 0; return;&#125;void create(int v, int s, int t) &#123; mul[v] = 1; add[v] = 0; if (s == t) &#123; scanf("%lld", &amp;tree[v]); tree[v] %= p; return; &#125; int mid = s+t&gt;&gt;1; create(v&lt;&lt;1, s, mid); create(v&lt;&lt;1|1, mid+1, t); updata(v);&#125;void modify1(int v, int s, int t, int l, int r, int x) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; add[v] = (add[v]+(ll)x)%p; tree[v] = (tree[v]+(ll)x*(ll)(t-s+1)%p)%p; return; &#125; int mid = s+t&gt;&gt;1; downtag(v, s, t, mid); if (l &lt;= mid) &#123; modify1(v&lt;&lt;1, s, mid, l, r, x); &#125; if (r &gt;= mid+1) &#123; modify1(v&lt;&lt;1|1, mid+1, t, l, r, x); &#125; updata(v);&#125;void modify2(int v, int s, int t, int l, int r, int x) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; mul[v] = mul[v]*(ll)x%p; add[v] = add[v]*(ll)x%p; tree[v] = tree[v]*(ll)x%p; return; &#125; int mid = s+t&gt;&gt;1; downtag(v, s, t, mid); if (l &lt;= mid) &#123; modify2(v&lt;&lt;1, s, mid, l, r, x); &#125; if (r &gt;= mid+1) &#123; modify2(v&lt;&lt;1|1, mid+1, t, l, r, x); &#125; updata(v);&#125;ll query(int v, int s, int t, int l, int r) &#123; if (s &gt;= l &amp;&amp; t &lt;= r) &#123; return tree[v]; &#125; int mid = s+t&gt;&gt;1; ll ret = 0; downtag(v, s, t, mid); if (l &lt;= mid) &#123; ret = (ret+query(v&lt;&lt;1, s, mid, l, r))%p; &#125; if (r &gt;= mid+1) &#123; ret = (ret+query(v&lt;&lt;1|1, mid+1, t, l, r))%p; &#125; updata(v); return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;p); create(1, 1, n); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) &#123; int f; scanf("%d", &amp;f); if (f == 1) &#123; int l, r, x; scanf("%d%d%d", &amp;l, &amp;r, &amp;x); modify2(1, 1, n, l, r, x%p); &#125; else if (f == 2) &#123; int l, r, x; scanf("%d%d%d", &amp;l, &amp;r, &amp;x); modify1(1, 1, n, l, r, x%p); &#125; else &#123; int l, r; scanf("%d%d", &amp;l, &amp;r); printf("%lld\n", query(1, 1, n, l, r)); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>省选</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2002 Bounce 弹飞绵羊]]></title>
    <url>%2FBZOJ2002%20Bounce%20%E5%BC%B9%E9%A3%9E%E7%BB%B5%E7%BE%8A%20%E5%88%86%E5%9D%97%2F</url>
    <content type="text"><![CDATA[Problem Bounce 弹飞绵羊 Description某天，$Lostmonkey$发明了一种超级弹力装置，为了在他的绵羊朋友面前显摆，他邀请小绵羊一起玩个游戏。游戏一开始，$Lostmonkey$在地上沿着一条直线摆上$n$个装置，每个装置设定初始弹力系数$k_i$，当绵羊达到第$i$个装置时，它会往后弹$k_i$步，达到第$i+k_i$个装置，若不存在第$i+k_i$个装置，则绵羊被弹飞。绵羊想知道当它从第$i$个装置起步时，被弹几次后会被弹飞。为了使得游戏更有趣，$Lostmonkey$可以修改某个弹力装置的弹力系数，任何时候弹力系数均为正整数。 Input第一行包含一个整数$n$，表示地上有$n$个装置，装置的编号从$0$到$n-1$,接下来一行有$n$个正整数，依次为那$n$个装置的初始弹力系数。第三行有一个正整数$m$，接下来$m$行每行至少有两个数$i$、$j$，若$i=1$，你要输出从$j$出发被弹几次后被弹飞，若$i=2$则还会再输入一个正整数$k$，表示第$j$个弹力装置的系数被修改成$k$。 Output对于每个$i=1$的情况，你都要输出一个需要的步数，占一行。 Sample Input1234564 1 2 1 1 31 12 1 11 1 Sample Output1223 Hint 于$20\%$的数据$n,m\le 10^4$； 于$100\%$的数据$n\le 2\times 10^5$, $m\le 10^5$ 标签：LCT，分块 Solution本题其实应该是$LCT$的基础题，但是因为我身为蒟蒻写不来$LCT$，就用分块做了。把原数列分为$\sqrt{n}$个块，对于每个块，维护块内的每个位置需要多少步才能跳到块外，以及跳到块外后的位置，对于修改操作，重算那个块内的所有位置的两个值，这样单次询问或修改复杂度$O(\sqrt{n})$，总复杂度$O(n\sqrt{n})$。可过。 Code1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAX_N 200000using namespace std;int n, m, magic, k[MAX_N+5];int pos[MAX_N+5], times[MAX_N+5];void update(int l, int r) &#123; for (int i = r; i &gt;= l; i--) if (i+k[i] &gt;= n) pos[i] = -1, times[i] = 1; else if (i+k[i] &gt;= (i/magic+1)*magic) pos[i] = i+k[i], times[i] = 1; else pos[i] = pos[i+k[i]], times[i] = times[i+k[i]]+1;&#125;int main() &#123; scanf("%d", &amp;n), magic = sqrt(n); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;k[i]); update(0, n-1); scanf("%d", &amp;m); while (m--) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; int x, ans = 0; scanf("%d", &amp;x); while (x != -1) ans += times[x], x = pos[x]; printf("%d\n", ans); &#125; if (opt == 2) &#123;int x, y; scanf("%d%d", &amp;x, &amp;y), k[x] = y; update(x/magic*magic, x);&#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ2434【NOI2011】阿狸的打字机]]></title>
    <url>%2FBZOJ2434%E3%80%90NOI2011%E3%80%91%E9%98%BF%E7%8B%B8%E7%9A%84%E6%89%93%E5%AD%97%E6%9C%BA%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA%2BFail%E6%A0%91%2B%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[ProblemBZOJ2434 阿狸的打字机Description阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有$28$个按键，分别印有$26$个小写英文字母和$B$、$P$两个字母。经阿狸研究发现，这个打字机是这样工作的： 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。 按一下印有$B$的按键，打字机凹槽中最后一个字母会消失。 按一下印有$P$的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。 例如，阿狸输入$aPaPBbP$，纸上被打印的字符如下：$a$$aa$$ab$我们把纸上打印出来的字符串从$1$开始顺序编号，一直到$n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数$(x,y)$（其中$1\le x,y\le n$），打字机会显示第$x$个打印的字符串在第$y$个打印的字符串中出现了多少次。阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？ Input输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。第二行包含一个整数$m$，表示询问个数。接下来$m$行描述所有由小键盘输入的询问。其中第$i$行包含两个整数$x$, $y$，表示第$i$个询问为$(x, y)$。 Output输出$m$行，其中第$i$行包含一个整数，表示第$i$个询问的答案。 Sample Input12345aPaPBbP31 21 32 3 Sample Output123210 Hint$1\le N\le 10^5$$1\le M\le 10^5 $$输入总长\le 10^5$ 标签：$AC$自动机, $Fail$树, 树状数组 Solution这道题的提示还是很明显的。读完题目，很容易发现此题打字的部分就是在建一棵$Trie$。输入小写字母即在$Trie$中添加一个子结点并向儿子结点走，输入‘$B$’即退回到父结点，输入’$P$‘即在当前结点打标记。因而我们可以构建$Trie$如下：123456789101112131415161718192021222324void init() &#123; //我写Trie树的习惯：把根节点定为1 cnt = 0, root = 1, fa[root] = 0; //0号节点所有儿子都练到根，这样AC自动机CalcFail时更方便 for (int i = 0; i &lt; 26; i++) trie[0][i] = root;&#125;void build() &#123; init(); n = strlen(s); ind = 1;//ind记录当前结点数 for (int i = 0, cur = root; i &lt; n; i++) &#123; if (s[i] == 'B') &#123; //退到父结点 cur = fa[cur]; &#125; else if (s[i] == 'P') &#123; //打标记，标记为第cnt个字符串 pos[++cnt] = cur; &#125; else &#123; //新建子结点 trie[cur][s[i]-'a'] = ++ind; fa[ind] =cur, cur = ind;` &#125; &#125;&#125; 接下来我们对付这题的询问。首先，它要求一个字符串在另一个字符串中出现多少次，这显然是$AC$自动机的操作，所以我们建立$fail$数组如下： 12345678910111213141516void CalcFail() &#123; queue &lt;int&gt; que; que.push(root); while (!que.empty()) &#123; int u = que.front(); for (int i = 0; i &lt; DICNUM; i++) &#123; if (trie[u][i]) &#123; fail[trie[u][i]] = trie[fail[u]][i]; que.push(trie[u][i]); &#125; else &#123; trie[u][i] = trie[fail[u]][i]; &#125; &#125; que.pop(); &#125;&#125; 现在我们考虑$fail$数组的实质。如果$A$结点的$fail$指向$B$结点，则$B$结点代表的字符串一定是$A$结点代表字符串的后缀，即经过$A$的所有路径组成的字符串都包含$B$结点代表的字符串。对于一个字符串，它的所有字串为它所有前缀的所有后缀，所以对于询问$(x,y)$，我们需要找出从根节点到$y$的路径中有多少结点可以通过$fail$指针转移到$x$。 这时我们就需要考虑$Fail$树了。对于任意结点$p$，我们把所有通过$fail$指针能直接转移到$p$的结点作为$p$的子结点，而$p$通过$fail$指针转移到的结点作为$p$的父结点。这样我们就能构建一棵树。这样一来，对于询问$(x,y)$，问题等价于从根到$y$的结点中有多少节点是在$x$的子树中。我们就可以用$DFS$序操作。然后用树状数组维护。 为了使询问变得更好操作，我们考虑把询问按$y$值排序，这样我们就只需一直往下走，然后标记经过的结点，然后统计$x$子树即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define MAX_N 100000#define DICNUM 26using namespace std;int n, m, cnt, ind;int root, trie[MAX_N+5][DICNUM], fa[MAX_N+5], fail[MAX_N+5], pos[MAX_N+5], ans[MAX_N+5];char s[MAX_N+5];vector &lt;int&gt; G[MAX_N+5];int into[MAX_N+5], outo[MAX_N+5];int tr[MAX_N+5];struct Query &#123;int x, y, id;&#125; q[MAX_N+5];bool cmp (const Query &amp;a, const Query &amp;b) &#123;return a.y &lt; b.y;&#125;void init() &#123; cnt = 0, root = 1, fa[root] = 0; for (int i = 0; i &lt; DICNUM; i++) trie[0][i] = root;&#125;void CalcFail() &#123; queue &lt;int&gt; que; que.push(root); while (!que.empty()) &#123; int u = que.front(); for (int i = 0; i &lt; DICNUM; i++) &#123; if (trie[u][i]) &#123; fail[trie[u][i]] = trie[fail[u]][i]; que.push(trie[u][i]); &#125; else &#123; trie[u][i] = trie[fail[u]][i]; &#125; &#125; que.pop(); &#125;&#125;void DFS(int u) &#123; into[u] = ++ind; for (int i = 0; i &lt; G[u].size(); i++) DFS(G[u][i]); outo[u] = ind;&#125;void build() &#123; init(); n = strlen(s); ind = 1; for (int i = 0, cur = root; i &lt; n; i++) &#123; if (s[i] == 'B') &#123; cur = fa[cur]; &#125; else if (s[i] == 'P') &#123; pos[++cnt] = cur; &#125; else &#123; trie[cur][s[i]-'a'] = ++ind; fa[ind] = cur, cur = ind; &#125; &#125; CalcFail(); for (int i = 1; i &lt;= ind; i++) G[fail[i]].push_back(i); ind = 0; DFS(root);&#125;void inc(int pos) &#123;for (; pos &lt;= ind; pos += pos&amp;(-pos)) tr[pos]++;&#125;void dec(int pos) &#123;for (; pos &lt;= ind; pos += pos&amp;(-pos)) tr[pos]--;&#125;int sum(int pos) &#123;int ret = 0; for (; pos; pos -= pos&amp;(-pos)) ret += tr[pos]; return ret;&#125;void solve() &#123; sort(q, q+m, cmp); for (int i = 0, j = 0, cur = root, now = 0; i &lt; n; i++) if (s[i] == 'B') &#123; dec(into[cur]); cur = fa[cur]; &#125; else if (s[i] == 'P') &#123; now++; for (; j &lt; m &amp;&amp; q[j].y == now; j++) ans[q[j].id] = sum(outo[pos[q[j].x]])-sum(into[pos[q[j].x]]-1); &#125; else &#123; cur = trie[cur][s[i]-'a']; inc(into[cur]); &#125;&#125;int main() &#123; scanf("%s", s); build(); scanf("%d", &amp;m); for (int i = 0; i &lt; m; i++) scanf("%d%d", &amp;q[i].x, &amp;q[i].y), q[i].id = i; solve(); for (int i = 0; i &lt; m; i++) printf("%d\n", ans[i]); return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
        <tag>NOI</tag>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POJ1201 Intervals]]></title>
    <url>%2FPOJ1201%20Intervals%20%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[ProblemIntervalsDescriptionYou are given $n$ closed, integer intervals $[a_i, b_i]$ and $n$ integers $c_1\sim c_n$.Write a program that:reads the number of intervals, their end points and integers $c_1\sim c_n$ from the standard input, computes the minimal size of a set $Z$ of integers which has at least $c_i$ common elements with interval $[a_i, b_i]$, for each $i=1,2,\cdots ,n$, writes the answer to the standard output. InputThe first line of the input contains an integer $n$ ($1\le n\le 5\times 10^4$) – the number of intervals. The following n lines describe the intervals. The $(i+1)^{th}$ line of the input contains three integers $a_i$, $b_i$ and $c_i$ separated by single spaces and such that $0\le a_i\le b_i\le 5\times 10^4$ and $1\le c_i\le b_i - a_i+1$. OutputThe output contains exactly one integer equal to the minimal size of set $Z$ sharing at least $c_i$ elements with interval $[a_i, b_i]$, for each $i=1,2,\cdots ,n$. Sample Input12345653 7 38 10 36 8 11 3 110 11 1 Sample Output16 标签：差分约束系统 Translation题目大意：给出$n$个区间，试确定一个集合使得对于$i=1\sim n$，第$i$个区间内至少有$c_i$个数，并使得此集合尽量小，输出最小大小。 Solution首先用前缀和。$sum[i]$表示从$1$到$i$中共选出多少个数到集合中。这样对于集合$[a_i,b_i]$，有$sum[b_i]-sum[a_i-1]\ge c_i$，于是我们可以从点$a_i-1$到$b_i$连一条权值为$c_i$的边。因为题意是要满足所有的边，所以我们需要找最长路。此题有一些细节问题。首先，找最长路需要起点和终点，我们需要找到这些集合覆盖的范围，即找到左端点（其实应该是左端点$-1$）的最小值$s$和右端点的最大值$t$，找$s$到$t$的最大值。此外，光有上述的那些边时无法构成一个连通图的，所以我们需要找一些隐含条件。可以发现有$sum[i]-sum[i-1]\ge 0$，$sum[i]-sum[i-1]\le 1$，为了保持一致，应将后面的式子转化为大于等于，即$sum[i-1]-sum[i]\ge -1$，这样对于$i=s+1\sim t$，从$i-1$到$i$连接一条权值为$0$的路，从$i$到$i-1$连接一条权值为$-1$的路，之后就可以直接用$SPFA$找最长路了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAX_N 50000using namespace std;int n, cnt, s, t, pre[MAX_N+5], dis[MAX_N+5];struct node &#123;int v, c, nxt;&#125; E[MAX_N*3+5];void insert(int u, int v, int c) &#123; E[++cnt].v = v, E[cnt].c = c; E[cnt].nxt = pre[u], pre[u] = cnt;&#125;void SPFA() &#123; queue &lt;int&gt; que; bool inque[MAX_N+5]; memset(dis, 128, sizeof(dis)); memset(inque, 0, sizeof(inque)); dis[s] = 0; que.push(s), inque[s] = true; while (!que.empty()) &#123; int u = que.front(); for (int i = pre[u]; i; i = E[i].nxt) &#123; int v = E[i].v, c = E[i].c; if (dis[u]+c &gt; dis[v]) &#123; dis[v] = dis[u]+c; if (!inque[v]) que.push(v), inque[v] = true; &#125; &#125; que.pop(), inque[u] = false; &#125;&#125;int main() &#123; while (scanf("%d", &amp;n) != EOF) &#123; cnt = 0, s = 50000, t = 0; memset(pre, 0, sizeof(pre)); memset(E, 0, sizeof(E)); for (int i = 0; i &lt; n; i++) &#123; int u, v, c; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); insert(u, v+1, c); s = min(s, u); t = max(t, v+1); &#125; for (int i = s; i &lt; t; i++) insert(i, i+1, 0), insert(i+1, i, -1); SPFA(); printf("%d\n", dis[t]); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>图论</tag>
        <tag>POJ</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU5340 Three Palindromes]]></title>
    <url>%2FHDU5340%20Three%20Palindromes%20Manacher%2F</url>
    <content type="text"><![CDATA[Problem Three Palindromes DescriptionCan we divided a given string $S$ into three nonempty palindromes? InputFirst line contains a single integer $T\le 20$ which denotes the number of test cases.For each test case , there is an single line contains a string $S$ which only consist of lowercase English letters.$1\le |s|\le 20000$ OutputFor each case, output the $Yes$ or $No$ in a single line. Sample Input1232abcabaadada Sample Output12YesNo 标签：Manacher Translation题目大意：给出字符串$S$，判断$S$是否能被分为三段回文串。 Solution看到回文串，可知本题大概和$Manacher$有关。在$Manacher$中，我们有一个数组$f[]$，$f[i]$记录从第i位向两边拓展，最长回文串的半径是多少。注意到本题有一个特殊的数据——$3$，而三段中，只要能确定任意两段，另一段就能确定。而这三段中肯定有两段是覆盖到串首或串尾的。因而我们可以用$f[i]$是否等于$i$来确定$i$位置是否能成为第一个段的中心点，如法炮制可求出第三段。这时我们暴力枚举第一段和第三段，这样确定第二段后，找到此段中心，可通过$f[]$确定第二段是否是回文串。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAX_L 20000using namespace std;char s[MAX_L*2+5];int f[MAX_L*2+5];bool manacher (char* s0) &#123; int len = strlen(s0), pos = 0, r = 0; for (int i = 0; i &lt; len; i++) s[i*2+1] = '#', s[i*2+2] = s0[i]; s[len = len*2+1] = '#'; for (int i = 1; i &lt;= len; i++) &#123; f[i] = (i &lt; r) ? min(f[2*pos-i], r-i) : 1; while (i-f[i] &gt;= 1 &amp;&amp; i+f[i] &lt;= len &amp;&amp; s[i-f[i]] == s[i+f[i]]) f[i]++; if (i+f[i] &gt; r) pos = i, r = i+f[i]; &#125; int lm[MAX_L*2+5], rm[MAX_L*2+5], cntl = 0, cntr = 0; for (int i = 1; i &lt;= len; i++) &#123; if (f[i] == i &amp;&amp; f[i] &gt; 1) lm[cntl++] = i; if (f[len-i+1] == i &amp;&amp; f[len-i+1] &gt; 1) rm[cntr++] = len-i+1; &#125; for (int i = 0; i &lt; cntl; i++) for (int j = 0; j &lt; cntr; j++) &#123; int s = lm[i]+f[lm[i]], t = rm[j]-f[rm[j]]; if (s &gt; t) continue; if (f[s+t&gt;&gt;1] == 1) continue; if (f[s+t&gt;&gt;1]*2-1 &lt; t-s+1) continue; return true; &#125; return false;&#125;int main() &#123; int T; scanf("%d", &amp;T); while (T--) &#123; char s0[MAX_L+5]; scanf("%s", s0); if (manacher(s0)) printf("Yes\n"); else printf("No\n"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>字符串</tag>
        <tag>Manacher</tag>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BZOJ3673 可持久化并查集 by zky]]></title>
    <url>%2FBZOJ3673%20%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E5%B9%B6%E6%9F%A5%E9%9B%86%20by%20zky%20%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E7%BB%84%2B%E4%B8%BB%E5%B8%AD%E6%A0%91%2F</url>
    <content type="text"><![CDATA[Problem 可持久化并查集 by zky Description$n$个集合 $m$个操作操作：$1 a b$ 合并$a,b$所在集合$2 k$ 回到第$k$次操作之后的状态(查询算作操作)$3 a b$ 询问$a,b$是否属于同一集合，是则输出$1$否则输出$0$ Sample Input12345675 61 1 23 1 22 03 1 22 13 1 2 Sample Output123101 Hint $1 &lt; n,m \le 2\times 10^4$ 标签：主席树维护可持久化数组 Solution本题的做法其实和并查集没太大关联。如果是撤销，那可以用不加路径压缩的并查集完成，但是如果回到某时间，则不太好写。这时，我们发现并查集这个东西构造其实很简单，只需要一个$fa$数组就行了。所以我们自然可以想到直接用一个二维数组存储每个时间的$fa$数组，即用增加的一维表示时间。但是，$n$、$m$是$2\times 10^4$级别，所以肯定会$MLE$，这里我们就需要用到主席树，把$fa$数组可持久化。这里需要注意我们不能用路径压缩优化，因为我们需要回到前面的状态，为了让它跑得更快，我们可以用按秩合并优化。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;cstdio&gt;#define MAX_N 20000using namespace std;int n, m, cnt, now, root[MAX_N*10+5];struct node &#123;int fa, dep, ls, rs;&#125; tr[MAX_N*100+5];void build(int v, int l, int r) &#123; if (l == r) &#123;tr[v].fa = l; return;&#125; int mid = l+r&gt;&gt;1; tr[v].ls = ++cnt, tr[v].rs = ++cnt; build(tr[v].ls, l, mid); build(tr[v].rs, mid+1, r);&#125;void modifyfa(int v, int o, int s, int t, int pos, int x) &#123; tr[v] = tr[o]; if (s == t) &#123;tr[v].fa = x; return;&#125; int mid = s+t&gt;&gt;1; if (pos &lt;= mid) modifyfa(tr[v].ls = ++cnt, tr[o].ls, s, mid, pos, x); else modifyfa(tr[v].rs = ++cnt, tr[o].rs, mid+1, t, pos, x);&#125;void modifydep(int v, int s, int t, int pos) &#123; if (s == t) &#123;tr[v].dep++; return;&#125; int mid = s+t&gt;&gt;1; if (pos &lt;= mid) modifydep(tr[v].ls, s, mid, pos); else modifydep(tr[v].rs, mid+1, t, pos);&#125;int find(int v, int s, int t, int pos) &#123; if (s == t) return v; int mid = s+t&gt;&gt;1; if (pos &lt;= mid) return find(tr[v].ls, s, mid, pos); else return find(tr[v].rs, mid+1, t, pos);&#125;int getf(int r, int x) &#123; int pos = find(r, 1, n, x); if (tr[pos].fa != x) return getf(r, tr[pos].fa); return pos;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); cnt = 0, root[0] = ++cnt; build(root[0], 1, n); for (int now = 1; now &lt;= m; now++) &#123; int opt; scanf("%d", &amp;opt); if (opt == 1) &#123; root[now] = root[now-1]; int a, b; scanf("%d%d", &amp;a, &amp;b); int posa = getf(root[now], a), posb = getf(root[now], b); if (tr[posa].fa == tr[posb].fa) continue; if (tr[posa].dep &gt; tr[posb].dep) swap(posa, posb); root[now] = ++cnt; modifyfa(root[now], root[now-1], 1, n, tr[posa].fa, tr[posb].fa); if (tr[posa].dep == tr[posb].dep) modifydep(root[now], 1, n, tr[posb].fa); &#125; if (opt == 2) &#123; int k; scanf("%d", &amp;k); root[now] = root[k]; &#125; if (opt == 3) &#123; root[now] = root[now-1]; int a, b; scanf("%d%d", &amp;a, &amp;b); if (tr[getf(root[now], a)].fa == tr[getf(root[now], b)].fa) printf("1\n"); else printf("0\n"); &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>BZOJ</tag>
        <tag>数据结构</tag>
        <tag>主席树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170710总结]]></title>
    <url>%2F20170710%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是数据结构的最后一天。上午考试一反常态，花式翻车。T1是签到水题，居然没开longlong，int爆成负；T2T3用的是I64d（调试为windows下），考试为linux下，应该用lld，爆零了。T2是一个splay的版题，但是因为对翻转操作不熟悉，没有写正解。看来得多写写splay，因为比较好写又灵活的平衡树就是splay了（当然，treap也算）。T3写了一个玄学的值域主席树优化，虽然最坏复杂度还是O(n^2)，但是如果值域范围小，在10000以内都能过，因而我Task3和Task4都过了一半以上，可惜是子任务，不然就赚了。T3正解是分块，不太好写。隔壁小胖学长说是莫队，而且他的程序碾压标程，三项都比标程好,,ԾㅂԾ,,…莫队大法好下午先讲了树链剖分，然后讲了一些数据结构杂题。杂题的思维难度都比较高，而且根本看不出和数据结构有什么联系。个人认为，数据结构其实就是工具，和解题方法无关，方法归方法，数据结构只是在解题的时候进行优化。除了版题以外，对于其他数据结构题，想的时候还是不要使劲往数据结构上靠，应该先全面想，再在局部用数据结构优化，这样才能打开思维。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170707总结]]></title>
    <url>%2F20170707%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是数据结构最难的一天，学了平衡树。讲了替罪羊树、treap、splay。学长说掌握两种即可，又因为替罪羊树最基础，所以我没有写替罪羊树，只是理解了一下，准备学treap和splay。今天我写的是treap，不得不说，比以前见过的SBtree好写多了，操作就只有split和merge两种，插入删除都是split到要插入/删除的点，把其他点和要插入的点merge或把除要删除的点外的点merge，而经过压行，这两个函数都只有四行，insert和erase都只有三行，所以treap好写好调。下午调treap，作死地把所有操作都分别写到函数里，以至于是先merge再返回答案，这样merge的时候会改变答案的值。这就是指针的迷惑性，虽然指针没有任何变化，但它指向的东西变了，诶，初学指针……调WA调了很久，以至于都没时间写splay了。周末再写一写splay。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170706总结]]></title>
    <url>%2F20170706%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天学习了一些较为冗杂的小知识点。首先介绍了c++的stl库和algorithm。这些库里的东西虽然好用，但是从空间上和时间上来看，大多数不如手写，有时候为了降低代码复杂度可以使用，但是不能用多了，否则MLE，M得太多甚至会成WA。stl库里有个角bitset的东西很玄学，和分块一样，它可以强行优化暴力，在某些问题上有大用。接着讲了k维偏序。口诀：一维排序，二维分治，三维数据结构。三维在分治的基础上套了一个树状数组或线段树，四维则类似，只是数据结构变成了树套树，代码复杂度应该很高。五维及以上若再套一层树，时间复杂度还不如暴力，因而应该直接暴力，这里就可以用前面讲得bitset优化了。k维偏序的题不太好写，可以多做做题，其中三维和五维最具代表性，可以见识一下。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170705总结]]></title>
    <url>%2F20170705%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天学习了可持久化线段树、主席树和线段树套线段树。三者都是与线段树相关的较难数据结构。可持久化线段树和主席树感觉写起来较为简单，模板细节也并不多（HDU4348除外），模板题很快写完了，就试着去写HDU4348。这道题是主席树带区间修改，而每次都downtag则会MLE，因而只能不下放lazy标记，在询问的时候一路累加。累加的一步分类较多，应注意细节。调了很久，从TLE变成MLE又变成WA，因为对拍若每个数的值都小，则都没错，所以个人认为应该是longlong操作的错误，毕竟大数据爆成了负数。线段树套线段树虽然是第一次接触，但是因为接触过二维树状数组，理解起来也不难。代码虽短，但有些细节，最恼火的是二维不好调，因而肉眼查错很重要。树套树若加入平衡树，一定会很难，得多写题，多背模板，防止小错调半天。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170704总结]]></title>
    <url>%2F20170704%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是数据结构的第二天。上午考试，题目难度适中。T1考读题，较水。T2是线段树的奇葩用法，和普通用法不同，它是只递归单区间，另一区间则转化计算。T3是昨天讲过的题，线段树套单调队列，因为代码较为复杂，没能调出来。综上可知，线段树一些较难的题都是不具有合并性质的线段树或有限制（后效性）的线段树，一般只能得出左右两区间中其中一个区间的算法，另一区间则不断递归完成。两个区间有一个区间根本不去算，而是递归，这样让我感觉有些虚，经常想不清楚，应多加练习。下午先讲了dfs序列，这类题一般可以用树剖来做（前天第一次写，一直没调出来/(ㄒoㄒ)/~~），其中较难的是括号序列，尽管听懂了，但题目变化很多，需要练一练题。接着讲了几种并查集进阶，即带权并查集、可撤销并查集（貌似漏了种类并查集），这部分题目不难，只是实现的时候要注意细节，以防被卡常数。然后讲了分块，这种玄学的暴力优化在很多时候都有用，因为出题人预测不到，而且好写好调，性价比高，是个好东西。最后是传说中的莫队算法。这种算法号称“可以解决一切RMQ”，只是有时候容易卡常数，因而需要多加练习，用最好的写法。今天的题目比较难，得多消化消化。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170703总结]]></title>
    <url>%2F20170703%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天开始就是数据结构了。上午先快速地复习了栈、队列、链表、堆等基础数据结构。在此之中，学长提到了dancing links和左偏树。前者是链表实现暴力，能在暴搜的时候作很大优化，后者是支持合并的堆，在某些题有用。接下来复习了线段树和树状数组。做了几道较难的题，见识一下这种数据结构的各种灵活变化。其中一道叫“图腾”的题让我受益匪浅。线段树和树状数组作为优化的时候经常出现，而二位的线段树和树状数组则不常用，除了模板题就没什么应用了。写了几道模板题练手，现在把线段树写熟了，可以考虑开始压代码，毕竟原理什么的都很清楚，压代码也不会到调不出来的地步。下午做vjudge的题。其中一道是树链剖分的题，以前没学过，今天花了两个小时学写树剖。（CSDN某神犇对把树链映射到线段树上的讲解太过省略，想了半天才想清楚）因为是两个部分，因而代码量适中偏大，调了很久才搞对。得多写写树剖的题，熟悉模板，这样就会越写越熟。线段树的变形很多，需要多加练习。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170701总结]]></title>
    <url>%2F20170701%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是dp的最后一节课。上午讲了最后两种较难的dp，即状压和数位。状压dp我较为熟悉，思想和细节都不复杂。而数位dp虽然思想也较为简单，但从写码的细节上来说，较为复杂，会涉及到分类。周日写两道数位dp的题来看看。下午是dp优化。先复习了凸包算法（Graham水平扫描），然后讲斜率优化。这种优化思想是把dp方程转化成(y2-y1)/(x2-x1)&lt;c或(y2-y1)/(x2-x1)&gt;c的形式，其中c是常数，描出所有的(x,y)，然后用凸包求上凸壳或下凸壳，使得dp过程中所用的总是可用的最优状态。接下来是矩阵快速幂优化，个人觉得就是把连加的dp方程转化成连乘的dp方程，转化为幂后就可用矩阵快速幂了。这两种方法都对数学有要求，虽然听起来不难，但自己推会有些困难，应多加练习。最后是杂题选讲，其实就是对前面两种优化的巩固，题目的dp方程转换模式都是差不多的。dp优化需要多写写题，希望以后在考试中能接触到。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170630总结]]></title>
    <url>%2F20170630%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是dp的第二天，主讲树形dp，题目较难。早上考试，看到题目有些难，想做快些，结果把T1题意看错，得不偿失。T3也因此没有时间把记忆化改为dp。不过T2的确很难，是著名的鹰蛋问题。这道题的正解很有意思，有时间可以写一写。下午是树形dp的讲解，复习了经典的找直径、重心和“没有上司的舞会”这一经典题目。随后BZOJ“创世纪”一题将“没有上司的舞会”拓展到基环树上。接着是CodeForces的一道比赛题，因为没有怎么接触过树上背包，对此类问题有些生疏，故听得有些朦胧。树形dp后，又将了DAG中的dp。此类问题和树形dp差不多，只是根据题意有所区别，更为灵活。最后讲了k-regular问题，即构造一个无向图使每个点度为k，且有一个桥。在此给出构造方法（复习一遍，加深印象）：若k为偶数，则无解。若k为奇数，先构造一个k-1个结点的完全图，节点编号为0-（k-2），接着删去t到t^1这些边，每个点的度都为k-3了。然后再新建3个点，分别向原来的k-1个点连线，于是原来的k-1个点度都为k，3个新点度都为k-1。在这三个点中任选两个相连。现在把整个图复制一遍，变为两个图，把这两个图中度为k-1的两个点连起来，这样就有桥了。今天的题目整体较难，得写一些以加深印象。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170629总结]]></title>
    <url>%2F20170629%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天进入dp。上午讲了基础的dp，把记忆化、背包、区间的dp又复习了一遍。区间dp虽然状态转移方程较为好写，但我还是不太能在短时间内理出循环递推的顺序，得多写些题熟练一下。接着讲了几道较难的dp，我没有想出正解，但听了思路之后也是长了见识，虽然状态和转移方程都能确定，但没能想出合理有效的优化。下午考试较为简单，因为是dp，我强迫自己写了dp，没有暴力骗分（虽然数据水，暴力搜索能拿大部分分）。T1记忆化搜索写错了一个数组，WA了，尴尬,,???,,……T2可以用线段树优化，但因花大部分时间在T1，又不确定线段树能否写对，就并没有优化，但因数据过水，居然A了。T3想到了正解，但在枚举约束的时候忘记可以只枚举1到根号n了，时间较为仓促。今天的时间安排不太好，在最难的T1花了太多时间，简单的T3居然T了。此外，应多熟悉位运算，T1的思路和异或有很大关系，若先前知道很多性质，T1就不会花太多时间了。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170628总结]]></title>
    <url>%2F20170628%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是图论的最后一节课，除了网络流外都上完了。复习了欧拉路、拓扑，重新熟悉了代码。对于连通分量，复习了有向图的tarjan和割点割边，新学了无向图里的边双和点双连通分量。圆桌会议那道题虽然懂了，但自愧写不出来那样巧妙的代码。接下来是2-SAT，隐隐约约懂了，但推起细节却又有些模糊，2-SAT问题很玄妙，得花时间多理解理解。最后是最短路，给了几道比较难的题，但常用的做法就是拆点或在每个状态跑一遍SPFA，最后一道二分答案+最短路的题很精妙，但估计我调不出来。上午和中午的课余时间把昨天的三道题都调出来了。图论就是这样，难想，难建模，但想出来就是模板（可能综合几个模板）。下午考试很难，T1完全没想到是拓扑，甚至怀疑这不是图论，但听了评讲后觉得还是蛮简单的。T2想到了DFS序，又因时间复杂度想了3种优化，只可惜连记录进入时间戳都想到了，居然没想到打出来的时间戳，很冤。T3的确没有思路，因为没来得及听dogher大神讲，晚上问了杨林翰。听完觉得很精妙，有点像2-SAT的那种推理方式，但又有许多不同。对于图论，我还得加强建模的训练。明天开始就是DP了，我的弱项，希望RP++吧]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170627总结]]></title>
    <url>%2F20170627%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天进入真正的图论，复习了DFS序、LCA和最小生成树。LCA的两种方法，倍增写得很熟，RMQ则不那么熟练，学长提及了玄学的ST表，于是又把这个构造O(n)查询O(1)的神奇结构复习了一遍。我记得RMQ除了线段树，树状数组和ST表以外，还有一种叫莫队的东西。我九上的时候接触过，现在都忘完了，期待过几天讲数据结构的时候能遇到。关于最小生成树，虽然知道kruskal和prim两种算法，但是自己感觉这个东西如果研究深了也是很棘手的。比如今天的例题NOI2014魔法森林，虽然费劲脑力听懂了思路，但是自愧写不出来，对代码要求很高。增量最小生成树和次小生成树我都在CSDN上看了博客，思路清晰了，但是不知道写的时候会不会出问题。学长最后讲的有向图最小生成树，即最小树形图，我没听懂，因为时间匆忙，也没有问，得多研究研究CSDN的两篇博文。下午考试三道打baoli居然还得了130，意料之外。三道题都比较难。T1和货车运输很像，因为写过货车运输，惯性思维就想到LCA，事实证明我想复杂了。这道题多用笔画画图应该能想出正解。T2也是差一点想到正解，也是想复杂了。这里我总结出一种化繁为简的思考方法，即不要全面地考虑整个问题，应该把它分成子问题，逐个击破，而且想一个子问题的时候就不要受另外子问题的干扰。这道题我做复杂了，写了一个SPFA，两个BFS，一个DFS才写出来，不过我能在40分钟把它写和调出来还是值得欣慰的，看来多考考对代码能力提升很大。T3貌似数据有些问题，到现在还不知道怎么做，等明天大神讲。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170626总结]]></title>
    <url>%2F20170626%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天是图论的第一节课。上午图论入门，讲了位运算和搜索。位运算虽然简单，但用处巨大，特别是在搜索和DP中。复习了一下lowbit的原理，新学了求1个数的平行算法（虽然可以打表，但是了解一下算数算法保险一些）。我自己学状压dp的时候学过子集枚举，现在重温以便，发现还不够熟悉，希望过几天讲dp的时候能在熟练一下。搜索作为一项基本功，还是很重要的。DFS和BFS就不说了，后面讲的双向BFS和迭代加深虽然以前知道原理，但没有实现过。希望这几天的考试题里能有所涉及，毕竟现在时间较紧，除了课上的例题和考试就没有多少机会调题了。A*算法有点没懂，明天去问问。今天貌似没有讲启发式搜索，记忆化搜索也只是点了一下，这两种搜索我还不会，希望以后有机会接触。搜索题都是能想不会做，斗地主和八数码我都调不出来，还得提升代码能力。下午的题较为简单。三道题应该都是有原题出处的。T1改编自JSOI星球大战，以前做过，不难想到离线并查集。T2貌似见过，不过我以前好像没做过，考场上想出一个用优先队列的做法，虽然能过六个点，复杂度还是较高。标程的二分答案的确没想到。上次考分治也没想到，看来得刷点分治的题。T3是经典省选题，以前一直不会做。今天听了剪枝优化的方法，按位搜索还好，但倒着搜则显得有些突兀，不知道是怎么想到的，毕竟正搜倒搜和数据有很大关系。这和NOIP提高组的靶形数独很像。以后多积累些经验，就应该能直到什么时候要倒搜了。现在时间越来越紧了，需要调整作息，保证所花时间都有最高效益。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170623总结]]></title>
    <url>%2F20170623%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[上午继续听dogther大神的课，复习了贪心、二分答案、三分答案。我一直没有系统地刷过贪心的题，今天大神将贪心的各类题都过了一遍，都懂了，只是不知道写码的时候会不会出现问题。贪心的例题里k叉的哈夫曼树以前没见过，看来和二叉的哈夫曼树还有点区别。此外，还有两道字典树上的贪心，思想都懂了，可能写码会有些细节上的问题。三分答案的精度一直是个问题，我只A了一道模板题，连经典的铁人两项都没过，周末再调调。下午考试，整体难度比昨天难。T1想到了贪心，但是据大神说“很容易想到这种有漏洞的方法”(T_T)~~花了一个小时写出来的才得30分。T2枚举的时候就有错，思路上就错完了，还花了一个半小时写高精，看来以后得想清楚在写，不能忽略自己的感觉（写到一半就有WA的感觉）。T3很难，的确没想到，第1个和第2个点是手玩的，考完才发现第3个点也可以手玩，可惜啊，做的时候看到n=1000就吓到了。提交答案题找规律和特殊数据是很重要的，下次注意。考完听大神讲T3，将了三种策略，包括较为常规的“转换为标准图”、玄学的分治和完全没想到的平衡树旋转。平衡树还可以这样用，真是开了眼界。看来得好好搞搞平衡树（我寒假花了一周在CSDN上看，结果连SBTree都写不好，代码量太大啊）这几天连续听难题感觉思维稍微打开一点了，希望能保持这种状态。另外，考试对思维帮助相当大，这样再多考几次思维就容易打开了o(￣▽￣)ブ]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20170622总结]]></title>
    <url>%2F20170622%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[上午听dogther大神的课，重新学配vim，并复习了二分大神讲得很清楚，将所有基础知识点都复习了一遍，只可惜讲对拍的时候演示得太快，没学会大神在cpp程序内调用对拍的方法，只能苦逼地写脚本/(ㄒoㄒ)/~~听课之余复习了一下前天的ACautomation，又写了一道题（简单题，解密码，解完就是标准模板），发现貌似setFail有很多地方可以缩码，只是现下掌握不算熟练，多做点题后再压。AC自动机的dp题很有意思，有空可以研究研究。下午考试花式翻车，不过自己思想上还是差一截，难题做得不够，而且以前遇到难题想不了多久就放弃了。希望以后考试能够适应，毕竟考试逼着我多想。回来之后在调试，T1T2没太大问题（现在正在调T2），T3可能有点麻烦，虽然懂思想，但大神说这题细节多，要调很久，明天可以多调一下。我做的题还不多，难题就更少了，只能把接触到的题都保证调好，能多见识点就多见识点。]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax]]></title>
    <url>%2FMathJax%2F</url>
    <content type="text"><![CDATA[$O(n\sqrt{n})$ $$\begin{aligned}\nabla\cdot\vec{E} &amp;= \frac{\rho}{\epsilon_0} \\\nabla\cdot\vec{B} &amp;= 0 \\\nabla\times\vec{E} &amp;= -\frac{\partial B}{\partial t} \\\nabla\times\vec{B} &amp;= \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)\end{aligned}$$]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
