<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NIRVANA</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://azrael.top/"/>
  <updated>2018-03-27T12:22:40.679Z</updated>
  <id>http://azrael.top/</id>
  
  <author>
    <name>Azrael_Death</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ4695 最假女选手 &lt; SegBeats &gt;</title>
    <link href="http://azrael.top/BZOJ4695%20%E6%9C%80%E5%81%87%E5%A5%B3%E9%80%89%E6%89%8B%20SegBeats/"/>
    <id>http://azrael.top/BZOJ4695 最假女选手 SegBeats/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-03-27T12:22:40.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="最假女选手"><a href="#最假女选手" class="headerlink" title="最假女选手"></a>最假女选手</h3><p>$\mathrm{Time\;Limit:\;50\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在刚刚结束的水题嘉年华的压轴节目放水大赛中，$\mathrm{wyywyy}$如愿以偿的得到了最假女选手的奖项。但是作为主办人的$\mathrm{C_SUNSHINE}$为了证明$\mathrm{wyywyy}$确实在放水，决定出一道基础题考察$\mathrm{wyywyy}$的姿势水平。给定一个长度为$N$序列，编号从$1$到$N$。要求支持下面几种操作：</p><ol><li>给一个区间$[L,R]$加上一个数$x$ </li><li>把一个区间$[L,R]$里小于$x$的数变成$x$</li><li>把一个区间$[L,R]$里大于$x$的数变成$x$ </li><li>求区间$[L,R]$的和</li><li>求区间$[L,R]$的最大值</li><li>求区间$[L,R]$的最小值</li></ol><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数$N$表示序列长度<br>第二行$N$个整数$A_i$表示初始序列<br>第三行一个整数$M$表示操作个数<br>接下来$M$行，每行三或四个整数，第一个整数$Tp$表示操作类型，接下来$L,R,X$或$L,R$表述操作数</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个$4,5,6$类型的操作，输出一行一个整数表示答案<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2</span><br><span class="line">2 1 2 2</span><br><span class="line">4 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le Tp\le6,\;N,M\le5\times10^5,\;|A_i|\le10^8$<br>$Tp=1$时,$|x|\le1000$<br>$Tp=2$或$3$时，$|x|\le10^8$</p><p>标签：<code>SegBeats</code> <code>线段树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{Segment\;Tree\;Beats!}$<br>参见<a href="https://pan.baidu.com/s/1o7xSSQ2" target="_blank" rel="noopener">吉老师的冬令营课件</a>。</p><p>像课件里那样维护最大值、最大值个数、严格次大值、最小值、最小值个数、严格次小值、区间加标记、区间和，丧心病狂分类更新即可。注意只有区间和需要开$\mathrm{long\;long}$，这样即省空间又省常数。</p><p>好久没写过上$140$行的代码了…<br>强烈建议先对拍再交，否则容易卡住评测…</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (v&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (v&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> mx1, mx2, mxc, mi1, mi2, mic, tag;lnt s;&#125; tr[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">tr[v].s = tr[ls].s+tr[rs].s;</span><br><span class="line"><span class="keyword">if</span> (tr[ls].mx1 == tr[rs].mx1)</span><br><span class="line">tr[v].mx1 = tr[ls].mx1, </span><br><span class="line">tr[v].mxc = tr[ls].mxc+tr[rs].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx2, tr[rs].mx2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].mx1 &gt; tr[rs].mx1)</span><br><span class="line">tr[v].mx1 = tr[ls].mx1, </span><br><span class="line">tr[v].mxc = tr[ls].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx2, tr[rs].mx1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx1 = tr[rs].mx1, </span><br><span class="line">tr[v].mxc = tr[rs].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx1, tr[rs].mx2);</span><br><span class="line"><span class="keyword">if</span> (tr[ls].mi1 == tr[rs].mi1)</span><br><span class="line">tr[v].mi1 = tr[ls].mi1, </span><br><span class="line">tr[v].mic = tr[ls].mic+tr[rs].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi2, tr[rs].mi2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].mi1 &lt; tr[rs].mi1)</span><br><span class="line">tr[v].mi1 = tr[ls].mi1, </span><br><span class="line">tr[v].mic = tr[ls].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi2, tr[rs].mi1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mi1 = tr[rs].mi1, </span><br><span class="line">tr[v].mic = tr[rs].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi1, tr[rs].mi2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">tr[v].s -= <span class="number">1L</span>L*tr[v].mxc*(tr[v].mx1-x);</span><br><span class="line">tr[v].mx1 = x, tr[v].mi1 = min(x, tr[v].mi1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1^tr[v].mi1) tr[v].mi2 = min(x, tr[v].mi2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, </span><br><span class="line">tr[v].s = <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x, tr[v].mxc = tr[v].mic = t-s+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">tr[v].s += <span class="number">1L</span>L*tr[v].mic*(x-tr[v].mi1);</span><br><span class="line">tr[v].mi1 = x, tr[v].mx1 = max(x, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1^tr[v].mi1) tr[v].mx2 = max(x, tr[v].mx2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, </span><br><span class="line">tr[v].s = <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x, tr[v].mxc = tr[v].mic = t-s+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = tr[v].tag;tr[v].tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x)</span><br><span class="line">tr[ls].mx1 += x, tr[ls].mx2 += x, </span><br><span class="line">tr[ls].mi1 += x, tr[ls].mi2 += x, </span><br><span class="line">tr[ls].s += <span class="number">1L</span>L*(mid-s+<span class="number">1</span>)*x, tr[ls].tag += x, </span><br><span class="line">tr[rs].mx1 += x, tr[rs].mx2 += x, </span><br><span class="line">tr[rs].mi1 += x, tr[rs].mi2 += x, </span><br><span class="line">tr[rs].s += <span class="number">1L</span>L*(t-mid)*x, tr[rs].tag += x;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt; tr[ls].mx1 &amp;&amp; tr[v].mx1 &gt; tr[ls].mx2) updmx(ls, s, mid, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt; tr[ls].mi1 &amp;&amp; tr[v].mi1 &lt; tr[ls].mi2) updmi(ls, s, mid, tr[v].mi1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt; tr[rs].mx1 &amp;&amp; tr[v].mx1 &gt; tr[rs].mx2) updmx(rs, mid+<span class="number">1</span>, t, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt; tr[rs].mi1 &amp;&amp; tr[v].mi1 &lt; tr[rs].mi2) updmi(rs, mid+<span class="number">1</span>, t, tr[v].mi1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;</span><br><span class="line"><span class="keyword">int</span> x;read(x);</span><br><span class="line">tr[v].mx1 = tr[v].mi1 = x, tr[v].mxc = tr[v].mic = <span class="number">1</span>;</span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, tr[v].s = x;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">build(ls, s, mid), build(rs, mid+<span class="number">1</span>, t), update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">tr[v].mx1 += x, tr[v].mx2 += x;</span><br><span class="line">tr[v].mi1 += x, tr[v].mi2 += x;</span><br><span class="line">tr[v].s += <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x;</span><br><span class="line">tr[v].tag += x;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) modify(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) modify(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt;= x) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r &amp;&amp; x &lt; tr[v].mi2)</span><br><span class="line">&#123;updmi(v, s, t, x);<span class="keyword">return</span>;&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) optmx(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) optmx(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt;= x) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r &amp;&amp; x &gt; tr[v].mx2)</span><br><span class="line">&#123;updmx(v, s, t, x);<span class="keyword">return</span>;&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) optmi(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) optmi(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].s;</span><br><span class="line">downtag(v, s, t);lnt ret = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret += query(ls, s, mid, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret += query(rs, mid+<span class="number">1</span>, t, l, r);</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].mx1;</span><br><span class="line">downtag(v, s, t);<span class="keyword">int</span> ret = -INF;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret = max(ret, getmx(ls, s, mid, l, r));</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret = max(ret, getmx(rs, mid+<span class="number">1</span>, t, l, r));</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].mi1;</span><br><span class="line">downtag(v, s, t);<span class="keyword">int</span> ret = INF;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret = min(ret, getmi(ls, s, mid, l, r));</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret = min(ret, getmi(rs, mid+<span class="number">1</span>, t, l, r));</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, T;read(n), build(<span class="number">1</span>, <span class="number">1</span>, n), read(T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, l, r, x;read(opt);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) read(l), read(r), read(x), modify(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">2</span>) read(l), read(r), read(x), optmx(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">3</span>) read(l), read(r), read(x), optmi(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">4</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">5</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmx(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">6</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmi(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;最假女选手&quot;&gt;&lt;a href=&quot;#最假女选手&quot; class=&quot;headerlink&quot; title=&quot;最假女选手&quot;&gt;&lt;/a&gt;最假女选手&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;50\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在刚刚结束的水题嘉年华的压轴节目放水大赛中，$\mathrm{wyywyy}$如愿以偿的得到了最假女选手的奖项。但是作为主办人的$\mathrm{C_SUNSHINE}$为了证明$\mathrm{wyywyy}$确实在放水，决定出一道基础题考察$\mathrm{wyywyy}$的姿势水平。给定一个长度为$N$序列，编号从$1$到$N$。要求支持下面几种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给一个区间$[L,R]$加上一个数$x$ &lt;/li&gt;
&lt;li&gt;把一个区间$[L,R]$里小于$x$的数变成$x$&lt;/li&gt;
&lt;li&gt;把一个区间$[L,R]$里大于$x$的数变成$x$ &lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的和&lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的最大值&lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的最小值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个整数$N$表示序列长度&lt;br&gt;第二行$N$个整数$A_i$表示初始序列&lt;br&gt;第三行一个整数$M$表示操作个数&lt;br&gt;接下来$M$行，每行三或四个整数，第一个整数$Tp$表示操作类型，接下来$L,R,X$或$L,R$表述操作数&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每个$4,5,6$类型的操作，输出一行一个整数表示答案&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1430 小猴打架 &lt; Prufer序列+组合数学 &gt;</title>
    <link href="http://azrael.top/BZOJ1430%20%E5%B0%8F%E7%8C%B4%E6%89%93%E6%9E%B6%20Prufer%E5%BA%8F%E5%88%97+%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <id>http://azrael.top/BZOJ1430 小猴打架 Prufer序列+组合数学/</id>
    <published>2018-03-23T16:00:00.000Z</published>
    <updated>2018-03-27T12:23:19.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="小猴打架"><a href="#小猴打架" class="headerlink" title="小猴打架"></a>小猴打架</h3><p>$\mathrm{Time\;Limit:\;5\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一开始森林里面有$N$只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过$N-1$次打架之后，整个森林的小猴都会成为好朋友。 现在的问题是，总共有多少种不同的打架过程。 比如当$N=3$时，就有$\lbrace1-2,1-3\rbrace$ $\lbrace1-2,2-3\rbrace$ $\lbrace1-3,1-2\rbrace$ $\lbrace1-3,2-3\rbrace$ $\lbrace2-3,1-2\rbrace$ $\lbrace2-3,1-3\rbrace$六种不同的打架过程。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个整数N，$N\le10^6$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，方案数$\mod{9999991}$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96</span><br></pre></td></tr></table></figure><p>标签：<code>Prufer序列</code> <code>组合数学</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由$\mathrm{Prufer}序列$可知，一棵有$n$个点的树与一个长为$n-2$的序列一一对应。那么确定出这样的序列的方案数即可确定最后形成的树的形态。易知这样的序列共有$n^{n-2}$个。再考虑构建树的顺序，即为$n-1$个元素的全排列数，总数为$(n-1)!$。故答案为 $n^{n-2}-(n-1)!\mod{9999991}$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 9999991</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;lnt ans = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-2</span>; i++) (ans *= <span class="number">1L</span>L*n) %= MOD; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) (ans *= <span class="number">1L</span>L*i) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;小猴打架&quot;&gt;&lt;a href=&quot;#小猴打架&quot; class=&quot;headerlink&quot; title=&quot;小猴打架&quot;&gt;&lt;/a&gt;小猴打架&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;5\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一开始森林里面有$N$只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过$N-1$次打架之后，整个森林的小猴都会成为好朋友。 现在的问题是，总共有多少种不同的打架过程。 比如当$N=3$时，就有$\lbrace1-2,1-3\rbrace$ $\lbrace1-2,2-3\rbrace$ $\lbrace1-3,1-2\rbrace$ $\lbrace1-3,2-3\rbrace$ $\lbrace2-3,1-2\rbrace$ $\lbrace2-3,1-3\rbrace$六种不同的打架过程。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一个整数N，$N\le10^6$&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一行，方案数$\mod{9999991}$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="组合数学" scheme="http://azrael.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Prufer序列" scheme="http://azrael.top/tags/Prufer%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1027【JSOI2007】合金 &lt;凸包+Floyed&gt;</title>
    <link href="http://azrael.top/BZOJ1027%E3%80%90JSOI2007%E3%80%91%E5%90%88%E9%87%91%20%E5%87%B8%E5%8C%85+Floyed/"/>
    <id>http://azrael.top/BZOJ1027【JSOI2007】合金 凸包+Floyed/</id>
    <published>2018-03-22T16:00:00.000Z</published>
    <updated>2018-03-27T11:53:43.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【JSOI2007】合金"><a href="#【JSOI2007】合金" class="headerlink" title="【JSOI2007】合金"></a>【JSOI2007】合金</h3><p>$\mathrm{Time\;Limit:\;4\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了$n$种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数$m$和$n$$(m,n\le500)$，分别表示原材料种数和用户需要的合金种数。第$2$到$m+1$行，每行三个实数$a,b,c(a,b,c\ge0且a+b+c=1)$，分别表示铁铝锡在一种原材料中所占的比重。第$m+2$到$m+n+1$行，每行三个实数$a,b,c(a,b,c\ge0且a+b+c=1)$，分别表示铁铝锡在一种用户需要的合金中所占的比重。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数，表示最少需要的原材料种数。若无解，则输出$–1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br><span class="line">0.1 0.2 0.7</span><br><span class="line">0.2 0.3 0.5</span><br><span class="line">0.3 0.4 0.3</span><br><span class="line">0.4 0.5 0.1</span><br><span class="line">0.5 0.1 0.4</span><br><span class="line">0.6 0.2 0.2</span><br><span class="line">0.7 0.3 0</span><br><span class="line">0.8 0.1 0.1</span><br><span class="line">0.9 0.1 0</span><br><span class="line">1 0 0</span><br><span class="line">0.1 0.2 0.7</span><br><span class="line">0.2 0.3 0.5</span><br><span class="line">0.3 0.4 0.3</span><br><span class="line">0.4 0.5 0.1</span><br><span class="line">0.5 0.1 0.4</span><br><span class="line">0.6 0.2 0.2</span><br><span class="line">0.7 0.3 0</span><br><span class="line">0.8 0.1 0.1</span><br><span class="line">0.9 0.1 0</span><br><span class="line">1 0 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>标签：<code>凸包</code> <code>Floyed</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，给出的三个参数确定两个就能确定第三个，因此可以把参数缩减为两个。<br>考虑两种金属是否能造出第三种金属，若能造成，则第三种金属的两个参数必和这两种金属的参数成比例关系。<br>推广到用$k$种金属制造一种合金，若将这$k$种金属的两个参数作为横纵坐标描成点，那么合金所代表的点只要在这$k$个点形成的凸包内即可制造。<br>由此，题目转化为选出尽量少的点使得目标点都在选出点所构成的凸包内。</p><p>对于一个条有向线段，它能被选出到凸包上当且仅当所有目标点都在它的左侧。那么处理出所有这样的边后，我们就在点与点间连出了若干条边。我们需要尽量选尽量少的点，即选尽量少的边，使其构成凸包。这样直接跑$\mathrm{Floyed}$后枚举起始点即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;dnt,dnt&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">bool</span> G[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line">pdd p[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, f[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">pdd <span class="title">vec</span><span class="params">(pdd s, pdd t)</span> </span>&#123;<span class="keyword">return</span> mp(t.x-s.x, t.y-s.y);&#125;</span><br><span class="line"><span class="function">dnt <span class="title">dot</span><span class="params">(pdd a, pdd b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.x+a.y*b.y;&#125;</span><br><span class="line"><span class="function">dnt <span class="title">cross</span><span class="params">(pdd a, pdd b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(pdd s, pdd t, pdd a)</span> </span>&#123;</span><br><span class="line">dnt mul = cross(vec(a, s), vec(a, t));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(mul) &lt;= EPS &amp;&amp; dot(vec(a, s), vec(a, t)) &lt;= EPS) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">if</span> (mul &lt; -EPS) <span class="keyword">return</span> <span class="literal">true</span>;<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spj</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (<span class="built_in">fabs</span>(p[i].x-p[<span class="number">1</span>].x) &gt; EPS || <span class="built_in">fabs</span>(p[i].y-p[<span class="number">1</span>].y) &gt; EPS) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (<span class="built_in">fabs</span>(c[i].x-p[<span class="number">1</span>].x) &gt; EPS || <span class="built_in">fabs</span>(c[i].y-p[<span class="number">1</span>].y) &gt; EPS) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Floyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = INF;<span class="built_in">memset</span>(f, INF, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (G[i][j] &amp;&amp; i^j) f[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) f[i][j] = min(f[i][j], f[i][k]+f[k][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = min(ret, f[i][i]);</span><br><span class="line"><span class="keyword">return</span> spj() ? <span class="number">1</span> : (ret == INF ? <span class="number">-1</span> : ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), <span class="built_in">memset</span>(G, <span class="literal">true</span>, <span class="keyword">sizeof</span> G);dnt t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y, &amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;c[i].x, &amp;c[i].y, &amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (i^j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m &amp;&amp; G[i][j]; k++) G[i][j] &amp;= chk(p[i], p[j], c[k]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Floyed()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【JSOI2007】合金&quot;&gt;&lt;a href=&quot;#【JSOI2007】合金&quot; class=&quot;headerlink&quot; title=&quot;【JSOI2007】合金&quot;&gt;&lt;/a&gt;【JSOI2007】合金&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;4\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了$n$种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行两个整数$m$和$n$$(m,n\le500)$，分别表示原材料种数和用户需要的合金种数。第$2$到$m+1$行，每行三个实数$a,b,c(a,b,c\ge0且a+b+c=1)$，分别表示铁铝锡在一种原材料中所占的比重。第$m+2$到$m+n+1$行，每行三个实数$a,b,c(a,b,c\ge0且a+b+c=1)$，分别表示铁铝锡在一种用户需要的合金中所占的比重。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一个整数，表示最少需要的原材料种数。若无解，则输出$–1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="Floyed" scheme="http://azrael.top/tags/Floyed/"/>
    
      <category term="凸包" scheme="http://azrael.top/tags/%E5%87%B8%E5%8C%85/"/>
    
      <category term="计算机和" scheme="http://azrael.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1095【ZJOI2007】Hide捉迷藏 &lt;括号序列+线段树&gt;</title>
    <link href="http://azrael.top/BZOJ1095%E3%80%90ZJOI2007%E3%80%91Hide%E6%8D%89%E8%BF%B7%E8%97%8F%20%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97+%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ1095【ZJOI2007】Hide捉迷藏 括号序列+线段树/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-03-23T13:06:12.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【ZJOI2007】Hide捉迷藏"><a href="#【ZJOI2007】Hide捉迷藏" class="headerlink" title="【ZJOI2007】Hide捉迷藏"></a>【ZJOI2007】Hide捉迷藏</h3><p>$\mathrm{Time\;Limit:\;40\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>捉迷藏$\mathrm{Jiajia}$和$\mathrm{Wind}$是一对恩爱的夫妻，并且他们有很多孩子。某天，$\mathrm{Jiajia}$、$\mathrm{Wind}$和孩子们决定在家里玩捉迷藏游戏。他们的家很大且构造很奇特，由$N$个屋子和$N-1$条双向走廊组成，这$N-1$条走廊的分布使得任意两个屋子都互相可达。<br>游戏是这样进行的，孩子们负责躲藏，$\mathrm{Jiajia}$负责找，而$\mathrm{Wind}$负责操纵这$N$个屋子的灯。在起初的时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性，$\mathrm{Jiajia}$希望知道可能的最远的两个孩子的距离（即最远的两个关灯房间的距离）。<br>我们将以如下形式定义每一种操作：</p><ul><li>$\mathrm{C(hange)}\;i$ ：改变第$i$个房间的照明状态，若原来打开，则关闭；若原来关闭，则打开。</li><li>$\mathrm{G(ame)}$ ：开始一次游戏，查询最远的两个关灯房间的距离。</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数$N$，表示房间的个数，房间将被编号为$1,2,3\cdots N$的整数。接下来$N-1$行每行两个整数$a,b$，表示房间$a$与房间$b$之间有一条走廊相连。接下来一行包含一个整数$Q$，表示操作次数。接着$Q$行，每行一个操作，如上文所示。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一个操作$\mathrm{G(ame)}$，输出一个非负整数，表示最远的两个关灯房间的距离。<br>若只有一个房间是关着灯的，输出$0$；若所有房间的灯都开着，输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line">6 7</span><br><span class="line">6 8</span><br><span class="line">7</span><br><span class="line">G</span><br><span class="line">C 1</span><br><span class="line">G</span><br><span class="line">C 2</span><br><span class="line">G</span><br><span class="line">C 1</span><br><span class="line">G</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于$100\%$的数据，$N\le10^5,\;M\le5\times10^5$。</p><p>标签：<code>括号序列</code> <code>线段树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不会写动态点分，受<a href="http://www.shuizilong.com/house/archives/bzoj-1095-zjoi2007hide-%E6%8D%89%E8%BF%B7%E8%97%8F/" target="_blank" rel="noopener">小岛姐</a>的启发写了线段树，虽然有$7$个标记，但推出公式还是比较好写的。</p><p><strong>括号序列</strong><br>对于一棵树，我们可以将其$\mathrm{DFS}$序稍加优化，得到一个能记录每个点的子树结构的序列，即括号序列。<br>用左括号$($表示进入某点的子树，用右括号$)$表示走出某点的子树。<br><img src="https://images2015.cnblogs.com/blog/890886/201703/890886-20170304113106126-1381317123.png" alt=""></p><p>对于此树，括号序列为$(A(B)(C(D)(E)))$，可以看出括号序列有一个有用的性质，即仍两点之间的序列可以表示从前面的点走到后面的点的走法。例如对于点$B$和$E$，其中间的序列为$)(()($，如果去掉中间匹配的括号则变为$)(($，将$)$定义为向上走，将$($定义为向下走，那么可以看出$B$向上走两步，再向下走两步即可到$E$。那么如果维护此题中的树的括号序列，那么只需要知道任意两个黑点间的括号序列消除配对后的长度的最大值后即可得到答案。</p><p><strong>线段树维护</strong><br>对于一个序列的区间，可以用二元组$(a,b)$表示其消去配对后的序列，即有$a$个右括号和$b$个左括号。<br>对于区间$S_1(a_1,b_1)$和$S_2(a_2,b_2)$，它们合并起来的区间是$S(a,b)$，那么</p><ul><li>当$b_1&gt;a_2$时，$S_1$的左括号和$S_2$的右括号消去后一定会剩下$b_1-a_2$个左括号，因此$a=a_1-b_1+a_2$，$b=b_2$</li><li>当$b_1\le a_2$时，$S_1$的左括号和$S_2$的右括号消去后一定会剩下$a_2-b_1$个右括号，因此$a=a_1$，$b=-a_2+b_1+b_2$</li></ul><p>那么易得到几个推论：</p><ul><li>$a+b=a_1+a_2+|b_1-a_2|$</li><li>$a-b=a_1+a_2-b_1-b_2$</li><li>$b-a=-a_1-a_2+b_1+b_2$</li></ul><p>我们需要维护每个区间中两黑点间括号序列长度的最大值，那么我们还需要维护另外几个信息（有点像区间最大字段和）：</p><ul><li>$lp=\max\lbrace a+b|S’(a,b)是S的一个前缀，且一个黑点接在S’之后\rbrace$</li><li>$lm=\max\lbrace b-a|S’(a,b)是S的一个前缀，且一个黑点接在S’之后\rbrace$</li><li>$rp=\max\lbrace a+b|S’(a,b)是S的一个后缀，且S’接在一个黑点后\rbrace$</li><li>$rm=\max\lbrace a-b|S’(a,b)是S的一个后缀，且S’接在一个黑点后\rbrace$</li></ul><p>对于一个区间$S$，其两个子区间$S_1,S_2$的七个值分别为$a_1,b_1,lp_1,lm_1,rp_1,rm_1,dis_1$和$a_2,b_2,lp_2,lm_2,rp_2,rm_2,dis_2$，那么该区间的$dis$一定是以下四个值的最大值：</p><ul><li>$dis_1$</li><li>$dis_2$</li><li>$rp_1+lm_2$</li><li>$rm_1+lp_2$</li></ul><p>而对于维护的$4$个信息，观察发现可以这样计算：</p><ul><li>$lp=\max\lbrace lp_1,\;a_1-b_1+lp_2,\;a_1+b_1+lm_2\rbrace$</li><li>$lm=\max\lbrace lm_1,\;-a_1+b_1+lm_2\rbrace$</li><li>$rp=\max\lbrace rp_2,\;-a_2+b_2+rp_1,\;a_2+b_2+rm_1\rbrace$</li><li>$rm=\max\lbrace rm_2,\;a_2-b_2+rm_1\rbrace$</li></ul><p>这样以后我们就可以用线段树维护这七个标记了。<br>除了$update$有点长以外，其他都和裸线段树一样。</p><p>以后找时间把动态点分学一学吧。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, cnt, col[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ind, seq[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>], dfn[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> a, b, lp, lm, rp, rm, dis;&#125; tr[(MAX_N&lt;&lt;<span class="number">4</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;G[u].push_back(v), G[v].push_back(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">seq[++ind] = <span class="number">-1</span>, seq[++ind] = u, dfn[u] = ind;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> ((v = G[u][i]) ^ f) DFS(v, u);</span><br><span class="line">seq[++ind] = <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">tr[v].a = tr[v].b = <span class="number">0</span>, tr[v].dis = -INF;</span><br><span class="line"><span class="keyword">if</span> (seq[p] == <span class="number">-1</span>) tr[v].b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (seq[p] == <span class="number">-2</span>) tr[v].a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (seq[p] &gt; <span class="number">0</span> &amp;&amp; col[seq[p]])</span><br><span class="line">tr[v].lp = tr[v].lm = tr[v].rp = tr[v].rm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> tr[v].lp = tr[v].lm = tr[v].rp = tr[v].rm = -INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = tr[v&lt;&lt;<span class="number">1</span>].a, b = tr[v&lt;&lt;<span class="number">1</span>].b;</span><br><span class="line"><span class="keyword">int</span> c = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].a, d = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].b;</span><br><span class="line">tr[v].a = b &lt; c ? a-b+c : a;</span><br><span class="line">tr[v].b = b &lt; c ? d : b-c+d;</span><br><span class="line">tr[v].lp = tr[v&lt;&lt;<span class="number">1</span>].lp, tr[v].rp = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rp;</span><br><span class="line">tr[v].lm = tr[v&lt;&lt;<span class="number">1</span>].lm, tr[v].rm = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rm;</span><br><span class="line">tr[v].lp = max(tr[v].lp, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lp+a-b);</span><br><span class="line">tr[v].lp = max(tr[v].lp, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm+a+b);</span><br><span class="line">tr[v].lm = max(tr[v].lm, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm-a+b);</span><br><span class="line">tr[v].rp = max(tr[v].rp, tr[v&lt;&lt;<span class="number">1</span>].rp-c+d);</span><br><span class="line">tr[v].rp = max(tr[v].rp, tr[v&lt;&lt;<span class="number">1</span>].rm+c+d);</span><br><span class="line">tr[v].rm = max(tr[v].rm, tr[v&lt;&lt;<span class="number">1</span>].rm+c-d);</span><br><span class="line">tr[v].dis = max(tr[v&lt;&lt;<span class="number">1</span>].dis, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].dis);</span><br><span class="line">tr[v].dis = max(tr[v].dis, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm+tr[v&lt;&lt;<span class="number">1</span>].rp);</span><br><span class="line">tr[v].dis = max(tr[v].dis, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lp+tr[v&lt;&lt;<span class="number">1</span>].rm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;init(v, s);<span class="keyword">return</span>;&#125;</span><br><span class="line">build(v&lt;&lt;<span class="number">1</span>, s, mid), build(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t);</span><br><span class="line">update(v, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;init(v, s);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= mid) modify(v&lt;&lt;<span class="number">1</span>, s, mid, p);</span><br><span class="line"><span class="keyword">else</span> modify(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, p);</span><br><span class="line">update(v, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) col[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++)</span><br><span class="line">read(u), read(v), addedge(u, v);</span><br><span class="line"><span class="keyword">int</span> T;read(T), DFS(<span class="number">1</span>, <span class="number">0</span>), build(<span class="number">1</span>, <span class="number">1</span>, ind);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">2</span>];<span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line"><span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x;read(x);</span><br><span class="line">cnt += col[x] ? <span class="number">-1</span> : <span class="number">1</span>, col[x] ^= <span class="number">1</span>;</span><br><span class="line">modify(<span class="number">1</span>, <span class="number">1</span>, ind, dfn[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'G'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tr[<span class="number">1</span>].dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【ZJOI2007】Hide捉迷藏&quot;&gt;&lt;a href=&quot;#【ZJOI2007】Hide捉迷藏&quot; class=&quot;headerlink&quot; title=&quot;【ZJOI2007】Hide捉迷藏&quot;&gt;&lt;/a&gt;【ZJOI2007】Hide捉迷藏&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;40\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;捉迷藏$\mathrm{Jiajia}$和$\mathrm{Wind}$是一对恩爱的夫妻，并且他们有很多孩子。某天，$\mathrm{Jiajia}$、$\mathrm{Wind}$和孩子们决定在家里玩捉迷藏游戏。他们的家很大且构造很奇特，由$N$个屋子和$N-1$条双向走廊组成，这$N-1$条走廊的分布使得任意两个屋子都互相可达。&lt;br&gt;游戏是这样进行的，孩子们负责躲藏，$\mathrm{Jiajia}$负责找，而$\mathrm{Wind}$负责操纵这$N$个屋子的灯。在起初的时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性，$\mathrm{Jiajia}$希望知道可能的最远的两个孩子的距离（即最远的两个关灯房间的距离）。&lt;br&gt;我们将以如下形式定义每一种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\mathrm{C(hange)}\;i$ ：改变第$i$个房间的照明状态，若原来打开，则关闭；若原来关闭，则打开。&lt;/li&gt;
&lt;li&gt;$\mathrm{G(ame)}$ ：开始一次游戏，查询最远的两个关灯房间的距离。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含一个整数$N$，表示房间的个数，房间将被编号为$1,2,3\cdots N$的整数。接下来$N-1$行每行两个整数$a,b$，表示房间$a$与房间$b$之间有一条走廊相连。接下来一行包含一个整数$Q$，表示操作次数。接着$Q$行，每行一个操作，如上文所示。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每一个操作$\mathrm{G(ame)}$，输出一个非负整数，表示最远的两个关灯房间的距离。&lt;br&gt;若只有一个房间是关着灯的，输出$0$；若所有房间的灯都开着，输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="括号序列" scheme="http://azrael.top/tags/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1857【SCOI2010】传送带 &lt;三分法&gt;</title>
    <link href="http://azrael.top/BZOJ1857%E3%80%90SCOI2010%E3%80%91%E4%BC%A0%E9%80%81%E5%B8%A6%20%E4%B8%89%E5%88%86%E6%B3%95/"/>
    <id>http://azrael.top/BZOJ1857【SCOI2010】传送带 三分法/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-03-20T03:50:21.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2010】传送带"><a href="#【SCOI2010】传送带" class="headerlink" title="【SCOI2010】传送带"></a>【SCOI2010】传送带</h3><p>$\mathrm{Time\;Limit:\;1\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一个$2$维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段$AB$和线段$CD$。<br>$\mathrm{lxhgww}$在$AB$上的移动速度为$P$，在$CD$上的移动速度为$Q$，在平面上的移动速度$R$。<br>现在$\mathrm{lxhgww}$想从$A$点走到$D$点，他想知道最少需要走多长时间。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据第一行是$4$个整数，表示$A$和$B$的坐标，分别为$A_x,A_y,B_x,B_y$。<br>第二行是$4$个整数，表示$C$和$D$的坐标，分别为$C_x,C_y,D_x,D_y$。<br>第三行是$3$个整数，分别是$P,Q,R$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出数据为一行，表示$\mathrm{lxhgww}$从$A$点走到$D$点的最短时间，保留到小数点后$2$位。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 100</span><br><span class="line">100 0 100 100</span><br><span class="line">2 2 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">136.60</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于$100\%$的数据，$1\le A_x,A_y,B_x,B_y,C_x,C_y,D_x,D_y\le10^3$，$1\le P,Q,R\le10$。</p><p>标签：<code>三分法</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>三分套三分，据说有大学物理结论可以$\mathrm{O(1)}$做…<br>首先一定是从$A$走到$AB$上的一点$E$，然后走平面到$CD$上的一点$F$，最后从$F$沿$CD$走到$D$。<br>考虑确定$AB$上的$E$点，那么若将$F$点的所有位置都计算答案并画成函数图像，一定是一个单峰函数。那么确定$E$后可以三分法找到最佳$F$位置。<br>同样地，对于每个$E$位置的最佳答案，也会呈一个单峰函数。因此可以先对$E$在$AB$上进行三分，每次三分到的两个端点需要再对$F$在$CD$上进行三分找到最小时间。<br>这样一来，可以先在$AB$上三分$E$，每次三分找端点最值的时候再在$CD$上三分$F$，三分套三分即可找到答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xx first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yy second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;dnt,dnt&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">pdd A, B, C, D;dnt P, Q, R;</span><br><span class="line"><span class="function">dnt <span class="title">sqr</span><span class="params">(dnt x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function">dnt <span class="title">dis</span><span class="params">(pdd x, pdd y)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(x.xx-y.xx)+sqr(x.yy-y.yy));&#125;</span><br><span class="line"><span class="function">dnt <span class="title">tri_search_T</span><span class="params">(pdd l, pdd r, pdd S)</span> </span>&#123;</span><br><span class="line">dnt ret = dis(A, S)/dis(l, D)/Q+dis(S, l)/R;pdd llr, lrr;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(l.xx-r.xx) &gt; EPS || <span class="built_in">fabs</span>(l.yy-r.yy) &gt; EPS) &#123;</span><br><span class="line">llr = mp(l.xx+(r.xx-l.xx)/<span class="number">3</span>, l.yy+(r.yy-l.yy)/<span class="number">3</span>);</span><br><span class="line">lrr = mp(r.xx-(r.xx-l.xx)/<span class="number">3</span>, r.yy-(r.yy-l.yy)/<span class="number">3</span>);</span><br><span class="line">dnt tllr = dis(A, S)/P+dis(llr, D)/Q+dis(S, llr)/R;</span><br><span class="line">dnt tlrr = dis(A, S)/P+dis(lrr, D)/Q+dis(S, lrr)/R;</span><br><span class="line"><span class="keyword">if</span> (tllr &lt; tlrr) r = lrr; <span class="keyword">else</span> l = llr;</span><br><span class="line">ret = min(tllr, tlrr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">dnt <span class="title">tri_search_S</span><span class="params">(pdd l, pdd r)</span> </span>&#123;</span><br><span class="line">dnt ret = tri_search_T(C, D, l);pdd llr, lrr;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(l.xx-r.xx) &gt; EPS || <span class="built_in">fabs</span>(l.yy-r.yy) &gt; EPS) &#123;</span><br><span class="line">llr = mp(l.xx+(r.xx-l.xx)/<span class="number">3</span>, l.yy+(r.yy-l.yy)/<span class="number">3</span>);</span><br><span class="line">lrr = mp(r.xx-(r.xx-l.xx)/<span class="number">3</span>, r.yy-(r.yy-l.yy)/<span class="number">3</span>);</span><br><span class="line">dnt tllr = tri_search_T(C, D, llr);</span><br><span class="line">dnt tlrr = tri_search_T(C, D, lrr);</span><br><span class="line"><span class="keyword">if</span> (tllr &lt; tlrr) r = lrr; <span class="keyword">else</span> l = lrr;</span><br><span class="line">ret = min(tllr, tlrr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(A.xx), read(A.yy), read(B.xx), read(B.yy);</span><br><span class="line">read(C.xx), read(C.yy), read(D.xx), read(D.yy);</span><br><span class="line">read(P), read(Q), read(R);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, tri_search_S(A, B)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2010】传送带&quot;&gt;&lt;a href=&quot;#【SCOI2010】传送带&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2010】传送带&quot;&gt;&lt;/a&gt;【SCOI2010】传送带&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;1\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在一个$2$维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段$AB$和线段$CD$。&lt;br&gt;$\mathrm{lxhgww}$在$AB$上的移动速度为$P$，在$CD$上的移动速度为$Q$，在平面上的移动速度$R$。&lt;br&gt;现在$\mathrm{lxhgww}$想从$A$点走到$D$点，他想知道最少需要走多长时间。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入数据第一行是$4$个整数，表示$A$和$B$的坐标，分别为$A_x,A_y,B_x,B_y$。&lt;br&gt;第二行是$4$个整数，表示$C$和$D$的坐标，分别为$C_x,C_y,D_x,D_y$。&lt;br&gt;第三行是$3$个整数，分别是$P,Q,R$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出数据为一行，表示$\mathrm{lxhgww}$从$A$点走到$D$点的最短时间，保留到小数点后$2$位。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="三分法" scheme="http://azrael.top/tags/%E4%B8%89%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1068【SCOI2007】压缩 &lt;区间DP&gt;</title>
    <link href="http://azrael.top/BZOJ1068%E3%80%90SCOI2007%E3%80%91%E5%8E%8B%E7%BC%A9%20%E5%8C%BA%E9%97%B4DP/"/>
    <id>http://azrael.top/BZOJ1068【SCOI2007】压缩 区间DP/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-03-21T15:08:41.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2007】压缩"><a href="#【SCOI2007】压缩" class="headerlink" title="【SCOI2007】压缩"></a>【SCOI2007】压缩</h3><p>$\mathrm{Time\;Limit:\;1\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母$\mathrm{R}$与$\mathrm{M}$，其中$\mathrm{M}$标记重复串的开始，$\mathrm{R}$重复从上一个$\mathrm{M}$（如果当前位置左边没有$\mathrm{M}$，则从串的开始算起）开始的解压结果（称为缓冲串）。 $\mathrm{bcdcdcdcd}$可以压缩为$\mathrm{bMcdRR}$，下面是解压缩的过程：<br><img src="http://www.lydsy.com/JudgeOnline/images/1068/1.jpg" alt=""></p><p>另一个例子是$\mathrm{abcabcdabcabcdxyxyz}$可以被压缩为$\mathrm{abcRdRMxyRz}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入仅一行，包含待压缩字符串，仅包含小写字母，长度为$n$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出仅一行，即压缩后字符串的最短长度。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p><strong>Input #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaa</span><br></pre></td></tr></table></figure></p><p><strong>Input #2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdcdcdcdxcdcdcdcd</span><br></pre></td></tr></table></figure></p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p><strong>Output #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><p><strong>Output #2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure></p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p><strong>样例解释</strong><br>在第一个样例中，解为$\mathrm{aaaRa}$，在第二个例子中，解为$\mathrm{bMcdRRxMcdRR}$。<br><strong>数据规模</strong><br>$100\%$的数据满足$1\le n\le50$</p><p>标签：<code>区间DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>每次压缩的是连续的一段，考虑区间$\mathrm{DP}$。</p><p>设$f[l][r]$表示压缩字符串$s$的字串$s[l..r]$的最短长度，其中压缩后的串串首自带一个$\mathrm{M}$于是就会有两种转移：</p><ul><li>$f[l][r]=\min_{i=l}^{r-1}(f[l][i]+f[i+1][r])$</li><li>若$s[l..mid]=s[mid+1..r]$，则$f[l][r] = \min(f[l][r],f[l][mid]+2)$</li></ul><p>但这样是有锅的…压缩后串中间的$\mathrm{M}$会影响到后面的$\mathrm{R}$。<br>例如$\mathrm{orzwxhakakorzwxhakak}$，显然$\mathrm{orzwxhMakR}$为一种压缩，但其复制一遍形成的$\mathrm{MorzwxhMakRR}$表示的不是原串。这是因为中间的$\mathrm{M}$会使后面的$\mathrm{R}$少复制一截。</p><p>于是我们调整状态定义，定义$f[l][r][0]$表示压缩后除了串首不再含有任何一个$\mathrm{M}$，$f[l][r][1]$表示压缩后除了串首还含有其他$\mathrm{M}$，这样前者是可以整体复制的，而后者不行。<br>那么首先有边界条件$f[i][i][1]=2\;(i\in[1,n])$。<br>转移有三种：</p><ul><li>$f[l][r][0]=\min_{i=l}^{r-1}(f[l][i][0]+r-i)$，表示直接把后缀接上去</li><li>$f[l][r][0]=\min(f[l][r][0],f[l][mid][0]+1)$，其中$s[l..mid]=s[mid+1..r]$，表示把前一半复制一遍</li><li>$f[l][r][1]=\min_{i=l}^{r-1}(\min(f[l][i][0],f[l][i][1])+\min(f[i+1][r][0],f[i+1][r][1]))$，表示分成两半随便拼，只不过拼了以后不能复制，因为中间有$\mathrm{M}$</li></ul><p>直接记忆化即可，注意第三种情况要判左右边界。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>][<span class="number">2</span>];<span class="keyword">char</span> s[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;ret = f[l][r][x];</span><br><span class="line"><span class="keyword">if</span> (ret^INF) <span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">if</span> (l == r &amp;&amp; !x) <span class="keyword">return</span> ret = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">ret = min(ret, DP(l, i, <span class="number">0</span>)+DP(i+<span class="number">1</span>, r, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (l &lt; i) ret = min(ret, DP(l, i, <span class="number">0</span>)+DP(i+<span class="number">1</span>, r, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (i+<span class="number">1</span> &lt; r) ret = min(ret, DP(l, i, <span class="number">1</span>)+DP(i+<span class="number">1</span>, r, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (l &lt; i &amp;&amp; i+<span class="number">1</span> &lt; r) ret = min(ret, DP(l, i, <span class="number">1</span>)+DP(i+<span class="number">1</span>, r, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++)</span><br><span class="line">ret = min(ret, DP(l, i, <span class="number">0</span>)+r-i);</span><br><span class="line"><span class="keyword">bool</span> flag = (r-l)%<span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>; i &lt;= mid; i++, j++)</span><br><span class="line"><span class="keyword">if</span> (s[i]^s[j]) flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) ret = min(ret, DP(l, mid, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>), n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(f, INF, <span class="keyword">sizeof</span> f), DP(<span class="number">1</span>, n, <span class="number">0</span>), DP(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, min(f[<span class="number">1</span>][n][<span class="number">0</span>], f[<span class="number">1</span>][n][<span class="number">1</span>])<span class="number">-1</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2007】压缩&quot;&gt;&lt;a href=&quot;#【SCOI2007】压缩&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2007】压缩&quot;&gt;&lt;/a&gt;【SCOI2007】压缩&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;1\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母$\mathrm{R}$与$\mathrm{M}$，其中$\mathrm{M}$标记重复串的开始，$\mathrm{R}$重复从上一个$\mathrm{M}$（如果当前位置左边没有$\mathrm{M}$，则从串的开始算起）开始的解压结果（称为缓冲串）。 $\mathrm{bcdcdcdcd}$可以压缩为$\mathrm{bMcdRR}$，下面是解压缩的过程：&lt;br&gt;&lt;img src=&quot;http://www.lydsy.com/JudgeOnline/images/1068/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;另一个例子是$\mathrm{abcabcdabcabcdxyxyz}$可以被压缩为$\mathrm{abcRdRMxyRz}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入仅一行，包含待压缩字符串，仅包含小写字母，长度为$n$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出仅一行，即压缩后字符串的最短长度。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="区间DP" scheme="http://azrael.top/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3597【SCOI2014】方伯伯运椰子 &lt;费用流&gt;</title>
    <link href="http://azrael.top/BZOJ3597%E3%80%90SCOI2014%E3%80%91%E6%96%B9%E4%BC%AF%E4%BC%AF%E8%BF%90%E6%A4%B0%E5%AD%90%20%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ3597【SCOI2014】方伯伯运椰子 费用流/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2018-03-16T06:17:24.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2014】方伯伯运椰子"><a href="#【SCOI2014】方伯伯运椰子" class="headerlink" title="【SCOI2014】方伯伯运椰子"></a>【SCOI2014】方伯伯运椰子</h3><p>$\mathrm{Time\;Limit:\;30\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="http://www.lydsy.com/JudgeOnline/upload/201503/f1.PNG" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含二个整数$N$,$M$。<br>接下来$M$行代表$M$条边，表示这个交通网络。<br>每行六个整数，表示$U_i,V_i,A_i,B_i,C_i,D_i$。<br>接下来一行包含一条边，表示连接起点的边。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个浮点数，保留二位小数。表示答案，数据保证答案大于$0$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">1 5 13 13 0 412</span><br><span class="line">2 5 30 18 396 148</span><br><span class="line">1 5 33 31 0 39</span><br><span class="line">4 5 22 4 0 786</span><br><span class="line">4 5 13 32 0 561</span><br><span class="line">4 5 3 48 0 460</span><br><span class="line">2 5 32 47 604 258</span><br><span class="line">5 7 44 37 75 164</span><br><span class="line">5 7 34 50 925 441</span><br><span class="line">6 2 26 38 1000 22</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">103.00</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N\le5000$，$0\le M\le3000$，$1\le U_i,V_i\le N+2$，$0\le A_i,B_i\le500$，$0\le C_i\le10000$，$0\le D_i\le1000$。</p><p>标签：<code>费用流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>妙不可言的费用流。</p><p>首先肯定需要二分答案，设当前答案是$tans$，那么第$i$条边压缩$1$流量花费$a_i-d_i+tans$，扩容$1$流量花费$b_i+d_i+tans$。</p><p>对于二分后的$check$，发现修改的同时维护流量守恒比较麻烦，不妨考虑先将所有流量都退掉，随后再逐一把不用退的流量增广回来，这样每次增广都可以保证流量守恒。那么初始费用为$\sum_{i=1}^{m}(a_i-d_i+tans)\times c_i$。</p><p>建模：<br>对于原图的第$i$条边：</p><ul><li>$u_i\to v_i$，流量$c_i$，费用$-(a_i-d_i+tans)$</li><li>若$u_i\ne S$，则$u_i\to v_i$，流量$\infty$，费用$(b_i+d_i+tans)$</li></ul><p>这样跑最小费用最大流后判断$初始费用+最小增广费用&lt;0$是否成立即可判断是否有$X-Y\ge0$。</p><p>正确性：<br>由于跑费用流，会优先增广费用小的边，而$(b_i+d_i+tans)-[-(a_i-d_i+tans)]=a_i+b_i+2\times tans\ge 0$，因此第一类边比第二类边小，一定会先走第一类边补到原先流量后再继续走第二类边扩容。</p><p>本文参考<a href="https://www.cnblogs.com/qt666/p/6863985.html" target="_blank" rel="noopener">$qt66$的题解</a>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)/2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt; dnt w;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> u, v, a, b, c, d;&#125; e[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];dnt mic, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = n+<span class="number">1</span>, t = n+<span class="number">2</span>, cnt = <span class="number">0</span>, mic = tot = <span class="number">0.0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, dnt w)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u], w&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, dnt w)</span> </span>&#123;insert(u, v, c, w), insert(v, u, <span class="number">0</span>, -w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;<span class="keyword">bool</span> inq[MAX_N+<span class="number">5</span>];<span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">dnt d[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> cr[MAX_N+<span class="number">5</span>];<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) d[i] = INF;</span><br><span class="line">d[s] = <span class="number">0</span>, que.push(s), inq[s] = <span class="literal">true</span>, <span class="built_in">memset</span>(cr, <span class="number">-1</span>, <span class="keyword">sizeof</span> cr);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop(), inq[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;dnt w = E[i].w;</span><br><span class="line"><span class="keyword">if</span> (c &amp;&amp; d[u]+w &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u]+w, cr[v] = i;</span><br><span class="line"><span class="keyword">if</span> (!inq[v]) que.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(d[t]-INF) &lt;= EPS) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">int</span> flow = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) flow = min(flow, E[i].c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) E[i].c -= flow, E[i^<span class="number">1</span>].c += flow;</span><br><span class="line">mic += <span class="number">1.0</span>*flow*d[t];<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(dnt tans)</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">addedge(e[i].u, e[i].v, e[i].c, e[i].d-e[i].a-tans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (e[i].u^s)</span><br><span class="line">addedge(e[i].u, e[i].v, INF, e[i].b+e[i].d+tans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">tot += (e[i].a-e[i].d+tans)*e[i].c;</span><br><span class="line"><span class="keyword">while</span> (SPFA()) ;<span class="keyword">return</span> tot+mic &lt;= -EPS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">dnt <span class="title">bi_search</span><span class="params">(dnt l, dnt r)</span> </span>&#123;</span><br><span class="line">dnt ret = <span class="number">-1.0</span>;</span><br><span class="line"><span class="keyword">while</span> (r-l &gt;= EPS)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> ret = mid, l = mid;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">read(e[i].u), read(e[i].v), read(e[i].a), </span><br><span class="line">read(e[i].b), read(e[i].c), read(e[i].d);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, bi_search(<span class="number">0.0</span>, <span class="number">30000.0</span>)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2014】方伯伯运椰子&quot;&gt;&lt;a href=&quot;#【SCOI2014】方伯伯运椰子&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2014】方伯伯运椰子&quot;&gt;&lt;/a&gt;【SCOI2014】方伯伯运椰子&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;30\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://www.lydsy.com/JudgeOnline/upload/201503/f1.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含二个整数$N$,$M$。&lt;br&gt;接下来$M$行代表$M$条边，表示这个交通网络。&lt;br&gt;每行六个整数，表示$U_i,V_i,A_i,B_i,C_i,D_i$。&lt;br&gt;接下来一行包含一条边，表示连接起点的边。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一个浮点数，保留二位小数。表示答案，数据保证答案大于$0$。&lt;br&gt;
    
    </summary>
    
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="费用流" scheme="http://azrael.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3594【SCOI2014】方伯伯的玉米田 &lt;树状数组优化DP&gt;</title>
    <link href="http://azrael.top/BZOJ3594%E3%80%90SCOI2014%E3%80%91%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84%E7%8E%89%E7%B1%B3%E7%94%B0%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96DP/"/>
    <id>http://azrael.top/BZOJ3594【SCOI2014】方伯伯的玉米田 树状数组优化DP/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-03-18T07:20:28.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2014】方伯伯的玉米田"><a href="#【SCOI2014】方伯伯的玉米田" class="headerlink" title="【SCOI2014】方伯伯的玉米田"></a>【SCOI2014】方伯伯的玉米田</h3><p>$\mathrm{Time\;Limit:\;60\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。<br>这排玉米一共有$N$株，它们的高度参差不齐。<br>方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。<br>方伯伯可以选择一个区间，把这个区间的玉米全部拔高$1$单位高度，他可以进行最多$K$次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。<br>问能最多剩多少株玉米，来构成一排美丽的玉米。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第$1$行包含$2$个整数$N,K$，分别表示这排玉米的数目以及最多可进行多少次操作。<br>第$2$行包含$N$个整数，第$i$个数表示这排玉米，从左到右第$i$株玉米的高度$a_i$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$1$个整数，最多剩下的玉米数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$1&lt;N&lt;10^4,\;1&lt;K\le500,\;1\le a_i\le5000$</p><p>标签：<code>DP</code> <code>树状数组</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，显然每次拔高时，不管从哪里开始拔，区间右边界总是$N$肯定不会使答案变小。有此贪心后，考虑到第$i$株时前面拔高$j$次，那么第$i$株一定也已拔高$j$次。</p><p>令$f[i][j]$表示考虑前$i$株，共拔高了$j$次，最多可以剩下多少。那么有<br>$$<br>f[i][j]=\max{f[p][q]}+1\;\;\;\;(p&lt;i,\;q\le j,\;a[p]+q\le a[i]+j)<br>$$<br>对于$\mathrm{DP}$值$f[x][y]$，将其坐标设为$(x,a[x]+y)$，那么$\mathrm{DP}$到$f[i][j]$时，需要找的是坐标在$(0,0)\sim(j,a[i]+j-1)$范围内的最小值，可以二维树状数组维护。</p><p>注意$\mathrm{DP}$时第二层循环要倒着循环，以排除后效性，由于二维树状数组的坐标范围不能到$0$，可以把所有坐标的横纵值强行加$1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_A 5500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 500</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, a[MAX_N+<span class="number">5</span>], tr[MAX_M+<span class="number">5</span>][MAX_A+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= MAX_M+<span class="number">1</span>; i += (i&amp;-i))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = q; j &lt;= MAX_A; j += (j&amp;-j))</span><br><span class="line">tr[i][j] = max(tr[i][j], c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = p; i; i -= (i&amp;-i))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = q; j; j -= (j&amp;-j))</span><br><span class="line">ret = max(ret, tr[i][j]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);<span class="keyword">int</span> f, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = m; ~j; j--)</span><br><span class="line">ans = max(ans, f = query(j+<span class="number">1</span>, a[i]+j)+<span class="number">1</span>), modify(j+<span class="number">1</span>, a[i]+j, f);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2014】方伯伯的玉米田&quot;&gt;&lt;a href=&quot;#【SCOI2014】方伯伯的玉米田&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2014】方伯伯的玉米田&quot;&gt;&lt;/a&gt;【SCOI2014】方伯伯的玉米田&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;60\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。&lt;br&gt;这排玉米一共有$N$株，它们的高度参差不齐。&lt;br&gt;方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。&lt;br&gt;方伯伯可以选择一个区间，把这个区间的玉米全部拔高$1$单位高度，他可以进行最多$K$次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。&lt;br&gt;问能最多剩多少株玉米，来构成一排美丽的玉米。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第$1$行包含$2$个整数$N,K$，分别表示这排玉米的数目以及最多可进行多少次操作。&lt;br&gt;第$2$行包含$N$个整数，第$i$个数表示这排玉米，从左到右第$i$株玉米的高度$a_i$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$1$个整数，最多剩下的玉米数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="树状数组" scheme="http://azrael.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4443【SCOI2015】小凸玩矩阵 &lt;二分+网络流&gt;</title>
    <link href="http://azrael.top/BZOJ4443%E3%80%90SCOI2015%E3%80%91%E5%B0%8F%E5%87%B8%E7%8E%A9%E7%9F%A9%E9%98%B5%20%E4%BA%8C%E5%88%86+%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ4443【SCOI2015】小凸玩矩阵 二分+网络流/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-03-16T06:14:21.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2015】小凸玩矩阵"><a href="#【SCOI2015】小凸玩矩阵" class="headerlink" title="【SCOI2015】小凸玩矩阵"></a>【SCOI2015】小凸玩矩阵</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小凸和小方是好朋友，小方给小凸一个$N\times M\;(N\le M)$的矩阵$A$,要求小秃从其中选出$N$个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的$N$个数中第$K$大的数字的最小值是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行给出三个整数$N,M,K$<br>接下来$N$行，每行$M$个数字，用来描述这个矩阵</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示第$K$大数字的最小值<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 5 6 6 </span><br><span class="line">8 3 4 3</span><br><span class="line">6 8 6 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le K\le N\le M\le250,\;1\le 矩阵元素\le10^9$</p><p>标签：<code>二分答案</code> <code>网络流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>套路$二分+网络流匹配验证$。</p><p>二分第$K$大数的值，将所有$A[i][j]\le tans$的位置加入网络流图中 。<br>建模：给每行每列设一个点，初始$S\to行_i\;(i\in[1,n])$流量$1$，$列_j\to T\;(j\in[1,m])$流量$1$。如果$A[i][j]\le tans$，则连边$行_i\to列_j$，流量$1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, mx, s, t, cnt, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>];<span class="keyword">int</span> mat[<span class="number">255</span>][<span class="number">255</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;cnt = <span class="number">0</span>, s = <span class="number">0</span>, t = n+m+<span class="number">1</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>;cpy();<span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec();<span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> tans)</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(s, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) addedge(i+n, t, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span> (mat[i][j] &lt;= tans) addedge(i, j+n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Dinic() &gt;= n-k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = mid, r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">read(mat[i][j]), mx = max(mat[i][j], mx);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bi_search(<span class="number">0</span>, mx)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2015】小凸玩矩阵&quot;&gt;&lt;a href=&quot;#【SCOI2015】小凸玩矩阵&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2015】小凸玩矩阵&quot;&gt;&lt;/a&gt;【SCOI2015】小凸玩矩阵&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;小凸和小方是好朋友，小方给小凸一个$N\times M\;(N\le M)$的矩阵$A$,要求小秃从其中选出$N$个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的$N$个数中第$K$大的数字的最小值是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行给出三个整数$N,M,K$&lt;br&gt;接下来$N$行，每行$M$个数字，用来描述这个矩阵&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个整数，表示第$K$大数字的最小值&lt;br&gt;
    
    </summary>
    
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分答案" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4516【SHOI2016】生成魔咒 &lt;后缀自动机&gt;</title>
    <link href="http://azrael.top/BZOJ4516%E3%80%90SHOI2016%E3%80%91%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%20%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://azrael.top/BZOJ4516【SHOI2016】生成魔咒 后缀自动机/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-21T14:42:24.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="BZOJ4516【SHOI2016】生成魔咒"><a href="#BZOJ4516【SHOI2016】生成魔咒" class="headerlink" title="BZOJ4516【SHOI2016】生成魔咒"></a>BZOJ4516【SHOI2016】生成魔咒</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1$,$2$ 拼凑起来形成一个魔咒串 $[1,2]$。<br>一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1]$,$[2]$,$[1,2]$,$[2,1]$,$[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1]$,$[1,1]$,$[1,1,1]$ 三种。<br>最初 $S$ 为空串。共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数 $n$。<br>第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符<br>$1\le n\le100000$，用来表示魔咒字符的数字 $x$ 满足 $1\le x\le10^9$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出 $n$ 行，每行一个数。第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 3 3 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">12</span><br><span class="line">17</span><br><span class="line">22</span><br></pre></td></tr></table></figure><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>鸣谢<code>Menci</code>上传</p><p>标签：<code>后缀自动机</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>后缀自动机的模板题。</p><p>按题意增量构建后缀自动机，考虑每次新增的一位能构成多少新串，贡献计入答案。</p><p>对于每次新增的结点$np$，若其在$parent$树上的父亲为$par$，那么前面有若干条路走到$par$从而得到的字符串与其走到$np$得到的字符串相同。由于走到$par$的字符串个数是$len_{par}$，走到$np$的字符串个数是$len_{np}$。因此新增字符串个数是$len_{np}-len_{par}$。维护即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mii map<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, rt, sz, lst;lnt ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>mii ch; <span class="keyword">int</span> len, par;&#125; SAM[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> _len)</span> </span>&#123;SAM[++sz].len = _len; <span class="keyword">return</span> sz;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;sz = <span class="number">0</span>, rt = lst = newnode(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = lst, np = newnode(SAM[p].len+<span class="number">1</span>);lst = np;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !SAM[p].ch[c]; p = SAM[p].par) SAM[p].ch[c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;SAM[np].par = rt; <span class="keyword">return</span>;&#125;<span class="keyword">int</span> q = SAM[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (SAM[q].len == SAM[p].len+<span class="number">1</span>) &#123;SAM[np].par = q; <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> nq = newnode(SAM[p].len+<span class="number">1</span>); SAM[nq].ch = SAM[q].ch;</span><br><span class="line">SAM[nq].par = SAM[q].par, SAM[q].par = SAM[np].par = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; SAM[p].ch[c] == q; p = SAM[p].par) SAM[p].ch[c] = nq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123;ans += SAM[lst].len-SAM[SAM[lst].par].len;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; i++)</span><br><span class="line">read(x), insert(x), upd(), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;BZOJ4516【SHOI2016】生成魔咒&quot;&gt;&lt;a href=&quot;#BZOJ4516【SHOI2016】生成魔咒&quot; class=&quot;headerlink&quot; title=&quot;BZOJ4516【SHOI2016】生成魔咒&quot;&gt;&lt;/a&gt;BZOJ4516【SHOI2016】生成魔咒&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1$,$2$ 拼凑起来形成一个魔咒串 $[1,2]$。&lt;br&gt;一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1]$,$[2]$,$[1,2]$,$[2,1]$,$[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1]$,$[1,1]$,$[1,1,1]$ 三种。&lt;br&gt;最初 $S$ 为空串。共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个整数 $n$。&lt;br&gt;第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符&lt;br&gt;$1\le n\le100000$，用来表示魔咒字符的数字 $x$ 满足 $1\le x\le10^9$&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出 $n$ 行，每行一个数。第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="字符串" scheme="http://azrael.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://azrael.top/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3998【TJOI2015】弦论 &lt;后缀自动机&gt;</title>
    <link href="http://azrael.top/BZOJ3998%E3%80%90TJOI2015%E3%80%91%E5%BC%A6%E8%AE%BA%20%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://azrael.top/BZOJ3998【TJOI2015】弦论 后缀自动机/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-16T06:16:08.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【TJOI2015】弦论"><a href="#【TJOI2015】弦论" class="headerlink" title="【TJOI2015】弦论"></a>【TJOI2015】弦论</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>对于一个给定长度为$N$的字符串，求它的第$K$小子串是什么。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是一个仅由小写英文字母构成的字符串$S$。<br>第二行为两个整数$T$和$K$，$T$为$0$则表示不同位置的相同子串算作一个，$T=1$则表示不同位置的相同子串算作多个。$K$的意义如题所述。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出仅一行，为一个数字串，为第$K$小的子串。如果子串数目不足$K$个，则输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabc</span><br><span class="line">0 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aab</span><br></pre></td></tr></table></figure><p>标签：<code>后缀自动机</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>后缀自动机的模板题。</p><p>对于两个询问的找到第$K$大，预处理出从每个状态节点向后有多少种符合规则的字符串，然后每次选择走哪个字符即可。</p><p>关于预处理：</p><ul><li>对于$T=0$，即计算后缀自动机所形成的$DAG$上有多少条从初始状态出发路径，将每一个状态节点初值赋为$1$后按拓扑序在$DAG$上$DP$即可。</li><li>对于$T=1$，类似上面，也是按拓扑序在$DAG$上作$DP$，只是此时只有表示原字符串每个前缀结束状态的节点的初值为$1$。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> l, T, K, tot[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> rt, sz, lst, val[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>], sum[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> ch[<span class="number">26</span>], len, par;&#125; SAM[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> _len)</span> </span>&#123;SAM[++sz].len = _len; <span class="keyword">return</span> sz;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;sz = <span class="number">0</span>, rt = lst = newnode(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = lst, np = newnode(SAM[p].len+<span class="number">1</span>); lst = np, val[np] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !SAM[p].ch[c]; p = SAM[p].par) SAM[p].ch[c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;SAM[np].par = rt; <span class="keyword">return</span>;&#125;<span class="keyword">int</span> q = SAM[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (SAM[q].len == SAM[p].len+<span class="number">1</span>) &#123;SAM[np].par = q; <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> nq = newnode(SAM[p].len+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(SAM[nq].ch, SAM[q].ch, <span class="keyword">sizeof</span> SAM[q].ch);</span><br><span class="line">SAM[nq].par = SAM[q].par, SAM[q].par = SAM[np].par = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; SAM[p].ch[c] == q; p = SAM[p].par) SAM[p].ch[c] = nq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prt</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= val[c]) <span class="keyword">return</span> <span class="number">1</span>;k -= val[c];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span> &amp;&amp; k &gt; <span class="number">0</span>; k -= sum[SAM[c].ch[i++]])</span><br><span class="line"><span class="keyword">if</span> (SAM[c].ch[i] &amp;&amp; k &lt;= sum[SAM[c].ch[i]])</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'a'</span>+i), prt(SAM[c].ch[i], k);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> que[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];init();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, s, &amp;T, &amp;K), l = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) insert(s[i]-<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) tot[SAM[i].len]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) tot[i] += tot[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i; i--) que[tot[SAM[i].len]--] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i; i--)</span><br><span class="line"><span class="keyword">if</span> (!T) val[que[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> val[SAM[que[i]].par] += val[que[i]];</span><br><span class="line">val[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) sum[i] = val[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i; i--) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">sum[que[i]] += sum[SAM[que[i]].ch[j]];</span><br><span class="line"><span class="keyword">return</span> (K &gt; sum[rt] ? <span class="built_in">puts</span>(<span class="string">"-1"</span>) : prt(rt, K)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【TJOI2015】弦论&quot;&gt;&lt;a href=&quot;#【TJOI2015】弦论&quot; class=&quot;headerlink&quot; title=&quot;【TJOI2015】弦论&quot;&gt;&lt;/a&gt;【TJOI2015】弦论&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;对于一个给定长度为$N$的字符串，求它的第$K$小子串是什么。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行是一个仅由小写英文字母构成的字符串$S$。&lt;br&gt;第二行为两个整数$T$和$K$，$T$为$0$则表示不同位置的相同子串算作一个，$T=1$则表示不同位置的相同子串算作多个。$K$的意义如题所述。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出仅一行，为一个数字串，为第$K$小的子串。如果子串数目不足$K$个，则输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="字符串" scheme="http://azrael.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://azrael.top/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4569【SCOI2016】萌萌哒 &lt;并查集+ST表&gt;</title>
    <link href="http://azrael.top/BZOJ4569%E3%80%90SCOI2016%E3%80%91%E8%90%8C%E8%90%8C%E5%93%92%20%E5%B9%B6%E6%9F%A5%E9%9B%86+ST%E8%A1%A8/"/>
    <id>http://azrael.top/BZOJ4569【SCOI2016】萌萌哒 并查集+ST表/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-03-10T15:13:56.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2016】萌萌哒"><a href="#【SCOI2016】萌萌哒" class="headerlink" title="【SCOI2016】萌萌哒"></a>【SCOI2016】萌萌哒</h3><p>Time Limit: $20 Sec$<br>Memory Limit: $256 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一个长度为$n$的大数，用$S_1S_2S_3\cdots S_n$表示，其中$S_i$表示数的第$i$位，$S_1$是数的最高位，告诉你一些限制条件，每个条件表示为四个数，$l_1$，$r_1$，$l_2$，$r_2$，即两个长度相同的区间，表示子串$S_{l_1}S_{l_1+1}S_{l_1+2}\cdots S_{r_1}$与$S_{l_2}S_{l_2+1}S_{l_2+2}\cdots S_{r_2}$完全相同。比如$n=6$时，某限制条件$l_1=1$，$r_1=3$，$l_2=4$，$r_2=6$，那么$123123$，$351351$均满足条件，但是$12012$，$131141$不满足条件，前者数的长度不为$6$，后者第二位与第五位不同。问满足以上所有条件的数有多少个。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个数$n$和$m$，分别表示大数的长度，以及限制条件的个数。接下来$m$行，对于第$i$行，有$4$个数$l_{i_1}$，$r_{i_1}$，$l_{i_2}$，$r_{i_2}$，分别表示该限制条件对应的两个区间。<br>$1\le n\le 10^5$，$1\le m\le 10^5$，$1\le l_{i_1},r_{i_1},l_{i_2},r_{i_2}\le n$；并且保证$r_{i_1}-l_{i_1}=r_{i_2}-l_{i_2}$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个数，表示满足所有条件且长度为$n$的大数的个数，答案可能很大，因此输出答案模$10^9+7$的结果即可。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2 3 4 </span><br><span class="line">3 3 3 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure><p>标签：<code>并查集</code> <code>ST表</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>好题，把基础数据结构玩出了新花样。</p><p>首先朴素思想是用并查集维护每位的相同关系，每次暴力合并，最后统计有几个集合就有几个自由元。若有$cnt$个集合，那么答案为$Ans=9\times10^{cnt-1}$。</p><p>发现我们花费了很多时间再合并上，考虑用带$\log$数据结构优化合并。这里需要用到$ST$表。<br>考虑存$\log{n}$组并查集，第$i$组并查集的第$j$个元素维护的是区间$[j,j+2^i]$与其他长度为$2^i$的区间是否相同。这样对于关系$S_{l_1\sim r_1}=S_{l_2\sim r_2}$，令$len=r_1-l_1=r_2-l_2$，等同于$S_{l_1\sim(l_1+2^{\log{len}})}=S_{l_2\sim(l_2+2^{\log{len}})}$和$S_{(r_1-2^{\log{len}})\sim r_1}=S_{(r_2-2^{\log{len}})\sim r_2}$，那么合并第$\log{len}$组并查集中的$l_1$和$l_2$、第$\log{len}$组并查集中的$r_1-2^{\log{len}}$和$r_2-2^{\log{len}}$即可。随后像$ST$表一样自大区间向小区间合并信息，可得出最后的集合个数，计算答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, LOG2[MAX_N+<span class="number">5</span>], fa[LOG][MAX_N+<span class="number">5</span>];lnt ans = <span class="number">9L</span>L;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[d][x] == x ? x : fa[d][x] = getf(d, fa[d][x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) LOG2[i] = LOG2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOG; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) fa[i][j] = j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l1, l2, e1, e2, l, d; i &lt; m; i++) &#123;</span><br><span class="line">read(l1), read(e1), read(l2), read(e2), l = e1-l1+<span class="number">1</span>, d = LOG2[l];</span><br><span class="line"><span class="keyword">if</span> (getf(d, l1)^getf(d, l2)) fa[d][fa[d][l1]] = fa[d][l2];</span><br><span class="line"><span class="keyword">if</span> (getf(d, l1+l-(<span class="number">1</span>&lt;&lt;d))^getf(d, l2+l-(<span class="number">1</span>&lt;&lt;d)))</span><br><span class="line">fa[d][fa[d][l1+l-(<span class="number">1</span>&lt;&lt;d)]] = fa[d][l2+l-(<span class="number">1</span>&lt;&lt;d)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG2[n]; i; i--) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (getf(i<span class="number">-1</span>, j)^getf(i<span class="number">-1</span>, getf(i, j))) fa[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][j]] = fa[i<span class="number">-1</span>][fa[i][j]];</span><br><span class="line"><span class="keyword">if</span> (getf(i<span class="number">-1</span>, j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))^getf(i<span class="number">-1</span>, getf(i,j)+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))))</span><br><span class="line">fa[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]] = fa[i<span class="number">-1</span>][fa[i][j]+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (getf(<span class="number">0</span>, i) == i) cnt++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) (ans *= <span class="number">10L</span>L) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2016】萌萌哒&quot;&gt;&lt;a href=&quot;#【SCOI2016】萌萌哒&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2016】萌萌哒&quot;&gt;&lt;/a&gt;【SCOI2016】萌萌哒&lt;/h3&gt;&lt;p&gt;Time Limit: $20 Sec$&lt;br&gt;Memory Limit: $256 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一个长度为$n$的大数，用$S_1S_2S_3\cdots S_n$表示，其中$S_i$表示数的第$i$位，$S_1$是数的最高位，告诉你一些限制条件，每个条件表示为四个数，$l_1$，$r_1$，$l_2$，$r_2$，即两个长度相同的区间，表示子串$S_{l_1}S_{l_1+1}S_{l_1+2}\cdots S_{r_1}$与$S_{l_2}S_{l_2+1}S_{l_2+2}\cdots S_{r_2}$完全相同。比如$n=6$时，某限制条件$l_1=1$，$r_1=3$，$l_2=4$，$r_2=6$，那么$123123$，$351351$均满足条件，但是$12012$，$131141$不满足条件，前者数的长度不为$6$，后者第二位与第五位不同。问满足以上所有条件的数有多少个。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行两个数$n$和$m$，分别表示大数的长度，以及限制条件的个数。接下来$m$行，对于第$i$行，有$4$个数$l_{i_1}$，$r_{i_1}$，$l_{i_2}$，$r_{i_2}$，分别表示该限制条件对应的两个区间。&lt;br&gt;$1\le n\le 10^5$，$1\le m\le 10^5$，$1\le l_{i_1},r_{i_1},l_{i_2},r_{i_2}\le n$；并且保证$r_{i_1}-l_{i_1}=r_{i_2}-l_{i_2}$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一个数，表示满足所有条件且长度为$n$的大数的个数，答案可能很大，因此输出答案模$10^9+7$的结果即可。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="并查集" scheme="http://azrael.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="ST表" scheme="http://azrael.top/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4407 于神之怒加强版 &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ4407%20%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ4407 于神之怒加强版 莫比乌斯反演/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-16T06:15:34.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="于神之怒加强版"><a href="#于神之怒加强版" class="headerlink" title="于神之怒加强版"></a>于神之怒加强版</h3><p>$\mathrm{Time\;Limit:\;80\;Sec}$<br>$\mathrm{Memory\;Limit:\;512\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给下$N,M,K$，计算$\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k\mod(10^9+7)$的值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入有多组数据，输入数据的第一行两个正整数$T,K$，代表有$T$组数据，$K$的意义如上所示，下面第$2$行到第$T+1$行，每行为两个正整数$N,M$，其意义如上式所示。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一个询问，输出一行一个数作为回答。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N,M,K\le5\times 10^6,\;1\le T\le2000$<br><a href="http://www.lydsy.com/JudgeOnline/upload/201603/4407.rar" target="_blank" rel="noopener">官方题解</a></p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先套路转换出$\mu$：<br>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k\\<br>&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=d]\\<br>&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{x|\gcd(i ,j)}\mu(x)\\<br>&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{x=1}^{\lfloor\frac{\min(n,m)}{d}\rfloor}\mu(x)\lfloor\frac{n}{x\cdot d}\rfloor\lfloor\frac{m}{x\cdot d}\rfloor\\<br>&amp;=\sum_{t=1}^{\min(n,m)}\sum_{d=1}^{t}d^k\mu(\frac{t}{d})\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\\<br>&amp;=\sum_{t=1}^{\min(n,m)}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum_{d=1}^{t}d^k\mu(\frac{t}{d})\\<br>\end{aligned}<br>$$<br>那么每次询问对于前半部分可以根号分块，随后需要$O(1)$计算后半部分的值，因而需要线筛预处理后半部分的值。</p><p>令$f(t)=\sum_{d=1}^{t}d^k\mu(\frac{t}{d})$，$t=p_1^{a_1}\times p_2^{q_2}\times\cdots p_l^{a_l}$<br>由于$y=d^k$和$y=\mu(d)$均为积性函数，因而$f$也为积性函数。<br>那么就有<br>$$<br>\begin{aligned}<br>f(t)&amp;=\prod_{i=1}^{l}f(p_i^{a_i})\\&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(\frac{p_i^{a_i}}{p_i^j})\\<br>&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(p_i^{a_i-j})\\<br>\end{aligned}<br>$$<br>易知当$j\in[0,a_i-1)$时，均有$\mu(p_i^{a_i-j})=0$，因此有<br>$$<br>\begin{aligned}<br>f(t)&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(p_i^{a_i-j})\\<br>&amp;=\prod_{i=1}^{l}(\mu(p_i)\cdot p_i^{k\cdot(a_i-1)}+\mu(1)\cdot p_i^{k\cdot a_i})\\<br>&amp;=\prod_{i=1}^{l}(p_i^{k\cdot a_i}-p_i^{k\cdot(a_i-1)})\\<br>&amp;=\prod_{i=1}^{l}p_i^{k\cdot(a_i-1)}(p_i-1)<br>\end{aligned}<br>$$<br>接下来考虑在线筛中如何处理。<br>首先，对于所有质数，均有$f(p)=p^k-1$。<br>而对于合数，假设当前筛到的数是$x$，对于一个比它小的素数$p$，有两种情况：</p><ol><li>若$p|x$，设$p$在$x$分解质因数中的次数为$a$，那么$f(x\times p)$相比于$f(x)$而言，在含$p$的约数中$p$的次数都增加了$1$，否则$\mu=0$无贡献。因此$k\cdot(a-1)$增加了$k$，这样总共扩大了$p^k$倍，故$f(x\times p)=f(x)\times p^k$；</li><li>若$p\nmid x$，由积性函数可知$f(x\times p)=f(x)\times f(p)$。</li></ol><p>这样就可以$O(n\log{n})$筛出$f$的函数值，每次询问$O(T\sqrt{n})$根号分块，总复杂度$O(n\log{n}+T\sqrt{n})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">lnt k, cnt, ans, f[MAX_N+<span class="number">5</span>], p[MAX_N+<span class="number">5</span>], pri[MAX_N+<span class="number">5</span>];<span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">lnt <span class="title">PM</span><span class="params">(lnt x, lnt y)</span> </span>&#123;<span class="keyword">if</span> (!y) <span class="keyword">return</span> <span class="number">1L</span>L; lnt ret = PM(x, y&gt;&gt;<span class="number">1</span>); <span class="keyword">return</span> (y&amp;<span class="number">1</span>) ? ret*ret%MOD*x%MOD : ret*ret%MOD;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">NotPri[<span class="number">1</span>] = <span class="literal">true</span>, f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, p[i] = PM(i, k), f[i] = p[i]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>; NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) f[i*pri[j]] = f[i]*f[pri[j]]%MOD;</span><br><span class="line"><span class="keyword">else</span> &#123;f[i*pri[j]] = f[i]*p[pri[j]]%MOD; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) (f[i] += f[i<span class="number">-1</span>]) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T), read(k), init();</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">lnt n, m;read(n), read(m), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), (ans += (n/l)*(m/l)%MOD*(f[r]-f[l<span class="number">-1</span>]+MOD)%MOD) %= MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;于神之怒加强版&quot;&gt;&lt;a href=&quot;#于神之怒加强版&quot; class=&quot;headerlink&quot; title=&quot;于神之怒加强版&quot;&gt;&lt;/a&gt;于神之怒加强版&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;80\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;512\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给下$N,M,K$，计算$\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k\mod(10^9+7)$的值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入有多组数据，输入数据的第一行两个正整数$T,K$，代表有$T$组数据，$K$的意义如上所示，下面第$2$行到第$T+1$行，每行为两个正整数$N,M$，其意义如上式所示。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每一个询问，输出一行一个数作为回答。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3309 DZY Loves Math &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ3309%20DZY%20Loves%20Math%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ3309 DZY Loves Math 莫比乌斯反演/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2018-03-08T04:50:47.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="DZY-Loves-Math"><a href="#DZY-Loves-Math" class="headerlink" title="DZY Loves Math"></a>DZY Loves Math</h3><p>Time Limit: $20 Sec$<br>Memory Limit: $512 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>对于正整数$n$，定义$f(n)$为$n$所含质因子的最大幂指数。例如$f(1960)=f(2^3\times5^1\times7\times2)=3$, $f(10007)=1$, $f(1)=0$。<br>给定正整数$a,b$，求$\sum_{i=1}^{a}\sum_{j=1}^{b}{f(\gcd(i,j))}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个数$T$，表示询问数。<br>接下来$T$行，每行两个数$a,b$，表示一个询问。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一个询问，输出一行一个非负整数作为回答。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">7558588 9653114</span><br><span class="line">6514903 4451211</span><br><span class="line">7425644 1189442</span><br><span class="line">6335198 4957</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">35793453939901</span><br><span class="line">14225956593420</span><br><span class="line">4332838845846</span><br><span class="line">15400094813</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$T\le 10^4$<br>$1\le a,b\le 10^7$</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>好题，$get$线筛新姿势。</p><p>首先套路转化出莫比乌斯函数：<br>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{i=1}^{a}\sum_{j=1}^{b}f(\gcd(i,j))\\<br>&amp;=\sum_{d=1}^{\min(a,b)}\sum_{i=1}^{a}\sum_{j=1}^{b}f(d)[\gcd(i,j)=d]\\<br>&amp;=\sum_{d=1}^{\min(a,b)}f(d)\sum_{i=1}^{\lfloor\frac{a}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{b}{d}\rfloor}\sum_{k|\gcd(i,j)}\mu(k)\\<br>&amp;=\sum_{d=1}^{\min(a,b)}f(d)\sum_{k=1}^{\lfloor\frac{\min(a,b)}{d}\rfloor}\mu(k)\times\lfloor\frac{a}{d\times k}\rfloor\times\lfloor\frac{b}{d\times k}\rfloor\\<br>&amp;=\sum_{t=1}^{\min(a,b)}\lfloor\frac{a}{t}\rfloor\lfloor\frac{b}{t}\rfloor\sum_{d|t}\mu(\frac{t}{d})\times f(d)\\<br>\end{aligned}<br>$$<br>这时会发现前面用根号分块很好处理，而后面的部分需要$O(1)$计算，所以需要线性筛预处理。</p><p>令$g(t)=\sum_{d|t}\mu(\frac{t}{d})\times f(d)$，考虑通过$\mu$与$f$的性质找到其积性关系。</p><p>设$t=p_1^{a_1}\times p_2^{a_2}\times\cdots\times p_k^{a_k}$，$\frac{t}{d}=p_1^{a_1’}\times p_2^{a_2’}\times\cdots\times p_k^{a_k’}$，$d=p_1^{a_1-a_1’}\times p_2^{a_2-a_2’}\times\cdots\times p_k^{a_k-a_k’}$<br>那么一定有$0\le a_1’,a_2’,\cdots,a_k’\le 1$，否则$\mu(\lfloor\frac{t}{d}\rfloor)=0$，不计入总贡献。</p><ol><li>若$a_1=a_2=\cdots=a_k=\max{a}$<ul><li>对于$f(d)=\max{a}-1$的情况，只有一种，即$a_1’=a_2’=\cdots=a_k’=0$。而$\mu(\frac{t}{d})=(-1)^k$。故贡献为$(a-1)\times(-1)^k=a\times(-1)^k-(-1)^k$；</li><li>对于$f(d)=\max{a}$的情况，根据组合原理，有$\sum_{i=0}^{k-1}(-1)^i\binom{i}{k}$，而又由二项式基本定理知$\sum_{i=0}^{k}(-1)^k\binom{i}{k}=0$，因而贡献为$(-1)^k\binom{k}{k}=(-1)^k$。</li><li>故此情况$g(d)=a\times(-1)^k-(-1)^k+(-1)^k=a\times(-1)^k$。</li></ul></li><li>若$\exists i,j$使得$i\ne j,\;a_i\ne a_j$<ul><li>不论$f(d)=\max{a}$还是$f(d)=\max{a}-1$，都存在至少一个质因数$p_r$使得$a_r’$不论取$0$还是$1$对$f(d)$的取值都没有影响。然而$a_r’$取$0$或$1$会使得$\mu(\frac{t}{d})$取到$-1$或$1$，此处的贡献为$f(d)+(-f(d))=0$，一定全部被抵消。</li><li>故此情况$g(d)=0$。</li></ul></li></ol><p>综上，线性筛预处理$g(t)$需要知道每个数最小的质因数的次数$num$和最小质因数的幂指数次幂$sp$，这样看是否有$num[i\times pri[j]]=num[i/sp[i]]$即可知$i\times pri[j]$的最小与次小质因数的次数是否相等，由此可判断是情况$1$还是情况$2$。这样先线性筛预处理后，对每次询问$O(\sqrt{\min(a,b)})$进行根号分块，即可达到$O(T\sqrt{\min(a,b)})$的复杂度。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> g[MAX_N+<span class="number">5</span>], sp[MAX_N+<span class="number">5</span>], num[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], cnt;lnt ans;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">NotPri[<span class="number">0</span>] = NotPri[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = sp[i] = i, g[i] = num[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; n) <span class="keyword">break</span>;NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) sp[i*pri[j]] = pri[j], num[i*pri[j]] = <span class="number">1</span>, g[i*pri[j]] = num[i] == <span class="number">1</span> ? -g[i] : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> sp[i*pri[j]] = sp[i]*pri[j], num[i*pri[j]] = num[i]+<span class="number">1</span>, </span><br><span class="line">g[i*pri[j]] = sp[i] == i ? <span class="number">1</span> : (num[i/sp[i]] == num[i*pri[j]] ? -g[i/sp[i]] : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (i%pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i] += g[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T), init(MAX_N);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;read(a), read(b), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min(a,b); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(a/(a/l), b/(b/l)), ans += <span class="number">1L</span>L*(a/l)*(b/l)*(g[r]-g[l<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;DZY-Loves-Math&quot;&gt;&lt;a href=&quot;#DZY-Loves-Math&quot; class=&quot;headerlink&quot; title=&quot;DZY Loves Math&quot;&gt;&lt;/a&gt;DZY Loves Math&lt;/h3&gt;&lt;p&gt;Time Limit: $20 Sec$&lt;br&gt;Memory Limit: $512 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;对于正整数$n$，定义$f(n)$为$n$所含质因子的最大幂指数。例如$f(1960)=f(2^3\times5^1\times7\times2)=3$, $f(10007)=1$, $f(1)=0$。&lt;br&gt;给定正整数$a,b$，求$\sum_{i=1}^{a}\sum_{j=1}^{b}{f(\gcd(i,j))}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个数$T$，表示询问数。&lt;br&gt;接下来$T$行，每行两个数$a,b$，表示一个询问。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每一个询问，输出一行一个非负整数作为回答。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2693 jzptab &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ2693%20jzptab%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ2693 jzptab 莫比乌斯反演/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2018-03-08T04:38:40.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="jzptab"><a href="#jzptab" class="headerlink" title="jzptab"></a>jzptab</h3><p>Time Limit: $10 Sec$<br>Memory Limit: $512 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>求$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$，答案模$10^9+9$输出。<br>多组询问。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个正整数$T$表示数据组数。<br>接下来$T$行，每行两个正整数 表示$N,M$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>$T$行，每行一个整数，表示第$i$组数据的结果。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">122</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$T\le 10^4$<br>$N,M\le 10^7$</p><h3 id="Sourse"><a href="#Sourse" class="headerlink" title="Sourse"></a>Sourse</h3><p>版权所有者：<code>倪泽堃</code></p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>此题和$BZOJ2154$所求相同，只是又多组询问，如果每次都像$BZOJ2154$那样$O(n)$做为$TLE$。故需要改变求和方式。这里将使用$BZOJ2154$的最终推导结果来继续恒等变形。前面的推导见：<a href="http://azrael.top/BZOJ2154%20Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/">BZOJ2154</a>。<br>$$<br>\begin{aligned}<br>Answer&amp;=\sum_{d=1}^{\min(n,m)}{d}\sum_{k=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(k)\times k^2\times\frac{\lfloor\frac{n}{d\times k}\rfloor\times(\lfloor\frac{n}{d\times k}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{d\times k}\rfloor\times(\lfloor\frac{m}{d\times k}\rfloor+1)}{2}\\<br>&amp;=\sum_{d=1}^{\min(n,m)}\sum_{t=k\times d(k\in\mathbb{N^*})}^{\min(n,m)}\mu(\frac{t}{d})\times\frac{t^2}{d^2}\times\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}\times{d}\\<br>&amp;=\sum_{t=1}^{\min(n,m)}{\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}}\sum_{k|t}\mu(k)\times k^2\times\frac{t}{k}\\<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>&amp;Let\;F(t)=\sum_{k|t}\mu(k)\times k^2\times \frac{t}{k} ,\\<br>&amp;then\;S=\sum_{t=1}^{\min(n,m)}{\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}}\times F(t)\\<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>&amp;\because f(x)=\mu(x),\;g(x)=x^2,\;h(x)=\frac{t}{x}\;are\;all\;multiplicative\;functions\\<br>&amp;\therefore F(x)=\sum_{t|x}f(t)\times g(t)\times h(t)\;is\;a\;multiplicative\;function\\<br>&amp;\Longrightarrow We\;can\;use\;a\;Linear\;Seive\;to\;calculate\;F(x)\\<br>&amp;If\;x\equiv1\sim y-1\mod{y}\;\;(y\;is\;a\;prime\;number)\\<br>&amp;\;\;\;\;then\;F(x\times y)=F(x)\times F(y)\\<br>&amp;If\;x\equiv0\mod{y}\;\;(y\;is\;a\;prime\;number)\\<br>&amp;\;\;\;\;then\;\mu(x\times y)=0,\;F(x\times y)=F(x)\times y<br>\end{aligned}<br>$$<br>综上，$F(x)$的前缀和可用线性筛预处理，对于每次询问对$\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}$根号分块，即可做到$O(T\sqrt{n})$的复杂度。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 100000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">lnt n, m, cnt, ans, s[MAX_N+<span class="number">5</span>], pri[MAX_N+<span class="number">5</span>];<span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">NotPri[<span class="number">1</span>] = <span class="literal">true</span>, s[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (lnt i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, s[i] = (i-i*i%MOD)%MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) s[i*pri[j]] = s[i]*s[pri[j]]%MOD;</span><br><span class="line"><span class="keyword">else</span> &#123;s[i*pri[j]] = s[i]*pri[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_N; i++) (s[i] += s[i<span class="number">-1</span>]) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">lnt n, m;read(n), read(m), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), (ans += (n/l*(n/l+<span class="number">1</span>)/<span class="number">2</span>%MOD)*(m/l*(m/l+<span class="number">1</span>)/<span class="number">2</span>%MOD)%MOD*(s[r]-s[l<span class="number">-1</span>])%MOD) %= MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans+MOD)%MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;jzptab&quot;&gt;&lt;a href=&quot;#jzptab&quot; class=&quot;headerlink&quot; title=&quot;jzptab&quot;&gt;&lt;/a&gt;jzptab&lt;/h3&gt;&lt;p&gt;Time Limit: $10 Sec$&lt;br&gt;Memory Limit: $512 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;求$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$，答案模$10^9+9$输出。&lt;br&gt;多组询问。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一个正整数$T$表示数据组数。&lt;br&gt;接下来$T$行，每行两个正整数 表示$N,M$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;$T$行，每行一个整数，表示第$i$组数据的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2154 Crash的数字表格 &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ2154%20Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ2154 Crash的数字表格 莫比乌斯反演/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2018-03-16T06:16:50.090Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Crash的数字表格"><a href="#Crash的数字表格" class="headerlink" title="Crash的数字表格"></a>Crash的数字表格</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;259\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>今天的数学课上，$Crash$小朋友学习了最小公倍数$(Least\;Common\;Multiple)$。对于两个正整数$a$和$b$，$LCM(a, b)$表示能同时被$a$和$b$整除的最小正整数。例如，$LCM(6, 8) = 24$。回到家后，$Crash$还在想着课上学的东西，为了研究最小公倍数，他画了一张$N\times M$的表格。每个格子里写了一个数字，其中第$i$行第$j$列的那个格子里写着数为$LCM(i, j)$。看着这个表格，$Crash$想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当$N$和$M$很大时，$Crash$就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，$Crash$只想知道表格里所有数的和$\mod 20101009\;\;$的值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含两个正整数，分别表示$N$和$M$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个正整数，表示表格中所有数的和$\mod 20101009\;\;$的值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">122</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$100\%$的数据满足$N,M\le10^7$。</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{x=1}^{n}\sum_{y=1}^{m}\frac{x\times y}{\gcd(x,y)}\\<br>&amp;=\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{n}\sum_{y=1}^{m}[\gcd(x,y)=d]\frac{x\times y}{d}\\<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>&amp;Let\;f(n,m,d)=\sum_{x=1}^{n}\sum_{y=1}^{m}[\gcd(x,y)=d]\cdot x\cdot y\\<br>&amp;then\;f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)=\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(x,y)=1]\cdot x\cdot y\\<br>&amp;\therefore Ans=\sum_{d=1}^{\min(n,m)}\frac{f(n,m,d)}{d}=\sum_{d=1}^{\min(n,m)}f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)\times d\\<br>&amp;\;\;\;\;If\;we\;can\;calculate\;f(p,q,1)\;in\;a\;rapid\;way,\\&amp;\;\;\;\;we\;can\;calculate\;the\;answer\;rapidly.\\<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>f(p,q,1)&amp;=\sum_{i=1}^{p}\sum_{j=1}^{q}\sum_{d|\gcd(i,j)}\mu(d)\cdot i\cdot j\\<br>&amp;=\sum_{d=1}^{\min(p,q)}\mu(d)\times d^2\;\sum_{i=1}^{\lfloor\frac{p}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{q}{d}\rfloor}i\times j\\<br>&amp;=\sum_{d=1}^{\min(p,q)}\mu(d)\times d^2\times\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}\\<br>\end{aligned}<br>$$<br>由以上推导，可见$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$和$\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}$是可以根号分块的，在外层对$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$进行分块，在每个值相同的块中，对$\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}$进行分块以求出$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$带回外层算贡献。</p><p>综上，外层复杂度为$O(\sqrt{n})$，内层复杂度为$O(\sqrt{n})$，总时间复杂度为$O(n)$。</p><p>其实可以做得更块，详见加强版<a href="http://azrael.top/BZOJ2693%20jzptab%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/">BZOJ2693</a>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 20101009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">lnt n, m, ans, s[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">NotPri[<span class="number">1</span>] = <span class="literal">true</span>, mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= min(n,m); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; min(n,m)) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); i++) s[i] = (s[i<span class="number">-1</span>]+<span class="number">1L</span>L*mu[i]*i*i%MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">f</span><span class="params">(lnt p, lnt q)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">1</span>, r; l &lt;= min(p, q); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(p/(p/l), q/(q/l)), </span><br><span class="line">(ret += (p/l*(p/l+<span class="number">1</span>)/<span class="number">2</span>%MOD)*(q/l*(q/l+<span class="number">1</span>)/<span class="number">2</span>%MOD)%MOD*(s[r]-s[l<span class="number">-1</span>])%MOD) %= MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), getMu();</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), (ans += (l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>%MOD*f(n/l, m/l)%MOD) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (ans+MOD)%MOD), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;Crash的数字表格&quot;&gt;&lt;a href=&quot;#Crash的数字表格&quot; class=&quot;headerlink&quot; title=&quot;Crash的数字表格&quot;&gt;&lt;/a&gt;Crash的数字表格&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;259\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;今天的数学课上，$Crash$小朋友学习了最小公倍数$(Least\;Common\;Multiple)$。对于两个正整数$a$和$b$，$LCM(a, b)$表示能同时被$a$和$b$整除的最小正整数。例如，$LCM(6, 8) = 24$。回到家后，$Crash$还在想着课上学的东西，为了研究最小公倍数，他画了一张$N\times M$的表格。每个格子里写了一个数字，其中第$i$行第$j$列的那个格子里写着数为$LCM(i, j)$。看着这个表格，$Crash$想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当$N$和$M$很大时，$Crash$就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，$Crash$只想知道表格里所有数的和$\mod 20101009\;\;$的值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含两个正整数，分别表示$N$和$M$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个正整数，表示表格中所有数的和$\mod 20101009\;\;$的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1010【HNOI2008】玩具装箱toy &lt;斜率优化&gt;</title>
    <link href="http://azrael.top/BZOJ1010%E3%80%90HNOI2008%E3%80%91%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1toy%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://azrael.top/BZOJ1010【HNOI2008】玩具装箱toy 斜率优化/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-03-16T15:41:41.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【HNOI2008】玩具装箱toy"><a href="#【HNOI2008】玩具装箱toy" class="headerlink" title="【HNOI2008】玩具装箱toy"></a>【HNOI2008】玩具装箱toy</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$P$教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。$P$教授有编号为$1\sim N$的$N$件玩具，第$i$件玩具经过压缩后变成一维长度为$C_i$.为了方便整理，$P$教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第$i$件玩具到第$j$个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum_{k=i}^{j}C_k$制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$X$,其制作费用为$(X-L)^2$.其中$L$是一个常量。$P$教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望费用最小.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入两个整数$N,L$.接下来$N$行输入$C_i$.<br>$1\le N\le50000,1\le L,C_i\le10^7$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最小费用.<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>标签：<code>斜率优化DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>令$L=L+1$，有如下$DP$方程：$f[i]=\min_{j=0}^{i-1}{f[j]+[(i-j+\sum_{k=j}^{i}C_k)-L]^2}$。</p><p>预处理$s[i]=\sum_{j=1}^{i}C_j,\;w[i]=s[i]+i$。对于当前$DP$到的位置$i$，必然存在$p,q\in[0,i)$，使得<br>$$<br>\begin{aligned}<br>f[p]+[(i-p+\sum_{k=p}^{i}C_k)-L]^2&amp;\le f[q]+[(i-q+\sum_{k=q}^{i}C_k)-L]^2\\<br>&amp;\Updownarrow\\<br>f[p]+(w[i]-w[p]-L)^2&amp;\le f[q]+(w[i]-w[q]-L)^2\\<br>&amp;\Updownarrow\\<br>f[p]+w[i]^2+w[p]^2+L^2-2\times w[i]&amp;\times w[p]-2\times w[i]\times L+2\times w[p]\times L\\<br>&amp;\le\\<br>f[q]+w[i]^2+w[q]^2+L^2-2\times w[i]&amp;\times w[q]-2\times w[i]\times L+2\times w[q]\times L\\<br>&amp;\Updownarrow\\<br>f[p]+(w[p]+L)^2-2\times w[i]\times w[p]&amp;\le f[q]+(w[q]+L)^2-2\times w[i]\times w[q]\\<br>&amp;\Updownarrow\\<br>\frac{(f[p]-f[q])+((w[p]+L)^2-(w[q]+L)^2)}{2\times(w[p]-w[q])}&amp;\le w[i]\\<br>\end{aligned}<br>$$<br>$$<br>\therefore k(p,q)=\frac{(f[p]-f[q])+((w[p]+L)^2-(w[q]+L)^2)}{2\times(w[p]-w[q])}\le w[i]\iff p\;is\;better\;than\;q<br>$$<br>按照此斜率维护单调栈即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, l, sta[MAX_N+<span class="number">5</span>], s, t;lnt f[MAX_N+<span class="number">5</span>], w[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">dnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;<span class="keyword">return</span> (f[p]-f[q]+(w[p]+l)*(w[p]+l)-(w[q]+l)*(w[q]+l))/(<span class="number">2.0</span>*(w[p]-w[q]));&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(l), l++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(w[i]), w[i] += w[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) w[i] += i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (s &lt; t &amp;&amp; calc(sta[s+<span class="number">1</span>], sta[s]) &lt;= w[i]) s++;</span><br><span class="line">f[i] = f[sta[s]]+(w[i]-w[sta[s]]-l)*(w[i]-w[sta[s]]-l);</span><br><span class="line"><span class="keyword">while</span> (s &lt; t &amp;&amp; calc(sta[t], sta[t<span class="number">-1</span>]) &gt; calc(i, sta[t])) t--;</span><br><span class="line">sta[++t] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【HNOI2008】玩具装箱toy&quot;&gt;&lt;a href=&quot;#【HNOI2008】玩具装箱toy&quot; class=&quot;headerlink&quot; title=&quot;【HNOI2008】玩具装箱toy&quot;&gt;&lt;/a&gt;【HNOI2008】玩具装箱toy&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$P$教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。$P$教授有编号为$1\sim N$的$N$件玩具，第$i$件玩具经过压缩后变成一维长度为$C_i$.为了方便整理，$P$教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第$i$件玩具到第$j$个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum_{k=i}^{j}C_k$制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$X$,其制作费用为$(X-L)^2$.其中$L$是一个常量。$P$教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望费用最小.&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行输入两个整数$N,L$.接下来$N$行输入$C_i$.&lt;br&gt;$1\le N\le50000,1\le L,C_i\le10^7$&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出最小费用.&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="斜率优化" scheme="http://azrael.top/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1096【ZJOI2007】仓库建设 &lt;斜率优化&gt;</title>
    <link href="http://azrael.top/BZOJ1096%E3%80%90ZJOI2007%E3%80%91%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://azrael.top/BZOJ1096【ZJOI2007】仓库建设 斜率优化/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-03-18T04:45:26.666Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【ZJOI2007】仓库建设"><a href="#【ZJOI2007】仓库建设" class="headerlink" title="【ZJOI2007】仓库建设"></a>【ZJOI2007】仓库建设</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$L$公司有$N$个工厂，由高到底分布在一座山上。如图所示，工厂$1$在山顶，工厂$N$在山脚。由于这座山处于高原内陆地区（干燥少雨），$L$公司一般把产品直接堆放在露天，以节省费用。突然有一天，$L$公司的总裁$L$先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是$L$先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第$i$个工厂目前已有成品$P_i$件，在第$i$个工厂位置建立仓库的费用是$C_i$。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于$L$公司产品的对外销售处设置在山脚的工厂$N$，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送$1$个单位距离的费用是$1$。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：</p><ol><li>工厂$i$距离工厂$1$的距离$X_i$（其中$X_1=0$）</li><li>工厂$i$目前已有成品数量$P_i$</li><li>在工厂$i$建立仓库的费用$C_i$</li></ol><p>请你帮助$L$公司寻找一个仓库建设的方案，使得总的费用（$建造费用+运输费用$）最小。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数$N$，表示工厂的个数。接下来$N$行每行包含两个整数$X_i, P_i, C_i$, 意义如题中所述。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个整数，为可以找到最优方案的费用。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 5 10</span><br><span class="line">5 3 100</span><br><span class="line">9 6 10</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><p>标签：<code>斜率优化DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由题意，易得到$DP$方程：$f[i]=c[i]+\min_{j=0}^{i-1}{f[j]+\sum_{k=j+1}^{i}p[k]\times(x[i]-x[k])}$<br>那么对于当前$DP$到的位置$i$，一定存在$p,q\in[0,i)$使得<br>$$<br>\begin{aligned}<br>f[p]+\sum_{k=p+1}^{i}p[k]\times(x[i]-x[k])&amp;\le f[q]+\sum_{k=q+1}^{i}p[k]\times(x[i]-x[k])\\<br>f[p]+\sum_{k=p+1}^{i}p[k]\times x[i]-\sum_{k=p+1}^{i}p[k]\times x[k]&amp;\le f[q]+\sum_{k=q+1}^{i}p[k]\times x[i]-\sum_{k=q+1}^{i}p[k]\times x[k]\\<br>Let\;s_1[i]=\sum_{j=1}^{i}p[j]\times x[j]&amp;,\;s_2[i]=\sum_{j=1}^{i}p[j]\\<br>f[p]+(s_2[i]-s_2[p])\times x[i]-s_1[i]+s_1[p]&amp;\le f[q]+(s_2[i]-s_2[q])\times x[i]-s_1[i]+s_1[q]\\<br>f[p]-s_2[p]\times x[i]+s_1[p]&amp;\le f[q]-s_2[q]\times x[i]+s_1[q]\\<br>\frac{(f[p]-f[q])+(s_1[p]-s_1[q])}{s_2[p]-s_2[q]}&amp;\le x[i]\\<br>\end{aligned}<br>$$<br>$$<br>\therefore k(p,q)=\frac{(f[p]-f[q])+(s_1[p]-s_1[q])}{s_2[p]-s_2[q]}\le x[i]\iff p\;is\;better\;than\;q<br>$$<br>按照此斜率维护单调栈即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, c[MAX_N+<span class="number">5</span>], x[MAX_N+<span class="number">5</span>], m[MAX_N+<span class="number">5</span>];</span><br><span class="line">lnt s1[MAX_N+<span class="number">5</span>], s2[MAX_N+<span class="number">5</span>], f[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> l, r, sta[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">dnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;<span class="keyword">return</span> (dnt)(f[p]-f[q]+s1[p]-s1[q])/(dnt)(s2[p]-s2[q]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(x[i]), read(m[i]), read(c[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s1[i] = s1[i<span class="number">-1</span>]+<span class="number">1L</span>L*m[i]*x[i], s2[i] = s2[i<span class="number">-1</span>]+m[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; calc(sta[l+<span class="number">1</span>], sta[l]) &lt;= x[i]) l++;</span><br><span class="line">f[i] = f[sta[l]]+<span class="number">1L</span>L*x[i]*(s2[i]-s2[sta[l]])-s1[i]+s1[sta[l]]+c[i];</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; calc(sta[r], sta[r<span class="number">-1</span>]) &gt; calc(i, sta[r])) r--;</span><br><span class="line">sta[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【ZJOI2007】仓库建设&quot;&gt;&lt;a href=&quot;#【ZJOI2007】仓库建设&quot; class=&quot;headerlink&quot; title=&quot;【ZJOI2007】仓库建设&quot;&gt;&lt;/a&gt;【ZJOI2007】仓库建设&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$L$公司有$N$个工厂，由高到底分布在一座山上。如图所示，工厂$1$在山顶，工厂$N$在山脚。由于这座山处于高原内陆地区（干燥少雨），$L$公司一般把产品直接堆放在露天，以节省费用。突然有一天，$L$公司的总裁$L$先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是$L$先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第$i$个工厂目前已有成品$P_i$件，在第$i$个工厂位置建立仓库的费用是$C_i$。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于$L$公司产品的对外销售处设置在山脚的工厂$N$，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送$1$个单位距离的费用是$1$。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工厂$i$距离工厂$1$的距离$X_i$（其中$X_1=0$）&lt;/li&gt;
&lt;li&gt;工厂$i$目前已有成品数量$P_i$&lt;/li&gt;
&lt;li&gt;在工厂$i$建立仓库的费用$C_i$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请你帮助$L$公司寻找一个仓库建设的方案，使得总的费用（$建造费用+运输费用$）最小。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含一个整数$N$，表示工厂的个数。接下来$N$行每行包含两个整数$X_i, P_i, C_i$, 意义如题中所述。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅包含一个整数，为可以找到最优方案的费用。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="斜率优化" scheme="http://azrael.top/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>HDU4560 我是歌手 &lt;二分+网络流&gt;</title>
    <link href="http://azrael.top/HDU4560%20%E6%88%91%E6%98%AF%E6%AD%8C%E6%89%8B%20%E4%BA%8C%E5%88%86+%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://azrael.top/HDU4560 我是歌手 二分+网络流/</id>
    <published>2018-02-20T16:00:00.000Z</published>
    <updated>2018-03-08T04:41:12.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="我是歌手"><a href="#我是歌手" class="headerlink" title="我是歌手"></a>我是歌手</h3><p>Time Limit: $2000 MS$<br>Memory Limit: $32768 KB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$2013$年一开始，一档音乐节目“我是歌手”就惊艳了大家一回。闲话少说，现在，你成为了这档节目的总导演，你的任务很简单，安排每一期节目的内容。<br>现在有$N$个歌手，$M$种歌曲流派（$Rock$，$Pop$之类），每个歌手都有自己擅长的流派领域，这些资料都已整理。你的工作是，安排尽可能多场的演唱比赛。每一场比赛所有歌手都必须上场，为了提高收视率，每个人演唱的歌曲类型不能相同，即便一些歌手要被迫选择一些他们不擅长的。同时，为了展现全面性，在不同的演唱比赛上，每个歌手都会安排不同的歌曲流派。<br>但是问题是，对于任何一个歌曲流派的歌迷，如果超过$K$个不擅长的歌手演唱了这种歌曲，他们就会表示不满，比如，发一些宣泄不满的帖子微博，为了表示观点挑起事端等等。你当然不希望这些事情与你的节目有关，在这个前提下，你可以任意安排尽可能多的比赛场次。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为$T$，表示有$T$组测试数据。<br>每组数据以四个数字$N$，$M$，$L$，$K$开始。$L$表示有$L$组擅长关系，接下来的$L$行，每一行有两个数字$A_i$，$B_i$，表示歌手$A_i$擅长$B_i$类型的歌曲。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每组数据，先输出为第几组数据，然后输出最多比赛场次。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1 0</span><br><span class="line">1 1</span><br><span class="line">1 3 0 1</span><br><span class="line">3 3 5 1</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 3</span><br><span class="line">Case 3: 2</span><br></pre></td></tr></table></figure><p><strong>Explanation</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对第三组样例，可以如此安排：</span><br><span class="line">第一场三位歌手分别演唱(2,3,1)类型的歌曲，第二场分别演唱(1,2,3)。</span><br><span class="line">这样只有类型3被不擅长的歌手演唱过1次，挑剔的歌迷观众还可以接受。</span><br></pre></td></tr></table></figure></p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$1\le T \le 100 $<br>$1\le N \le M \le 74, 0 \le K \le N $<br>$0\le L \le N\times M$<br>$1\le A_i \le N, 1 \le B_i \le M$<br>相同关系不会重复出现</p><p>标签：<code>带修主席树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>挺好的一道$二分+网络流$套路建模题。</p><p>二分最多能安排的场次，得到当前答案进行判定。</p><p>首先，如果保证每个人唱每种流派最多仅一次，并且$n$个流派均会被唱至少$tans$次，那么一定能找到一组解。这样就可以用最大流判定。<br>由于有“每个流派仅能有$k$个不擅长的选手唱”，我们需要把每个流派又擅长的选手唱和不擅长的选手唱分开，而限制不擅长的选手的数量。可将每个流派拆成两个点，即第$i$个流派$Style_i$拆成$Style_i$和$Style_i’$。从$Style_i$向擅长的选手连边，从$Style_i’$向不擅长的选手连边，而由于从源点向$Style_i$连有$tans$的边，因而所有可用流量都在$Style_i$中，$Style_i’$的流量需要限制，故要在$Style_i$和$Style_i’$间连$K$的边来限制不擅长选手的数量。</p><p>建模总述：<br>$$<br>\begin{aligned}<br>S &amp;\to Style_i(i\in [1,m]):Capacity=tans\\<br>Style_i &amp;\to Style_i’(i\in [1,m]):Capacity=K\\<br>Style_i &amp;\to Competitor_j(Competitor_j is good at Style_i):Capacity=1\\<br>Style_i’ &amp;\to Competitor_j(Competitor_j is not good at Style_i):Capacity = 1\\<br>Competitor_j &amp;\to T(j\in [1,n]):Capacity=tans\\<br>\end{aligned}<br>$$<br>建模后跑最大流，看是否有$MaxFlow=tans\times n$即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 2000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, f, s, t, cnt, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="keyword">bool</span> G[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;cnt = s = <span class="number">0</span>, t = <span class="number">3</span>*m+<span class="number">1</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>;cpy();<span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec();<span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> tans)</span> </span>&#123;</span><br><span class="line">init();<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(i+<span class="number">2</span>*m, t, tans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) addedge(s, i, tans), addedge(i, i+m, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) addedge(G[i][j] ? i : i+m, j+<span class="number">2</span>*m, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Dinic() == n*tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid)) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = mid, l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> C = <span class="number">1</span>; C &lt;= T; C++) &#123;</span><br><span class="line">read(n), read(m), read(f), read(k), <span class="built_in">memset</span>(G, <span class="literal">false</span>, <span class="keyword">sizeof</span> G);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y; i &lt; f; i++) read(x), read(y), G[y][x] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, C, bi_search(<span class="number">1</span>, m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;我是歌手&quot;&gt;&lt;a href=&quot;#我是歌手&quot; class=&quot;headerlink&quot; title=&quot;我是歌手&quot;&gt;&lt;/a&gt;我是歌手&lt;/h3&gt;&lt;p&gt;Time Limit: $2000 MS$&lt;br&gt;Memory Limit: $32768 KB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$2013$年一开始，一档音乐节目“我是歌手”就惊艳了大家一回。闲话少说，现在，你成为了这档节目的总导演，你的任务很简单，安排每一期节目的内容。&lt;br&gt;现在有$N$个歌手，$M$种歌曲流派（$Rock$，$Pop$之类），每个歌手都有自己擅长的流派领域，这些资料都已整理。你的工作是，安排尽可能多场的演唱比赛。每一场比赛所有歌手都必须上场，为了提高收视率，每个人演唱的歌曲类型不能相同，即便一些歌手要被迫选择一些他们不擅长的。同时，为了展现全面性，在不同的演唱比赛上，每个歌手都会安排不同的歌曲流派。&lt;br&gt;但是问题是，对于任何一个歌曲流派的歌迷，如果超过$K$个不擅长的歌手演唱了这种歌曲，他们就会表示不满，比如，发一些宣泄不满的帖子微博，为了表示观点挑起事端等等。你当然不希望这些事情与你的节目有关，在这个前提下，你可以任意安排尽可能多的比赛场次。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入第一行为$T$，表示有$T$组测试数据。&lt;br&gt;每组数据以四个数字$N$，$M$，$L$，$K$开始。$L$表示有$L$组擅长关系，接下来的$L$行，每一行有两个数字$A_i$，$B_i$，表示歌手$A_i$擅长$B_i$类型的歌曲。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对每组数据，先输出为第几组数据，然后输出最多比赛场次。&lt;br&gt;
    
    </summary>
    
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="http://azrael.top/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="HDU" scheme="http://azrael.top/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>CF446C DZY Loves Fibonacci Numbers &lt;线段树&gt;</title>
    <link href="http://azrael.top/CF446C%20DZY%20Loves%20Fibonacci%20Numbers%20%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://azrael.top/CF446C DZY Loves Fibonacci Numbers 线段树/</id>
    <published>2018-02-19T16:00:00.000Z</published>
    <updated>2018-03-08T04:49:44.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="DZY-Loves-Fibonacci-Numbers"><a href="#DZY-Loves-Fibonacci-Numbers" class="headerlink" title="DZY Loves Fibonacci Numbers"></a>DZY Loves Fibonacci Numbers</h3><p>Time limit: $4Sec$<br>Memory limit: $256MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>In mathematical terms, the sequence $F_n$ of $Fibonacci$ $numbers$ is defined by the recurrence relation $F_1 = 1,F_2 = 1,F_3=F_1+F_2=3,\cdots F_n = F_{n-1}+F_{n-2}$.<br>$DZY$ loves Fibonacci numbers very much. Today $DZY$ gives you an array consisting of $n$ integers: $a_1, a_2,cdots , a_n$. Moreover, there are $m$ queries, each query has one of the two types:</p><ol><li>Format of the query “$1$ $l$ $r$”. In reply to the query, you need to add $F_{i-l+1}$ to each element $a_i$, where $l\le i\le r$.</li><li>Format of the query “$2$ $l$ $r$”. In reply to the query you should output the value of  $\sum_{i=l}^{r}{a_i}$ modulo $10^9+9$.</li></ol><p>Help $DZY$ reply to all the queries.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains two integers $n$ and $m$ $(1 \le n, m \le 3\times 10^5)$. The second line contains <em>n</em> integers $a_1, a_2, \cdots, a_n (1 ≤ a_i \le10^9)$ — initial array $a$.<br>Then, <em>m</em> lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality $1 \le l \le r \le n$ holds.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each query of the second type, print the value of the sum on a single line.<br><a id="more"></a></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>Input</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 3 4</span><br><span class="line">1 1 4</span><br><span class="line">2 1 4</span><br><span class="line">1 2 4</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure></p><p><strong>Output</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>After the first query, $a = [2, 3, 5, 7]$.<br>For the second query, $sum = 2 + 3 + 5 + 7 = 17$.<br>After the third query, $a = [2, 4, 6, 9]$.<br>For the fourth query, $sum = 2 + 4 + 6 = 12$.</p><p>标签：<code>线段树</code></p><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>题目大意：<br>给出一个长为$3\times 10^5$级别的初始数组，要求维护两种操作：</p><ol><li>将$a_l \sim a_r$中的每个数对应加上从$Fib_1\sim Fib_{l-r+1}$的斐波那契数，即使$a_i(i\in[l,r])$加上$Fib_{i-l+1}$</li><li>询问$\sum_{i=l}^{r}{a_i}$模$10^9+9$的值</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不难想到此题需要用线段树维护。不过难点在于如何合并标记。</p><p>初步想法是每次打标记时记录下此区间是从斐波那契数列的多少项开始一一对应地加进去，不过这样是无法合并标记的，每个结点只能有一个标记，可以被卡成$O(n^2\log n)$。</p><p>考虑把标记换一种存法。对于一个数列$x_1=a,x_2=b,x_3=a+b,x_4=a+b\times 2,\cdots x_n=x_{n-1}+x_{n-2}$，我们将其称为一个“伪斐波那契数列”，不难发现其等于几个斐波那契数列的子序列之和，即在原题中，不管如何加，每个区间最后加的数列都是一个伪斐波那契数列。而此序列可以仅通过最前面的两项$a$和$b$推出后面的任意项以及前若干项之和，即<br>$$<br>\begin{aligned}<br>x_n &amp;= x_{n-1}+x_{n-2}\\<br>&amp;= 2\times x_{n-2}+x_{n-3}\\<br>&amp;= 3\times x_{n-3}+2\times x_{n-4}\\<br>&amp;= Fib_{n-2}\times x_1+Fib_{n-1}\times x_2\\<br>\sum_{i=1}^{n}{x_i} &amp;= x_1+x_2+x_3+\cdots x_n\\<br>&amp;= x_1+x_2+x_2+x_3+\cdots +x_n-x_2\\<br>&amp;= x_3+x_4+x_4+x_5+\cdots +x_n-x_2\\<br>&amp;= x_5+x_6+x_6+x_7+\cdots +x_n-x_2\\<br>&amp;= x_{n-2}+x_{n-1}+x_{n-1}+x_{n}-x_2\\<br>&amp;= x_n+x_{n+1}-x_2\\<br>&amp;= x_{n+2}-x_{2}<br>\end{aligned}<br>$$<br>用这两个公式我们可以$O(1)$计算任意项及前任意项的和。<br>每个标记为一个数对$(a,b)$，那么合并标记的时候将两个标记的$a$和$b$分别相加，得到$(a_1+a_2,b_1+b_2)$即可。<br>总时间复杂度$O(n\log n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;lnt fib[MAX_N+<span class="number">5</span>] = &#123;<span class="number">0L</span>L, <span class="number">1L</span>L&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>lnt c, f1, f2;&#125; tr[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function">lnt <span class="title">fn</span><span class="params">(lnt f1, lnt f2, <span class="keyword">int</span> len)</span> </span>&#123;<span class="keyword">return</span> len == <span class="number">1</span> ? f1 : (len == <span class="number">2</span> ? f2 : (f1*fib[len<span class="number">-2</span>]%MOD+f2*fib[len<span class="number">-1</span>]%MOD)%MOD);&#125;</span><br><span class="line"><span class="function">lnt <span class="title">sum</span><span class="params">(lnt f1, lnt f2, <span class="keyword">int</span> len)</span> </span>&#123;<span class="keyword">return</span> len == <span class="number">1</span> ? f1 : (len == <span class="number">2</span> ? (f1+f2)%MOD : (fn(f1, f2, len+<span class="number">2</span>)-f2+MOD)%MOD);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;tr[v].c = (tr[v&lt;&lt;<span class="number">1</span>].c+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].c)%MOD;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[v].f1) <span class="keyword">return</span>;</span><br><span class="line">lnt lf1 = tr[v].f1, lf2 = tr[v].f2, rf1 = fn(lf1, lf2, mid-s+<span class="number">2</span>), rf2 = fn(lf1, lf2, mid-s+<span class="number">3</span>);</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>].f1 += lf1) %= MOD, (tr[v&lt;&lt;<span class="number">1</span>].f2 += lf2) %= MOD, (tr[v&lt;&lt;<span class="number">1</span>].c += sum(lf1, lf2, mid-s+<span class="number">1</span>)) %= MOD;</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].f1 += rf1) %= MOD, (tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].f2 += rf2) %= MOD, (tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].c += sum(rf1, rf2, t-mid)) %= MOD;</span><br><span class="line">tr[v].f1 = tr[v].f2 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;read(tr[v].c); <span class="keyword">return</span>;&#125;</span><br><span class="line">build(v&lt;&lt;<span class="number">1</span>, s, mid), build(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t);</span><br><span class="line">updata(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">(tr[v].f1 += fib[s-l+<span class="number">1</span>]) %= MOD, (tr[v].f2 += fib[s-l+<span class="number">2</span>]) %= MOD;</span><br><span class="line">(tr[v].c += sum(fib[s-l+<span class="number">1</span>], fib[s-l+<span class="number">2</span>], t-s+<span class="number">1</span>)) %= MOD;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) modify(v&lt;&lt;<span class="number">1</span>, s, mid, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) modify(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r);</span><br><span class="line">updata(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].c;</span><br><span class="line">lnt ret = <span class="number">0</span>;downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) (ret += query(v&lt;&lt;<span class="number">1</span>, s, mid, l, r)) %= MOD;</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) (ret += query(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r)) %= MOD;</span><br><span class="line">updata(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) fib[i] = (fib[i<span class="number">-2</span>]+fib[i<span class="number">-1</span>])%MOD;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), init(), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, l, r;read(opt), read(l), read(r);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) modify(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;DZY-Loves-Fibonacci-Numbers&quot;&gt;&lt;a href=&quot;#DZY-Loves-Fibonacci-Numbers&quot; class=&quot;headerlink&quot; title=&quot;DZY Loves Fibonacci Numbers&quot;&gt;&lt;/a&gt;DZY Loves Fibonacci Numbers&lt;/h3&gt;&lt;p&gt;Time limit: $4Sec$&lt;br&gt;Memory limit: $256MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;In mathematical terms, the sequence $F_n$ of $Fibonacci$ $numbers$ is defined by the recurrence relation $F_1 = 1,F_2 = 1,F_3=F_1+F_2=3,\cdots F_n = F_{n-1}+F_{n-2}$.&lt;br&gt;$DZY$ loves Fibonacci numbers very much. Today $DZY$ gives you an array consisting of $n$ integers: $a_1, a_2,cdots , a_n$. Moreover, there are $m$ queries, each query has one of the two types:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Format of the query “$1$ $l$ $r$”. In reply to the query, you need to add $F_{i-l+1}$ to each element $a_i$, where $l\le i\le r$.&lt;/li&gt;
&lt;li&gt;Format of the query “$2$ $l$ $r$”. In reply to the query you should output the value of  $\sum_{i=l}^{r}{a_i}$ modulo $10^9+9$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Help $DZY$ reply to all the queries.&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;The first line of the input contains two integers $n$ and $m$ $(1 \le n, m \le 3\times 10^5)$. The second line contains &lt;em&gt;n&lt;/em&gt; integers $a_1, a_2, \cdots, a_n (1 ≤ a_i \le10^9)$ — initial array $a$.&lt;br&gt;Then, &lt;em&gt;m&lt;/em&gt; lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality $1 \le l \le r \le n$ holds.&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;For each query of the second type, print the value of the sum on a single line.&lt;br&gt;
    
    </summary>
    
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="CodeForces" scheme="http://azrael.top/tags/CodeForces/"/>
    
  </entry>
  
</feed>
