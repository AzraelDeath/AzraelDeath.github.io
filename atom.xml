<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NIRVANA</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://azrael.top/"/>
  <updated>2018-04-20T12:58:24.673Z</updated>
  <id>http://azrael.top/</id>
  
  <author>
    <name>Azrael_Death</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ1178【APIO2009】会议中心 &lt;贪心+倍增&gt;</title>
    <link href="http://azrael.top/BZOJ1178%E3%80%90APIO2009%E3%80%91%E4%BC%9A%E8%AE%AE%E4%B8%AD%E5%BF%83%20%E8%B4%AA%E5%BF%83+%E5%80%8D%E5%A2%9E/"/>
    <id>http://azrael.top/BZOJ1178【APIO2009】会议中心 贪心+倍增/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-20T12:58:24.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2009】会议中心"><a href="#【APIO2009】会议中心" class="headerlink" title="【APIO2009】会议中心"></a>【APIO2009】会议中心</h3><p>$\mathrm{Time\;Limit:\;15\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Siruseri}$政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。<br>对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。<br>显然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有$4$个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。</p><table><thead><tr><th>公司</th><th>开始日期</th><th>结束日期</th></tr></thead><tbody><tr><td>$公司1$</td><td>$4$</td><td>$9$</td></tr><tr><td>$公司2$</td><td>$9$</td><td>$11$</td></tr><tr><td>$公司3$</td><td>$13$</td><td>$19$</td></tr><tr><td>$公司4$</td><td>$10$</td><td>$17$</td></tr></tbody></table><p>上例中，最多将会堂租借给两家公司。租借策略分别是租给$公司1$和$公司3$， 或是$公司2$和$公司3$，也可以是$公司1$和$公司4$。注意会议中心一天最多租借给 一个公司，所以$公司1$和$公司2$不能同时租借会议中心，因为他们在第九天重合 了。<br>销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小的候选策略作为最终的策略。<br>例中，会堂最终将被租借给$公司1$和$公司3$：$3$个候选策略是 $\lbrace(1,3),(2,3),(1,4)\rbrace$，而在字典序中$(1,3)&lt;(1,4)&lt;(2,3)$。<br>你的任务是帮助销售主管确定应该将会堂租借给哪些公司。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有一个整数$N\;(N\le2\times10^5)$，表示发出租借会堂申请的公司的个数。<br>第$2$到第$N+1$行每行有$2$个整数。第$i+1$行的整数表示第$i$家公司申请租借的起始和终止日期。<br>对于每个公司的申请，起始日期为不小于$1$的整数，终止日期为不大于$10^9$的整数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出的第一行应有一个整数$M$，表示最多可以租借给多少家公司。<br>第二行应列出$M$个数，表示最终将会堂租借给哪些公司。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4 9</span><br><span class="line">9 11</span><br><span class="line">13 19</span><br><span class="line">10 17</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>修复数据$\mathrm{BUG}$，并新加数据一组。$\mathrm{By\;NanoApe\;2016.5.11}$<br><a href="http://www.lydsy.com/JudgeOnline/upload/201605/dd.rar" target="_blank" rel="noopener">修复后数据</a></p><p>标签：<code>贪心</code> <code>倍增</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思路清奇的贪心…</p><p>如果没有“字典序最小”，直接无脑贪心即可。有输方案的要求后，就需要用另外一种贪心。</p><p>首先先做一遍贪心找到最多能有多少个会议，然后从$1$到$n$按编号枚举会议，看当前会议加入后会不会使答案变小，如果不会变小就贪心把这个会议加入到方案中。</p><p>具体地，首先以$r$从小到大为第一关键字，以$l$从大到小为第二关键字排序，去掉包含的区间。<br>找到一种方法（一会儿说）计算$F(p,q)$，表示$p\sim q$时间段最多可以放多少个会议。<br>对于会议$i$，其时间段是$[l,r]$，已经加入的会议中此会议的前驱的结束时间是$lr$，后继的开始时间是$rl$（前驱和后继用<code>set</code>维护）。</p><ul><li>若$l\le lr$或$r\ge rl$，那么一定不能放入。</li><li>若$F(lr+1,l-1)+F(r+1,rl-1)+1=F(lr+1,rl-1)$，那么放入后一定不会影响答案，输出编号后把此会议加入<code>set</code>即可。这个等式表示加入此会议后虽然把原区间分成了三个子区间，但最大值依旧不变。</li><li>若$F(lr+1,l-1)+F(r+1,rl-1)+1\ne F(lr+1,rl-1)$，那么不能放入。</li></ul><p>这样一来，就可以解决输出方案的问题了。</p><p>但如何计算$F(p,q)$呢？<br>如果直接算，是$O(n)$的，考虑把这个过程变成$O(\log n)$。<br>倍增预处理出$nxt[u][i]$，表示从区间$u$开始向后选$2^i$个连续区间，最后一个区间的编号。于是每次计算可以倍增跳累加答案。</p><p>$\mathrm{Problem\;solved.}$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, L[MAX_N+<span class="number">5</span>], R[MAX_N+<span class="number">5</span>], nxt[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> l, r; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span>;&#125; a[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> node::<span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> r == t.r ? l &gt; t.l : r &lt; t.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = lower_bound(L+<span class="number">1</span>, L+m+<span class="number">1</span>, l)-L, ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (u &gt; m || R[u] &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (nxt[u][i] &amp;&amp; R[nxt[u][i]] &lt;= r)</span><br><span class="line">ret += <span class="number">1</span>&lt;&lt;i, u = nxt[u][i];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); <span class="built_in">set</span> &lt;node&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(a[i].l), read(a[i].r), b[i] = a[i];</span><br><span class="line">sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>), m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (b[i].l &gt; b[m].l) b[++m] = b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) L[i] = b[i].l, R[i] = b[i].r;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= m &amp;&amp; b[j].l &lt;= b[i].r) j++;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= m) nxt[i][<span class="number">0</span>] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOG; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">nxt[j][i] = nxt[nxt[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">s.insert((node)&#123;-INF, -INF&#125;), s.insert((node)&#123;INF, INF&#125;);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, calc(-INF, INF));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">set</span> &lt;node&gt; :: iterator ln = s.lower_bound(a[i]), rn = ln;</span><br><span class="line">ln--; <span class="keyword">int</span> l = a[i].l, r = a[i].r, lr = ln-&gt;r, rl = rn-&gt;l;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= lr || r &gt;= rl) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (calc(lr+<span class="number">1</span>, rl<span class="number">-1</span>) == calc(lr+<span class="number">1</span>, l<span class="number">-1</span>)+calc(r+<span class="number">1</span>, rl<span class="number">-1</span>)+<span class="number">1</span>)</span><br><span class="line">s.insert(a[i]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">""</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2009】会议中心&quot;&gt;&lt;a href=&quot;#【APIO2009】会议中心&quot; class=&quot;headerlink&quot; title=&quot;【APIO2009】会议中心&quot;&gt;&lt;/a&gt;【APIO2009】会议中心&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;15\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Siruseri}$政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。&lt;br&gt;对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。&lt;br&gt;显然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有$4$个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;公司&lt;/th&gt;
&lt;th&gt;开始日期&lt;/th&gt;
&lt;th&gt;结束日期&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$公司1$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$9$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司2$&lt;/td&gt;
&lt;td&gt;$9$&lt;/td&gt;
&lt;td&gt;$11$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司3$&lt;/td&gt;
&lt;td&gt;$13$&lt;/td&gt;
&lt;td&gt;$19$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司4$&lt;/td&gt;
&lt;td&gt;$10$&lt;/td&gt;
&lt;td&gt;$17$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上例中，最多将会堂租借给两家公司。租借策略分别是租给$公司1$和$公司3$， 或是$公司2$和$公司3$，也可以是$公司1$和$公司4$。注意会议中心一天最多租借给 一个公司，所以$公司1$和$公司2$不能同时租借会议中心，因为他们在第九天重合 了。&lt;br&gt;销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小的候选策略作为最终的策略。&lt;br&gt;例中，会堂最终将被租借给$公司1$和$公司3$：$3$个候选策略是 $\lbrace(1,3),(2,3),(1,4)\rbrace$，而在字典序中$(1,3)&amp;lt;(1,4)&amp;lt;(2,3)$。&lt;br&gt;你的任务是帮助销售主管确定应该将会堂租借给哪些公司。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行有一个整数$N\;(N\le2\times10^5)$，表示发出租借会堂申请的公司的个数。&lt;br&gt;第$2$到第$N+1$行每行有$2$个整数。第$i+1$行的整数表示第$i$家公司申请租借的起始和终止日期。&lt;br&gt;对于每个公司的申请，起始日期为不小于$1$的整数，终止日期为不大于$10^9$的整数。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出的第一行应有一个整数$M$，表示最多可以租借给多少家公司。&lt;br&gt;第二行应列出$M$个数，表示最终将会堂租借给哪些公司。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="贪心" scheme="http://azrael.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="倍增" scheme="http://azrael.top/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>【APIO2011】方格染色 &lt;带权并查集&gt;</title>
    <link href="http://azrael.top/BZOJ2303%E3%80%90APIO2011%E3%80%91%E6%96%B9%E6%A0%BC%E6%9F%93%E8%89%B2%20%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://azrael.top/BZOJ2303【APIO2011】方格染色 带权并查集/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-20T12:21:28.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2011】方格染色"><a href="#【APIO2011】方格染色" class="headerlink" title="【APIO2011】方格染色"></a>【APIO2011】方格染色</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;256MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Sam}$和他的妹妹$\mathrm{Sara}$有一个包含$n\times m$个方格的表格。她们想要将其的每个方格都染成红色或蓝色。<br>出于个人喜好，他们想要表格中每个$2\times 2$的方形区域都包含奇数个（$1$个或$3$个）红色方格。 可是昨天晚上，有人已经给表格中的一些方格染上了颜色！<br>现在$\mathrm{Sam}$和$\mathrm{Sara}$非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格仍然满足她们的要求。<br>如果可能的话，满足他们要求的染色方案数有多少呢？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含三个整数$n$, $m$和$k$，分别代表表格的行数、列数和已被染色的方格数目。<br>之后的$k$行描述已被染色的方格。其中第$i$行包含三个整数$x_i$, $y_i$和$c_i$，分别代表第$i$个已被染色的方格的行编号、列编号和颜色。$c_i$为$1$表示方格被染成红色，$c_i$为$0$表示方格被染成蓝色。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示可能的染色方案数目$W$模$10^9$得到的值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于所有的测试数据，$2\le n,m\le10^6$, $0\le k\le10^6$, $1\le x_i\le n$, $1\le y_i\le m$。<br>数据为国内数据+国际数据+修正版<br>鸣谢<code>GYZ</code></p><p>标签：<code>带权并查集</code> <code>异或方程组</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>并查集解异或方程组。</p><p>令$a_{i,j}$表示第$i$行第$j$列的格子最终是否被染，对于$\forall i\in[1,n),j\in[1,m)$，一定有$a_{i,j}\oplus a_{i,j+1}\oplus a_{i+1,j}\oplus a_{i+1,j+1}=1$。而易得到结论：确定一行一列的情况，即可确定最后是否能正确染色。</p><p>于是我们尝试确定第一行和第一列的情况，即做一个$n+m-1$个变量的异或方程组。<br>对于给定的$a_{x,y}=0/1$，我们如果把$i\in[1,x),j\in[1,y)$的所有上一段所属方程异或起来，那么相同元抵消，可知$a_{1,1}\oplus a_{i,1}\oplus a_{1,j}=a_{i,j}\oplus1$，如果我们知道$a_{1,1}$，那么就能确定$a_{i,1}\oplus a_{1,j}$的值，这时用一个带权并查集维护一下，即可得到联通块的个数。那么答案为$2^{自由元个数-1}$（$a_{1,1}$所在联通块的取值是一定的）。<br>如果我们预先不知道$a_{1,1}$的值，就可以枚举两种取值，分别计算后加起来即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, f[MAX_N+<span class="number">5</span>], g[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> x[MAX_N+<span class="number">5</span>], y[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> f[x] == x ? x : getf(f[x]), g[x] ^= g[f[x]], f[x] = f[f[x]];&#125;</span><br><span class="line"><span class="function">lnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> (x[i] &gt; <span class="number">1</span> &amp;&amp; y[i] &gt; <span class="number">1</span>) c[i] ^= val;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+m; i++) f[i] = i, g[i] = <span class="number">0</span>; f[n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> ((x[i]^<span class="number">1</span>) || (y[i]^<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getf(x[i]), v = getf(y[i]+n), w = g[x[i]]^g[y[i]+n]^c[i];</span><br><span class="line"><span class="keyword">if</span> (u^v) f[v] = u, g[v] = w; <span class="keyword">else</span> <span class="keyword">if</span> (w) <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>; i &lt;= n+m; i++) <span class="keyword">if</span> (getf(i) == i)</span><br><span class="line">&#123;<span class="keyword">if</span> (t) (ret *= <span class="number">2L</span>L) %= MOD; <span class="keyword">else</span> t = <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), read(k);</span><br><span class="line"><span class="keyword">bool</span> f0 = <span class="literal">true</span>, f1 = <span class="literal">true</span>; lnt ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">read(x[i]), read(y[i]), read(c[i]);</span><br><span class="line"><span class="keyword">if</span> (!(x[i]%<span class="number">2</span>) &amp;&amp; !(y[i]%<span class="number">2</span>)) c[i] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x[i] == <span class="number">1</span> &amp;&amp; y[i] == <span class="number">1</span>) c[i] ? f0 = <span class="literal">false</span> : f1 = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f0) (ans += calc(<span class="number">0</span>)) %= MOD;</span><br><span class="line"><span class="keyword">if</span> (f1) (ans += calc(<span class="number">1</span>)) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2011】方格染色&quot;&gt;&lt;a href=&quot;#【APIO2011】方格染色&quot; class=&quot;headerlink&quot; title=&quot;【APIO2011】方格染色&quot;&gt;&lt;/a&gt;【APIO2011】方格染色&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Sam}$和他的妹妹$\mathrm{Sara}$有一个包含$n\times m$个方格的表格。她们想要将其的每个方格都染成红色或蓝色。&lt;br&gt;出于个人喜好，他们想要表格中每个$2\times 2$的方形区域都包含奇数个（$1$个或$3$个）红色方格。 可是昨天晚上，有人已经给表格中的一些方格染上了颜色！&lt;br&gt;现在$\mathrm{Sam}$和$\mathrm{Sara}$非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格仍然满足她们的要求。&lt;br&gt;如果可能的话，满足他们要求的染色方案数有多少呢？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含三个整数$n$, $m$和$k$，分别代表表格的行数、列数和已被染色的方格数目。&lt;br&gt;之后的$k$行描述已被染色的方格。其中第$i$行包含三个整数$x_i$, $y_i$和$c_i$，分别代表第$i$个已被染色的方格的行编号、列编号和颜色。$c_i$为$1$表示方格被染成红色，$c_i$为$0$表示方格被染成蓝色。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个整数，表示可能的染色方案数目$W$模$10^9$得到的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="并查集" scheme="http://azrael.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ5180【Baltic2016】Cities &lt;斯坦纳树&gt;</title>
    <link href="http://azrael.top/BZOJ5180%E3%80%90Baltic2016%E3%80%91Cities%20%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ5180【Baltic2016】Cities 斯坦纳树/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-17T05:45:42.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【Baltic2016】Cities"><a href="#【Baltic2016】Cities" class="headerlink" title="【Baltic2016】Cities"></a>【Baltic2016】Cities</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定$n$个点，$m$条双向边的图，其中有$k$个点是重要的，每条边都有一定的长度。<br>现在要你选定一些边来构成一个图，要使得$k$个重要的点相互连通，求边的长度和的最小值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>共$m+2$行<br>第$1$行读入$n,k,m$，表示$n$个点，$k$个重要的点，$m$条边<br>第$2$行读入$k$个重要点的编号<br>第$3$至第$m+2$行，每行包括$3$个数字$a,b,c$，表示有一条从$a$到$b$长度为$c$的双向路径</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共$1$行，即最小长度和<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 3 6</span><br><span class="line">1 3 4</span><br><span class="line">1 2 4</span><br><span class="line">1 3 9</span><br><span class="line">1 4 6</span><br><span class="line">2 3 2</span><br><span class="line">2 4 5</span><br><span class="line">3 4 8</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$k\le5,\;n\le10^5,\;1\le m\le2\times10^5$</p><p>标签：<code>斯坦纳树</code> <code>状压DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>斯坦纳树裸题。</p><p>斯坦纳树的基本解法是状压$\mathrm{DP}$，压缩联通状态进行$\mathrm{DP}$，$f[s][i]$表示在$i$点，联通状态为$s$的最小花费。<br>有两种转移：</p><ul><li>状态$s$可以通过两个状态组合而来，对于$s$的一个子集$t$，有$f[s][i]=\max(f[s][i],f[t][i]+f[s-t][i])$</li><li>状态$s$也可以在同层向邻接点扩展，即最短路中的松弛操作，对于边$u,v$，有$f[s][v]=\max(f[s][v],f[s][u]+Edge_{u,v})$，可以跑最短路更新。</li></ul><p>此题有点卡，注意不要用<code>SPFA</code>，要用<code>堆优Dijkstra</code>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;lnt,<span class="keyword">int</span>&gt; pli;</span><br><span class="line"><span class="keyword">typedef</span> priority_queue&lt;pli&gt; pri_que;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k; lnt f[<span class="number">32</span>][MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[<span class="number">32</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="built_in">vector</span> &lt;lnt&gt; E[MAX_N+<span class="number">5</span>]; pri_que que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;G[u].push_back(v), E[u].push_back(c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;insert(u, v, c), insert(v, u, c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(k), read(m), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p; i &lt; k; i++) read(p), f[<span class="number">1</span>&lt;&lt;i][p] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt;= m; i++)</span><br><span class="line">read(u), read(v), read(c), addedge(u, v, c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span>&lt;&lt;k); s++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = (s<span class="number">-1</span>)&amp;s; t; t = (t<span class="number">-1</span>)&amp;s)</span><br><span class="line">f[s][i] = min(f[s][i], f[t][i]+f[s^t][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) que.push(mp(-f[s][i], i));</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.top().sec; que.pop();</span><br><span class="line"><span class="keyword">if</span> (mrk[s][u]) <span class="keyword">continue</span>; mrk[s][u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (f[s][v = G[u][i]] &gt; f[s][u]+E[u][i])</span><br><span class="line">f[s][v] = f[s][u]+E[u][i], que.push(mp(-f[s][v], v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lnt mi = <span class="number">1L</span>L&lt;&lt;<span class="number">62</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">mi = min(mi, f[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>][i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mi), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【Baltic2016】Cities&quot;&gt;&lt;a href=&quot;#【Baltic2016】Cities&quot; class=&quot;headerlink&quot; title=&quot;【Baltic2016】Cities&quot;&gt;&lt;/a&gt;【Baltic2016】Cities&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定$n$个点，$m$条双向边的图，其中有$k$个点是重要的，每条边都有一定的长度。&lt;br&gt;现在要你选定一些边来构成一个图，要使得$k$个重要的点相互连通，求边的长度和的最小值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;共$m+2$行&lt;br&gt;第$1$行读入$n,k,m$，表示$n$个点，$k$个重要的点，$m$条边&lt;br&gt;第$2$行读入$k$个重要点的编号&lt;br&gt;第$3$至第$m+2$行，每行包括$3$个数字$a,b,c$，表示有一条从$a$到$b$长度为$c$的双向路径&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;共$1$行，即最小长度和&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="状压DP" scheme="http://azrael.top/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="斯坦纳树" scheme="http://azrael.top/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2809【APIO2012】Dispatching &lt;可并堆&gt;</title>
    <link href="http://azrael.top/BZOJ2809%E3%80%90APIO2012%E3%80%91Dispatching%20%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    <id>http://azrael.top/BZOJ2809【APIO2012】Dispatching 可并堆/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-04-16T08:51:55.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2012】Dispatching"><a href="#【APIO2012】Dispatching" class="headerlink" title="【APIO2012】Dispatching"></a>【APIO2012】Dispatching</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。<br>在这个帮派里，有一名忍者被称之为$\mathrm{Master}$。除了$\mathrm{Master}$以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。<br>现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，就不需要支付管理者的薪水。你的目标是在预算内使顾客的满意度最大。<br>这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。<br>写一个程序，给定每一个忍者$i$的上级$B_i$，薪水$C_i$，领导力$L_i$，以及支付给忍者们的薪水总预算$M$，输出在预算内满足上述要求时顾客满意度的最大值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>从标准输入读入数据。<br>第一行包含两个整数$N$和$M$，其中$N$表示忍者的个数，$M$表示薪水的总预算。<br>接下来$N$行描述忍者们的上级、薪水以及领导力。其中的第$i$行包含三个整数$B_i,C_i,L_i$分别表示第$i$个忍者的上级，薪水以及领导力。$\mathrm{Master}$满足$B_i=0$，并且每一个忍者的老板的编号一定小于自己的编号。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个数，表示在预算内顾客的满意度的最大值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 3 3</span><br><span class="line">1 3 5</span><br><span class="line">2 2 2</span><br><span class="line">1 2 4</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p><strong>样例解释</strong><br>如果我们选择编号为$1$的忍者作为管理者并且派遣第三个和第四个忍者，薪水总和为$4$，没有超过总预算$4$。<br>因为派遣了$2$个忍者并且管理者的领导力为$3$，用户的满意度为$6$，是可以得到的用户满意度的最大值。<br><strong>数据范围</strong><br>$1\le N\le10^5,\;1\le M\le10^9,\;0\le B_i&lt;i,\;1\le C_i\le M,\;1\le L_i\le10^9$</p><p>标签：<code>可并堆</code> <code>左偏树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>可并堆基础题。</p><p>对于每个结点作领导的情况，贪心策略肯定在其子树中从小往大选，直到选不了为止。可以每个结点用一个堆维护，但遍历子树会导致复杂度爆炸。</p><p>考虑每次用已经算出的一些结点的答案。那么可以想到一种做法：<br>将每个结点子树中的所有点默认先选上，再从大往小去掉直到可行为止。这样在儿子结点中都没选到的点一定不会在父节点中选到。于是可以直接将每个结点最后选出的点加入到父亲的备选点集中。这样不难发现可以用可并堆维护，$\mathrm{DFS}$时将所有儿子结点的可并堆并起来，再从大往小$\mathrm{pop}$点，找到可行最大$size$后更新答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> c, d, ls, rs;&#125; h[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, b[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>], l[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> fa[MAX_N+<span class="number">5</span>]; lnt mx, s[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? fa[x] : getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> a^b;</span><br><span class="line"><span class="keyword">if</span> (h[a].c &lt; h[b].c) swap(a, b);</span><br><span class="line">h[a].rs = merge(h[a].rs, b), fa[h[a].rs] = a;</span><br><span class="line"><span class="keyword">if</span> (h[h[a].rs].d &gt; h[h[a].ls].d) swap(h[a].ls, h[a].rs);</span><br><span class="line">h[a].d = h[a].rs ? h[h[a].rs].d+<span class="number">1</span> : <span class="number">0</span>;<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = h[a].ls, r = h[a].rs;</span><br><span class="line">h[a].ls = h[a].rs = h[a].c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fa[l] = l, fa[r] = r, merge(l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rt = u;s[u] = c[u], sz[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line">rt = merge(rt, DFS(v = G[u][i])), s[u] += s[v], sz[u] += sz[v];</span><br><span class="line"><span class="keyword">while</span> (s[u] &gt; m &amp;&amp; sz[u]) s[u] -= h[rt].c, sz[u]--, rt = pop(rt);</span><br><span class="line"><span class="keyword">return</span> mx = max(mx, <span class="number">1L</span>L*sz[u]*l[u]), rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(b[i]), read(c[i]), read(l[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">G[b[i]].push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">fa[i] = i, h[i].c = c[i];</span><br><span class="line"><span class="keyword">return</span> DFS(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mx), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2012】Dispatching&quot;&gt;&lt;a href=&quot;#【APIO2012】Dispatching&quot; class=&quot;headerlink&quot; title=&quot;【APIO2012】Dispatching&quot;&gt;&lt;/a&gt;【APIO2012】Dispatching&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。&lt;br&gt;在这个帮派里，有一名忍者被称之为$\mathrm{Master}$。除了$\mathrm{Master}$以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。&lt;br&gt;现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，就不需要支付管理者的薪水。你的目标是在预算内使顾客的满意度最大。&lt;br&gt;这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。&lt;br&gt;写一个程序，给定每一个忍者$i$的上级$B_i$，薪水$C_i$，领导力$L_i$，以及支付给忍者们的薪水总预算$M$，输出在预算内满足上述要求时顾客满意度的最大值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;从标准输入读入数据。&lt;br&gt;第一行包含两个整数$N$和$M$，其中$N$表示忍者的个数，$M$表示薪水的总预算。&lt;br&gt;接下来$N$行描述忍者们的上级、薪水以及领导力。其中的第$i$行包含三个整数$B_i,C_i,L_i$分别表示第$i$个忍者的上级，薪水以及领导力。$\mathrm{Master}$满足$B_i=0$，并且每一个忍者的老板的编号一定小于自己的编号。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个数，表示在预算内顾客的满意度的最大值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="可并堆" scheme="http://azrael.top/tags/%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ5251【2018多省省队联测】劈配 &lt;网络流&gt;</title>
    <link href="http://azrael.top/BZOJ5251%E3%80%902018%E5%A4%9A%E7%9C%81%E7%9C%81%E9%98%9F%E8%81%94%E6%B5%8B%E3%80%91%E5%8A%88%E9%85%8D%20%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ5251【2018多省省队联测】劈配 网络流/</id>
    <published>2018-04-13T16:00:00.000Z</published>
    <updated>2018-04-16T08:38:56.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【2018多省省队联测】劈配"><a href="#【2018多省省队联测】劈配" class="headerlink" title="【2018多省省队联测】劈配"></a>【2018多省省队联测】劈配</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;512\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一年一度的综艺节目《中国新代码》又开始了。$\mathrm{Zayid}$从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。<br>轻车熟路的$\mathrm{Zayid}$顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：<br>总共$n$名参赛选手（编号从$1$至$n$）每人写出一份代码并介绍自己的梦想。接着由所有导师对这些选手进行排名。<br>为了避免后续的麻烦，规定不存在排名并列的情况。<br>同时，每名选手都将独立地填写一份志愿表，来对总共$m$位导师（编号从$1$至$m$）作出评价。志愿表上包含了共$m$档志愿。对于每一档志愿，选手被允许填写最多$C$位导师，每位导师最多被每位选手填写一次（放弃某些导师也是被允许的）。<br>在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。<br>节目组对“前$i$名的录取结果最优”作出如下定义：</p><ul><li>前$1$名的录取结果最优，当且仅当第$1$名被其最高非空志愿录取（特别地，如果第$1$名没有填写志愿表，那么该选手出局）。</li><li>前$i$名的录取结果最优，当且仅当在前$i-1$名的录取结果最优的情况下：第$i$名被其理论可能的最高志愿录取（特别地，如果第i名没有填写志愿表、或其所有志愿中的导师战队均已满员，那么该选手出局）。</li></ul><p>如果一种方案满足“前$n$名的录取结果最优”，那么我们可以简称这种方案是最优的。<br>举例而言，$2$位导师$T$老师、$F$老师的战队人数上限分别都是$1$人；$2$位选手$\mathrm{Zayid}$、$\mathrm{DuckD}$分列第$1、2$名。那么下面$3$种志愿表及其对应的最优录取结果如表中所示：</p><center><br><img src="https://www.lydsy.com/JudgeOnline/upload/201804/111(1).jpg" alt=""><br></center><p>可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。<br>每个人都有一个自己的理想值$s_i$，表示第$i$位同学希望自己被第$s_i$或更高的志愿录取，如果没有，那么他就会非常沮丧。<br>现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。<br>对于每一位选手，$\mathrm{Zayid}$都想知道下面两个问题的答案：</p><ul><li>在最优的录取方案中，他会被第几志愿录取。</li><li>在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。</li></ul><p>作为《中国新代码》的实力派代码手，$\mathrm{Zayid}$当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每个测试点包含多组测试数据，第一行$2$个用空格隔开的非负整数$T,C$，分别表示数据组数、每档志愿最多允许填写的导师数目。<br>接下来依次描述每组数据，对于每组数据：</p><ul><li>第$1$行两个用空格隔开的正整数$n,m$。$n,m$分别表示选手的数量、导师的数量。</li><li>第$2$行$m$个用空格隔开的正整数：其中第$i$个整数为$b_i$。$B_i$表示编号为$i$的导师战队人数的上限。</li><li>第$3$行至第$n+2$行，每行$m$个用空格隔开的非负整数：其中第$i+2$行左起第$j$个数为$a_{i,j}$<ul><li>$a_{i,j}$表示编号为$i$的选手将编号为$j$的导师编排在了第$a_{i,j}$志愿。特别地，如果$a_{i,j}=0$，则表示该选手没有将该导师填入志愿表。</li><li>在这一部分，保证每行中不存在某一个正数出现超过$C$次（$0$可能出现超过$C$次），同时保证所有$a_{i,j}\le m$。</li></ul></li><li>第$n+3$行$n$个用空格隔开的正整数，其中第$i$个整数为$S_i$<ul><li>$S_i$表示编号为$i$的选手的理想值。</li><li>在这一部分，保证$S_i\le m$。</li></ul></li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>按顺序输出每组数据的答案。对于每组数据，输出$2$行：</p><ul><li>第$1$行输出$n$个用空格隔开的正整数，其中第$i$个整数的意义为：<ul><li>在最优的录取方案中，编号为$i$的选手会被该档志愿录取。</li><li>特别地，如果该选手出局，则这个数为$m+1$。</li></ul></li><li>第$2$行输出$n$个用空格隔开的非负整数，其中第$i$个整数的意义为：<ul><li>使编号为$i$的选手不沮丧，最少需要让他上升的排名数。</li><li>特别地，如果该选手一定会沮丧，则这个数为$i$。</li></ul></li></ul><a id="more"></a><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 0</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">1 3</span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p><strong>样例解释</strong><br>三组数据分别与题目描述中的三个表格对应。<br>对于第$1$组数据：由于选手$1$没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手$2$按原排名就不沮丧，因此他不需要提升排名。<br>对于第$2$组和第$3$组数据：$1$号选手都不需要提升排名。而希望被第一志愿录取的$2$号选手都必须升到第$1$名才能如愿。<br><strong>数据范围</strong><br>$T\le 5,\;m\le n\le 200,\;B_i\le N$<br><a href="https://www.lydsy.com/JudgeOnline/upload/201804/day2(3).pdf" target="_blank" rel="noopener">原题面</a></p><p>标签：<code>网络流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>九省联考$\mathrm{Day2}$唯一一道有区分度的题。</p><p>容易看出本质就是一个二分图匹配。只不过每条边的优先度是有差别的。<br><strong>第一问</strong><br>先将源点到每个学员流量为$1$的边和导师到汇点的流量为$b$的边连上。<br>顺次考虑每个学员，每次将一个志愿中的所有导师的边加到图里，看能否使其找到匹配，找到就退出，标记此志愿为答案。</p><p><strong>第二问</strong><br>考虑像第一问那样判断，那么就可以每次加入一个学员，判断能否达到要求，当加入一个学员后不能达到要求时，$此时加入的学员数-1$为此人满足要求的最大名次，用其真实名次减去即可得到答案。注意特判无论如何都不能满足的情况。<br>另外，这里还可以二分答案，不过直接暴力加入在$\mathrm{BZOJ}$上已经可以过了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, rk[MAX_N+<span class="number">5</span>], mi[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> b[MAX_N+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n+m+<span class="number">1</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; cpy(); <span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec(); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(s, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) addedge(i+n, t, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)a[p][i].size(); j++)</span><br><span class="line">addedge(p, a[p][i][j]+n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Dinic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, C; read(T), read(C);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">a[i][j].clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= m; j++)</span><br><span class="line">read(x), a[i][x].push_back(j);</span><br><span class="line">build();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (rk[i] = <span class="number">1</span>; rk[i] &lt;= m; rk[i]++)</span><br><span class="line"><span class="keyword">if</span> (inc(i, rk[i], rk[i])) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; i++) &#123;</span><br><span class="line">read(k), mi[i] = i, build();</span><br><span class="line"><span class="keyword">if</span> (!inc(i, <span class="number">1</span>, k)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; mi[i]--; j++) <span class="keyword">if</span> (rk[j] &lt;= m)</span><br><span class="line"><span class="keyword">if</span> (!inc(j, rk[j], rk[j])) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, rk[i]);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, mi[i]);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【2018多省省队联测】劈配&quot;&gt;&lt;a href=&quot;#【2018多省省队联测】劈配&quot; class=&quot;headerlink&quot; title=&quot;【2018多省省队联测】劈配&quot;&gt;&lt;/a&gt;【2018多省省队联测】劈配&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;512\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一年一度的综艺节目《中国新代码》又开始了。$\mathrm{Zayid}$从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。&lt;br&gt;轻车熟路的$\mathrm{Zayid}$顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：&lt;br&gt;总共$n$名参赛选手（编号从$1$至$n$）每人写出一份代码并介绍自己的梦想。接着由所有导师对这些选手进行排名。&lt;br&gt;为了避免后续的麻烦，规定不存在排名并列的情况。&lt;br&gt;同时，每名选手都将独立地填写一份志愿表，来对总共$m$位导师（编号从$1$至$m$）作出评价。志愿表上包含了共$m$档志愿。对于每一档志愿，选手被允许填写最多$C$位导师，每位导师最多被每位选手填写一次（放弃某些导师也是被允许的）。&lt;br&gt;在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。&lt;br&gt;节目组对“前$i$名的录取结果最优”作出如下定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前$1$名的录取结果最优，当且仅当第$1$名被其最高非空志愿录取（特别地，如果第$1$名没有填写志愿表，那么该选手出局）。&lt;/li&gt;
&lt;li&gt;前$i$名的录取结果最优，当且仅当在前$i-1$名的录取结果最优的情况下：第$i$名被其理论可能的最高志愿录取（特别地，如果第i名没有填写志愿表、或其所有志愿中的导师战队均已满员，那么该选手出局）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一种方案满足“前$n$名的录取结果最优”，那么我们可以简称这种方案是最优的。&lt;br&gt;举例而言，$2$位导师$T$老师、$F$老师的战队人数上限分别都是$1$人；$2$位选手$\mathrm{Zayid}$、$\mathrm{DuckD}$分列第$1、2$名。那么下面$3$种志愿表及其对应的最优录取结果如表中所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/upload/201804/111(1).jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。&lt;br&gt;每个人都有一个自己的理想值$s_i$，表示第$i$位同学希望自己被第$s_i$或更高的志愿录取，如果没有，那么他就会非常沮丧。&lt;br&gt;现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。&lt;br&gt;对于每一位选手，$\mathrm{Zayid}$都想知道下面两个问题的答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在最优的录取方案中，他会被第几志愿录取。&lt;/li&gt;
&lt;li&gt;在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为《中国新代码》的实力派代码手，$\mathrm{Zayid}$当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;每个测试点包含多组测试数据，第一行$2$个用空格隔开的非负整数$T,C$，分别表示数据组数、每档志愿最多允许填写的导师数目。&lt;br&gt;接下来依次描述每组数据，对于每组数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第$1$行两个用空格隔开的正整数$n,m$。$n,m$分别表示选手的数量、导师的数量。&lt;/li&gt;
&lt;li&gt;第$2$行$m$个用空格隔开的正整数：其中第$i$个整数为$b_i$。$B_i$表示编号为$i$的导师战队人数的上限。&lt;/li&gt;
&lt;li&gt;第$3$行至第$n+2$行，每行$m$个用空格隔开的非负整数：其中第$i+2$行左起第$j$个数为$a_{i,j}$&lt;ul&gt;
&lt;li&gt;$a_{i,j}$表示编号为$i$的选手将编号为$j$的导师编排在了第$a_{i,j}$志愿。特别地，如果$a_{i,j}=0$，则表示该选手没有将该导师填入志愿表。&lt;/li&gt;
&lt;li&gt;在这一部分，保证每行中不存在某一个正数出现超过$C$次（$0$可能出现超过$C$次），同时保证所有$a_{i,j}\le m$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第$n+3$行$n$个用空格隔开的正整数，其中第$i$个整数为$S_i$&lt;ul&gt;
&lt;li&gt;$S_i$表示编号为$i$的选手的理想值。&lt;/li&gt;
&lt;li&gt;在这一部分，保证$S_i\le m$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;按顺序输出每组数据的答案。对于每组数据，输出$2$行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第$1$行输出$n$个用空格隔开的正整数，其中第$i$个整数的意义为：&lt;ul&gt;
&lt;li&gt;在最优的录取方案中，编号为$i$的选手会被该档志愿录取。&lt;/li&gt;
&lt;li&gt;特别地，如果该选手出局，则这个数为$m+1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第$2$行输出$n$个用空格隔开的非负整数，其中第$i$个整数的意义为：&lt;ul&gt;
&lt;li&gt;使编号为$i$的选手不沮丧，最少需要让他上升的排名数。&lt;/li&gt;
&lt;li&gt;特别地，如果该选手一定会沮丧，则这个数为$i$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1911【APIO2010】特别行动队 &lt;斜率优化&gt;</title>
    <link href="http://azrael.top/BZOJ1911%E3%80%90APIO2010%E3%80%91%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://azrael.top/BZOJ1911【APIO2010】特别行动队 斜率优化/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-16T03:39:04.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2010】特别行动队"><a href="#【APIO2010】特别行动队" class="headerlink" title="【APIO2010】特别行动队"></a>【APIO2010】特别行动队</h3><p>$\mathrm{Time\;Limit:\;4\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/1911_1.jpg" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/1911_2.jpg" alt=""><br></center><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/1911_3.jpg" alt=""><br></center><a id="more"></a><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">-1 10 -20</span><br><span class="line">2 2 3 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><p>标签：<code>斜率优化DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先易得$\mathrm{DP}$方程：设$f[i]$为考虑前$i$人的最大收益，则$f[i]=\max_{j=0}^{i-1}\lbrace{A\times(S_i-S_j)^2+B\times(S_i-S_j)+C+f[j]}\rbrace$。<br>那么推一推：<br>$$<br>\begin{aligned}<br>f[i]&amp;=\max_{j=0}^{i-1}\lbrace{A\times(S_i-S_j)^2+B\times(S_i-S_j)+C+f[j]}\rbrace\\<br>&amp;=\max_{j=0}^{i-1}\lbrace{A\times S_i^2-A\times S_j^2+2A\times S_i\times S_j+B\times S_i-B\times S_j+C+f[j]}\rbrace\\<br>&amp;=\max_{j=0}^{i-1}\lbrace{-2AS_j\times S_i+(A\times S_j^2-B\times S_j+f[j])}\rbrace+A\times S_i^2+B\times S_i+C\\<br>\end{aligned}<br>$$<br>发现中间$-2AS_j\times S_i+(A\times S_j^2-B\times S_j+f[j])$是一次函数，那么对于两个位置$p,q\;(p&lt;q)$，若$q$比$p$优秀，则有：<br>$$<br>\begin{aligned}<br>Let\;k_p=-2AS_p,\;b_p&amp;=A\times S_p^2-B\times S_p+f[p]\\<br>k_pS_i+b_p&amp;&lt; k_qS_i+b_q\\<br>S_i&amp;\le\frac{b_p-b_q}{k_q-k_p}<br>\end{aligned}<br>$$<br>按照此斜率维护单调栈即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, que[MAX_N+<span class="number">5</span>], l, r; lnt A, B, C;</span><br><span class="line">lnt s[MAX_N+<span class="number">5</span>], k[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>], f[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">dnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (dnt)(b[x]-b[y])/(dnt)(k[y]-k[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(A), read(B), read(C);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), s[i] = s[i<span class="number">-1</span>]+x;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; que[<span class="number">0</span>] = <span class="number">0</span>, b[<span class="number">0</span>] = C;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; calc(que[l], que[l+<span class="number">1</span>]) &lt;= s[i]) l++;</span><br><span class="line">f[i] = k[que[l]]*s[i]+b[que[l]]+A*s[i]*s[i]+B*s[i];</span><br><span class="line">k[i] = <span class="number">-2</span>*A*s[i], b[i] = A*s[i]*s[i]-B*s[i]+C+f[i];</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; calc(que[r], i) &lt;= calc(que[r<span class="number">-1</span>], que[r])) r--;</span><br><span class="line">que[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2010】特别行动队&quot;&gt;&lt;a href=&quot;#【APIO2010】特别行动队&quot; class=&quot;headerlink&quot; title=&quot;【APIO2010】特别行动队&quot;&gt;&lt;/a&gt;【APIO2010】特别行动队&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;4\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/1911_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/1911_2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/1911_3.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://azrael.top/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3675【APIO2014】序列分割 &lt;斜率优化&gt;</title>
    <link href="http://azrael.top/BZOJ3675%E3%80%90APIO2014%E3%80%91%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://azrael.top/BZOJ3675【APIO2014】序列分割 斜率优化/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-16T03:59:00.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2014】序列分割"><a href="#【APIO2014】序列分割" class="headerlink" title="【APIO2014】序列分割"></a>【APIO2014】序列分割</h3><p>$\mathrm{Time\;Limit:\;40\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{小H}$最近迷上了一个分隔序列的游戏。<br>在这个游戏里，$\mathrm{小H}$需要将一个长度为$n$的非负整数序列分割成$k+1$个非空的子序列。<br>为了得到$k+1$个子序列，$\mathrm{小H}$需要重复$k$次以下的步骤：</p><ol><li>$\mathrm{小H}$首先选择一个长度超过$1$的序列（一开始$\mathrm{小H}$只有一个长度为$n$的序列，也就是一开始得到的整个序列）</li><li>选择一个位置，并通过这个位置将这个序列分割成连续的两个非空的新序列</li></ol><p>每次进行上述步骤之后，$\mathrm{小H}$将会得到一定的分数。这个分数为两个新序列中元素和的乘积。<br>$\mathrm{小H}$希望选择一种最佳的分割方式，使得$k$轮之后，$\mathrm{小H}$的总得分最大。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行包含两个整数$n,k\;(k+1\le n)$。<br>第二行包含$n$个非负整数$a_1,a_2,\cdots,a_n\;(0\le a_i\le10^4)$，表示一开始$\mathrm{小H}$得到的序列。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出第一行包含一个整数，为$\mathrm{小H}$可以得到的最大分数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br><span class="line">4 1 3 4 0 2 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">108</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>在样例中，$\mathrm{小H}$可以通过如下3轮操作得到108分： </p><ol><li>一开始$\mathrm{小H}$有一个序列$(4,1,3,4,0,2,3)$。$\mathrm{小H}$选择在第$1$个数之后的位置将序列分成两部分，并得到$4\times (1+3+4+0+2+3)=52$分。 </li><li>这一轮开始时$\mathrm{小H}$有两个序列：$(4),\;(1,3,4,0,2,3)$。$\mathrm{小H}$选择在第3个数字之后的位置将第二个序列分成两部分，并得到$(1+3)\times(4+0+2+3)=36$分。 </li><li>这一轮开始时$\mathrm{小H}$有三个序列：$(4),\;(1,3),\;(4,0,2,3)$。$\mathrm{小H}$选择在第$5$个数字之后的位置将第三个序列分成两部分，并得到$(4+0)\times(2+3)=20$分。 </li></ol><p>经过上述三轮操作，$\mathrm{小H}$将会得到四个子序列：$(4),\;(1,3),\;(4,0),\;(2,3)$并总共得到$52+36+20=108$分。 </p><p>标签：<code>斜率优化DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>易得$\mathrm{DP}$方程：$f[t][i]$表示玩$t$轮时只考虑$[1,i]$区间内的数的最大贡献。那么有$f[t][i]=\max_{j=0}^{i-1}\lbrace{f[t-1][j]+(S_i-S_j)\times S_j}\rbrace$。<br>简单推一推：<br>$$<br>\begin{aligned}<br>f[t][i]&amp;=\max_{j=0}^{i-1}\lbrace{f[t-1][j]+(S_i-S_j)\times S_j}\rbrace\\<br>&amp;=\max_{j=0}^{i-1}\lbrace{f[t-1][j]+S_j\times S_i-S_j^2}\rbrace\\<br>&amp;=\max_{j=0}^{i-1}\lbrace{S_iS_j+f[t-1][j]-S_j^2}\rbrace\\<br>\end{aligned}<br>$$<br>套上斜率优化：<br>$$<br>For\;i\in[1,n],\;if\;p&lt;q,\;q\;is\;better\;than\;p,\;then\\<br>S_pS_i+f[t-1][p]-S_p^2\le S_qS_i+f[t-1][q]-S_q^2\\<br>Let\;a_n=S_n,\;b_n=f[t-1][n]-S_n^2,\\<br>then\;(a_p-a_q)S_i\le b_q-b_p\\<br>\therefore If\;(a_p-a_q)S_i\le b_q-b_p,\;then\;we\;can\;pop\;p\;out\;of\;the\;stack.<br>$$<br>注意这里不要写成斜率的形式，因为$a_p-a_q$可能等于$0$。<br>按照不等式用单调栈对每层$k$进行维护即可，这里可以做$k$次一维$\mathrm{DP}$，每次重新算$b$数组。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, l, r, que[MAX_N+<span class="number">5</span>]; lnt s[MAX_N+<span class="number">5</span>];</span><br><span class="line">lnt f[MAX_N+<span class="number">5</span>], a[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">lnt x = (b[p]-b[que[r]])*(a[que[r<span class="number">-1</span>]]-a[que[r]]);</span><br><span class="line">lnt y = (b[que[r]]-b[que[r<span class="number">-1</span>]])*(a[que[r]]-a[p]);</span><br><span class="line"><span class="keyword">return</span> x &lt;= y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), s[i] = s[i<span class="number">-1</span>]+x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">a[i] = s[i], b[i] = -s[i]*s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">que[l = r = <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; s[i]*(a[que[l]]-a[que[l+<span class="number">1</span>]]) &lt;= b[que[l+<span class="number">1</span>]]-b[que[l]]) l++;</span><br><span class="line">f[i] = a[que[l]]*s[i]+b[que[l]]; <span class="keyword">while</span> (l &lt; r &amp;&amp; chk(i, l, r)) r--; que[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = f[i]-s[i]*s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2014】序列分割&quot;&gt;&lt;a href=&quot;#【APIO2014】序列分割&quot; class=&quot;headerlink&quot; title=&quot;【APIO2014】序列分割&quot;&gt;&lt;/a&gt;【APIO2014】序列分割&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;40\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{小H}$最近迷上了一个分隔序列的游戏。&lt;br&gt;在这个游戏里，$\mathrm{小H}$需要将一个长度为$n$的非负整数序列分割成$k+1$个非空的子序列。&lt;br&gt;为了得到$k+1$个子序列，$\mathrm{小H}$需要重复$k$次以下的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\mathrm{小H}$首先选择一个长度超过$1$的序列（一开始$\mathrm{小H}$只有一个长度为$n$的序列，也就是一开始得到的整个序列）&lt;/li&gt;
&lt;li&gt;选择一个位置，并通过这个位置将这个序列分割成连续的两个非空的新序列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每次进行上述步骤之后，$\mathrm{小H}$将会得到一定的分数。这个分数为两个新序列中元素和的乘积。&lt;br&gt;$\mathrm{小H}$希望选择一种最佳的分割方式，使得$k$轮之后，$\mathrm{小H}$的总得分最大。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入第一行包含两个整数$n,k\;(k+1\le n)$。&lt;br&gt;第二行包含$n$个非负整数$a_1,a_2,\cdots,a_n\;(0\le a_i\le10^4)$，表示一开始$\mathrm{小H}$得到的序列。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出第一行包含一个整数，为$\mathrm{小H}$可以得到的最大分数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://azrael.top/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3730 震波 &lt;动态点分治&gt;</title>
    <link href="http://azrael.top/BZOJ3730%20%E9%9C%87%E6%B3%A2%20%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>http://azrael.top/BZOJ3730 震波 动态点分治/</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2018-04-14T08:43:17.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="震波"><a href="#震波" class="headerlink" title="震波"></a>震波</h3><p>$\mathrm{Time\;Limit:\;15\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一片土地上有$N$个城市，通过$N-1$条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为$1$，其中第i个城市的价值为$value_i$。<br>不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。<br>接下来你需要在线处理$M$次操作：</p><ul><li>$0\;x\;k$ 表示发生了一次地震，震中城市为$x$，影响范围为$k$，所有与$x$距离不超过$k$的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。</li><li>$1\;x\;y$ 表示第$x$个城市的价值变成了$y$。</li></ul><p>为了体现程序的在线性，操作中的$x,y,k$都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为$0$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个正整数$N$和$M$。<br>第二行包含$N$个正整数，第$i$个数表示$value_i$。<br>接下来$N-1$行，每行包含两个正整数$u,v$，表示$u$和$v$之间有一条无向边。<br>接下来$M$行，每行包含三个数，表示$M$次操作。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>包含若干行，对于每个询问输出一行一个正整数表示答案。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8 1</span><br><span class="line">1 10 100 1000 10000 100000 1000000 10000000</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br><span class="line">3 7</span><br><span class="line">3 8</span><br><span class="line">0 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11100101</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$1\le N,M\le10^5$<br>$1\le u,v,x\le N$<br>$1\le value_i,y\le10^4$<br>$0\le k\le N-1$</p><p>标签：<code>动态点分治</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>终于学会动态点分辣QAQ~<br>赶快来肝几道基础题</p><p>先不考虑时间复杂度，那么对于每个$0$操作显然可以暴力从震源向上爬统计答案。每次加上当前子树中距离符合题意的点，再减去其儿子（就是向上爬时此点的前驱）的子树中与其算重复的点。这样维护两个树状数组即可。<br>但是树高可以构造比$\log n$大，这时就需要建立点分树，把树高降成$\log n$。</p><p>提取重心建立点分树，对每个分治中心维护两个树状数组，第一个是其子树中到此分治中心的每种距离的所有点的点权和，第二个是其子树中到此分治中心的上一层分治中心的每种距离的所有点的点权和。<br>这样对于询问，每次$\log n$向上爬，爬到每个分治中心$\log size$统计；对于修改，每次$\log n$向上爬，爬到每个分治中心$\log size$更新树状数组即可。这样总复杂度是$O(Q\log^2n)$。</p><p>不过此题有些卡常，有三种策略：</p><ol><li>用$\mathrm{RMQ}$做$\mathrm{LCA}$</li><li>带<code>fread</code>大读优</li><li>将$n$棵树状数组建到同一个大数组上，每个$\mathrm{BIT}$记录其起始指针和终止指针，可以避免<code>vector</code>的一些常数</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, e, c[MAX_N+<span class="number">5</span>], fa[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> w[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>], rt, tot;</span><br><span class="line"><span class="keyword">int</span> anc[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>], dep[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> *p0[MAX_N+<span class="number">5</span>], *p1[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> BIT0[MAX_N*<span class="number">100</span>], BIT1[MAX_N*<span class="number">100</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, nxt;&#125; E[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;E[e] = (node)&#123;v, pr[u]&#125;, pr[u] = e++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> *tr, <span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> l)</span> </span>&#123;<span class="keyword">for</span> (p = min(p+<span class="number">1</span>, l); p &lt;= l; p += (p&amp;-p)) tr[p] += x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *tr, <span class="keyword">int</span> p, <span class="keyword">int</span> l)</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; <span class="keyword">for</span> (p = min(p+<span class="number">1</span>, l); p; p -= (p&amp;-p)) ret += tr[p]; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOG; i++)</span><br><span class="line">anc[u][i] =anc[anc[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> ((v = E[i].v) ^ anc[u][<span class="number">0</span>])</span><br><span class="line">anc[v][<span class="number">0</span>] = u, dep[v] = dep[u]+<span class="number">1</span>, init(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (dep[a]-(<span class="number">1</span>&lt;&lt;i) &gt;= dep[b]) a = anc[a][i];</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--) <span class="keyword">if</span> (anc[a][i]^anc[b][i])</span><br><span class="line">a = anc[a][i], b = anc[b][i];</span><br><span class="line"><span class="keyword">return</span> anc[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> dep[u]+dep[v]<span class="number">-2</span>*dep[LCA(u, v)];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsz</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (((v = E[i].v) ^ f) &amp;&amp; !mrk[v])</span><br><span class="line">ret += getsz(v, u);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>, w[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (((v = E[i].v) ^ f) &amp;&amp; !mrk[v])</span><br><span class="line">getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]);</span><br><span class="line">w[u] = max(w[u], tot-sz[u]); <span class="keyword">if</span> (w[u] &lt; w[rt]) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">rt = <span class="number">0</span>, tot = getsz(u, <span class="number">0</span>), getrt(u, <span class="number">0</span>);</span><br><span class="line">fa[u = rt] = f, mrk[u] = <span class="literal">true</span>, sz[u] = tot+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v]) divide(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">inc(p0[x], <span class="number">0</span>, y, sz[x]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = x; fa[u]; u = fa[u]) &#123;</span><br><span class="line"><span class="keyword">int</span> dis = dist(fa[u], x);</span><br><span class="line">inc(p1[u], dis, y, sz[u]);</span><br><span class="line">inc(p0[fa[u]], dis, y, sz[fa[u]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = sum(p0[x], y, sz[x]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = x, dis; fa[u]; u = fa[u]) <span class="keyword">if</span> ((dis = dist(fa[u], x)) &lt;= y)</span><br><span class="line">ret += sum(p0[fa[u]], y-dis, sz[fa[u]])-sum(p1[u], y-dis, sz[u]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), w[<span class="number">0</span>] = n;</span><br><span class="line"><span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(c[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++)</span><br><span class="line">read(u), read(v), addedge(u, v), addedge(v, u);</span><br><span class="line">init(<span class="number">1</span>), divide(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> cnt = <span class="number">0</span>, lst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; cnt += sz[i++]+<span class="number">1</span>)</span><br><span class="line">p0[i] = BIT0+cnt, p1[i] = BIT1+cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) modify(i, c[i]);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, x, y; read(opt);</span><br><span class="line">read(x), read(y), x ^= lst, y ^= lst;</span><br><span class="line"><span class="keyword">if</span> (opt) modify(x, y-c[x]), c[x] = y;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lst = query(x, y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;震波&quot;&gt;&lt;a href=&quot;#震波&quot; class=&quot;headerlink&quot; title=&quot;震波&quot;&gt;&lt;/a&gt;震波&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;15\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在一片土地上有$N$个城市，通过$N-1$条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为$1$，其中第i个城市的价值为$value_i$。&lt;br&gt;不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。&lt;br&gt;接下来你需要在线处理$M$次操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$0\;x\;k$ 表示发生了一次地震，震中城市为$x$，影响范围为$k$，所有与$x$距离不超过$k$的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。&lt;/li&gt;
&lt;li&gt;$1\;x\;y$ 表示第$x$个城市的价值变成了$y$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了体现程序的在线性，操作中的$x,y,k$都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为$0$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个正整数$N$和$M$。&lt;br&gt;第二行包含$N$个正整数，第$i$个数表示$value_i$。&lt;br&gt;接下来$N-1$行，每行包含两个正整数$u,v$，表示$u$和$v$之间有一条无向边。&lt;br&gt;接下来$M$行，每行包含三个数，表示$M$次操作。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;包含若干行，对于每个询问输出一行一个正整数表示答案。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树分治" scheme="http://azrael.top/tags/%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>SCOI2018总结</title>
    <link href="http://azrael.top/SCOI2018%E6%80%BB%E7%BB%93/"/>
    <id>http://azrael.top/SCOI2018总结/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-23T05:35:18.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SCOI2018退役记"><a href="#SCOI2018退役记" class="headerlink" title="SCOI2018退役记"></a>SCOI2018退役记</h1><a id="more"></a><h2 id="集训"><a href="#集训" class="headerlink" title="集训"></a>集训</h2><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>到成电打校赛，中午吃饭碰到$\mathrm{Joker}$和$\mathrm{dxymaster}$，一起骑车去考场。<br>结果走错门了，绕了$20\;\mathrm{min}$才绕过去。</p><p>比赛$14:20$才开始，貌似是内网出了点小锅。刚刚拿到题我们三人都蒙了，看了$40\;\mathrm{min}$才找到签到题。$\mathrm{C}$和$\mathrm{G}$都很水，$\mathrm{OwenOwl}$和$\mathrm{Joker}$各做一道，我在看$\mathrm{Joker}$给的一道类似文理分科建模的网络流图。先过了两道签到题，接着$\mathrm{OwenOwl}$就看出$\mathrm{K}$的贪心了。于是三道签到题就搞定了。</p><p>接着我和$\mathrm{Joker}$开始肛$\mathrm{H}$，这时全场没人过$\mathrm{H}$，所以我们有点虚。发现和文理分科不一样的是这个模的贡献可能有负数，然后我就懵逼了…$\mathrm{Joker}$机智地想到了把正负拆成差的方法，这样边权都是正的了。我直接套上我洛谷的网络流板，一发过样例，交了，然后…然后…$\mathrm{Wrong\;Answer\;on\;test\;1}$…</p><p>我和$\mathrm{Joker}$开始肉眼查错，发现我的当前弧是错的…洛谷的板题是给出$S$和$T$，所以当前弧每次复原是循环$1\sim n$，而$\mathrm{H}$中建模$S$时$0$号点，$T$是$n+m+1$，然后就$\mathrm{GG}$了。改了再交，$\mathrm{Accepted}$，惊奇地发现一血了。过了两分钟，柱神他们也过了$\mathrm{H}$。</p><p>接下来$\mathrm{Joker}$和$\mathrm{OwenOwl}$开始肛$\mathrm{B}$，傻逼主席树，不过容易写错。封榜的时候交了$\mathrm{A}$，然后我们队就$\mathrm{rank\;4}$了。</p><p>话说我好像全程抱大腿…<br>$\mathrm{\%\%\%Joker\;\;\;\%\%\%OwenOwl}$</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>到中和中学参加省选集训，本来还期待能学些东西，结果上午全程骑车。某天津老师来讲异或方程组，先水了$40\;\mathrm{min}$高消，然后用了各种技巧避开线性基水了若干线性基裸题…只能说这老师$拖时间能力\to\infty$。</p><p>下午去体验机房，在初中生高度的座位上颓颓颓。神机安了$5$个五笔输入法，而且开新页面会默认调成拼音输入法。什么编译器都没有，分辨率出翔…</p><p>晚上回酒店，刷水搞了几道线性基，然后颓颓颓。厕所漏水严重，水管工貌似修不好，凑合凑合。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>$\mathrm{THU}$巨佬讲博弈论，讲得挺好。前半场很简单，开热点刷题。最后讲了尼姆积，玄学玩意儿，不过听懂了，这东西虽然精妙，但是题目并不是很常见。</p><p>下午继续刷题，居然没颓。</p><p>晚上继续刷题，十点过和$\mathrm{YY}$颓了一会儿炉石。</p><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>成电学生来讲数论，全程划水。讲了一些并无卵用的东西，而且就讲了一些素数论的皮毛，$\mathrm{NOIp}$难度。补觉补觉。</p><p>下午刷题，刷完颓颓颓。</p><p>晚上打了几个板子，继续颓。</p><h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h3><p>上午省选模拟，抱着划水的心态边打弹球边写（中和中学机房最好的地方就是有三维弹球）。$\mathrm{T1}$状压$\mathrm{DP}$，打了一个玄学做法，考完发现有锅，结果考试的时候并没有$\mathrm{WA}$，最后两个点卡常$\mathrm{TLE}$了。$\mathrm{T2}$没想到贪心，暴力滚粗。$\mathrm{T3}$暴力，不过评测的时候貌似$\mathrm{CE}$了，而且好像好几个人都$\mathrm{CE}$了。</p><p>下午赶到清水河，晚上打了几个板子，睡前膜一膜$\mathrm{OwenOwl}$和$\mathrm{Joker}$</p><h2 id="正式考试"><a href="#正式考试" class="headerlink" title="正式考试"></a>正式考试</h2><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>考前听到$\mathrm{XXX}$说不能用<code>bits/stdc++.h</code>，我信了。</p><p>上考场先看了看题，黑人问号$\mathrm{.jpg}$。没$\mathrm{DP}$？$\mathrm{T1}$动态点分？$\mathrm{T2}$数据结构？（考完才发现我有多$\mathrm{naive}$）$\mathrm{T3}$什么玄学玩意儿？</p><p>先肛$\mathrm{T2}$，并没有想出去除$c_u\times c_v$影响的办法，于是打$45\;\mathrm{pts}$翻译滚粗。</p><p>回去看$\mathrm{T1}$，写不熟动态点分，而且貌似不好维护，再加上卡点分树空间，直接想如何骗分。$\mathrm{yy}$出一种暴力爬树高统计的方法，期待数据有随机点。对拍+调试花了$\mathrm{2h}$。$0.6\;s$过了大样例，感觉挺稳。</p><p>最后剩$\mathrm{30\;min}$做$\mathrm{T3}$。好不容易把题读懂，打了暴力$\mathrm{BFS}$，不过貌似并没有暴力分。</p><p>考完下来预估$\mathrm{50+45=95\;pts}$。</p><p>下午接到成绩，心态崩了…爆$0$滚粗。查分发现前两道都$\mathrm{CE}$了，最后一道肯定没分。电子科大神机的$\mathrm{MinGW}$版本很低，然后和$\mathrm{vim}$适配的时候出锅了。所以在$\mathrm{vim}$下编辑，用<code>memset</code>可以不开<code>cstring</code>，用<code>sort</code>可以不开<code>algorithm</code>。我的$\mathrm{95\;pts}$就这样送了。</p><p>晚上开会发现$\mathrm{myjs}$和我$\mathrm{T1}$写的一样的算法，他拿了$\mathrm{70\;pts}$，我：……</p><h3 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h3><p>改用<code>bits/stdc++.h</code>，不要又$\mathrm{CE}$。</p><p>前一天$\mathrm{CE}$爆$0$整个心态都炸了。于是抱着划水的心态考$\mathrm{Day\;2}$。一鼓作气，三道暴力，先花$\mathrm{1.5\;h}$把三道暴力写了，发现$\mathrm{T1}$可做，开始肛。</p><p>考试的时候有点懵，没直接用绝对值函数分开维护，而是分$9$种情况维护凸函数。写了$\mathrm{1.5\;h}$才大致理清楚。结果过了小样例，没过$n=50$的另一个小样例。赶紧对拍，然后补锅。耗了$\mathrm{1.5\;h}$才过$n=50$的样例。然后随手造了一个$n=100$的数据，崩溃地发现$\mathrm{WA}$了…弃疗扫雷（我貌似没有找到做蛋糕）。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在退役的边缘试探$\mathrm{.jpg}$</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SCOI2018退役记&quot;&gt;&lt;a href=&quot;#SCOI2018退役记&quot; class=&quot;headerlink&quot; title=&quot;SCOI2018退役记&quot;&gt;&lt;/a&gt;SCOI2018退役记&lt;/h1&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://azrael.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2756【SCOI2012】奇怪的游戏 &lt;二分答案+网络流&gt;</title>
    <link href="http://azrael.top/BZOJ2756%E3%80%90SCOI2012%E3%80%91%E5%A5%87%E6%80%AA%E7%9A%84%E6%B8%B8%E6%88%8F%20%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ2756【SCOI2012】奇怪的游戏 网络流/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-04-17T04:43:22.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2012】奇怪的游戏"><a href="#【SCOI2012】奇怪的游戏" class="headerlink" title="【SCOI2012】奇怪的游戏"></a>【SCOI2012】奇怪的游戏</h3><p>$\mathrm{Time\;Limit:\;40\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Blinker}$最近喜欢上一个奇怪的游戏。<br>这个游戏在一个$N\times M$的棋盘上玩，每个格子有一个数。每次$\mathrm{Blinker}$会选择两个相邻的格子，并使这两个数都加上$1$。<br>现在$\mathrm{Blinker}$想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出$-1$。 </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行是一个整数$T$，表示输入数据有$T$轮游戏组成。<br>每轮游戏的第一行有两个整数$N$和$M$， 分别代表棋盘的行数和列数。<br>接下来有$N$行，每行$M$个数。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 </span><br><span class="line">2 2 </span><br><span class="line">1 2 </span><br><span class="line">2 3 </span><br><span class="line">3 3 </span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">4 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$30\%$的数据，保证$T\le10,\;1\le N,M\le8$<br>对于$100\%$的数据，保证$T\le10,\;1\le N,M\le40$，所有数为正整数且小于$10^9$ </p><p>标签：<code>网络流</code> <code>黑白染色</code> <code>二分答案</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>黑白染色，两色个数为$c_1$和$c_2$，两色初始数字和为$s_1$和$s_2$。则有<br>$$<br>c_1\times x-s_1=c_2\times x-s_2\\<br>(c_1-c_2)\times x=s_1-s_2\\<br>$$<br>当$c_1\ne c_2$时，可以直接解出$x$，这时网络流$check$一下是否可能达到即可。<br>当$c_1=c_2$时，每次操作都会使一定能在某一基础上将所有格子都$+1$，那么所有大于等于最小$x$的值都可以达到，具有二分性。那么二分$x$，网络流$check$即可。</p><p>对于网络流$check$，建图如下：</p><ul><li>对于白格$i$，连接$S\to i\;[cap=x-val_i]$</li><li>对于黑格$i$，连接$i\to T\;[cap=x-val_i]$</li><li>对于每组相邻点$x,y$，连接$x\to y\;[cap=\infty]$</li></ul><p>再计算一个$tot=所有白格的值与x的差之和$<br>若$最大流=tot$，则当前$x$可行。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF (1LL&lt;&lt;50)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, nxt; lnt c;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">50</span>][<span class="number">50</span>], c0, c1; lnt a[<span class="number">50</span>][<span class="number">50</span>], s0, s1, mx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x*m-m+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n*m+<span class="number">1</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;E[cnt] = (node)&#123;v, pr[u], c&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v;lnt c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, lnt flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;lnt ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v;lnt c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">lnt tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function">lnt <span class="title">Dinic</span><span class="params">()</span> </span>&#123;lnt ret = <span class="number">0</span>; cpy(); <span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec(); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(lnt x)</span> </span>&#123;</span><br><span class="line">init();lnt tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (col[i][j])</span><br><span class="line">addedge(s, p(i, j), x-a[i][j]), tot += x-a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (!col[i][j])</span><br><span class="line">addedge(p(i, j), t, x-a[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (col[i][j])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i+nxt[k][<span class="number">0</span>], y = j+nxt[k][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">addedge(p(i, j), p(x, y), INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Dinic() == tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">bi_search</span><span class="params">(lnt l, lnt r)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = mid, r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mx = c0 = c1 = s0 = s1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">col[i][j] = (i+j)&amp;<span class="number">1</span>, </span><br><span class="line">(col[i][j] ? c1++ : c0++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">read(n), read(m), color();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">read(a[i][j]), mx = max(mx, a[i][j]), </span><br><span class="line">(col[i][j] ? s1 += a[i][j] : s0 += a[i][j]);</span><br><span class="line"><span class="keyword">if</span> (c0^c1) &#123;</span><br><span class="line"><span class="keyword">if</span> ((s0-s1)/(c0-c1) &gt;= m &amp;&amp; chk((s0-s1)/(c0-c1)))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (s0-s1)/(c0-c1)*c0-s0);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s0^s1) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, bi_search(mx, INF)*c0-s0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2012】奇怪的游戏&quot;&gt;&lt;a href=&quot;#【SCOI2012】奇怪的游戏&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2012】奇怪的游戏&quot;&gt;&lt;/a&gt;【SCOI2012】奇怪的游戏&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;40\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Blinker}$最近喜欢上一个奇怪的游戏。&lt;br&gt;这个游戏在一个$N\times M$的棋盘上玩，每个格子有一个数。每次$\mathrm{Blinker}$会选择两个相邻的格子，并使这两个数都加上$1$。&lt;br&gt;现在$\mathrm{Blinker}$想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出$-1$。 &lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行是一个整数$T$，表示输入数据有$T$轮游戏组成。&lt;br&gt;每轮游戏的第一行有两个整数$N$和$M$， 分别代表棋盘的行数和列数。&lt;br&gt;接下来有$N$行，每行$M$个数。 &lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分答案" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3944 Sum &lt;杜教筛&gt;</title>
    <link href="http://azrael.top/BZOJ3944%20Sum%20%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    <id>http://azrael.top/BZOJ3944 Sum 杜教筛/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-04-12T14:45:55.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/upload/201504/aaa.PNG" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一共$T+1$行<br>第$1$行为数据组数$T(T\le10)$<br>第$2\sim T+1$行每行一个非负整数$N$，代表一组询问</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一共$T$行，每行两个用空格分隔的数$ans_1,ans_2$<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">30</span><br><span class="line">2333</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 0</span><br><span class="line">22 -2</span><br><span class="line">58 -3</span><br><span class="line">278 -3</span><br><span class="line">1655470 2</span><br></pre></td></tr></table></figure><p>标签：<code>杜教筛</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>杜教筛板题。</p><p>首先推杜教筛通式。<br>对于积性函数$f,g,h$，若$h=f\otimes g$，即$h(n)=\sum_{d|n}f(d)g(\frac{n}{d})$，那么可以得到<br>$$<br>\begin{aligned}<br>\sum_{i=1}^{n}h(i)&amp;=\sum_{i=1}^{n}\sum_{d|i}f(d)g(\frac{n}{d})\\<br>&amp;=\sum_{i=1}^{n}g(i)\sum_{d=1}^{\lfloor n/i\rfloor}f(d)\\<br>&amp;=\sum_{i=1}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)\\<br>&amp;=\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)+g(1)S(n)\\<br>\therefore S(n)&amp;=\frac{\sum_{i=1}^{n}h(i)-\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)}{g(1)}<br>\end{aligned}<br>$$<br>这样就可以预处理较小的$S$后数论分块求解。</p><p>然后对于题目中的两问分别推式子：<br>$$<br>Calculate\;\sum_{i=1}^{n}\mu(i).\\<br>\begin{aligned}<br>&amp;\because\sum_{d|n}\mu(d)=[n=1]=e(n)\\<br>&amp;\therefore e=\mu\otimes1\\<br>&amp;\Rightarrow S(n)=1-\sum_{i=2}^{n}S(\lfloor\frac{n}{i}\rfloor)<br>\end{aligned}<br>$$<br>$$<br>Calculate\;\sum_{i=1}^{n}\varphi(i).\\<br>\begin{aligned}<br>&amp;\because\sum_{d|n}\varphi(d)=n=id(n)\\<br>&amp;\therefore id=\varphi\otimes1\\<br>&amp;\Rightarrow S(n)=\frac{n\times(n+1)}{2}-\sum_{i=2}^{n}S(\lfloor\frac{n}{i}\rfloor)<br>\end{aligned}<br>$$</p><p>注意将两个答案的求解放在一起，用<code>pair&lt;long,long&gt;</code>返回，否则可能$\mathrm{TLE}$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MX 2500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;lnt,lnt&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt, pri[MX+<span class="number">5</span>]; lnt phi[MX+<span class="number">5</span>], mu[MX+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> NotPri[MX+<span class="number">5</span>]; <span class="built_in">map</span> &lt;lnt, lnt&gt; ex1, ex2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MX; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, phi[i] = i<span class="number">-1</span>, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MX) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]<span class="number">-1</span>), mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;phi[i*pri[j]] = phi[i]*pri[j], mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">phi[i] += phi[i<span class="number">-1</span>], mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pll <span class="title">sum</span><span class="params">(lnt n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MX) <span class="keyword">return</span> mp(phi[n], mu[n]);</span><br><span class="line"><span class="keyword">if</span> (ex1[n]) <span class="keyword">return</span> mp(ex1[n], ex2[n]);</span><br><span class="line">lnt ret1 = <span class="number">1L</span>L*n*(n+<span class="number">1</span>)/<span class="number">2</span>, ret2 = <span class="number">1L</span>L; pll t;</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">2</span>, r; l &lt;= n; l = r+<span class="number">1</span>)</span><br><span class="line">r = n/(n/l), t = sum(n/l), </span><br><span class="line">ret1 -= <span class="number">1L</span>L*(r-l+<span class="number">1</span>)*t.fir, </span><br><span class="line">ret2 -= <span class="number">1L</span>L*(r-l+<span class="number">1</span>)*t.sec;</span><br><span class="line"><span class="keyword">return</span> mp(ex1[n] = ret1, ex2[n] = ret2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(lnt n)</span> </span>&#123;</span><br><span class="line">pll ans = sum(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans.fir, ans.sec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lnt T, n;read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) read(n), sol(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;Sum&quot;&gt;&lt;a href=&quot;#Sum&quot; class=&quot;headerlink&quot; title=&quot;Sum&quot;&gt;&lt;/a&gt;Sum&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/upload/201504/aaa.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一共$T+1$行&lt;br&gt;第$1$行为数据组数$T(T\le10)$&lt;br&gt;第$2\sim T+1$行每行一个非负整数$N$，代表一组询问&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一共$T$行，每行两个用空格分隔的数$ans_1,ans_2$&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="杜教筛" scheme="http://azrael.top/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3289 Mato的文件管理 &lt;莫队+树状数组&gt;</title>
    <link href="http://azrael.top/BZOJ3289%20Mato%E7%9A%84%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%20%E8%8E%AB%E9%98%9F+%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://azrael.top/BZOJ3289 Mato的文件管理 莫队+树状数组/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-04-04T12:58:39.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Mato的文件管理"><a href="#Mato的文件管理" class="headerlink" title="Mato的文件管理"></a>Mato的文件管理</h3><p>$\mathrm{Time\;Limit:\;40\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Mato}$同学从各路神犇以各种方式收集了许多资料，这些资料一共有$n$份，每份有一个大小和一个编号。为了防止他人偷拷，这些资料都是加密过的，只能用$\mathrm{Mato}$自己写的程序才能访问。$\mathrm{Mato}$每天随机选一个区间$[l,r]$，他今天就看编号在此区间内的这些资料。$\mathrm{Mato}$有一个习惯，他总是从文件大小从小到大看资料。他先把要看的文件按编号顺序依次拷贝出来，再用他写的排序程序给文件大小排序。排序程序可以在$1$单位时间内交换$2$个相邻的文件（因为加密需要，不能随机访问）。$\mathrm{Mato}$想要使文件交换次数最小，你能告诉他每天需要交换多少次吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个正整数$n$，表示$\mathrm{Mato}$的资料份数。<br>第二行由空格隔开的$n$个正整数，第$i$个表示编号为$i$的资料的大小。<br>第三行一个正整数$q$，表示$\mathrm{Mato}$会看几天资料。<br>之后$q$行每行两个正整数$l,r$，表示$\mathrm{Mato}$这天看$[l,r]$区间的文件。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>$q$行，每行一个正整数，表示$\mathrm{Mato}$这天需要交换的次数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 4 2 3</span><br><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p><strong>样例解释</strong><br>第一天，$\mathrm{Mato}$不需要交换<br>第二天，$\mathrm{Mato}$可以把$2$号交换$2$次移到最后。<br><strong>数据规模和约定</strong><br>$n,q\le5\times10^4$</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>By <code>taorunz</code></p><p>标签：<code>莫队</code> <code>树状数组</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$最小交换次数=区间逆序对数$<br>因此此问题等价于求区间逆序对数，傻逼莫队水过。<br>离线下所有询问，每次加入或删除一个数用树状数组维护，计算会增加或减少多少对逆序对，更新答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAGIC = <span class="number">230</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, q, a[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>], tr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span><span class="keyword">int</span> l, r, lb, rb, id;&#125; Q[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> ans[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpn</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;<span class="keyword">return</span> c[x] &lt; c[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpq</span> <span class="params">(<span class="keyword">const</span> query &amp;x, <span class="keyword">const</span> query &amp;y)</span> </span>&#123;<span class="keyword">return</span> x.lb == y.lb ? x.rb &lt; y.rb : x.lb &lt; y.lb;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">for</span> (; p &lt;= m; p += (p&amp;-p)) tr[p]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">for</span> (; p &lt;= m; p += (p&amp;-p)) tr[p]--;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> s = <span class="number">0</span>; <span class="keyword">for</span> (; p; p -= (p&amp;-p)) s += tr[p]; <span class="keyword">return</span> s;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_bef</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">return</span> sum(p<span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_aft</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">return</span> sum(m)-sum(p);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(c[i]), b[i] = i;</span><br><span class="line">sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>, cmpn);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; a[b[i++]] = m)</span><br><span class="line"><span class="keyword">if</span> (c[b[i]]^c[b[i<span class="number">-1</span>]]) m++;</span><br><span class="line">read(q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++)</span><br><span class="line">read(Q[i].l), read(Q[i].r), Q[i].id = i, </span><br><span class="line">Q[i].lb = Q[i].l/MAGIC, Q[i].rb = Q[i].r/MAGIC;</span><br><span class="line">sort(Q+<span class="number">1</span>, Q+q+<span class="number">1</span>, cmpq);<span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l = <span class="number">1</span>, r = <span class="number">0</span>; i &lt;= q; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (; l &gt; Q[i].l; l--) tot += get_bef(a[l<span class="number">-1</span>]), inc(a[l<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span> (; r &lt; Q[i].r; r++) tot += get_aft(a[r+<span class="number">1</span>]), inc(a[r+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (; l &lt; Q[i].l; l++) tot -= get_bef(a[l]), dec(a[l]);</span><br><span class="line"><span class="keyword">for</span> (; r &gt; Q[i].r; r--) tot -= get_aft(a[r]), dec(a[r]);</span><br><span class="line">ans[Q[i].id] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;Mato的文件管理&quot;&gt;&lt;a href=&quot;#Mato的文件管理&quot; class=&quot;headerlink&quot; title=&quot;Mato的文件管理&quot;&gt;&lt;/a&gt;Mato的文件管理&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;40\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Mato}$同学从各路神犇以各种方式收集了许多资料，这些资料一共有$n$份，每份有一个大小和一个编号。为了防止他人偷拷，这些资料都是加密过的，只能用$\mathrm{Mato}$自己写的程序才能访问。$\mathrm{Mato}$每天随机选一个区间$[l,r]$，他今天就看编号在此区间内的这些资料。$\mathrm{Mato}$有一个习惯，他总是从文件大小从小到大看资料。他先把要看的文件按编号顺序依次拷贝出来，再用他写的排序程序给文件大小排序。排序程序可以在$1$单位时间内交换$2$个相邻的文件（因为加密需要，不能随机访问）。$\mathrm{Mato}$想要使文件交换次数最小，你能告诉他每天需要交换多少次吗？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个正整数$n$，表示$\mathrm{Mato}$的资料份数。&lt;br&gt;第二行由空格隔开的$n$个正整数，第$i$个表示编号为$i$的资料的大小。&lt;br&gt;第三行一个正整数$q$，表示$\mathrm{Mato}$会看几天资料。&lt;br&gt;之后$q$行每行两个正整数$l,r$，表示$\mathrm{Mato}$这天看$[l,r]$区间的文件。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;$q$行，每行一个正整数，表示$\mathrm{Mato}$这天需要交换的次数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树状数组" scheme="http://azrael.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="莫队" scheme="http://azrael.top/tags/%E8%8E%AB%E9%98%9F/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2938【POI2000】病毒 &lt;AC自动机&gt;</title>
    <link href="http://azrael.top/BZOJ2938%E3%80%90POI2000%E3%80%91%E7%97%85%E6%AF%92%20AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://azrael.top/BZOJ2938【POI2000】病毒 AC自动机/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-04-04T13:07:16.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【POI2000】病毒"><a href="#【POI2000】病毒" class="headerlink" title="【POI2000】病毒"></a>【POI2000】病毒</h3><p>$\mathrm{Time\;Limit:\;1\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。<br>示例：<br>如果$\lbrace011, 11, 00000\rbrace$为病毒代码段，那么一个可能的无限长安全代码就是$010101\cdots$。<br>如果$\lbrace01, 11, 000000\rbrace$为病毒代码段，那么就不存在一个无限长的安全代码。<br>任务：<br>请写一个程序</p><ul><li>读入病毒代码</li><li>判断是否存在一个无限长的安全代码</li><li>将结果输出</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包括一个整数$n$，表示病毒代码段的数目。<br>以下的$n$行每一行都包括一个非空的$01$字符串就是一个病毒代码段。<br>所有病毒代码段的总长度不超过$30000$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行输出一个单词：<br>$\mathrm{TAK}$：存在这样的代码<br>$\mathrm{NIE}$：不存在这样的代码<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">01</span><br><span class="line">11</span><br><span class="line">00000</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NIE</span><br></pre></td></tr></table></figure><p>标签：<code>AC自动机</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先显然需要建$\mathrm{AC}$自动机。<br>然后，在此$\mathrm{AC}$自动机形成的$\mathrm{DAG}$上，一个符合题意的无限长的串一定对应一个环，并且换上没有任何一个结点有结束标记。因此直接在$\mathrm{DAG}$上$\mathrm{DFS}$，暴力找解即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 30000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, rt, cnt, tr[MAX_N+<span class="number">5</span>][<span class="number">2</span>], fail[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">char</span> s[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> end[MAX_N+<span class="number">5</span>], mrk[MAX_N+<span class="number">5</span>], ins[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;rt = ++cnt, tr[<span class="number">0</span>][<span class="number">0</span>] = tr[<span class="number">0</span>][<span class="number">1</span>] = rt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> cur = rt, len = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; cur = tr[cur][s[i++]-<span class="string">'0'</span>])</span><br><span class="line"><span class="keyword">if</span> (!tr[cur][s[i]-<span class="string">'0'</span>]) tr[cur][s[i]-<span class="string">'0'</span>] = ++cnt;</span><br><span class="line">end[cur] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; que.push(rt);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">if</span> (!tr[u][<span class="number">0</span>]) tr[u][<span class="number">0</span>] = tr[fail[u]][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">que.push(tr[u][<span class="number">0</span>]), </span><br><span class="line">fail[tr[u][<span class="number">0</span>]] = tr[fail[u]][<span class="number">0</span>], </span><br><span class="line">end[tr[u][<span class="number">0</span>]] |= end[tr[fail[u]][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span> (!tr[u][<span class="number">1</span>]) tr[u][<span class="number">1</span>] = tr[fail[u]][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">que.push(tr[u][<span class="number">1</span>]), </span><br><span class="line">fail[tr[u][<span class="number">1</span>]] = tr[fail[u]][<span class="number">1</span>], </span><br><span class="line">end[tr[u][<span class="number">1</span>]] |= end[tr[fail[u]][<span class="number">1</span>]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (end[u]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">ins[u] = mrk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (ins[tr[u][<span class="number">0</span>]]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (ins[tr[u][<span class="number">1</span>]]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!mrk[tr[u][<span class="number">0</span>]] &amp;&amp; DFS(tr[u][<span class="number">0</span>])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (!mrk[tr[u][<span class="number">1</span>]] &amp;&amp; DFS(tr[u][<span class="number">1</span>])) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">ins[u] = <span class="literal">false</span>;<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s), insert();</span><br><span class="line">setFail();</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(DFS(rt) ? <span class="string">"TAK"</span> : <span class="string">"NIE"</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【POI2000】病毒&quot;&gt;&lt;a href=&quot;#【POI2000】病毒&quot; class=&quot;headerlink&quot; title=&quot;【POI2000】病毒&quot;&gt;&lt;/a&gt;【POI2000】病毒&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;1\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。&lt;br&gt;示例：&lt;br&gt;如果$\lbrace011, 11, 00000\rbrace$为病毒代码段，那么一个可能的无限长安全代码就是$010101\cdots$。&lt;br&gt;如果$\lbrace01, 11, 000000\rbrace$为病毒代码段，那么就不存在一个无限长的安全代码。&lt;br&gt;任务：&lt;br&gt;请写一个程序&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读入病毒代码&lt;/li&gt;
&lt;li&gt;判断是否存在一个无限长的安全代码&lt;/li&gt;
&lt;li&gt;将结果输出&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包括一个整数$n$，表示病毒代码段的数目。&lt;br&gt;以下的$n$行每一行都包括一个非空的$01$字符串就是一个病毒代码段。&lt;br&gt;所有病毒代码段的总长度不超过$30000$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一行输出一个单词：&lt;br&gt;$\mathrm{TAK}$：存在这样的代码&lt;br&gt;$\mathrm{NIE}$：不存在这样的代码&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="POI" scheme="http://azrael.top/tags/POI/"/>
    
      <category term="AC自动机" scheme="http://azrael.top/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
      <category term="字符串" scheme="http://azrael.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2753【SCOI2012】滑雪与时间胶囊 &lt; MST &gt;</title>
    <link href="http://azrael.top/BZOJ2753%E3%80%90SCOI2012%E3%80%91%E6%BB%91%E9%9B%AA%E4%B8%8E%E6%97%B6%E9%97%B4%E8%83%B6%E5%9B%8A%20MST/"/>
    <id>http://azrael.top/BZOJ2753【SCOI2012】滑雪与时间胶囊 MST/</id>
    <published>2018-04-02T16:00:00.000Z</published>
    <updated>2018-04-20T12:45:02.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2012】滑雪与时间胶囊"><a href="#【SCOI2012】滑雪与时间胶囊" class="headerlink" title="【SCOI2012】滑雪与时间胶囊"></a>【SCOI2012】滑雪与时间胶囊</h3><p>$\mathrm{Time\;Limit:\;50\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{a180285}$非常喜欢滑雪。他来到一座雪山，这里分布着$M$条供滑行的轨道和$N$个轨道之间的交点（同时也是景点），而且每个景点都有一编号$i$（$1\le i\le N$）和一高度$H_i$。$\mathrm{a180285}$能从景点$i$滑到景点$j$当且仅当存在一条$i$和$j$之间的边，且$i$的高度不小于$j$。 与其他滑雪爱好者不同，$\mathrm{a180285}$喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。于是$\mathrm{a180285}$拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是$\mathrm{a180285}$滑行的距离）。请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，$\mathrm{a180285}$站在$1$号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行是两个整数$N$，$M$。<br>接下来$1$行有$N$个整数$H_i$，分别表示每个景点的高度。<br>接下来$M$行，表示各个景点之间轨道分布的情况。每行$3$个整数，$U_i,V_i,K_i$。表示<br>编号为$U_i$的景点和编号为$V_i$的景点之间有一条长度为$K_i$的轨道。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行，表示$\mathrm{a180285}$最多能到达多少个景点，以及此时最短的滑行距离总和。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">3 2 1</span><br><span class="line">1 2 1</span><br><span class="line">2 3 1</span><br><span class="line">1 3 10</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$30\%$的数据，保证$1\le N\le 2000$<br>对于$100\%$的数据，保证$1\le N\le10^5$, $1\le M\le10^6$, $1\le H_i\le10^9$, $1\le K_i\le10^9$。</p><p>标签：<code>MST</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>原题的一大坨叙述就是求有向图中从一点出发能达到的点数和最小生成树边权和。</p><p>第一问直接$\mathrm{BFS}$出解。<br>第二问比较麻烦，还是做$\mathrm{Kruskal}$，只是排序的时候以终点高度从高到低为第一关键字，以边权从低到高为第二关键字。</p><p>原理：<br>首先，同一高度的点间一定是双向边，于是是一个强连通分量，如果把每个高度的点缩起来，那么最后一定会形成一个$\mathrm{DAG}$，从$1$开始沿拓扑序遍历每个强连通分量，这个强连通分量中的边都是双向边，可以在这个强连通分量中跑$\mathrm{Kruskal}$，除了这些边以外还可能有从上面的点连下来的点。因此如果按终点高度为第一关键字排序，那么到一个高度时一定是此高度强连通分量内部的双向边和前面连到此强连通分量的边，符合$\mathrm{Kruskal}$贪心的前提。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 2000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, p, h[MAX_N+<span class="number">5</span>], fa[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> u, v, w; lnt c;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.w == b.w ? a.c &lt; b.c : a.w &gt; b.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;mrk[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; que.push(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = G[u][i]]) que.push(v), mrk[v] = <span class="literal">true</span>, ret++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);lnt ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(h[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v; lnt c; read(u), read(v), read(c);</span><br><span class="line"><span class="keyword">if</span> (h[u] &gt;= h[v]) G[u].pb(v), E[++p] = (node)&#123;u, v, h[v], c&#125;;</span><br><span class="line"><span class="keyword">if</span> (h[u] &lt;= h[v]) G[v].pb(u), E[++p] = (node)&#123;v, u, h[u], c&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sort(E+<span class="number">1</span>, E+(m=p)+<span class="number">1</span>, cmp), <span class="built_in">printf</span>(<span class="string">"%d "</span>, BFS());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">if</span> (mrk[E[i].u] &amp;&amp; mrk[E[i].v]) &#123;</span><br><span class="line">u = getf(E[i].u), v = getf(E[i].v);</span><br><span class="line"><span class="keyword">if</span> (u^v) fa[u] = v, ans += E[i].c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2012】滑雪与时间胶囊&quot;&gt;&lt;a href=&quot;#【SCOI2012】滑雪与时间胶囊&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2012】滑雪与时间胶囊&quot;&gt;&lt;/a&gt;【SCOI2012】滑雪与时间胶囊&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;50\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{a180285}$非常喜欢滑雪。他来到一座雪山，这里分布着$M$条供滑行的轨道和$N$个轨道之间的交点（同时也是景点），而且每个景点都有一编号$i$（$1\le i\le N$）和一高度$H_i$。$\mathrm{a180285}$能从景点$i$滑到景点$j$当且仅当存在一条$i$和$j$之间的边，且$i$的高度不小于$j$。 与其他滑雪爱好者不同，$\mathrm{a180285}$喜欢用最短的滑行路径去访问尽量多的景点。如果仅仅访问一条路径上的景点，他会觉得数量太少。于是$\mathrm{a180285}$拿出了他随身携带的时间胶囊。这是一种很神奇的药物，吃下之后可以立即回到上个经过的景点（不用移动也不被认为是$\mathrm{a180285}$滑行的距离）。请注意，这种神奇的药物是可以连续食用的，即能够回到较长时间之前到过的景点（比如上上个经过的景点和上上上个经过的景点）。 现在，$\mathrm{a180285}$站在$1$号景点望着山下的目标，心潮澎湃。他十分想知道在不考虑时间胶囊消耗的情况下，以最短滑行距离滑到尽量多的景点的方案（即满足经过景点数最大的前提下使得滑行总距离最小）。你能帮他求出最短距离和景点数吗？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行是两个整数$N$，$M$。&lt;br&gt;接下来$1$行有$N$个整数$H_i$，分别表示每个景点的高度。&lt;br&gt;接下来$M$行，表示各个景点之间轨道分布的情况。每行$3$个整数，$U_i,V_i,K_i$。表示&lt;br&gt;编号为$U_i$的景点和编号为$V_i$的景点之间有一条长度为$K_i$的轨道。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一行，表示$\mathrm{a180285}$最多能到达多少个景点，以及此时最短的滑行距离总和。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="MST" scheme="http://azrael.top/tags/MST/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2115【WC2011】Xor &lt;线性基&gt;</title>
    <link href="http://azrael.top/BZOJ2115%E3%80%90WC2011%E3%80%91Xor%20%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>http://azrael.top/BZOJ2115【WC2011】Xor 线性基/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-04-02T13:03:14.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【WC2011】Xor"><a href="#【WC2011】Xor" class="headerlink" title="【WC2011】Xor"></a>【WC2011】Xor</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;259MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/2606_1.jpg" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数$N$和$M$，表示该无向图中点的数目与边的数目。<br>接下来$M$行描述$M$条边，每行三个整数$S_i,T_i,D_i$，表示$S_i$与$T_i$之间存在 一条权值为$D_i$的无向边。<br>图中可能有重边或自环。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个整数，表示最大的$\mathrm{Xor}$和（十进制结果），注意输出后加换行回车。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/2606_3.jpg" alt=""><br></center><p>标签：<code>线性基</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>线性基经典题。</p><p>对于一条非简单的路径，其异或和等于其中的简单路径异或和异或上经过的环的异或和，即选取一条简单路径和若干环，此简单路径到环的那段路径会经过两次，因而异或和消成$0$。<br>因此只用选出一条从$1$到$n$的简单路径异或和，再异或上若干环的异或和使总和最大即可。<br>于是暴力$\mathrm{DFS}$找到简单路径异或和和所有环的异或和，对所有环的异或和求线性基，贪心选最大和即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">lnt b[SZ+<span class="number">5</span>], dis[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="built_in">vector</span> &lt;lnt&gt; E[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(lnt x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--) <span class="keyword">if</span> (x&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i]) x ^= b[i];</span><br><span class="line"><span class="keyword">else</span> &#123;b[i] = x; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (mrk[v = G[u][i]]) insert(dis[u]^dis[v]^E[u][i]);</span><br><span class="line"><span class="keyword">else</span> dis[v] = dis[u]^E[u][i], mrk[v] = <span class="literal">true</span>, DFS(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; m; i++) &#123;</span><br><span class="line">lnt c;read(u), read(v), read(c);</span><br><span class="line">G[u].push_back(v), E[u].push_back(c);</span><br><span class="line">G[v].push_back(u), E[v].push_back(c);</span><br><span class="line">&#125;</span><br><span class="line">DFS(<span class="number">1</span>);lnt mx = dis[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (!(mx&gt;&gt;i&amp;<span class="number">1</span>)) mx ^= b[i];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mx), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【WC2011】Xor&quot;&gt;&lt;a href=&quot;#【WC2011】Xor&quot; class=&quot;headerlink&quot; title=&quot;【WC2011】Xor&quot;&gt;&lt;/a&gt;【WC2011】Xor&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;259MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/2606_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个整数$N$和$M$，表示该无向图中点的数目与边的数目。&lt;br&gt;接下来$M$行描述$M$条边，每行三个整数$S_i,T_i,D_i$，表示$S_i$与$T_i$之间存在 一条权值为$D_i$的无向边。&lt;br&gt;图中可能有重边或自环。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅包含一个整数，表示最大的$\mathrm{Xor}$和（十进制结果），注意输出后加换行回车。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性基" scheme="http://azrael.top/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
      <category term="WC" scheme="http://azrael.top/tags/WC/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4568【SCOI2016】幸运数字 &lt;LCA+线性基&gt;</title>
    <link href="http://azrael.top/BZOJ4568%E3%80%90SCOI2016%E3%80%91%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%20LCA+%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>http://azrael.top/BZOJ4568【SCOI2016】幸运数字 LCA+线性基/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-04-03T04:32:50.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2016】幸运数字"><a href="#【SCOI2016】幸运数字" class="headerlink" title="【SCOI2016】幸运数字"></a>【SCOI2016】幸运数字</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$A$国共有$n$座城市，这些城市由$n-1$条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览$A$国。旅行者计划乘飞机降落在$x$号城市，沿着$x$号城市到$y$号城市之间那条唯一的路径游览，最终从$y$城市起飞离开$A$国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，游览者拍了$3$张照片，幸运值分别是$5,7,11$，那么最终保留在自己身上的幸运值就是 $\mathrm{9\;(5\oplus7\oplus11)}$。有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择$5$和$11$，可以保留的幸运值为$14$ 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含$2$个正整数$n,q$，分别表示城市的数量和旅行者数量。第二行包含$n$个非负整数，其中第$i$个整数$G_i$表示$i$号城市的幸运值。随后$n-1$行，每行包含两个正整数$x,y$，表示$x$号城市和$y$号城市之间有一条道路相连。随后$q$行，每行包含两个正整数$x,y$，表示这名旅行者的旅行计划是从$x$号城市到$y$号城市。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出需要包含$q$行，每行包含$1$个非负整数，表示这名旅行者可以保留的最大幸运值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">11</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$N\le2\times10^4,\;Q\le2\times10^5,\;G_i\le2^{60}$</p><p>标签：<code>线性基</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>最大子集异或和上树…</p><p>树上两点间路径，容易联想到倍增$\mathrm{LCA}$；最大子集异或和，容易联想到线性基。<br>因此把两者结合起来，预处理出每个结点到其$2^i$祖先结点路径上的线性基，对于倍增的合并，可以暴力合并线性基，即将一个线性基中的数暴力插到另一个线性基中。<br>求$\mathrm{LCA}$的过程照常，只是将单个值合并换成了两个数组合并。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl vector<span class="meta-string">&lt;lnt&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">lnt a[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, q, fa[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>], dep[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;lnt&gt; b[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>]; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;G[u].push_back(v), G[v].push_back(u);&#125;</span><br><span class="line"><span class="function">lnt <span class="title">get_mx</span><span class="params">(vl base)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--) <span class="keyword">if</span> (base[i])</span><br><span class="line"><span class="keyword">if</span> ((ret^base[i]) &gt; ret) ret ^= base[i];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vl <span class="title">merge</span><span class="params">(vl x, vl y)</span> </span>&#123;</span><br><span class="line">vl ret = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--) <span class="keyword">if</span> (y[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; ~j; j--) <span class="keyword">if</span> (y[i]&gt;&gt;j&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret[j]) y[i] ^= ret[j];</span><br><span class="line"><span class="keyword">else</span> &#123;ret[j] = y[i]; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">b[u][<span class="number">0</span>].resize(SZ+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (a[u]&gt;&gt;i&amp;<span class="number">1</span>) &#123;b[u][<span class="number">0</span>][i] = a[u]; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOG; i++)</span><br><span class="line">fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>], b[u][i].resize(SZ+<span class="number">1</span>), </span><br><span class="line">b[u][i] = merge(b[u][i<span class="number">-1</span>], b[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> ((v = G[u][i]) ^ fa[u][<span class="number">0</span>])</span><br><span class="line">fa[v][<span class="number">0</span>] = u, dep[v] = dep[u]+<span class="number">1</span>, DFS(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">vl ub, vb;ub.resize(SZ+<span class="number">1</span>), vb.resize(SZ+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--) <span class="keyword">if</span> (dep[u]-dep[v] &gt;= (<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">ub = merge(ub, b[u][i]), u = fa[u][i];</span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span> get_mx(merge(ub, b[u][<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--) <span class="keyword">if</span> (fa[u][i]^fa[v][i])</span><br><span class="line">ub = merge(ub, b[u][i]), u = fa[u][i],</span><br><span class="line">vb = merge(vb, b[v][i]), v = fa[v][i];</span><br><span class="line">ub = merge(ub, b[u][<span class="number">0</span>]), vb = merge(vb, b[v][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> get_mx(merge(merge(ub, vb), b[fa[u][<span class="number">0</span>]][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++)</span><br><span class="line">read(u), read(v), addedge(u, v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= LOG; i++) b[<span class="number">0</span>][i].resize(SZ+<span class="number">1</span>);</span><br><span class="line">DFS(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v;read(u), read(v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(u, v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2016】幸运数字&quot;&gt;&lt;a href=&quot;#【SCOI2016】幸运数字&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2016】幸运数字&quot;&gt;&lt;/a&gt;【SCOI2016】幸运数字&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$A$国共有$n$座城市，这些城市由$n-1$条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览$A$国。旅行者计划乘飞机降落在$x$号城市，沿着$x$号城市到$y$号城市之间那条唯一的路径游览，最终从$y$城市起飞离开$A$国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，游览者拍了$3$张照片，幸运值分别是$5,7,11$，那么最终保留在自己身上的幸运值就是 $\mathrm{9\;(5\oplus7\oplus11)}$。有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择$5$和$11$，可以保留的幸运值为$14$ 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含$2$个正整数$n,q$，分别表示城市的数量和旅行者数量。第二行包含$n$个非负整数，其中第$i$个整数$G_i$表示$i$号城市的幸运值。随后$n-1$行，每行包含两个正整数$x,y$，表示$x$号城市和$y$号城市之间有一条道路相连。随后$q$行，每行包含两个正整数$x,y$，表示这名旅行者的旅行计划是从$x$号城市到$y$号城市。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出需要包含$q$行，每行包含$1$个非负整数，表示这名旅行者可以保留的最大幸运值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="LCA" scheme="http://azrael.top/tags/LCA/"/>
    
      <category term="线性基" scheme="http://azrael.top/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2177 曼哈顿最小生成树 &lt;树状数组优化建边&gt;</title>
    <link href="http://azrael.top/BZOJ2177%20%E6%9B%BC%E5%93%88%E9%A1%BF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%E5%BB%BA%E8%BE%B9/"/>
    <id>http://azrael.top/BZOJ2177 曼哈顿最小生成树 树状数组优化建边/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-03-30T12:38:44.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="曼哈顿最小生成树"><a href="#曼哈顿最小生成树" class="headerlink" title="曼哈顿最小生成树"></a>曼哈顿最小生成树</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>平面坐标系$\mathrm{xOy}$内，给定$n$个顶点$V=(x,y)$。对于顶点$u,\;v$，$u$与$v$之间的距离$d$定义为$|x_u-x_v|+|y_u-y_v|$。你的任务是求出这$n$个顶点的最小生成树。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个正整数$n$，表示定点个数。<br>接下来$n$行每行两个正整数$x,\;y$，描述一个顶点。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一行，为最小生成树的边的距离和。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 -1</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据，$n\le5\times10^4,\;0\le x, y\le10^5$。</p><p>标签：<code>树状数组</code> <code>MST</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{MMST}$裸题。</p><p>对于曼哈顿最小生成树，直接建边肯定是不行的，考虑优化建边，去掉一些一定不会在$\mathrm{MST}$中的边。<br>考虑一个点$A(x_1,y_1)$，以$A$为中心将整个图分为$8$个部分。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2e2a1e453.png" alt="0.PNG"><br></center><p>对于一个在右上角的点$B(x_2,y_2)$，一定有$x_2-x_1&lt;y_2-y_1且x_2&gt;x_1$，若其使$x_2+y_2-x_1-y_1$最小，则所有在右上角的点的曼哈顿距离都没有$A\to B$小。因此在$A$右上角的所有点中，只连$AB$即可。同理在$A$周围的八个方向中，每个方向只需连曼哈顿距离最小的点。</p><p>对于如何寻找这样的点，拿找右上角的最近点做例子：<br>最近的点$B(x_2,y_2)$一定使$x_2+y_2-x_1-y_1$最小，即使$x_2+y_2$最小。同时要满足$x_2-x_1&lt;y_2-y_1和x_2&gt;x_1$，即满足$x_2-y_2&lt;x_1-y_1且x_2&gt;x_1$。可以发现这就是以$x$为第一维，$x-y$为第二维做偏序，找到符合的位置中的最小值，用$排序+树状数组$维护。<br>这样我们就可以连每个点到其右上角的最近点的边了。考虑到边可以每次都连双向，因此每个点只用枚举一半即可。这里默认向$y$坐标比当前点大的点连边。其实是可以把每种情况都转化为右上角的。<br>一开始的时候，我们总共需要考虑的是下图区域$1,2,3,4$中的最近点。第一次连边将$1$中的最近点连边。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2f41874f2.png" alt="1.PNG"><br></center><p>接下来将每个点的$x,y$坐标互换，即关于直线$y=x$对称，可以得到下图。第二次连边将$2$中的最近点连边。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2f40e03f2.png" alt="2.PNG"><br></center><p>然后将每个点的$x$坐标取反，即可得到下图。这时第三次连边将$3$中的最近点连边。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2f40e1a74.png" alt="3.PNG"><br></center><p>最后再次互换每个点的$x,y$坐标，得到下图。第四次连边将$4$中的最近点连边。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2f40e3226.png" alt="4.PNG"><br></center><p>由此，我们可以不改回原值就将$8$个方向连边。<br>建图后，直接跑$\mathrm{Kruskal}$或$\mathrm{Prim}$即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 4020010910LL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, cnt, fa[MAX_N+<span class="number">5</span>];</span><br><span class="line">lnt tr[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> mi[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> u, v; lnt c;&#125; E[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span><span class="keyword">int</span> id; lnt x, y;&#125; p[MAX_N+<span class="number">5</span>], q[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpe</span> <span class="params">(<span class="keyword">const</span> edge &amp;a, <span class="keyword">const</span> edge &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.c &lt; b.c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpp</span> <span class="params">(<span class="keyword">const</span> P &amp;a, <span class="keyword">const</span> P &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;</span><br><span class="line"><span class="function">lnt <span class="title">dist</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(q[u].x-q[v].x)+<span class="built_in">abs</span>(q[u].y-q[v].y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;E[++cnt] = (edge)&#123;u, v, dist(u, v)&#125;;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos, lnt x, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; pos; pos -= pos&amp;-pos)</span><br><span class="line"><span class="keyword">if</span> (tr[pos] &gt; x) tr[pos] = x, mi[pos] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;lnt mc = INF;</span><br><span class="line"><span class="keyword">for</span> (; pos &lt;= n; pos += pos&amp;-pos)</span><br><span class="line"><span class="keyword">if</span> (tr[pos] &lt; mc) mc = tr[pos], ret = mi[pos];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>], m;sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmpp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = b[i] = p[i].y-p[i].x;</span><br><span class="line">sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>), m = (<span class="keyword">int</span>)(unique(b+<span class="number">1</span>, b+n+<span class="number">1</span>)-b<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tr[i] = INF;</span><br><span class="line"><span class="built_in">memset</span>(mi, <span class="number">-1</span>, <span class="keyword">sizeof</span> mi);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n, rk, mp; i; i--) &#123;</span><br><span class="line">rk = (<span class="keyword">int</span>)(lower_bound(b+<span class="number">1</span>, b+m+<span class="number">1</span>, a[i])-b);</span><br><span class="line">mp = query(rk); <span class="keyword">if</span> (~mp) addedge(p[i].id, mp);</span><br><span class="line">modify(rk, p[i].x+p[i].y, p[i].id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">MST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(E+<span class="number">1</span>, E+cnt+<span class="number">1</span>, cmpe); lnt ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= cnt; i++) &#123;</span><br><span class="line">u = getf(E[i].u), v = getf(E[i].v);</span><br><span class="line"><span class="keyword">if</span> (u^v) fa[u] = v, ret += E[i].c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">p[i].id = i, read(p[i].x), read(p[i].y), q[i] = p[i];</span><br><span class="line">build(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) swap(p[i].x, p[i].y);</span><br><span class="line">build(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].x *= <span class="number">-1</span>;</span><br><span class="line">build(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) swap(p[i].x, p[i].y);</span><br><span class="line">build(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].y *= <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MST()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;曼哈顿最小生成树&quot;&gt;&lt;a href=&quot;#曼哈顿最小生成树&quot; class=&quot;headerlink&quot; title=&quot;曼哈顿最小生成树&quot;&gt;&lt;/a&gt;曼哈顿最小生成树&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;平面坐标系$\mathrm{xOy}$内，给定$n$个顶点$V=(x,y)$。对于顶点$u,\;v$，$u$与$v$之间的距离$d$定义为$|x_u-x_v|+|y_u-y_v|$。你的任务是求出这$n$个顶点的最小生成树。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个正整数$n$，表示定点个数。&lt;br&gt;接下来$n$行每行两个正整数$x,\;y$，描述一个顶点。 &lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;只有一行，为最小生成树的边的距离和。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树状数组" scheme="http://azrael.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="MST" scheme="http://azrael.top/tags/MST/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4695 最假女选手 &lt; SegBeats &gt;</title>
    <link href="http://azrael.top/BZOJ4695%20%E6%9C%80%E5%81%87%E5%A5%B3%E9%80%89%E6%89%8B%20SegBeats/"/>
    <id>http://azrael.top/BZOJ4695 最假女选手 SegBeats/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-03-27T12:22:40.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="最假女选手"><a href="#最假女选手" class="headerlink" title="最假女选手"></a>最假女选手</h3><p>$\mathrm{Time\;Limit:\;50\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在刚刚结束的水题嘉年华的压轴节目放水大赛中，$\mathrm{wyywyy}$如愿以偿的得到了最假女选手的奖项。但是作为主办人的$\mathrm{C_SUNSHINE}$为了证明$\mathrm{wyywyy}$确实在放水，决定出一道基础题考察$\mathrm{wyywyy}$的姿势水平。给定一个长度为$N$序列，编号从$1$到$N$。要求支持下面几种操作：</p><ol><li>给一个区间$[L,R]$加上一个数$x$ </li><li>把一个区间$[L,R]$里小于$x$的数变成$x$</li><li>把一个区间$[L,R]$里大于$x$的数变成$x$ </li><li>求区间$[L,R]$的和</li><li>求区间$[L,R]$的最大值</li><li>求区间$[L,R]$的最小值</li></ol><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数$N$表示序列长度<br>第二行$N$个整数$A_i$表示初始序列<br>第三行一个整数$M$表示操作个数<br>接下来$M$行，每行三或四个整数，第一个整数$Tp$表示操作类型，接下来$L,R,X$或$L,R$表述操作数</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个$4,5,6$类型的操作，输出一行一个整数表示答案<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2</span><br><span class="line">2 1 2 2</span><br><span class="line">4 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le Tp\le6,\;N,M\le5\times10^5,\;|A_i|\le10^8$<br>$Tp=1$时,$|x|\le1000$<br>$Tp=2$或$3$时，$|x|\le10^8$</p><p>标签：<code>SegBeats</code> <code>线段树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{Segment\;Tree\;Beats!}$<br>参见<a href="https://pan.baidu.com/s/1o7xSSQ2" target="_blank" rel="noopener">吉老师的冬令营课件</a>。</p><p>像课件里那样维护最大值、最大值个数、严格次大值、最小值、最小值个数、严格次小值、区间加标记、区间和，丧心病狂分类更新即可。注意只有区间和需要开$\mathrm{long\;long}$，这样即省空间又省常数。</p><p>好久没写过上$140$行的代码了…<br>强烈建议先对拍再交，否则容易卡住评测…</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (v&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (v&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> mx1, mx2, mxc, mi1, mi2, mic, tag;lnt s;&#125; tr[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">tr[v].s = tr[ls].s+tr[rs].s;</span><br><span class="line"><span class="keyword">if</span> (tr[ls].mx1 == tr[rs].mx1)</span><br><span class="line">tr[v].mx1 = tr[ls].mx1, </span><br><span class="line">tr[v].mxc = tr[ls].mxc+tr[rs].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx2, tr[rs].mx2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].mx1 &gt; tr[rs].mx1)</span><br><span class="line">tr[v].mx1 = tr[ls].mx1, </span><br><span class="line">tr[v].mxc = tr[ls].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx2, tr[rs].mx1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx1 = tr[rs].mx1, </span><br><span class="line">tr[v].mxc = tr[rs].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx1, tr[rs].mx2);</span><br><span class="line"><span class="keyword">if</span> (tr[ls].mi1 == tr[rs].mi1)</span><br><span class="line">tr[v].mi1 = tr[ls].mi1, </span><br><span class="line">tr[v].mic = tr[ls].mic+tr[rs].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi2, tr[rs].mi2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].mi1 &lt; tr[rs].mi1)</span><br><span class="line">tr[v].mi1 = tr[ls].mi1, </span><br><span class="line">tr[v].mic = tr[ls].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi2, tr[rs].mi1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mi1 = tr[rs].mi1, </span><br><span class="line">tr[v].mic = tr[rs].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi1, tr[rs].mi2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">tr[v].s -= <span class="number">1L</span>L*tr[v].mxc*(tr[v].mx1-x);</span><br><span class="line">tr[v].mx1 = x, tr[v].mi1 = min(x, tr[v].mi1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1^tr[v].mi1) tr[v].mi2 = min(x, tr[v].mi2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, </span><br><span class="line">tr[v].s = <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x, tr[v].mxc = tr[v].mic = t-s+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">tr[v].s += <span class="number">1L</span>L*tr[v].mic*(x-tr[v].mi1);</span><br><span class="line">tr[v].mi1 = x, tr[v].mx1 = max(x, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1^tr[v].mi1) tr[v].mx2 = max(x, tr[v].mx2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, </span><br><span class="line">tr[v].s = <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x, tr[v].mxc = tr[v].mic = t-s+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = tr[v].tag;tr[v].tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x)</span><br><span class="line">tr[ls].mx1 += x, tr[ls].mx2 += x, </span><br><span class="line">tr[ls].mi1 += x, tr[ls].mi2 += x, </span><br><span class="line">tr[ls].s += <span class="number">1L</span>L*(mid-s+<span class="number">1</span>)*x, tr[ls].tag += x, </span><br><span class="line">tr[rs].mx1 += x, tr[rs].mx2 += x, </span><br><span class="line">tr[rs].mi1 += x, tr[rs].mi2 += x, </span><br><span class="line">tr[rs].s += <span class="number">1L</span>L*(t-mid)*x, tr[rs].tag += x;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt; tr[ls].mx1 &amp;&amp; tr[v].mx1 &gt; tr[ls].mx2) updmx(ls, s, mid, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt; tr[ls].mi1 &amp;&amp; tr[v].mi1 &lt; tr[ls].mi2) updmi(ls, s, mid, tr[v].mi1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt; tr[rs].mx1 &amp;&amp; tr[v].mx1 &gt; tr[rs].mx2) updmx(rs, mid+<span class="number">1</span>, t, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt; tr[rs].mi1 &amp;&amp; tr[v].mi1 &lt; tr[rs].mi2) updmi(rs, mid+<span class="number">1</span>, t, tr[v].mi1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;</span><br><span class="line"><span class="keyword">int</span> x;read(x);</span><br><span class="line">tr[v].mx1 = tr[v].mi1 = x, tr[v].mxc = tr[v].mic = <span class="number">1</span>;</span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, tr[v].s = x;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">build(ls, s, mid), build(rs, mid+<span class="number">1</span>, t), update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">tr[v].mx1 += x, tr[v].mx2 += x;</span><br><span class="line">tr[v].mi1 += x, tr[v].mi2 += x;</span><br><span class="line">tr[v].s += <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x;</span><br><span class="line">tr[v].tag += x;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) modify(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) modify(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt;= x) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r &amp;&amp; x &lt; tr[v].mi2)</span><br><span class="line">&#123;updmi(v, s, t, x);<span class="keyword">return</span>;&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) optmx(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) optmx(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt;= x) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r &amp;&amp; x &gt; tr[v].mx2)</span><br><span class="line">&#123;updmx(v, s, t, x);<span class="keyword">return</span>;&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) optmi(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) optmi(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].s;</span><br><span class="line">downtag(v, s, t);lnt ret = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret += query(ls, s, mid, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret += query(rs, mid+<span class="number">1</span>, t, l, r);</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].mx1;</span><br><span class="line">downtag(v, s, t);<span class="keyword">int</span> ret = -INF;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret = max(ret, getmx(ls, s, mid, l, r));</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret = max(ret, getmx(rs, mid+<span class="number">1</span>, t, l, r));</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].mi1;</span><br><span class="line">downtag(v, s, t);<span class="keyword">int</span> ret = INF;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret = min(ret, getmi(ls, s, mid, l, r));</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret = min(ret, getmi(rs, mid+<span class="number">1</span>, t, l, r));</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, T;read(n), build(<span class="number">1</span>, <span class="number">1</span>, n), read(T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, l, r, x;read(opt);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) read(l), read(r), read(x), modify(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">2</span>) read(l), read(r), read(x), optmx(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">3</span>) read(l), read(r), read(x), optmi(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">4</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">5</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmx(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">6</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmi(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;最假女选手&quot;&gt;&lt;a href=&quot;#最假女选手&quot; class=&quot;headerlink&quot; title=&quot;最假女选手&quot;&gt;&lt;/a&gt;最假女选手&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;50\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在刚刚结束的水题嘉年华的压轴节目放水大赛中，$\mathrm{wyywyy}$如愿以偿的得到了最假女选手的奖项。但是作为主办人的$\mathrm{C_SUNSHINE}$为了证明$\mathrm{wyywyy}$确实在放水，决定出一道基础题考察$\mathrm{wyywyy}$的姿势水平。给定一个长度为$N$序列，编号从$1$到$N$。要求支持下面几种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给一个区间$[L,R]$加上一个数$x$ &lt;/li&gt;
&lt;li&gt;把一个区间$[L,R]$里小于$x$的数变成$x$&lt;/li&gt;
&lt;li&gt;把一个区间$[L,R]$里大于$x$的数变成$x$ &lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的和&lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的最大值&lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的最小值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个整数$N$表示序列长度&lt;br&gt;第二行$N$个整数$A_i$表示初始序列&lt;br&gt;第三行一个整数$M$表示操作个数&lt;br&gt;接下来$M$行，每行三或四个整数，第一个整数$Tp$表示操作类型，接下来$L,R,X$或$L,R$表述操作数&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每个$4,5,6$类型的操作，输出一行一个整数表示答案&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1071【SCOI2007】组队 &lt;双指针&gt;</title>
    <link href="http://azrael.top/BZOJ1071%E3%80%90SCOI2007%E3%80%91%E7%BB%84%E9%98%9F%20%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://azrael.top/BZOJ1071【SCOI2007】组队 双指针/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-03-28T12:32:31.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2007】组队"><a href="#【SCOI2007】组队" class="headerlink" title="【SCOI2007】组队"></a>【SCOI2007】组队</h3><p>$\mathrm{Time\;Limit:\;3\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$NBA$每年都有球员选秀环节。通常用速度和身高两项数据来衡量一个篮球运动员的基本素质。假如一支球队里速度最慢的球员速度为$min_V$，身高最矮的球员高度为$min_H$，那么这支球队的所有队员都应该满足：$A\times(height-min_H)+B\times(speed-min_V)\le C$。其中$A$和$B,C$为给定的经验值。这个式子很容易理解，如果一个球队的球员速度和身高差距太大，会造成配合的不协调。 请问作为球队管理层的你，在$N$名选秀球员中，最多能有多少名符合条件的候选球员。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行四个数$N,A,B,C$。<br>下接$N$行每行两个数描述一个球员的$height$和$speed$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>最多候选球员数目。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 1 2 10</span><br><span class="line">5 1</span><br><span class="line">3 2</span><br><span class="line">2 3</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$N\le5000$，$height$和$speed$不大于$10000$。$A,B,C$在长整型以内。<br>$2016.3.26$数据加强，$\mathrm{Nano_ape}$程序未重测。</p><p>标签：<code>双指针</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>挺神的题，两个序列上双指针的操作挺奇葩。</p><p>对于每个队员，令$s=v+h$，将队员数组$A$同时复制到$B$中，分别排序。$A$按照$h$从小到大排序，$B$按照$s$从小到大排序。<br>首先按任意顺序枚举$v$的最小值大小，不妨直接再$A$中枚举。这时定义左指针和右指针$l$和$r$，只是与普通双指针不同的是，$l$指向的是$A$中的元素，$r$指向的是$B$中的元素，可以理解为$A$中的右指针是不动的，$B$中的左指针是不动的。这样精妙设计是考虑到$A$中递增的$h$值如果不满足要求，即小于枚举到的$H$值，小于的部分一定是从前面开始的；同样地，$B$中递增的$s$值如果不满足要求，即大于$A\times min_H+B\times min_V+C$，大于的部分一定是从后面开始的。这样对每个数组跑“单指针”即可得到可行最大子段，更新答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 5000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;lnt A, B, C, miv, mxv;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>lnt h, v, s;&#125; p[MAX_N+<span class="number">5</span>], q[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmph</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.h &lt;= b.h;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmps</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.s &lt;= b.s;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(A), read(B), read(C);<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(p[i].h), read(p[i].v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].s = A*p[i].h+B*p[i].v, q[i] = p[i];</span><br><span class="line">sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmph), sort(q+<span class="number">1</span>, q+n+<span class="number">1</span>, cmps);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r, cnt; i &lt;= n; i++) &#123;</span><br><span class="line">l = r = cnt = <span class="number">0</span>, miv = p[i].v, mxv = miv+C/B;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++, ans = max(ans, cnt)) &#123;</span><br><span class="line"><span class="keyword">while</span> (r &lt; n &amp;&amp; q[r+<span class="number">1</span>].s &lt;= A*p[j].h+B*p[i].v+C)</span><br><span class="line">r++, cnt += q[r].v &gt;= miv &amp;&amp; q[r].v &lt;= mxv;</span><br><span class="line"><span class="keyword">while</span> (l &lt; n &amp;&amp; p[l+<span class="number">1</span>].h &lt; p[j].h)</span><br><span class="line">l++, cnt -= p[l].v &gt;= miv &amp;&amp; p[l].v &lt;= mxv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2007】组队&quot;&gt;&lt;a href=&quot;#【SCOI2007】组队&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2007】组队&quot;&gt;&lt;/a&gt;【SCOI2007】组队&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;3\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$NBA$每年都有球员选秀环节。通常用速度和身高两项数据来衡量一个篮球运动员的基本素质。假如一支球队里速度最慢的球员速度为$min_V$，身高最矮的球员高度为$min_H$，那么这支球队的所有队员都应该满足：$A\times(height-min_H)+B\times(speed-min_V)\le C$。其中$A$和$B,C$为给定的经验值。这个式子很容易理解，如果一个球队的球员速度和身高差距太大，会造成配合的不协调。 请问作为球队管理层的你，在$N$名选秀球员中，最多能有多少名符合条件的候选球员。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行四个数$N,A,B,C$。&lt;br&gt;下接$N$行每行两个数描述一个球员的$height$和$speed$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;最多候选球员数目。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="双指针" scheme="http://azrael.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2820 YY的GCD &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ2820%20YY%E7%9A%84GCD%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ2820 YY的GCD 莫比乌斯反演/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-04-02T03:17:28.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="YY的GCD"><a href="#YY的GCD" class="headerlink" title="YY的GCD"></a>YY的GCD</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;512\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>神犇$\mathrm{YY}$虐完数论后给$\mathrm{傻叉kAc}$出了一题：<br>给定$N,M$，求$1\le x\le N,\;1\le y\le M$且$\gcd(x, y)$为质数的$(x, y)$有多少对<br>$\mathrm{kAc}$这种$\mathrm{傻叉}$必然不会了，于是向你来请教。<br>多组输入。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数$T$表述数据组数。<br>接下来$T$行，每行两个正整数，表示$N,M$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>$T$行，每行一个整数表示第$i$组数据的结果。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">100 100</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line">2791</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$T=10^4$<br>$N,M\le10^7$</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>套路反演+积性函数预处理。</p><p>先套路推一波反演式：<br>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{p}\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=p]\\<br>&amp;=\sum_{p}\sum_{i=1}^{\lfloor n/p\rfloor}\sum_{j=1}^{\lfloor m/p\rfloor}\sum_{d|i,j}\mu(d)\\<br>&amp;=\sum_{p}\sum_{d=1}^{\lfloor\frac{\min(n,m)}{p}\rfloor}\mu(d)\times\lfloor\frac{n}{d\cdot p}\rfloor\times\lfloor\frac{m}{d\cdot p}\rfloor\\<br>&amp;=\sum_{T=1}^{n}\sum_{p|T}\mu(\frac{T}{p})\times\lfloor\frac{n}{T}\rfloor\times\lfloor\frac{m}{T}\rfloor\\<br>&amp;=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{p|T}\mu(\frac{T}{p})\\<br>\\<br>Let\;f(x)&amp;=\sum_{p|T}\mu(\frac{T}{p}),\\<br>then\;Ans&amp;=\sum_{T=1}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor f(T)<br>\end{aligned}<br>$$<br>那么我们需要用线筛预处理出所有$f$值。<br>对于当前预处理到的数$x$和枚举到的质数$p$，有<br>$$<br>f(x)=\sum_{d|x,\;d\in\;pri}\mu(\frac{x}{d})\\<br>f(x\cdot p)=\sum_{d|x\cdot p,\;d\in\;pri}\mu(\frac{x\cdot p}{d})\\<br>$$<br>下面的式子的一部分可以化为上面的式子，剩余部分直接加上去。<br>分类讨论：</p><ul><li>若$p|x$，则下式中$d\ne p$时，$\frac{x\cdot p}{d}$的分解式中$p$的指数一定大于$1$，于是只有$d=p$时会对答案产生$\mu(\frac{x\cdot p}{p})=\mu(x)$的贡献，所以$f(x\cdot p)=\mu(x)$。</li><li>若$p\nmid x$，则下式中对于任意$d|x$，其贡献都为上式中对应项的贡献乘$\mu(p)=-1$，即$d|x$的贡献为$f(x)$。当$d\nmid x$时，只存在$d=p$，此时贡献为$\mu(x)$。因此$f(x\cdot p)=\mu(x)-f(x)$。</li></ul><p>由此，可以线筛预处理出所有$f$值，然后根号分块计算答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>], fac[MAX_N+<span class="number">5</span>], cnt;<span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PriS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((x = i*pri[j]) &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[x] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[x] = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;read(n), PriS();lnt ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (lnt i = <span class="number">1</span>, l, r; i &lt; <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line">cnt = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">sqrt</span>(i); j++) <span class="keyword">if</span> (i%j == <span class="number">0</span>) fac[cnt++] = j;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span>; l &lt; i; l = r+<span class="number">1</span>) &#123;</span><br><span class="line">lnt val = n/(i*(i+l)); <span class="keyword">if</span> (!val) <span class="keyword">break</span>;r = min(n/val/i-i, i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (lnt k = <span class="number">0</span>, j; k &lt; cnt; k++) &#123;</span><br><span class="line">j = fac[k], ans += mu[j]*(r/j-(l<span class="number">-1</span>)/j)*val;lnt t = i/j;</span><br><span class="line"><span class="keyword">if</span> (i%t == <span class="number">0</span> &amp;&amp; (j^t)) ans += mu[t]*(r/t-(l<span class="number">-1</span>)/t)*val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;YY的GCD&quot;&gt;&lt;a href=&quot;#YY的GCD&quot; class=&quot;headerlink&quot; title=&quot;YY的GCD&quot;&gt;&lt;/a&gt;YY的GCD&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;512\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;神犇$\mathrm{YY}$虐完数论后给$\mathrm{傻叉kAc}$出了一题：&lt;br&gt;给定$N,M$，求$1\le x\le N,\;1\le y\le M$且$\gcd(x, y)$为质数的$(x, y)$有多少对&lt;br&gt;$\mathrm{kAc}$这种$\mathrm{傻叉}$必然不会了，于是向你来请教。&lt;br&gt;多组输入。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个整数$T$表述数据组数。&lt;br&gt;接下来$T$行，每行两个正整数，表示$N,M$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;$T$行，每行一个整数表示第$i$组数据的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
</feed>
