<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NIRVANA</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://azrael.top/"/>
  <updated>2018-04-26T14:49:47.513Z</updated>
  <id>http://azrael.top/</id>
  
  <author>
    <name>Azrael_Death</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ3438 小M的作物 &lt;最小割&gt;</title>
    <link href="http://azrael.top/BZOJ3438%20%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9%20%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <id>http://azrael.top/BZOJ3438 小M的作物 最小割/</id>
    <published>2018-04-25T16:00:00.000Z</published>
    <updated>2018-04-26T14:49:47.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="小M的作物"><a href="#小M的作物" class="headerlink" title="小M的作物"></a>小M的作物</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{小M}$在$\mathrm{MC}$里开辟了两块巨大的耕地$A$和$B$（你可以认为容量是无穷）。<br>现在，$\mathrm{小M}$有种$n$作物的种子，每种作物的种子有$1$个（就是可以种一棵作物）（用$1\sim n$编号），第$i$种作物种植在$A$中种植可以获得$a_i$的收益，在$B$中种植可以获得$b_i$的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益。<br>$\mathrm{小M}$找到了规则中共有$m$种作物组合，第$i$个组合中的作物共同种在$A$中可以获得$c_{i,1}$的额外收益，共同总在$B$中可以获得$c_{i,2}$的额外收益。<br>$\mathrm{小M}$很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包括一个整数$n$<br>第二行包括$n$个整数，表示$a_i$<br>第三行包括$n$个整数，表示$b_i$<br>第四行包括一个整数$m$<br>接下来$m$行，第$i$行依次输入：</p><ul><li>一个整数$k_i$，表示第$i$个作物组合中共有$k_i$种作物</li><li>两个整数$c_{i,1},c_{i,2}$，表示两种收益分别是多少</li><li>$k_i$个整数，表示该组合中的作物编号</li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一行，包括一个整数，表示最大收益<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1</span><br><span class="line">2 3 2 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>$A$耕地种$1,2$，$B$耕地种$3$，收益$4+2+3+2=11$</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le k&lt;n\le1000$, $0&lt;m\le1000$，保证所有数据及结果不超过$2\times10^9$</p><p>标签：<code>最小割</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>文理分科加强版，建模稍有变化。</p><p>首先容易想到将每个作物作为结点，对于作物$i$，连接$S\to i$容量$a_i$，连接$i\to T$容量$b_i$。割掉一条边表示不选对应的那片田，就可以以最小割的形式处理只考虑选$A$和选$B$收益，不考虑集团收益的问题。</p><p>对于每个组合，由于作物个数很多，不能像文理分科一样把失去的收益拆到$S\to i$和$i\to T$上。这里可以建立辅助结点，即给每个组合建立结点。由于存在两种贡献，需要拆成两个节点$p$和$q$，连接$S\to p$容量$c_1$，$q\to T$容量$c_2$。以$p$为例，$S\to p$需要被割去当且仅当此组合中任意作物选择$A$而非$B$，即此组合中存在作物$t$，$t\to T$并未被割掉。因此需要串联，即从$p$连边到此组合中的所有作物，容量$\infty$（从中间割断是没有意义的）。对应地，$q$的连法相同。</p><p>建模：</p><ul><li>对于每个作物$i\in[1,n]$，连接$S\to i$容量$a_i$，$i\to T$容量$b_i$</li><li>对于每个组合$i$，建立结点$p_i,q_i$，连接$S\to p_i$容量$c_1$，$q_i\to T$容量$c_2$</li><li>对于每个组合$i$，设其内作物为$x_1\sim x_k$，那么对每个作物$x_j$，连接$p_i\to x_j$容量$\infty$，$x_j\to q_i$容量$\infty$</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, sum, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = <span class="number">4000</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; cpy(); <span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec(); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) read(x), addedge(s, i, x), sum += x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) read(x), addedge(i, t, x), sum += x;</span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c1, c2, k; i &lt;= m; i++) &#123;</span><br><span class="line">read(k), read(c1), read(c2), sum += c1+c2;</span><br><span class="line">addedge(s, n+i*<span class="number">2</span><span class="number">-1</span>, c1), addedge(n+i*<span class="number">2</span>, t, c2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; k; j++)</span><br><span class="line">read(x), addedge(n+i*<span class="number">2</span><span class="number">-1</span>, x, INF), addedge(x, n+i*<span class="number">2</span>, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum-Dinic()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;小M的作物&quot;&gt;&lt;a href=&quot;#小M的作物&quot; class=&quot;headerlink&quot; title=&quot;小M的作物&quot;&gt;&lt;/a&gt;小M的作物&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{小M}$在$\mathrm{MC}$里开辟了两块巨大的耕地$A$和$B$（你可以认为容量是无穷）。&lt;br&gt;现在，$\mathrm{小M}$有种$n$作物的种子，每种作物的种子有$1$个（就是可以种一棵作物）（用$1\sim n$编号），第$i$种作物种植在$A$中种植可以获得$a_i$的收益，在$B$中种植可以获得$b_i$的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益。&lt;br&gt;$\mathrm{小M}$找到了规则中共有$m$种作物组合，第$i$个组合中的作物共同种在$A$中可以获得$c_{i,1}$的额外收益，共同总在$B$中可以获得$c_{i,2}$的额外收益。&lt;br&gt;$\mathrm{小M}$很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包括一个整数$n$&lt;br&gt;第二行包括$n$个整数，表示$a_i$&lt;br&gt;第三行包括$n$个整数，表示$b_i$&lt;br&gt;第四行包括一个整数$m$&lt;br&gt;接下来$m$行，第$i$行依次输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个整数$k_i$，表示第$i$个作物组合中共有$k_i$种作物&lt;/li&gt;
&lt;li&gt;两个整数$c_{i,1},c_{i,2}$，表示两种收益分别是多少&lt;/li&gt;
&lt;li&gt;$k_i$个整数，表示该组合中的作物编号&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;只有一行，包括一个整数，表示最大收益&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最小割" scheme="http://azrael.top/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3626【LNOI2014】LCA &lt;离线+树链剖分&gt;</title>
    <link href="http://azrael.top/BZOJ3626%E3%80%90LNOI2014%E3%80%91LCA%20%E7%A6%BB%E7%BA%BF+%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>http://azrael.top/BZOJ3626【LNOI2014】LCA 离线+树链剖分/</id>
    <published>2018-04-25T16:00:00.000Z</published>
    <updated>2018-04-26T15:09:01.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【LNOI2014】LCA"><a href="#【LNOI2014】LCA" class="headerlink" title="【LNOI2014】LCA"></a>【LNOI2014】LCA</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给出一个$n$个节点的有根树（编号为$0$到$n-1$，根节点为$0$）。一个点的深度定义为$这个节点到根的距离+1$。设$dep_i$表示点$i$的深度，$lca_{i,j}$表示$i$与$j$的最近公共祖先。<br>有$q$次询问，每次询问给出$l,r,z$，求$\sum_{l&lt;=i&lt;=r}dep_{lca_{i,z}}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行$2$个整数$n,q$。<br>接下来$n-1$行，分别表示点$1$到点$n-1$的父节点编号。<br>接下来$q$行，每行$3$个整数$l,r,z$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$q$行，每行表示一个询问的答案。每个答案对$201314$取模输出<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 4 3</span><br><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>共$5$组数据，$n$与$q$的规模分别为$10000$,$20000$,$30000$,$40000$,$50000$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>数据已加强$\;\mathrm{By\;}$<code>saffah</code></p><p>标签：<code>树链剖分</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>傻逼树链剖分，练手居然还$\mathrm{WA}$了一发…</p><p>首先有一个这样的暴力：对于每个询问，将$z$到根的路径打标记，枚举$l\sim r$，每次累加当前节点最近的标记节点的深度。<br>然后发现可以反转一下：对于每个询问，枚举$l\sim r$，每次将当前结点到根路径上的所有结点权值$+1$，统计$z$到根路径上的总权值即可。（权值$+1$相当于深度累加）。<br>这道题没有强制在线，于是可以把所有的询问都离线下来，拆成两个前缀询问$[1,l-1]$和$[1,r]$分别计算。如果将所有前缀询问按右端点位置排序，不难发现可以依次操作，每次将一个新的结点到根路径上的所有结点权值$+1$，操作完统计右端点在此结点上的所有前缀询问的答案。<br>注意模完两个前缀答案相减后可能出现负数，需要先加上$\mathrm{MOD}$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 201314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> t, p, id; <span class="keyword">bool</span> f;&#125; opt[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, ind, ans[MAX_N+<span class="number">5</span>], tr[MAX_N&lt;&lt;<span class="number">2</span>], tag[MAX_N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dep[MAX_N+<span class="number">5</span>], fa[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>], son[MAX_N+<span class="number">5</span>], top[MAX_N+<span class="number">5</span>], dfn[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;x, <span class="keyword">const</span> node &amp;y)</span> </span>&#123;<span class="keyword">return</span> x.t &lt;= y.t;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[u].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i]; <span class="keyword">if</span> (v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v] = dep[u]+<span class="number">1</span>, fa[v] = u, DFS(v), sz[u] += sz[v];</span><br><span class="line"><span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">top[u] = tp, dfn[u] = ++ind; <span class="keyword">if</span> (son[u]) DFS(son[u], tp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i])^fa[u]) &amp;&amp; (v^son[u])) DFS(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;tr[v] = tr[v&lt;&lt;<span class="number">1</span>]+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tag[v]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> x = tag[v]; tag[v] = <span class="number">0</span>;</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>] += x*(mid-s+<span class="number">1</span>)%MOD) %= MOD;</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += x*(t-mid)%MOD) %= MOD;</span><br><span class="line">(tag[v&lt;&lt;<span class="number">1</span>] += x) %= MOD, (tag[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += x) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">(tr[v] += x*(t-s+<span class="number">1</span>)%MOD) %= MOD;</span><br><span class="line">(tag[v] += x) %= MOD; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) modify(v&lt;&lt;<span class="number">1</span>, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) modify(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> (tr[v]+MOD)%MOD;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>; downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) (ret += query(v&lt;&lt;<span class="number">1</span>, s, mid, l, r)) %= MOD;</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) (ret += query(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r)) %= MOD;</span><br><span class="line"><span class="keyword">return</span> (ret%MOD+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; u; u = fa[top[u]])</span><br><span class="line">modify(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[u]], dfn[u], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; u; u = fa[top[u]])</span><br><span class="line">(ret += query(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[u]], dfn[u])) %= MOD;</span><br><span class="line"><span class="keyword">return</span> (ret += MOD) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), G[x+<span class="number">1</span>].push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r, p; i &lt;= m; i++)</span><br><span class="line">read(l), read(r), read(p), </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].p = opt[i*<span class="number">2</span>].p = p+<span class="number">1</span>, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].id = opt[i*<span class="number">2</span>].id = i, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].t = l, opt[i*<span class="number">2</span>].t = r+<span class="number">1</span>, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].f = <span class="literal">false</span>, opt[i*<span class="number">2</span>].f = <span class="literal">true</span>;</span><br><span class="line">sort(opt+<span class="number">1</span>, opt+m*<span class="number">2</span>+<span class="number">1</span>, cmp), DFS(<span class="number">1</span>), DFS(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m*<span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; opt[i].t) change(++j);</span><br><span class="line"><span class="keyword">if</span> (opt[i].f) (ans[opt[i].id] += getsum(opt[i].p)) %= MOD;</span><br><span class="line"><span class="keyword">else</span> (ans[opt[i].id] += MOD-getsum(opt[i].p)) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans[i]%MOD+MOD)%MOD);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【LNOI2014】LCA&quot;&gt;&lt;a href=&quot;#【LNOI2014】LCA&quot; class=&quot;headerlink&quot; title=&quot;【LNOI2014】LCA&quot;&gt;&lt;/a&gt;【LNOI2014】LCA&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给出一个$n$个节点的有根树（编号为$0$到$n-1$，根节点为$0$）。一个点的深度定义为$这个节点到根的距离+1$。设$dep_i$表示点$i$的深度，$lca_{i,j}$表示$i$与$j$的最近公共祖先。&lt;br&gt;有$q$次询问，每次询问给出$l,r,z$，求$\sum_{l&amp;lt;=i&amp;lt;=r}dep_{lca_{i,z}}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行$2$个整数$n,q$。&lt;br&gt;接下来$n-1$行，分别表示点$1$到点$n-1$的父节点编号。&lt;br&gt;接下来$q$行，每行$3$个整数$l,r,z$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$q$行，每行表示一个询问的答案。每个答案对$201314$取模输出&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树链剖分" scheme="http://azrael.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2440【中山市选2011】完全平方数 &lt;二分+莫比乌斯容斥&gt;</title>
    <link href="http://azrael.top/BZOJ2440%E3%80%90%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892011%E3%80%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20%E4%BA%8C%E5%88%86+%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%AE%B9%E6%96%A5/"/>
    <id>http://azrael.top/BZOJ2440【中山市选2011】完全平方数 二分+莫比乌斯容斥/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-25T04:52:39.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【中山市选2011】完全平方数"><a href="#【中山市选2011】完全平方数" class="headerlink" title="【中山市选2011】完全平方数"></a>【中山市选2011】完全平方数</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小$\mathrm{X}$自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。<br>这天是小$\mathrm{X}$的生日，小$\mathrm{W}$想送一个数给他作为生日礼物。当然他不能送一个小$\mathrm{X}$讨厌的数。他列出了所有小$\mathrm{X}$不讨厌的数，然后选取了第$K$个数送给了小$\mathrm{X}$。小$\mathrm{X}$很开心地收下了。<br>然而现在小$\mathrm{W}$却记不起送给小$\mathrm{X}$的是哪个数了。你能帮他一下吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>包含多组测试数据。文件第一行有一个整数$T$，表示测试数据的组数。<br>第$2$至第$T+1$行每行有一个整数$K_i$，描述一组数据，含义如题目中所描述。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>含$T$行，分别对每组数据作出回答。第$i$行输出相应的第$K_i$个不是完全平方数的正整数倍的数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">13</span><br><span class="line">100</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">19</span><br><span class="line">163</span><br><span class="line">2030745</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据有$1\le K_i\le10^9,\;T\le50$</p><p>标签：<code>二分答案</code> <code>莫比乌斯容斥</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{QAQ}$没做起水题…</p><p>似乎答案不超过$2\times K$？不会证。</p><p>二分答案，对于当前尝试的答案$n$，统计$n$以下有多少个符合条件的数。<br>$符合条件的数的个数=n-完全平方数的倍数的个数$<br>容易发现为了避免算重复，可以约数容斥来算。另外，如果完全平方数的底数有平方因子，一定不会产生贡献。<br>设所有质数的集合为$S_1$，所有由两个不同质数相乘而得数的集合为$S_2$，…，由$q$个不同质数相乘而得的数的集合为$S_q$，那么符合条件的数的个数为：<br>$$<br>cnt=\sum_{i_2\in S_1}\lfloor\frac{n}{i^2}\rfloor-\sum_{i_2\in S_2}\lfloor\frac{n}{i_2^2}\rfloor+\sum_{i_3\in S_3}\lfloor\frac{n}{i_3^2}\rfloor-\cdots\\<br>$$<br>发现上面的式子可以用莫比乌斯函数简化，即<br>$$<br>cnt=\sum_{i=1}^{\sqrt{n}}\mu(i)\cdot\lfloor\frac{n}{i^2}\rfloor<br>$$<br>这样每次用$O(\sqrt{n})$时间$check$，总复杂度为$O(\sqrt{K}\log{K})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l+((r-l)&gt;&gt;1))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n); i; i--)</span><br><span class="line">rk += mu[i]*(n/i/i);</span><br><span class="line"><span class="keyword">return</span> rk &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">2</span>*k, ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid, k)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans = mid, r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, k;read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) read(k), sol(k);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【中山市选2011】完全平方数&quot;&gt;&lt;a href=&quot;#【中山市选2011】完全平方数&quot; class=&quot;headerlink&quot; title=&quot;【中山市选2011】完全平方数&quot;&gt;&lt;/a&gt;【中山市选2011】完全平方数&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;小$\mathrm{X}$自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。&lt;br&gt;这天是小$\mathrm{X}$的生日，小$\mathrm{W}$想送一个数给他作为生日礼物。当然他不能送一个小$\mathrm{X}$讨厌的数。他列出了所有小$\mathrm{X}$不讨厌的数，然后选取了第$K$个数送给了小$\mathrm{X}$。小$\mathrm{X}$很开心地收下了。&lt;br&gt;然而现在小$\mathrm{W}$却记不起送给小$\mathrm{X}$的是哪个数了。你能帮他一下吗？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;包含多组测试数据。文件第一行有一个整数$T$，表示测试数据的组数。&lt;br&gt;第$2$至第$T+1$行每行有一个整数$K_i$，描述一组数据，含义如题目中所描述。 &lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;含$T$行，分别对每组数据作出回答。第$i$行输出相应的第$K_i$个不是完全平方数的正整数倍的数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="容斥" scheme="http://azrael.top/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1061【NOI2008】志愿者招募 &lt;线性规划转费用流&gt;</title>
    <link href="http://azrael.top/BZOJ1061%E3%80%90NOI2008%E3%80%91%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%BD%AC%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ1061【NOI2008】志愿者招募 线性规划转费用流/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-26T12:40:25.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【NOI2008】志愿者招募"><a href="#【NOI2008】志愿者招募" class="headerlink" title="【NOI2008】志愿者招募"></a>【NOI2008】志愿者招募</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。<br>经过估算，这个项目需要$N$天才能完成，其中第$i$天至少需要$A_i$个人。布布通过了解得知，一共有$M$类志愿者可以招募。其中第$i$类可以从第$S_i$天工作到第$T_i$天，招募费用是每人$C_i$元。<br>新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数$N,M$，表示完成项目的天数和可以招募的志愿者的种类。<br>接下来的一行中包含$N$个非负整数，表示每天至少需要的志愿者人数。<br>接下来的$M$行中每行包含三个整数$S_i,T_i,C_i$，含义如上文所述。<br>为了方便起见，我们可以认为每类志愿者的数量都是无限多的。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个整数，表示你所设计的最优方案的总费用。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 3 4</span><br><span class="line">1 2 2</span><br><span class="line">2 3 5</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N\le1000$，$1\le M\le10000$，题目中其他所涉及的数据均不超过$2^{31}-1$。</p><p>标签：<code>线性规划</code> <code>费用流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>经典线性规划转网络流。</p><p>由题意可知，共会有$N$个限制条件，还有一个需要最小化的表达式。以样例作例子，第$i$种招募$x_i$人，则有<br>$$<br>\begin{aligned}<br>x_1&amp;\ge2\\<br>x_2+x_3&amp;\ge3\\<br>x_2+x_3&amp;\ge4\\<br>we\;need\;to\;minimize\;&amp;2x_1+5x_2+2x_3\\<br>\end{aligned}<br>$$<br>接着设三个辅助变量$y_1,y_2,y_3\;(y_1,y_2,y_3\ge0)$，使得<br>$$<br>\begin{aligned}<br>x_1-y_1&amp;=2\\<br>x_2+x_3-y_2&amp;=3\\<br>x_2+x_3-y_3&amp;=4\\<br>\end{aligned}<br>$$<br>在最前面和最后面加入两个$0=0$，差分一下，得到<br>$$<br>\begin{aligned}<br>x_1-y_1-2&amp;=0\\<br>x_2+x_3-y_2-x_1+y_1-1&amp;=0\\<br>y_2-y_3-1&amp;=0\\<br>-x_2-x_3+y_3+4&amp;=0\\<br>\end{aligned}<br>$$<br>发现每个变量只出现两次，并且正、负各一次。这个性质其实一定成立。因为每种志愿者只在一个区间内出现，即每个变量只会在连续的式子中出现，这样差分后就会只剩一次正和一次负。辅助变量也有这个性质是显然的。<br>如果将每个式子看成一个结点，等式可以看作这个点的流量平衡方程。将正看成出流，负看成入流，即可构图。例如，对于$x_2$，其在第二个式子中出现正，在第四个式子中出现负，可以想成是从二号结点流出的$x_2$流量进入四号结点。对于辅助变量也是一样。而对于每个式子中的常数项，可以看成从源点流出或流入汇点，即若移到左边后为负，则为从源点流出这么多流量；若为正，则为向汇点流这么多流量。<br>这样一来，根据费用流一定跑出最大流（废话），跑出的流一定满足流量平衡方程（废话$\times$2），最后跑出的方案一定能满足所有限制。如果加上边权（即所要取最小值的式子的系数），可以跑最小费用最大流解出最小值。</p><p>建模：</p><ul><li>对于$\forall i\in[1,n+1]$，<ul><li>若$A_i\ge A_{i-1}$，连接$S\to i$，容量$A_i-A_{i-1}$，单位费用$0$</li><li>若$A_i&lt;A_{i-1}$，连接$i\to T$，容量$A_{i-1}-A_i$，单位费用$0$</li></ul></li><li>对于一种志愿者$l,r,w$，连接$l\to r+1$，容量$\infty$，单位费用$w$</li><li>辅助变量：对于$\forall i\in[2,n+1]$，连接$i\to i-1$，容量$\infty$，单位费用$0$</li></ul><p>跑最小费用最大流即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>], mxf, mic;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, w, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="keyword">int</span> a[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n+<span class="number">2</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;insert(u, v, c, w), insert(v, u, <span class="number">0</span>, -w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; <span class="keyword">bool</span> inq[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> d[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq), <span class="built_in">memset</span>(d, INF, <span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>, que.push(s), inq[s] = <span class="literal">true</span>, <span class="built_in">memset</span>(cr, <span class="number">-1</span>, <span class="keyword">sizeof</span> cr);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop(), inq[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c, w = E[i].w;</span><br><span class="line"><span class="keyword">if</span> (c &amp;&amp; d[u]+w &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u]+w, cr[v] = i;</span><br><span class="line"><span class="keyword">if</span> (!inq[v]) que.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == INF) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">int</span> flow = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) flow = min(flow, E[i].c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) E[i].c -= flow, E[i^<span class="number">1</span>].c += flow;</span><br><span class="line">mxf += flow, mic += d[t]*flow;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= a[i<span class="number">-1</span>]) addedge(s, i, a[i]-a[i<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> addedge(i, t, a[i<span class="number">-1</span>]-a[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; i++)</span><br><span class="line">read(u), read(v), read(w), addedge(u, v+<span class="number">1</span>, INF, w);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n+<span class="number">1</span>; i++) addedge(i, i<span class="number">-1</span>, INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (SPFA()) ;<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mic), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【NOI2008】志愿者招募&quot;&gt;&lt;a href=&quot;#【NOI2008】志愿者招募&quot; class=&quot;headerlink&quot; title=&quot;【NOI2008】志愿者招募&quot;&gt;&lt;/a&gt;【NOI2008】志愿者招募&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。&lt;br&gt;经过估算，这个项目需要$N$天才能完成，其中第$i$天至少需要$A_i$个人。布布通过了解得知，一共有$M$类志愿者可以招募。其中第$i$类可以从第$S_i$天工作到第$T_i$天，招募费用是每人$C_i$元。&lt;br&gt;新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个整数$N,M$，表示完成项目的天数和可以招募的志愿者的种类。&lt;br&gt;接下来的一行中包含$N$个非负整数，表示每天至少需要的志愿者人数。&lt;br&gt;接下来的$M$行中每行包含三个整数$S_i,T_i,C_i$，含义如上文所述。&lt;br&gt;为了方便起见，我们可以认为每类志愿者的数量都是无限多的。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅包含一个整数，表示你所设计的最优方案的总费用。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="线性规划" scheme="http://azrael.top/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
      <category term="费用流" scheme="http://azrael.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="NOI" scheme="http://azrael.top/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4293【PA2015】Siano &lt;线段树&gt;</title>
    <link href="http://azrael.top/BZOJ4293%E3%80%90PA2015%E3%80%91Siano%20%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ4293【PA2015】Siano 线段树/</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2018-04-24T09:10:30.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【PA2015】Siano"><a href="#【PA2015】Siano" class="headerlink" title="【PA2015】Siano"></a>【PA2015】Siano</h3><p>$\mathrm{Time\;Limit:\;30\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>农夫$\mathrm{Byteasar}$买了一片$n$亩的土地，他要在这上面种草。<br>他在每一亩土地上都种植了一种独一无二的草，其中，第$i$亩土地的草每天会长高$a_i$厘米。<br>$\mathrm{Byteasar}$一共会进行$m$次收割，其中第$i$次收割在第$d_i$天，并把所有高度大于等于$b_i$的部分全部割去。<br>$\mathrm{Byteasar}$想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个正整数$n,m$，分别表示亩数和收割次数。<br>第二行包含$n$个正整数，其中第$i$个数为$a_i$，依次表示每亩种植的草的生长能力。<br>接下来$m$行，每行包含两个正整数$d_i,b_i$，依次描述每次收割。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$m$行，每行一个整数，依次回答每次收割能得到的草的高度总和。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 4 3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 0</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br><span class="line">18</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>第$1$天，草的高度分别为$1,2,4,3$，收割后变为$1,1,1,1$。<br>第$2$天，草的高度分别为$2,3,5,4$，收割后变为$2,2,2,2$。<br>第$3$天，草的高度分别为$3,4,6,5$，收割后变为$0,0,0,0$。<br>第$4$天，草的高度分别为$1,2,4,3$，收割后变为$1,2,4,3$。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le n,m\le5\times10^5$, $1\le a_i\le10^6$, $1\le d_i,b_i\le10^{12}$<br>数据保证$d_1&lt;d_2&lt;\cdots&lt;d_m$，并且任何时刻没有任何一亩草的高度超过$10^12$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>By <code>Claris</code></p><p>标签：<code>线段树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>比较灵活的线段树。</p><p>观察题目可以发现一个性质，即长速快的在任意时刻都比长速慢的高度高。这是由于每次修剪都是将所有的剪到同一高度，这样长速快的在修剪后的高度一定大于等于长速慢的在修剪后的高度。</p><p>将长速从低到高排序，不会影响询问，并且每次询问剪去的部分一定是一个后缀。那么可以在线段树上分治寻找剪和不剪的分界点，同时累加答案。</p><p>对于每个区间需要维护其长速之和、高度和两个基础元素。为了方便询问，需要维护高度的最大和最小值，即该区间最右边和最左边的苗的高度。这样如果当前区间的最大高度$mx\le b$，可知不用继续递归；如果当前区间最小高度$mi\ge b$，可知整个区间都要修剪，打区间标记后返回。而对于标记，每个区间需要维护三个元素$tc,td,ld$，分别表示该区间中的所有高度均变为$tc$，这个变化发生在$td$时刻，上一次递归到该区间的时间是$ld$。询问每次递归进入一个区间先计算从上次递归到该区间也就是$ld$到现在总共长了多少，更新信息。注意$td$和$ld$不能合并为一个变量，这是由于该区间上次被递归到时可能先更新了信息，但是并未打标记，即其下面的子区间没有更新信息，故$td$和$ld$不同。</p><p>一棵线段树即可维护，某些细节注意一下即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;lnt a[MAX_N+<span class="number">5</span>], b, d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>lnt v, s, tc, td, ld, lv, rv;&#125; tr[MAX_N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">tr[v].v = tr[v&lt;&lt;<span class="number">1</span>].v+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v;</span><br><span class="line">tr[v].s = tr[v&lt;&lt;<span class="number">1</span>].s+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s;</span><br><span class="line">tr[v].lv = tr[v&lt;&lt;<span class="number">1</span>].lv, tr[v].rv = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].tc == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].s = tr[v].tc*(mid-s+<span class="number">1</span>);</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s = tr[v].tc*(t-mid);</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].lv = tr[v&lt;&lt;<span class="number">1</span>].rv = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lv = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rv = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].tc = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tc = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].td = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].td = tr[v].td;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].ld = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ld = tr[v].td;</span><br><span class="line">tr[v].tc = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">tr[v].tc = <span class="number">-1</span>;<span class="keyword">if</span> (s == t) &#123;tr[v].v = a[s]; <span class="keyword">return</span>;&#125;</span><br><span class="line">build(v&lt;&lt;<span class="number">1</span>, s, mid), build(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t), update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0L</span>L;tr[v].s += (d-tr[v].ld)*tr[v].v;</span><br><span class="line">tr[v].lv += a[s]*(d-tr[v].ld), tr[v].rv += a[t]*(d-tr[v].ld);</span><br><span class="line"><span class="keyword">if</span> (tr[v].lv &gt;= b) &#123;</span><br><span class="line">ret = tr[v].s-b*(t-s+<span class="number">1</span>), tr[v].s = b*(t-s+<span class="number">1</span>);</span><br><span class="line">tr[v].lv = tr[v].rv = tr[v].tc = b, tr[v].td = d;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tr[v].rv &gt; b) &#123;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line">ret += query(v&lt;&lt;<span class="number">1</span>, s, mid);</span><br><span class="line">ret += query(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tr[v].ld = d, ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line">sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span> (m--) read(d), read(b), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【PA2015】Siano&quot;&gt;&lt;a href=&quot;#【PA2015】Siano&quot; class=&quot;headerlink&quot; title=&quot;【PA2015】Siano&quot;&gt;&lt;/a&gt;【PA2015】Siano&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;30\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;农夫$\mathrm{Byteasar}$买了一片$n$亩的土地，他要在这上面种草。&lt;br&gt;他在每一亩土地上都种植了一种独一无二的草，其中，第$i$亩土地的草每天会长高$a_i$厘米。&lt;br&gt;$\mathrm{Byteasar}$一共会进行$m$次收割，其中第$i$次收割在第$d_i$天，并把所有高度大于等于$b_i$的部分全部割去。&lt;br&gt;$\mathrm{Byteasar}$想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个正整数$n,m$，分别表示亩数和收割次数。&lt;br&gt;第二行包含$n$个正整数，其中第$i$个数为$a_i$，依次表示每亩种植的草的生长能力。&lt;br&gt;接下来$m$行，每行包含两个正整数$d_i,b_i$，依次描述每次收割。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$m$行，每行一个整数，依次回答每次收割能得到的草的高度总和。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PA" scheme="http://azrael.top/tags/PA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4299 FRBSUM &lt;主席树&gt;</title>
    <link href="http://azrael.top/BZOJ4299%20FRBSUM%20%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ4299 FRBSUM 主席树/</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2018-04-24T09:17:30.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="FRBSUM"><a href="#FRBSUM" class="headerlink" title="FRBSUM"></a>FRBSUM</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>数集$S$的$\mathrm{Forbidden\;Sum}$定义为无法用$S$的某个子集（可以为空）的和表示的最小的非负整数。<br>例如，$S={1,1,3,7}$，则它的子集和中包含$0(S’=\emptyset)$，$1(S’={1})$，$2(S’={1,1})$，$3(S’={3})$，$4(S’={1,3})$，$5(S’={1,1,3})$，但是它无法得到$6$。因此$S$的$\mathrm{Forbidden\;Sum}$为$6$。<br>给定一个序列$A$，你的任务是回答该数列的一些子区间所形成的数集的$\mathrm{Forbidden\;Sum}$是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行包含一个整数$N$，表示序列的长度。<br>接下来一行包含$N$个数，表示给定的序列$A$（从$1$标号）。<br>接下来一行包含一个整数$M$，表示询问的组数。<br>接下来$M$行，每行一对整数，表示一组询问。</p><h3 id="Ouput"><a href="#Ouput" class="headerlink" title="Ouput"></a>Ouput</h3><p>对于每组询问，输出一行表示对应的答案。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 4 9 10</span><br><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于$100\%$的数据，$1\le N,M\le10^5$, $1\le A_i\le10^9$, $1\le A_1+A_2+\cdots+A_N\le10^9$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>By <code>yts1999</code></p><p>标签：<code>主席树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>本题和<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4408" target="_blank" rel="noopener">【FJOI2016】神秘数</a>相同，双倍经验。</p><p>首先不难发现一个结论，若某集合当前能凑出$0\sim mx$中的所有数，加入一个数$x$，可凑出的数的值域扩展当且仅当$x\le mx+1$，并且会将值域扩展到$0\sim mx+x$。<br>如此，对于每个区间$[l,r]$，从小到大逐一将每个数加入到集合中，像上面那样不断扩展值域，如果加入某个数时$x&gt;mx+1$，值域无法继续扩充，那么$mx+1$即为最小的不能凑成的数。<br>这个过程可以用一棵值域主席树维护，每次将所有小于等于$mx+1$的数求和，作为新的$mx$，若$mx$在某次这样的操作中不变，则无法继续扩展，输出答案$mx+1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, rt[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> ls, rs, s;&#125; tr[MAX_N*<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> o, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">tr[v] = tr[o], tr[v].s += p;<span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, p);</span><br><span class="line"><span class="keyword">else</span> modify(tr[v].rs = ++cnt, tr[o].rs, mid+<span class="number">1</span>, t, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) <span class="keyword">return</span> tr[r].s-tr[l].s;</span><br><span class="line"><span class="keyword">int</span> lsum = tr[tr[r].ls].s-tr[tr[l].ls].s;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= mid) <span class="keyword">return</span> query(tr[l].ls, tr[r].ls, s, mid, p);</span><br><span class="line"><span class="keyword">return</span> lsum+query(tr[l].rs, tr[r].rs, mid+<span class="number">1</span>, t, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), modify(rt[i] = ++cnt, rt[i<span class="number">-1</span>], <span class="number">1</span>, INF, x);</span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> l, r;read(l), read(r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mx = <span class="number">0</span>, lst = <span class="number">0</span>; ; lst = mx) &#123;</span><br><span class="line">mx = query(rt[l<span class="number">-1</span>], rt[r], <span class="number">1</span>, INF, mx+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (mx == lst) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mx+<span class="number">1</span>); <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;FRBSUM&quot;&gt;&lt;a href=&quot;#FRBSUM&quot; class=&quot;headerlink&quot; title=&quot;FRBSUM&quot;&gt;&lt;/a&gt;FRBSUM&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;数集$S$的$\mathrm{Forbidden\;Sum}$定义为无法用$S$的某个子集（可以为空）的和表示的最小的非负整数。&lt;br&gt;例如，$S={1,1,3,7}$，则它的子集和中包含$0(S’=\emptyset)$，$1(S’={1})$，$2(S’={1,1})$，$3(S’={3})$，$4(S’={1,3})$，$5(S’={1,1,3})$，但是它无法得到$6$。因此$S$的$\mathrm{Forbidden\;Sum}$为$6$。&lt;br&gt;给定一个序列$A$，你的任务是回答该数列的一些子区间所形成的数集的$\mathrm{Forbidden\;Sum}$是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入数据的第一行包含一个整数$N$，表示序列的长度。&lt;br&gt;接下来一行包含$N$个数，表示给定的序列$A$（从$1$标号）。&lt;br&gt;接下来一行包含一个整数$M$，表示询问的组数。&lt;br&gt;接下来$M$行，每行一对整数，表示一组询问。&lt;/p&gt;
&lt;h3 id=&quot;Ouput&quot;&gt;&lt;a href=&quot;#Ouput&quot; class=&quot;headerlink&quot; title=&quot;Ouput&quot;&gt;&lt;/a&gt;Ouput&lt;/h3&gt;&lt;p&gt;对于每组询问，输出一行表示对应的答案。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="http://azrael.top/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="CodeChef" scheme="http://azrael.top/tags/CodeChef/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1913【APIO2010】信号覆盖 &lt;极角排序+双指针&gt;</title>
    <link href="http://azrael.top/BZOJ1913%E3%80%90APIO2010%E3%80%91%E4%BF%A1%E5%8F%B7%E8%A6%86%E7%9B%96%20%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F+%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://azrael.top/BZOJ1913【APIO2010】信号覆盖 极角排序+双指针/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-04-24T14:06:34.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2010】信号覆盖"><a href="#【APIO2010】信号覆盖" class="headerlink" title="【APIO2010】信号覆盖"></a>【APIO2010】信号覆盖</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/1913_1.jpg" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行包含一个正整数$n$，表示房子的总数。接下来有$n$行，分别表示每一个房子的位置。对于，$i=1,2,\cdots,n$第$i$个房子的坐标用一对整数$x_i$和$y_i$来表示，中间用空格隔开。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出文件包含一个实数，表示平均有多少个房子被信号所覆盖，需保证输出结果与精确值的绝对误差不超过$0.01$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 2</span><br><span class="line">4 4</span><br><span class="line">0 0</span><br><span class="line">2 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.500</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$40\%$的数据，$n\le100$<br>$70\%$的数据，$n\le500$<br>$100\%$的数据，$3\le n\le1500$<br>$100\%$的数据保证，对于$i=1,2,\cdots,n$，第$i$个房子的坐标$(x_i,y_i)$为整数且$-10^6\le x_i,y_i\le10^6$。<br>任何三个房子不在同一条直线上，任何四个房子不在同一个圆上。</p><p>标签：<code>极角排序</code> <code>双指针</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>总体思路是求出所有三元组形成的圆能<strong>多</strong>覆盖的点的总数$tot$，$ans=tot\div\binom{n}{3}+3$</p><p>对于任意四点构成的四边形，考虑任选其中任意三点形成的圆能否包括另一个点。<br>有两种情况：</p><ol><li>凹四边形：除凹进去的点外另外三点的外接圆可以包括凹进去的点外，其余三元组构成的圆一定不能包括第四点，故贡献为$1$。</li><li>凸四边形：由于不存在共圆四边形，对角和一定一个大于$180^\circ$，一个小于$180^\circ$。只有对角和大于$180^\circ$的两个角上三点的外接圆能包括另一点，故贡献为$2$。</li></ol><p>因此$tot=凹四边形数+2\times凸四边形数$。</p><p>接下来考虑如何求两种四边形的个数。由于$凹四边形数+凸四边形数=\binom{n}{4}$，我们只用求凹四边形个数即可。<br>枚举每个点，考虑其作为凹四边形凹进去的那个点又多少种情况。易知$情况数=\binom{n-1}{3}-含此点的凸多边形数$。于是需要求含此点$(p)$的凸多边形数。即枚举凸多边形上的另一个点$(q)$，看有多少点$(r)$使得$pr$和$pq$的夹角小于$180^\circ$。这个过程可以用极角排序后双指针扫一遍统计。这样$O(n^2)$计算出凹多边形数后即可得到最终答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1500</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;dnt,dnt&gt; pdd;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n; lnt c1, c2; pdd p[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">lnt <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">1L</span>L;<span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ret *= <span class="number">1L</span>L*(n-i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ret /= i;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(p[i].x), read(p[i].y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, m = <span class="number">0</span>; i &lt;= n; i++, m = <span class="number">0</span>) &#123;</span><br><span class="line">lnt tot = <span class="number">0L</span>L; dnt a[MAX_N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (i^j)</span><br><span class="line">a[++m] = <span class="built_in">atan2</span>(p[j].y-p[i].y, p[j].x-p[i].x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (a[j] &lt; <span class="number">0</span>) a[j] += <span class="number">2</span>*Pi;</span><br><span class="line">sort(a+<span class="number">1</span>, a+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[m+j] = a[j]+<span class="number">2</span>*Pi;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>, v = <span class="number">1</span>; u &lt;= m; tot += C(v-u, <span class="number">2</span>), u++)</span><br><span class="line"><span class="keyword">while</span> (v &lt; (m&lt;&lt;<span class="number">1</span>) &amp;&amp; a[v+<span class="number">1</span>]-a[u] &lt; Pi) v++;</span><br><span class="line">c1 += C(m, <span class="number">3</span>)-tot;</span><br><span class="line">&#125;</span><br><span class="line">c2 = C(n, <span class="number">4</span>)-c1;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (dnt)(c1+c2*<span class="number">2</span>)/(dnt)C(n, <span class="number">3</span>)+<span class="number">3</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2010】信号覆盖&quot;&gt;&lt;a href=&quot;#【APIO2010】信号覆盖&quot; class=&quot;headerlink&quot; title=&quot;【APIO2010】信号覆盖&quot;&gt;&lt;/a&gt;【APIO2010】信号覆盖&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/1913_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入第一行包含一个正整数$n$，表示房子的总数。接下来有$n$行，分别表示每一个房子的位置。对于，$i=1,2,\cdots,n$第$i$个房子的坐标用一对整数$x_i$和$y_i$来表示，中间用空格隔开。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出文件包含一个实数，表示平均有多少个房子被信号所覆盖，需保证输出结果与精确值的绝对误差不超过$0.01$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
      <category term="计算几何" scheme="http://azrael.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4069【APIO2015】巴厘岛的雕塑 &lt; DP &gt;</title>
    <link href="http://azrael.top/BZOJ4069%E3%80%90APIO2015%E3%80%91%E5%B7%B4%E5%8E%98%E5%B2%9B%E7%9A%84%E9%9B%95%E5%A1%91%20DP/"/>
    <id>http://azrael.top/BZOJ4069【APIO2015】巴厘岛的雕塑 DP/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-04-24T09:14:48.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2015】巴厘岛的雕塑"><a href="#【APIO2015】巴厘岛的雕塑" class="headerlink" title="【APIO2015】巴厘岛的雕塑"></a>【APIO2015】巴厘岛的雕塑</h3><p>$\mathrm{Time\;Limit: \;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。<br>在这条主干道上一共有$N$座雕塑，为方便起见，我们把这些雕塑从$1$到$N$连续地进行标号，其中第 i 座雕塑的年龄是$Y_i$年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。<br>下面是将雕塑分组的规则：<br>这些雕塑必须被分为恰好$X$组，其中$A\le X\le B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。<br>当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。<br>计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。<br>请问政府能得到的最小的最终优美度是多少?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含三个用空格分开的整数$N,A,B$。<br>第二行包含$N$个用空格分开的整数$Y_1,Y_2,\cdots,Y_N$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个数，表示最小的最终优美度。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 1 3</span><br><span class="line">8 1 2 1 5 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>将这些雕塑分为$2$组，$(8,1,2)$和$(1,5,4)$，它们的和是$(11)$和$(10)$，最终优美度是$(11\mid10)=11$。不难验证，这也是最终优美度的最小值。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><table><thead><tr><th style="text-align:center">子任务编号</th><th style="text-align:center">$N$</th><th style="text-align:center">$A,B$</th><th style="text-align:center">$Y_i$</th><th style="text-align:center">分值</th></tr></thead><tbody><tr><td style="text-align:center">$1$</td><td style="text-align:center">$1\le N\le20$</td><td style="text-align:center">$A,B\le N$</td><td style="text-align:center">$0\le Y_i\le10^9$</td><td style="text-align:center">$\mathrm{9\;pts}$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$1\le N\le 50$</td><td style="text-align:center">$A,B\le\min(20,N)$</td><td style="text-align:center">$0\le Y_i\le10$</td><td style="text-align:center">$\mathrm{16\;pts}$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$1\le N\le100$</td><td style="text-align:center">$A=1,\;B\le N$</td><td style="text-align:center">$0\le Y_i\le20$</td><td style="text-align:center">$\mathrm{21\;pts}$</td></tr><tr><td style="text-align:center">$4$</td><td style="text-align:center">$1\le N\le100$</td><td style="text-align:center">$A,B\le N$</td><td style="text-align:center">$0\le Y_i\le10^9$</td><td style="text-align:center">$\mathrm{25\;pts}$</td></tr><tr><td style="text-align:center">$5$</td><td style="text-align:center">$1\le N\le2000$</td><td style="text-align:center">$A=1,\;B\le N$</td><td style="text-align:center">$0\le Y_i\le10^9$</td><td style="text-align:center">$\mathrm{29\;pts}$</td></tr></tbody></table><p>标签：<code>DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>奇葩的面向数据编程题。</p><p>由于算答案是按位或，可以考虑从高位向低位贪心，每次判断在前面的位都取到最优情况下，这一位能否取$0$。这个判断的过程可以$\mathrm{DP}$实现。<br>$f[i][j]$表示考虑前$i$个雕塑，分成$j$个组，能否在当前位上取$0$。<br>那么$f[i][j]=true$当且仅当$\exists k\in[j-1,i)$，满足$f[k][j-1]=true$，并且$sum_{k+1,i}$和当前答案取或的结果还是当前答案（即不会使得前面位上不为最优解），还需要$sum_{k+1,j}$在当前位上的值为$0$（这样当前位才能取$0$）。<br>求出所有$f$后，判断是否$\exists t\in[A,B]$满足$f[n][t]=true$，如果存在则可以取$0$，否则此位取$1$。</p><p>然而这样并不能得满分。上面的方法是$O(n^3)$处理出所有$f$值，不能通过$n=2000$的$\mathrm{Subtask\;5}$。</p><p>而对于$\mathrm{Subtask\;5}$，发现$A=1$，则每次使得分的组数量尽量小肯定是最优的。于是用$g[i]$表示当前位考虑前$i$个雕塑，最少需要分成几组才能使当前位上可以取$0$。如果在当前位处理$g$后发现$g[n]&gt;B$，那么必须取$1$，否则可以取$0$。这样复杂度降成了$O(n^2)$，可以解决$\mathrm{Subtask\;5}$。</p><p>综上，特判数据分两种情况分别做即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, A, B; lnt s[MAX_N+<span class="number">5</span>], ans;</span><br><span class="line"><span class="keyword">bool</span> f[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> g[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = m, flag = <span class="number">1</span>; p; p--, flag = <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="literal">false</span>, <span class="keyword">sizeof</span> f), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j<span class="number">-1</span>; k &lt; i; k++) <span class="keyword">if</span> (f[k][j<span class="number">-1</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> ((((s[i]-s[k])&gt;&gt;p)|ans)^ans) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((s[i]-s[k])&amp;(<span class="number">1L</span>L&lt;&lt;(p<span class="number">-1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">f[i][j] = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = A; i &lt;= B; i++)</span><br><span class="line"><span class="keyword">if</span> (f[n][i]) &#123;flag = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">(ans &lt;&lt;= <span class="number">1</span>) |= flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = m; p; p--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g), g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((((s[i]-s[k])&gt;&gt;p)|ans)^ans) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((s[i]-s[k])&amp;(<span class="number">1L</span>L&lt;&lt;(p<span class="number">-1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">g[i] = min(g[i], g[k]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">(ans &lt;&lt;= <span class="number">1</span>) |= (g[n] &gt; B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(A), read(B);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(s[i]), s[i] += s[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (lnt i = s[n]; i; i &gt;&gt;= <span class="number">1</span>) m++;</span><br><span class="line"><span class="keyword">return</span> (A != <span class="number">1</span> ? sub1() : sub2()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2015】巴厘岛的雕塑&quot;&gt;&lt;a href=&quot;#【APIO2015】巴厘岛的雕塑&quot; class=&quot;headerlink&quot; title=&quot;【APIO2015】巴厘岛的雕塑&quot;&gt;&lt;/a&gt;【APIO2015】巴厘岛的雕塑&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit: \;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。&lt;br&gt;在这条主干道上一共有$N$座雕塑，为方便起见，我们把这些雕塑从$1$到$N$连续地进行标号，其中第 i 座雕塑的年龄是$Y_i$年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。&lt;br&gt;下面是将雕塑分组的规则：&lt;br&gt;这些雕塑必须被分为恰好$X$组，其中$A\le X\le B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。&lt;br&gt;当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。&lt;br&gt;计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。&lt;br&gt;请问政府能得到的最小的最终优美度是多少?&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含三个用空格分开的整数$N,A,B$。&lt;br&gt;第二行包含$N$个用空格分开的整数$Y_1,Y_2,\cdots,Y_N$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一行一个数，表示最小的最终优美度。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4070【APIO2015】雅加达的摩天楼 &lt;分块+最短路&gt;</title>
    <link href="http://azrael.top/BZOJ4070%E3%80%90APIO2015%E3%80%91%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC%20%E5%88%86%E5%9D%97+%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>http://azrael.top/BZOJ4070【APIO2015】雅加达的摩天楼 分块+最短路/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-04-23T14:45:59.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2015】雅加达的摩天楼"><a href="#【APIO2015】雅加达的摩天楼" class="headerlink" title="【APIO2015】雅加达的摩天楼"></a>【APIO2015】雅加达的摩天楼</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>印尼首都雅加达市有$N$座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为$0$到$N-1$。除了这$N$座摩天楼外，雅加达市没有其他摩天楼。<br>有$M$只叫做$\mathrm{doge}$的神秘生物在雅加达市居住，它们的编号依次是$0$到$M-1$。编号为$i$的$\mathrm{doge}$最初居住于编号为$B_i$的摩天楼。每只$\mathrm{doge}$都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为$i$的$\mathrm{doge}$的跳跃能力为$P_i\;(P_i&gt;0)$。<br>在一次跳跃中，位于摩天楼$b$而跳跃能力为$p$的$\mathrm{doge}$可以跳跃到编号为$b-p$（如果$0\le b-p&lt;N$）或$b+p$（如果$0\le b+p&lt;N$）的摩天楼。<br>编号为$0$的$\mathrm{doge}$是所有$\mathrm{doge}$的首领，它有一条紧急的消息要尽快传送给编号为$1$的$\mathrm{doge}$。<br>任何一个收到消息的$\mathrm{doge}$有以下两个选择:</p><ul><li>跳跃到其他摩天楼上</li><li>将消息传递给它当前所在的摩天楼上的其他$\mathrm{doge}$</li></ul><p>请帮助$\mathrm{doge}$们计算将消息从$0$号$\mathrm{doge}$传递到$1$号$\mathrm{doge}$所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到$1$号$\mathrm{doge}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含两个整数$N$和$M$。<br>接下来$M$行，每行包含两个整数$B_i$和$P_i$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行，表示所需要的最少步数。<br>如果消息永远无法传递到$1$号$\mathrm{doge}$，输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">0 2</span><br><span class="line">1 1</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>下面是一种步数为$5$的解决方案：<br>$0$号$\mathrm{doge}$跳跃到$2$号摩天楼，再跳跃到$4$号摩天楼（$2$步）。<br>$0$号$\mathrm{doge}$将消息传递给$2$号$\mathrm{doge}$。<br>$2$号$\mathrm{doge}$跳跃到$3$号摩天楼,接着跳跃到$2$号摩天楼，再跳跃到$1$号摩天楼（$3$步）。<br>$2$号$\mathrm{doge}$将消息传递给$1$号$\mathrm{doge}$。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N,P_i\le3\times10^4,\;2\le M\le3\times 10^4,\;0\le B_i&lt;N$</p><p>标签：<code>最短路</code> <code>分块</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><code>分块</code>优化最短路建边。新姿势$\mathrm{get}$。</p><p>考虑直接建边，由于可以多次跳跃，最多会形成$n^2$条边，肯定不行。</p><p>正解是给每个结点建立若干个辅助结点，像分块一样把建边数降下来。<br>具体来说，设块大小为$\mathrm{MAGIC}$，</p><ul><li>对于$p_i&gt;\mathrm{MAGIC}$，连出的边数较少，可以直接连边</li><li>对于$p_i\le\mathrm{MAGIC}$，连出的边数较多，需要对每个点建立$\mathrm{MAGIC}$个中转节点，第$i$个点的第$k$个中转节点只会通向距离$i$距离恰为$k$的结点$j$的第$k$个中转节点。可以理解为建立的图为$\mathrm{MAGIC}$层的高架桥，越高层的道路每次走的距离越大。对于点$i$，连接第$0$层的$i$结点（表示$i$结点本身）到第$p_i$层的$i$结点（表示每次走的距离都是$p_i$）。</li></ul><p>初始化同节点层与层之间的连边，即对于$i$结点，连接其每个中转节点到其本身（即第$0$层的$i$结点）边权为$0$，这样如果在某节点$u$想要停止跳过来时的步长$x$，转用$u$结点本身的步长$y$，则可以从$i$的第$x$个中转节点花费$0$的代价走到$i$结点本身，再花费$0$的代价走到$i$的第$y$个中转节点。</p><p>如此，边数和点数都变成了$n\sqrt{n}​$级别，由于卡内存，可以把$\mathrm{MAGIC}​$调成$\min(\sqrt{n},100)​$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir top().first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec top().second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 4000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 15000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> priority_queue&lt;pii&gt; pri_que;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, MAGIC, b[MAX_N+<span class="number">5</span>], p[MAX_N+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="keyword">int</span> pr[MAX_N+<span class="number">5</span>]; pri_que que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = b[<span class="number">1</span>], t = b[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>, que.push(mp(-d[s], s));</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.sec, w = -que.fir;</span><br><span class="line">que.pop(); <span class="keyword">if</span> (d[u]^w) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v, c; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (d[u]+(c=E[i].c) &lt; d[v = E[i].v])</span><br><span class="line">d[v] = d[u]+c, que.push(mp(-d[v], v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[t] == INF ? <span class="number">-1</span> : d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);</span><br><span class="line">read(n), read(m), MAGIC = min((<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n), <span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(b[i]), read(p[i]), b[i]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAGIC; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) addedge(i*n+j, j, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAGIC; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n-i; j++)</span><br><span class="line">addedge(i*n+j, i*n+i+j, <span class="number">1</span>), addedge(i*n+i+j, i*n+j, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i] &lt;= MAGIC) addedge(b[i], p[i]*n+b[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = b[i]+p[i]; j &lt;= n; j += p[i])</span><br><span class="line">addedge(b[i], j, (j-b[i])/p[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = b[i]-p[i]; j &gt;= <span class="number">1</span>; j -= p[i])</span><br><span class="line">addedge(b[i], j, (b[i]-j)/p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Dijkstra()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2015】雅加达的摩天楼&quot;&gt;&lt;a href=&quot;#【APIO2015】雅加达的摩天楼&quot; class=&quot;headerlink&quot; title=&quot;【APIO2015】雅加达的摩天楼&quot;&gt;&lt;/a&gt;【APIO2015】雅加达的摩天楼&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;印尼首都雅加达市有$N$座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为$0$到$N-1$。除了这$N$座摩天楼外，雅加达市没有其他摩天楼。&lt;br&gt;有$M$只叫做$\mathrm{doge}$的神秘生物在雅加达市居住，它们的编号依次是$0$到$M-1$。编号为$i$的$\mathrm{doge}$最初居住于编号为$B_i$的摩天楼。每只$\mathrm{doge}$都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为$i$的$\mathrm{doge}$的跳跃能力为$P_i\;(P_i&amp;gt;0)$。&lt;br&gt;在一次跳跃中，位于摩天楼$b$而跳跃能力为$p$的$\mathrm{doge}$可以跳跃到编号为$b-p$（如果$0\le b-p&amp;lt;N$）或$b+p$（如果$0\le b+p&amp;lt;N$）的摩天楼。&lt;br&gt;编号为$0$的$\mathrm{doge}$是所有$\mathrm{doge}$的首领，它有一条紧急的消息要尽快传送给编号为$1$的$\mathrm{doge}$。&lt;br&gt;任何一个收到消息的$\mathrm{doge}$有以下两个选择:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跳跃到其他摩天楼上&lt;/li&gt;
&lt;li&gt;将消息传递给它当前所在的摩天楼上的其他$\mathrm{doge}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请帮助$\mathrm{doge}$们计算将消息从$0$号$\mathrm{doge}$传递到$1$号$\mathrm{doge}$所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到$1$号$\mathrm{doge}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含两个整数$N$和$M$。&lt;br&gt;接下来$M$行，每行包含两个整数$B_i$和$P_i$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一行，表示所需要的最少步数。&lt;br&gt;如果消息永远无法传递到$1$号$\mathrm{doge}$，输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
      <category term="分块" scheme="http://azrael.top/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="最短路" scheme="http://azrael.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1178【APIO2009】会议中心 &lt;贪心+倍增&gt;</title>
    <link href="http://azrael.top/BZOJ1178%E3%80%90APIO2009%E3%80%91%E4%BC%9A%E8%AE%AE%E4%B8%AD%E5%BF%83%20%E8%B4%AA%E5%BF%83+%E5%80%8D%E5%A2%9E/"/>
    <id>http://azrael.top/BZOJ1178【APIO2009】会议中心 贪心+倍增/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-20T12:58:24.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2009】会议中心"><a href="#【APIO2009】会议中心" class="headerlink" title="【APIO2009】会议中心"></a>【APIO2009】会议中心</h3><p>$\mathrm{Time\;Limit:\;15\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Siruseri}$政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。<br>对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。<br>显然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有$4$个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。</p><table><thead><tr><th>公司</th><th>开始日期</th><th>结束日期</th></tr></thead><tbody><tr><td>$公司1$</td><td>$4$</td><td>$9$</td></tr><tr><td>$公司2$</td><td>$9$</td><td>$11$</td></tr><tr><td>$公司3$</td><td>$13$</td><td>$19$</td></tr><tr><td>$公司4$</td><td>$10$</td><td>$17$</td></tr></tbody></table><p>上例中，最多将会堂租借给两家公司。租借策略分别是租给$公司1$和$公司3$， 或是$公司2$和$公司3$，也可以是$公司1$和$公司4$。注意会议中心一天最多租借给 一个公司，所以$公司1$和$公司2$不能同时租借会议中心，因为他们在第九天重合 了。<br>销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小的候选策略作为最终的策略。<br>例中，会堂最终将被租借给$公司1$和$公司3$：$3$个候选策略是 $\lbrace(1,3),(2,3),(1,4)\rbrace$，而在字典序中$(1,3)&lt;(1,4)&lt;(2,3)$。<br>你的任务是帮助销售主管确定应该将会堂租借给哪些公司。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有一个整数$N\;(N\le2\times10^5)$，表示发出租借会堂申请的公司的个数。<br>第$2$到第$N+1$行每行有$2$个整数。第$i+1$行的整数表示第$i$家公司申请租借的起始和终止日期。<br>对于每个公司的申请，起始日期为不小于$1$的整数，终止日期为不大于$10^9$的整数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出的第一行应有一个整数$M$，表示最多可以租借给多少家公司。<br>第二行应列出$M$个数，表示最终将会堂租借给哪些公司。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4 9</span><br><span class="line">9 11</span><br><span class="line">13 19</span><br><span class="line">10 17</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>修复数据$\mathrm{BUG}$，并新加数据一组。$\mathrm{By\;NanoApe\;2016.5.11}$<br><a href="http://www.lydsy.com/JudgeOnline/upload/201605/dd.rar" target="_blank" rel="noopener">修复后数据</a></p><p>标签：<code>贪心</code> <code>倍增</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思路清奇的贪心…</p><p>如果没有“字典序最小”，直接无脑贪心即可。有输方案的要求后，就需要用另外一种贪心。</p><p>首先先做一遍贪心找到最多能有多少个会议，然后从$1$到$n$按编号枚举会议，看当前会议加入后会不会使答案变小，如果不会变小就贪心把这个会议加入到方案中。</p><p>具体地，首先以$r$从小到大为第一关键字，以$l$从大到小为第二关键字排序，去掉包含的区间。<br>找到一种方法（一会儿说）计算$F(p,q)$，表示$p\sim q$时间段最多可以放多少个会议。<br>对于会议$i$，其时间段是$[l,r]$，已经加入的会议中此会议的前驱的结束时间是$lr$，后继的开始时间是$rl$（前驱和后继用<code>set</code>维护）。</p><ul><li>若$l\le lr$或$r\ge rl$，那么一定不能放入。</li><li>若$F(lr+1,l-1)+F(r+1,rl-1)+1=F(lr+1,rl-1)$，那么放入后一定不会影响答案，输出编号后把此会议加入<code>set</code>即可。这个等式表示加入此会议后虽然把原区间分成了三个子区间，但最大值依旧不变。</li><li>若$F(lr+1,l-1)+F(r+1,rl-1)+1\ne F(lr+1,rl-1)$，那么不能放入。</li></ul><p>这样一来，就可以解决输出方案的问题了。</p><p>但如何计算$F(p,q)$呢？<br>如果直接算，是$O(n)$的，考虑把这个过程变成$O(\log n)$。<br>倍增预处理出$nxt[u][i]$，表示从区间$u$开始向后选$2^i$个连续区间，最后一个区间的编号。于是每次计算可以倍增跳累加答案。</p><p>$\mathrm{Problem\;solved.}$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, L[MAX_N+<span class="number">5</span>], R[MAX_N+<span class="number">5</span>], nxt[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> l, r; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span>;&#125; a[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> node::<span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> r == t.r ? l &gt; t.l : r &lt; t.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = lower_bound(L+<span class="number">1</span>, L+m+<span class="number">1</span>, l)-L, ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (u &gt; m || R[u] &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (nxt[u][i] &amp;&amp; R[nxt[u][i]] &lt;= r)</span><br><span class="line">ret += <span class="number">1</span>&lt;&lt;i, u = nxt[u][i];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); <span class="built_in">set</span> &lt;node&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(a[i].l), read(a[i].r), b[i] = a[i];</span><br><span class="line">sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>), m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (b[i].l &gt; b[m].l) b[++m] = b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) L[i] = b[i].l, R[i] = b[i].r;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= m &amp;&amp; b[j].l &lt;= b[i].r) j++;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= m) nxt[i][<span class="number">0</span>] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOG; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">nxt[j][i] = nxt[nxt[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">s.insert((node)&#123;-INF, -INF&#125;), s.insert((node)&#123;INF, INF&#125;);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, calc(-INF, INF));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">set</span> &lt;node&gt; :: iterator ln = s.lower_bound(a[i]), rn = ln;</span><br><span class="line">ln--; <span class="keyword">int</span> l = a[i].l, r = a[i].r, lr = ln-&gt;r, rl = rn-&gt;l;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= lr || r &gt;= rl) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (calc(lr+<span class="number">1</span>, rl<span class="number">-1</span>) == calc(lr+<span class="number">1</span>, l<span class="number">-1</span>)+calc(r+<span class="number">1</span>, rl<span class="number">-1</span>)+<span class="number">1</span>)</span><br><span class="line">s.insert(a[i]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">""</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2009】会议中心&quot;&gt;&lt;a href=&quot;#【APIO2009】会议中心&quot; class=&quot;headerlink&quot; title=&quot;【APIO2009】会议中心&quot;&gt;&lt;/a&gt;【APIO2009】会议中心&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;15\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Siruseri}$政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。&lt;br&gt;对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。&lt;br&gt;显然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有$4$个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;公司&lt;/th&gt;
&lt;th&gt;开始日期&lt;/th&gt;
&lt;th&gt;结束日期&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$公司1$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$9$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司2$&lt;/td&gt;
&lt;td&gt;$9$&lt;/td&gt;
&lt;td&gt;$11$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司3$&lt;/td&gt;
&lt;td&gt;$13$&lt;/td&gt;
&lt;td&gt;$19$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司4$&lt;/td&gt;
&lt;td&gt;$10$&lt;/td&gt;
&lt;td&gt;$17$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上例中，最多将会堂租借给两家公司。租借策略分别是租给$公司1$和$公司3$， 或是$公司2$和$公司3$，也可以是$公司1$和$公司4$。注意会议中心一天最多租借给 一个公司，所以$公司1$和$公司2$不能同时租借会议中心，因为他们在第九天重合 了。&lt;br&gt;销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小的候选策略作为最终的策略。&lt;br&gt;例中，会堂最终将被租借给$公司1$和$公司3$：$3$个候选策略是 $\lbrace(1,3),(2,3),(1,4)\rbrace$，而在字典序中$(1,3)&amp;lt;(1,4)&amp;lt;(2,3)$。&lt;br&gt;你的任务是帮助销售主管确定应该将会堂租借给哪些公司。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行有一个整数$N\;(N\le2\times10^5)$，表示发出租借会堂申请的公司的个数。&lt;br&gt;第$2$到第$N+1$行每行有$2$个整数。第$i+1$行的整数表示第$i$家公司申请租借的起始和终止日期。&lt;br&gt;对于每个公司的申请，起始日期为不小于$1$的整数，终止日期为不大于$10^9$的整数。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出的第一行应有一个整数$M$，表示最多可以租借给多少家公司。&lt;br&gt;第二行应列出$M$个数，表示最终将会堂租借给哪些公司。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="贪心" scheme="http://azrael.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="倍增" scheme="http://azrael.top/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ5180【Baltic2016】Cities &lt;斯坦纳树&gt;</title>
    <link href="http://azrael.top/BZOJ5180%E3%80%90Baltic2016%E3%80%91Cities%20%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ5180【Baltic2016】Cities 斯坦纳树/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-23T13:53:16.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【Baltic2016】Cities"><a href="#【Baltic2016】Cities" class="headerlink" title="【Baltic2016】Cities"></a>【Baltic2016】Cities</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定$n$个点，$m$条双向边的图，其中有$k$个点是重要的，每条边都有一定的长度。<br>现在要你选定一些边来构成一个图，要使得$k$个重要的点相互连通，求边的长度和的最小值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>共$m+2$行<br>第$1$行读入$n,k,m$，表示$n$个点，$k$个重要的点，$m$条边<br>第$2$行读入$k$个重要点的编号<br>第$3$至第$m+2$行，每行包括$3$个数字$a,b,c$，表示有一条从$a$到$b$长度为$c$的双向路径</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共$1$行，即最小长度和<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 3 6</span><br><span class="line">1 3 4</span><br><span class="line">1 2 4</span><br><span class="line">1 3 9</span><br><span class="line">1 4 6</span><br><span class="line">2 3 2</span><br><span class="line">2 4 5</span><br><span class="line">3 4 8</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$k\le5,\;n\le10^5,\;1\le m\le2\times10^5$</p><p>标签：<code>斯坦纳树</code> <code>状压DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>斯坦纳树裸题。</p><p>斯坦纳树的基本解法是状压$\mathrm{DP}$，压缩联通状态进行$\mathrm{DP}$，$f[s][i]$表示在$i$点，联通状态为$s$的最小花费。<br>有两种转移：</p><ul><li>状态$s$可以通过两个状态组合而来，对于$s$的一个子集$t$，有$f[s][i]=\max(f[s][i],f[t][i]+f[s-t][i])$</li><li>状态$s$也可以在同层向邻接点扩展，即最短路中的松弛操作，对于边$u,v$，有$f[s][v]=\max(f[s][v],f[s][u]+Edge_{u,v})$，可以跑最短路更新。</li></ul><p>此题有点卡，注意不要用<code>SPFA</code>，要用<code>堆优Dijkstra</code>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;lnt,<span class="keyword">int</span>&gt; pli;</span><br><span class="line"><span class="keyword">typedef</span> priority_queue&lt;pli&gt; pri_que;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k; lnt f[<span class="number">32</span>][MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[<span class="number">32</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="built_in">vector</span> &lt;lnt&gt; E[MAX_N+<span class="number">5</span>]; pri_que que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;G[u].push_back(v), E[u].push_back(c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;insert(u, v, c), insert(v, u, c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(k), read(m), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p; i &lt; k; i++) read(p), f[<span class="number">1</span>&lt;&lt;i][p] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt;= m; i++)</span><br><span class="line">read(u), read(v), read(c), addedge(u, v, c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span>&lt;&lt;k); s++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = (s<span class="number">-1</span>)&amp;s; t; t = (t<span class="number">-1</span>)&amp;s)</span><br><span class="line">f[s][i] = min(f[s][i], f[t][i]+f[s^t][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) que.push(mp(-f[s][i], i));</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.top().sec; que.pop();</span><br><span class="line"><span class="keyword">if</span> (mrk[s][u]) <span class="keyword">continue</span>; mrk[s][u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (f[s][v = G[u][i]] &gt; f[s][u]+E[u][i])</span><br><span class="line">f[s][v] = f[s][u]+E[u][i], que.push(mp(-f[s][v], v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lnt mi = <span class="number">1L</span>L&lt;&lt;<span class="number">62</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">mi = min(mi, f[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>][i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mi), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【Baltic2016】Cities&quot;&gt;&lt;a href=&quot;#【Baltic2016】Cities&quot; class=&quot;headerlink&quot; title=&quot;【Baltic2016】Cities&quot;&gt;&lt;/a&gt;【Baltic2016】Cities&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定$n$个点，$m$条双向边的图，其中有$k$个点是重要的，每条边都有一定的长度。&lt;br&gt;现在要你选定一些边来构成一个图，要使得$k$个重要的点相互连通，求边的长度和的最小值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;共$m+2$行&lt;br&gt;第$1$行读入$n,k,m$，表示$n$个点，$k$个重要的点，$m$条边&lt;br&gt;第$2$行读入$k$个重要点的编号&lt;br&gt;第$3$至第$m+2$行，每行包括$3$个数字$a,b,c$，表示有一条从$a$到$b$长度为$c$的双向路径&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;共$1$行，即最小长度和&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="状压DP" scheme="http://azrael.top/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="斯坦纳树" scheme="http://azrael.top/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
      <category term="Baltic" scheme="http://azrael.top/tags/Baltic/"/>
    
  </entry>
  
  <entry>
    <title>【APIO2011】方格染色 &lt;带权并查集&gt;</title>
    <link href="http://azrael.top/BZOJ2303%E3%80%90APIO2011%E3%80%91%E6%96%B9%E6%A0%BC%E6%9F%93%E8%89%B2%20%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://azrael.top/BZOJ2303【APIO2011】方格染色 带权并查集/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-20T12:21:28.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2011】方格染色"><a href="#【APIO2011】方格染色" class="headerlink" title="【APIO2011】方格染色"></a>【APIO2011】方格染色</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;256MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Sam}$和他的妹妹$\mathrm{Sara}$有一个包含$n\times m$个方格的表格。她们想要将其的每个方格都染成红色或蓝色。<br>出于个人喜好，他们想要表格中每个$2\times 2$的方形区域都包含奇数个（$1$个或$3$个）红色方格。 可是昨天晚上，有人已经给表格中的一些方格染上了颜色！<br>现在$\mathrm{Sam}$和$\mathrm{Sara}$非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格仍然满足她们的要求。<br>如果可能的话，满足他们要求的染色方案数有多少呢？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含三个整数$n$, $m$和$k$，分别代表表格的行数、列数和已被染色的方格数目。<br>之后的$k$行描述已被染色的方格。其中第$i$行包含三个整数$x_i$, $y_i$和$c_i$，分别代表第$i$个已被染色的方格的行编号、列编号和颜色。$c_i$为$1$表示方格被染成红色，$c_i$为$0$表示方格被染成蓝色。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示可能的染色方案数目$W$模$10^9$得到的值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于所有的测试数据，$2\le n,m\le10^6$, $0\le k\le10^6$, $1\le x_i\le n$, $1\le y_i\le m$。<br>数据为国内数据+国际数据+修正版<br>鸣谢<code>GYZ</code></p><p>标签：<code>带权并查集</code> <code>异或方程组</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>并查集解异或方程组。</p><p>令$a_{i,j}$表示第$i$行第$j$列的格子最终是否被染，对于$\forall i\in[1,n),j\in[1,m)$，一定有$a_{i,j}\oplus a_{i,j+1}\oplus a_{i+1,j}\oplus a_{i+1,j+1}=1$。而易得到结论：确定一行一列的情况，即可确定最后是否能正确染色。</p><p>于是我们尝试确定第一行和第一列的情况，即做一个$n+m-1$个变量的异或方程组。<br>对于给定的$a_{x,y}=0/1$，我们如果把$i\in[1,x),j\in[1,y)$的所有上一段所属方程异或起来，那么相同元抵消，可知$a_{1,1}\oplus a_{i,1}\oplus a_{1,j}=a_{i,j}\oplus1$，如果我们知道$a_{1,1}$，那么就能确定$a_{i,1}\oplus a_{1,j}$的值，这时用一个带权并查集维护一下，即可得到联通块的个数。那么答案为$2^{自由元个数-1}$（$a_{1,1}$所在联通块的取值是一定的）。<br>如果我们预先不知道$a_{1,1}$的值，就可以枚举两种取值，分别计算后加起来即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, f[MAX_N+<span class="number">5</span>], g[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> x[MAX_N+<span class="number">5</span>], y[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> f[x] == x ? x : getf(f[x]), g[x] ^= g[f[x]], f[x] = f[f[x]];&#125;</span><br><span class="line"><span class="function">lnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> (x[i] &gt; <span class="number">1</span> &amp;&amp; y[i] &gt; <span class="number">1</span>) c[i] ^= val;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+m; i++) f[i] = i, g[i] = <span class="number">0</span>; f[n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> ((x[i]^<span class="number">1</span>) || (y[i]^<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getf(x[i]), v = getf(y[i]+n), w = g[x[i]]^g[y[i]+n]^c[i];</span><br><span class="line"><span class="keyword">if</span> (u^v) f[v] = u, g[v] = w; <span class="keyword">else</span> <span class="keyword">if</span> (w) <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>; i &lt;= n+m; i++) <span class="keyword">if</span> (getf(i) == i)</span><br><span class="line">&#123;<span class="keyword">if</span> (t) (ret *= <span class="number">2L</span>L) %= MOD; <span class="keyword">else</span> t = <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), read(k);</span><br><span class="line"><span class="keyword">bool</span> f0 = <span class="literal">true</span>, f1 = <span class="literal">true</span>; lnt ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">read(x[i]), read(y[i]), read(c[i]);</span><br><span class="line"><span class="keyword">if</span> (!(x[i]%<span class="number">2</span>) &amp;&amp; !(y[i]%<span class="number">2</span>)) c[i] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x[i] == <span class="number">1</span> &amp;&amp; y[i] == <span class="number">1</span>) c[i] ? f0 = <span class="literal">false</span> : f1 = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f0) (ans += calc(<span class="number">0</span>)) %= MOD;</span><br><span class="line"><span class="keyword">if</span> (f1) (ans += calc(<span class="number">1</span>)) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2011】方格染色&quot;&gt;&lt;a href=&quot;#【APIO2011】方格染色&quot; class=&quot;headerlink&quot; title=&quot;【APIO2011】方格染色&quot;&gt;&lt;/a&gt;【APIO2011】方格染色&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Sam}$和他的妹妹$\mathrm{Sara}$有一个包含$n\times m$个方格的表格。她们想要将其的每个方格都染成红色或蓝色。&lt;br&gt;出于个人喜好，他们想要表格中每个$2\times 2$的方形区域都包含奇数个（$1$个或$3$个）红色方格。 可是昨天晚上，有人已经给表格中的一些方格染上了颜色！&lt;br&gt;现在$\mathrm{Sam}$和$\mathrm{Sara}$非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格仍然满足她们的要求。&lt;br&gt;如果可能的话，满足他们要求的染色方案数有多少呢？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含三个整数$n$, $m$和$k$，分别代表表格的行数、列数和已被染色的方格数目。&lt;br&gt;之后的$k$行描述已被染色的方格。其中第$i$行包含三个整数$x_i$, $y_i$和$c_i$，分别代表第$i$个已被染色的方格的行编号、列编号和颜色。$c_i$为$1$表示方格被染成红色，$c_i$为$0$表示方格被染成蓝色。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个整数，表示可能的染色方案数目$W$模$10^9$得到的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="并查集" scheme="http://azrael.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2809【APIO2012】Dispatching &lt;可并堆&gt;</title>
    <link href="http://azrael.top/BZOJ2809%E3%80%90APIO2012%E3%80%91Dispatching%20%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    <id>http://azrael.top/BZOJ2809【APIO2012】Dispatching 可并堆/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-04-16T08:51:55.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2012】Dispatching"><a href="#【APIO2012】Dispatching" class="headerlink" title="【APIO2012】Dispatching"></a>【APIO2012】Dispatching</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。<br>在这个帮派里，有一名忍者被称之为$\mathrm{Master}$。除了$\mathrm{Master}$以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。<br>现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，就不需要支付管理者的薪水。你的目标是在预算内使顾客的满意度最大。<br>这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。<br>写一个程序，给定每一个忍者$i$的上级$B_i$，薪水$C_i$，领导力$L_i$，以及支付给忍者们的薪水总预算$M$，输出在预算内满足上述要求时顾客满意度的最大值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>从标准输入读入数据。<br>第一行包含两个整数$N$和$M$，其中$N$表示忍者的个数，$M$表示薪水的总预算。<br>接下来$N$行描述忍者们的上级、薪水以及领导力。其中的第$i$行包含三个整数$B_i,C_i,L_i$分别表示第$i$个忍者的上级，薪水以及领导力。$\mathrm{Master}$满足$B_i=0$，并且每一个忍者的老板的编号一定小于自己的编号。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个数，表示在预算内顾客的满意度的最大值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 3 3</span><br><span class="line">1 3 5</span><br><span class="line">2 2 2</span><br><span class="line">1 2 4</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p><strong>样例解释</strong><br>如果我们选择编号为$1$的忍者作为管理者并且派遣第三个和第四个忍者，薪水总和为$4$，没有超过总预算$4$。<br>因为派遣了$2$个忍者并且管理者的领导力为$3$，用户的满意度为$6$，是可以得到的用户满意度的最大值。<br><strong>数据范围</strong><br>$1\le N\le10^5,\;1\le M\le10^9,\;0\le B_i&lt;i,\;1\le C_i\le M,\;1\le L_i\le10^9$</p><p>标签：<code>可并堆</code> <code>左偏树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>可并堆基础题。</p><p>对于每个结点作领导的情况，贪心策略肯定在其子树中从小往大选，直到选不了为止。可以每个结点用一个堆维护，但遍历子树会导致复杂度爆炸。</p><p>考虑每次用已经算出的一些结点的答案。那么可以想到一种做法：<br>将每个结点子树中的所有点默认先选上，再从大往小去掉直到可行为止。这样在儿子结点中都没选到的点一定不会在父节点中选到。于是可以直接将每个结点最后选出的点加入到父亲的备选点集中。这样不难发现可以用可并堆维护，$\mathrm{DFS}$时将所有儿子结点的可并堆并起来，再从大往小$\mathrm{pop}$点，找到可行最大$size$后更新答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> c, d, ls, rs;&#125; h[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, b[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>], l[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> fa[MAX_N+<span class="number">5</span>]; lnt mx, s[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? fa[x] : getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> a^b;</span><br><span class="line"><span class="keyword">if</span> (h[a].c &lt; h[b].c) swap(a, b);</span><br><span class="line">h[a].rs = merge(h[a].rs, b), fa[h[a].rs] = a;</span><br><span class="line"><span class="keyword">if</span> (h[h[a].rs].d &gt; h[h[a].ls].d) swap(h[a].ls, h[a].rs);</span><br><span class="line">h[a].d = h[a].rs ? h[h[a].rs].d+<span class="number">1</span> : <span class="number">0</span>;<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = h[a].ls, r = h[a].rs;</span><br><span class="line">h[a].ls = h[a].rs = h[a].c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fa[l] = l, fa[r] = r, merge(l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rt = u;s[u] = c[u], sz[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line">rt = merge(rt, DFS(v = G[u][i])), s[u] += s[v], sz[u] += sz[v];</span><br><span class="line"><span class="keyword">while</span> (s[u] &gt; m &amp;&amp; sz[u]) s[u] -= h[rt].c, sz[u]--, rt = pop(rt);</span><br><span class="line"><span class="keyword">return</span> mx = max(mx, <span class="number">1L</span>L*sz[u]*l[u]), rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(b[i]), read(c[i]), read(l[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">G[b[i]].push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">fa[i] = i, h[i].c = c[i];</span><br><span class="line"><span class="keyword">return</span> DFS(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mx), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2012】Dispatching&quot;&gt;&lt;a href=&quot;#【APIO2012】Dispatching&quot; class=&quot;headerlink&quot; title=&quot;【APIO2012】Dispatching&quot;&gt;&lt;/a&gt;【APIO2012】Dispatching&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。&lt;br&gt;在这个帮派里，有一名忍者被称之为$\mathrm{Master}$。除了$\mathrm{Master}$以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。&lt;br&gt;现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，就不需要支付管理者的薪水。你的目标是在预算内使顾客的满意度最大。&lt;br&gt;这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。&lt;br&gt;写一个程序，给定每一个忍者$i$的上级$B_i$，薪水$C_i$，领导力$L_i$，以及支付给忍者们的薪水总预算$M$，输出在预算内满足上述要求时顾客满意度的最大值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;从标准输入读入数据。&lt;br&gt;第一行包含两个整数$N$和$M$，其中$N$表示忍者的个数，$M$表示薪水的总预算。&lt;br&gt;接下来$N$行描述忍者们的上级、薪水以及领导力。其中的第$i$行包含三个整数$B_i,C_i,L_i$分别表示第$i$个忍者的上级，薪水以及领导力。$\mathrm{Master}$满足$B_i=0$，并且每一个忍者的老板的编号一定小于自己的编号。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个数，表示在预算内顾客的满意度的最大值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="可并堆" scheme="http://azrael.top/tags/%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ5251【2018多省省队联测】劈配 &lt;网络流&gt;</title>
    <link href="http://azrael.top/BZOJ5251%E3%80%902018%E5%A4%9A%E7%9C%81%E7%9C%81%E9%98%9F%E8%81%94%E6%B5%8B%E3%80%91%E5%8A%88%E9%85%8D%20%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ5251【2018多省省队联测】劈配 网络流/</id>
    <published>2018-04-13T16:00:00.000Z</published>
    <updated>2018-04-16T08:38:56.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【2018多省省队联测】劈配"><a href="#【2018多省省队联测】劈配" class="headerlink" title="【2018多省省队联测】劈配"></a>【2018多省省队联测】劈配</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;512\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一年一度的综艺节目《中国新代码》又开始了。$\mathrm{Zayid}$从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。<br>轻车熟路的$\mathrm{Zayid}$顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：<br>总共$n$名参赛选手（编号从$1$至$n$）每人写出一份代码并介绍自己的梦想。接着由所有导师对这些选手进行排名。<br>为了避免后续的麻烦，规定不存在排名并列的情况。<br>同时，每名选手都将独立地填写一份志愿表，来对总共$m$位导师（编号从$1$至$m$）作出评价。志愿表上包含了共$m$档志愿。对于每一档志愿，选手被允许填写最多$C$位导师，每位导师最多被每位选手填写一次（放弃某些导师也是被允许的）。<br>在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。<br>节目组对“前$i$名的录取结果最优”作出如下定义：</p><ul><li>前$1$名的录取结果最优，当且仅当第$1$名被其最高非空志愿录取（特别地，如果第$1$名没有填写志愿表，那么该选手出局）。</li><li>前$i$名的录取结果最优，当且仅当在前$i-1$名的录取结果最优的情况下：第$i$名被其理论可能的最高志愿录取（特别地，如果第i名没有填写志愿表、或其所有志愿中的导师战队均已满员，那么该选手出局）。</li></ul><p>如果一种方案满足“前$n$名的录取结果最优”，那么我们可以简称这种方案是最优的。<br>举例而言，$2$位导师$T$老师、$F$老师的战队人数上限分别都是$1$人；$2$位选手$\mathrm{Zayid}$、$\mathrm{DuckD}$分列第$1、2$名。那么下面$3$种志愿表及其对应的最优录取结果如表中所示：</p><center><br><img src="https://www.lydsy.com/JudgeOnline/upload/201804/111(1).jpg" alt=""><br></center><p>可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。<br>每个人都有一个自己的理想值$s_i$，表示第$i$位同学希望自己被第$s_i$或更高的志愿录取，如果没有，那么他就会非常沮丧。<br>现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。<br>对于每一位选手，$\mathrm{Zayid}$都想知道下面两个问题的答案：</p><ul><li>在最优的录取方案中，他会被第几志愿录取。</li><li>在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。</li></ul><p>作为《中国新代码》的实力派代码手，$\mathrm{Zayid}$当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每个测试点包含多组测试数据，第一行$2$个用空格隔开的非负整数$T,C$，分别表示数据组数、每档志愿最多允许填写的导师数目。<br>接下来依次描述每组数据，对于每组数据：</p><ul><li>第$1$行两个用空格隔开的正整数$n,m$。$n,m$分别表示选手的数量、导师的数量。</li><li>第$2$行$m$个用空格隔开的正整数：其中第$i$个整数为$b_i$。$B_i$表示编号为$i$的导师战队人数的上限。</li><li>第$3$行至第$n+2$行，每行$m$个用空格隔开的非负整数：其中第$i+2$行左起第$j$个数为$a_{i,j}$<ul><li>$a_{i,j}$表示编号为$i$的选手将编号为$j$的导师编排在了第$a_{i,j}$志愿。特别地，如果$a_{i,j}=0$，则表示该选手没有将该导师填入志愿表。</li><li>在这一部分，保证每行中不存在某一个正数出现超过$C$次（$0$可能出现超过$C$次），同时保证所有$a_{i,j}\le m$。</li></ul></li><li>第$n+3$行$n$个用空格隔开的正整数，其中第$i$个整数为$S_i$<ul><li>$S_i$表示编号为$i$的选手的理想值。</li><li>在这一部分，保证$S_i\le m$。</li></ul></li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>按顺序输出每组数据的答案。对于每组数据，输出$2$行：</p><ul><li>第$1$行输出$n$个用空格隔开的正整数，其中第$i$个整数的意义为：<ul><li>在最优的录取方案中，编号为$i$的选手会被该档志愿录取。</li><li>特别地，如果该选手出局，则这个数为$m+1$。</li></ul></li><li>第$2$行输出$n$个用空格隔开的非负整数，其中第$i$个整数的意义为：<ul><li>使编号为$i$的选手不沮丧，最少需要让他上升的排名数。</li><li>特别地，如果该选手一定会沮丧，则这个数为$i$。</li></ul></li></ul><a id="more"></a><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 0</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">1 3</span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p><strong>样例解释</strong><br>三组数据分别与题目描述中的三个表格对应。<br>对于第$1$组数据：由于选手$1$没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手$2$按原排名就不沮丧，因此他不需要提升排名。<br>对于第$2$组和第$3$组数据：$1$号选手都不需要提升排名。而希望被第一志愿录取的$2$号选手都必须升到第$1$名才能如愿。<br><strong>数据范围</strong><br>$T\le 5,\;m\le n\le 200,\;B_i\le N$<br><a href="https://www.lydsy.com/JudgeOnline/upload/201804/day2(3).pdf" target="_blank" rel="noopener">原题面</a></p><p>标签：<code>网络流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>九省联考$\mathrm{Day2}$唯一一道有区分度的题。</p><p>容易看出本质就是一个二分图匹配。只不过每条边的优先度是有差别的。<br><strong>第一问</strong><br>先将源点到每个学员流量为$1$的边和导师到汇点的流量为$b$的边连上。<br>顺次考虑每个学员，每次将一个志愿中的所有导师的边加到图里，看能否使其找到匹配，找到就退出，标记此志愿为答案。</p><p><strong>第二问</strong><br>考虑像第一问那样判断，那么就可以每次加入一个学员，判断能否达到要求，当加入一个学员后不能达到要求时，$此时加入的学员数-1$为此人满足要求的最大名次，用其真实名次减去即可得到答案。注意特判无论如何都不能满足的情况。<br>另外，这里还可以二分答案，不过直接暴力加入在$\mathrm{BZOJ}$上已经可以过了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, rk[MAX_N+<span class="number">5</span>], mi[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> b[MAX_N+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n+m+<span class="number">1</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; cpy(); <span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec(); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(s, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) addedge(i+n, t, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)a[p][i].size(); j++)</span><br><span class="line">addedge(p, a[p][i][j]+n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Dinic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, C; read(T), read(C);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">a[i][j].clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= m; j++)</span><br><span class="line">read(x), a[i][x].push_back(j);</span><br><span class="line">build();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (rk[i] = <span class="number">1</span>; rk[i] &lt;= m; rk[i]++)</span><br><span class="line"><span class="keyword">if</span> (inc(i, rk[i], rk[i])) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; i++) &#123;</span><br><span class="line">read(k), mi[i] = i, build();</span><br><span class="line"><span class="keyword">if</span> (!inc(i, <span class="number">1</span>, k)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; mi[i]--; j++) <span class="keyword">if</span> (rk[j] &lt;= m)</span><br><span class="line"><span class="keyword">if</span> (!inc(j, rk[j], rk[j])) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, rk[i]);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, mi[i]);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【2018多省省队联测】劈配&quot;&gt;&lt;a href=&quot;#【2018多省省队联测】劈配&quot; class=&quot;headerlink&quot; title=&quot;【2018多省省队联测】劈配&quot;&gt;&lt;/a&gt;【2018多省省队联测】劈配&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;512\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一年一度的综艺节目《中国新代码》又开始了。$\mathrm{Zayid}$从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。&lt;br&gt;轻车熟路的$\mathrm{Zayid}$顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：&lt;br&gt;总共$n$名参赛选手（编号从$1$至$n$）每人写出一份代码并介绍自己的梦想。接着由所有导师对这些选手进行排名。&lt;br&gt;为了避免后续的麻烦，规定不存在排名并列的情况。&lt;br&gt;同时，每名选手都将独立地填写一份志愿表，来对总共$m$位导师（编号从$1$至$m$）作出评价。志愿表上包含了共$m$档志愿。对于每一档志愿，选手被允许填写最多$C$位导师，每位导师最多被每位选手填写一次（放弃某些导师也是被允许的）。&lt;br&gt;在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。&lt;br&gt;节目组对“前$i$名的录取结果最优”作出如下定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前$1$名的录取结果最优，当且仅当第$1$名被其最高非空志愿录取（特别地，如果第$1$名没有填写志愿表，那么该选手出局）。&lt;/li&gt;
&lt;li&gt;前$i$名的录取结果最优，当且仅当在前$i-1$名的录取结果最优的情况下：第$i$名被其理论可能的最高志愿录取（特别地，如果第i名没有填写志愿表、或其所有志愿中的导师战队均已满员，那么该选手出局）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一种方案满足“前$n$名的录取结果最优”，那么我们可以简称这种方案是最优的。&lt;br&gt;举例而言，$2$位导师$T$老师、$F$老师的战队人数上限分别都是$1$人；$2$位选手$\mathrm{Zayid}$、$\mathrm{DuckD}$分列第$1、2$名。那么下面$3$种志愿表及其对应的最优录取结果如表中所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/upload/201804/111(1).jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。&lt;br&gt;每个人都有一个自己的理想值$s_i$，表示第$i$位同学希望自己被第$s_i$或更高的志愿录取，如果没有，那么他就会非常沮丧。&lt;br&gt;现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。&lt;br&gt;对于每一位选手，$\mathrm{Zayid}$都想知道下面两个问题的答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在最优的录取方案中，他会被第几志愿录取。&lt;/li&gt;
&lt;li&gt;在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为《中国新代码》的实力派代码手，$\mathrm{Zayid}$当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;每个测试点包含多组测试数据，第一行$2$个用空格隔开的非负整数$T,C$，分别表示数据组数、每档志愿最多允许填写的导师数目。&lt;br&gt;接下来依次描述每组数据，对于每组数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第$1$行两个用空格隔开的正整数$n,m$。$n,m$分别表示选手的数量、导师的数量。&lt;/li&gt;
&lt;li&gt;第$2$行$m$个用空格隔开的正整数：其中第$i$个整数为$b_i$。$B_i$表示编号为$i$的导师战队人数的上限。&lt;/li&gt;
&lt;li&gt;第$3$行至第$n+2$行，每行$m$个用空格隔开的非负整数：其中第$i+2$行左起第$j$个数为$a_{i,j}$&lt;ul&gt;
&lt;li&gt;$a_{i,j}$表示编号为$i$的选手将编号为$j$的导师编排在了第$a_{i,j}$志愿。特别地，如果$a_{i,j}=0$，则表示该选手没有将该导师填入志愿表。&lt;/li&gt;
&lt;li&gt;在这一部分，保证每行中不存在某一个正数出现超过$C$次（$0$可能出现超过$C$次），同时保证所有$a_{i,j}\le m$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第$n+3$行$n$个用空格隔开的正整数，其中第$i$个整数为$S_i$&lt;ul&gt;
&lt;li&gt;$S_i$表示编号为$i$的选手的理想值。&lt;/li&gt;
&lt;li&gt;在这一部分，保证$S_i\le m$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;按顺序输出每组数据的答案。对于每组数据，输出$2$行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第$1$行输出$n$个用空格隔开的正整数，其中第$i$个整数的意义为：&lt;ul&gt;
&lt;li&gt;在最优的录取方案中，编号为$i$的选手会被该档志愿录取。&lt;/li&gt;
&lt;li&gt;特别地，如果该选手出局，则这个数为$m+1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第$2$行输出$n$个用空格隔开的非负整数，其中第$i$个整数的意义为：&lt;ul&gt;
&lt;li&gt;使编号为$i$的选手不沮丧，最少需要让他上升的排名数。&lt;/li&gt;
&lt;li&gt;特别地，如果该选手一定会沮丧，则这个数为$i$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1911【APIO2010】特别行动队 &lt;斜率优化&gt;</title>
    <link href="http://azrael.top/BZOJ1911%E3%80%90APIO2010%E3%80%91%E7%89%B9%E5%88%AB%E8%A1%8C%E5%8A%A8%E9%98%9F%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://azrael.top/BZOJ1911【APIO2010】特别行动队 斜率优化/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-16T03:39:04.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2010】特别行动队"><a href="#【APIO2010】特别行动队" class="headerlink" title="【APIO2010】特别行动队"></a>【APIO2010】特别行动队</h3><p>$\mathrm{Time\;Limit:\;4\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/1911_1.jpg" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/1911_2.jpg" alt=""><br></center><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/1911_3.jpg" alt=""><br></center><a id="more"></a><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">-1 10 -20</span><br><span class="line">2 2 3 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><p>标签：<code>斜率优化DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先易得$\mathrm{DP}$方程：设$f[i]$为考虑前$i$人的最大收益，则$f[i]=\max_{j=0}^{i-1}\lbrace{A\times(S_i-S_j)^2+B\times(S_i-S_j)+C+f[j]}\rbrace$。<br>那么推一推：<br>$$<br>\begin{aligned}<br>f[i]&amp;=\max_{j=0}^{i-1}\lbrace{A\times(S_i-S_j)^2+B\times(S_i-S_j)+C+f[j]}\rbrace\\<br>&amp;=\max_{j=0}^{i-1}\lbrace{A\times S_i^2-A\times S_j^2+2A\times S_i\times S_j+B\times S_i-B\times S_j+C+f[j]}\rbrace\\<br>&amp;=\max_{j=0}^{i-1}\lbrace{-2AS_j\times S_i+(A\times S_j^2-B\times S_j+f[j])}\rbrace+A\times S_i^2+B\times S_i+C\\<br>\end{aligned}<br>$$<br>发现中间$-2AS_j\times S_i+(A\times S_j^2-B\times S_j+f[j])$是一次函数，那么对于两个位置$p,q\;(p&lt;q)$，若$q$比$p$优秀，则有：<br>$$<br>\begin{aligned}<br>Let\;k_p=-2AS_p,\;b_p&amp;=A\times S_p^2-B\times S_p+f[p]\\<br>k_pS_i+b_p&amp;&lt; k_qS_i+b_q\\<br>S_i&amp;\le\frac{b_p-b_q}{k_q-k_p}<br>\end{aligned}<br>$$<br>按照此斜率维护单调栈即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, que[MAX_N+<span class="number">5</span>], l, r; lnt A, B, C;</span><br><span class="line">lnt s[MAX_N+<span class="number">5</span>], k[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>], f[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">dnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> (dnt)(b[x]-b[y])/(dnt)(k[y]-k[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(A), read(B), read(C);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), s[i] = s[i<span class="number">-1</span>]+x;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; que[<span class="number">0</span>] = <span class="number">0</span>, b[<span class="number">0</span>] = C;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; calc(que[l], que[l+<span class="number">1</span>]) &lt;= s[i]) l++;</span><br><span class="line">f[i] = k[que[l]]*s[i]+b[que[l]]+A*s[i]*s[i]+B*s[i];</span><br><span class="line">k[i] = <span class="number">-2</span>*A*s[i], b[i] = A*s[i]*s[i]-B*s[i]+C+f[i];</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; calc(que[r], i) &lt;= calc(que[r<span class="number">-1</span>], que[r])) r--;</span><br><span class="line">que[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2010】特别行动队&quot;&gt;&lt;a href=&quot;#【APIO2010】特别行动队&quot; class=&quot;headerlink&quot; title=&quot;【APIO2010】特别行动队&quot;&gt;&lt;/a&gt;【APIO2010】特别行动队&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;4\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/1911_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/1911_2.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/1911_3.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://azrael.top/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3675【APIO2014】序列分割 &lt;斜率优化&gt;</title>
    <link href="http://azrael.top/BZOJ3675%E3%80%90APIO2014%E3%80%91%E5%BA%8F%E5%88%97%E5%88%86%E5%89%B2%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://azrael.top/BZOJ3675【APIO2014】序列分割 斜率优化/</id>
    <published>2018-04-12T16:00:00.000Z</published>
    <updated>2018-04-16T03:59:00.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2014】序列分割"><a href="#【APIO2014】序列分割" class="headerlink" title="【APIO2014】序列分割"></a>【APIO2014】序列分割</h3><p>$\mathrm{Time\;Limit:\;40\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{小H}$最近迷上了一个分隔序列的游戏。<br>在这个游戏里，$\mathrm{小H}$需要将一个长度为$n$的非负整数序列分割成$k+1$个非空的子序列。<br>为了得到$k+1$个子序列，$\mathrm{小H}$需要重复$k$次以下的步骤：</p><ol><li>$\mathrm{小H}$首先选择一个长度超过$1$的序列（一开始$\mathrm{小H}$只有一个长度为$n$的序列，也就是一开始得到的整个序列）</li><li>选择一个位置，并通过这个位置将这个序列分割成连续的两个非空的新序列</li></ol><p>每次进行上述步骤之后，$\mathrm{小H}$将会得到一定的分数。这个分数为两个新序列中元素和的乘积。<br>$\mathrm{小H}$希望选择一种最佳的分割方式，使得$k$轮之后，$\mathrm{小H}$的总得分最大。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行包含两个整数$n,k\;(k+1\le n)$。<br>第二行包含$n$个非负整数$a_1,a_2,\cdots,a_n\;(0\le a_i\le10^4)$，表示一开始$\mathrm{小H}$得到的序列。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出第一行包含一个整数，为$\mathrm{小H}$可以得到的最大分数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br><span class="line">4 1 3 4 0 2 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">108</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>在样例中，$\mathrm{小H}$可以通过如下3轮操作得到108分： </p><ol><li>一开始$\mathrm{小H}$有一个序列$(4,1,3,4,0,2,3)$。$\mathrm{小H}$选择在第$1$个数之后的位置将序列分成两部分，并得到$4\times (1+3+4+0+2+3)=52$分。 </li><li>这一轮开始时$\mathrm{小H}$有两个序列：$(4),\;(1,3,4,0,2,3)$。$\mathrm{小H}$选择在第3个数字之后的位置将第二个序列分成两部分，并得到$(1+3)\times(4+0+2+3)=36$分。 </li><li>这一轮开始时$\mathrm{小H}$有三个序列：$(4),\;(1,3),\;(4,0,2,3)$。$\mathrm{小H}$选择在第$5$个数字之后的位置将第三个序列分成两部分，并得到$(4+0)\times(2+3)=20$分。 </li></ol><p>经过上述三轮操作，$\mathrm{小H}$将会得到四个子序列：$(4),\;(1,3),\;(4,0),\;(2,3)$并总共得到$52+36+20=108$分。 </p><p>标签：<code>斜率优化DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>易得$\mathrm{DP}$方程：$f[t][i]$表示玩$t$轮时只考虑$[1,i]$区间内的数的最大贡献。那么有$f[t][i]=\max_{j=0}^{i-1}\lbrace{f[t-1][j]+(S_i-S_j)\times S_j}\rbrace$。<br>简单推一推：<br>$$<br>\begin{aligned}<br>f[t][i]&amp;=\max_{j=0}^{i-1}\lbrace{f[t-1][j]+(S_i-S_j)\times S_j}\rbrace\\<br>&amp;=\max_{j=0}^{i-1}\lbrace{f[t-1][j]+S_j\times S_i-S_j^2}\rbrace\\<br>&amp;=\max_{j=0}^{i-1}\lbrace{S_iS_j+f[t-1][j]-S_j^2}\rbrace\\<br>\end{aligned}<br>$$<br>套上斜率优化：<br>$$<br>For\;i\in[1,n],\;if\;p&lt;q,\;q\;is\;better\;than\;p,\;then\\<br>S_pS_i+f[t-1][p]-S_p^2\le S_qS_i+f[t-1][q]-S_q^2\\<br>Let\;a_n=S_n,\;b_n=f[t-1][n]-S_n^2,\\<br>then\;(a_p-a_q)S_i\le b_q-b_p\\<br>\therefore If\;(a_p-a_q)S_i\le b_q-b_p,\;then\;we\;can\;pop\;p\;out\;of\;the\;stack.<br>$$<br>注意这里不要写成斜率的形式，因为$a_p-a_q$可能等于$0$。<br>按照不等式用单调栈对每层$k$进行维护即可，这里可以做$k$次一维$\mathrm{DP}$，每次重新算$b$数组。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, l, r, que[MAX_N+<span class="number">5</span>]; lnt s[MAX_N+<span class="number">5</span>];</span><br><span class="line">lnt f[MAX_N+<span class="number">5</span>], a[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">lnt x = (b[p]-b[que[r]])*(a[que[r<span class="number">-1</span>]]-a[que[r]]);</span><br><span class="line">lnt y = (b[que[r]]-b[que[r<span class="number">-1</span>]])*(a[que[r]]-a[p]);</span><br><span class="line"><span class="keyword">return</span> x &lt;= y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), s[i] = s[i<span class="number">-1</span>]+x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">a[i] = s[i], b[i] = -s[i]*s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">que[l = r = <span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; s[i]*(a[que[l]]-a[que[l+<span class="number">1</span>]]) &lt;= b[que[l+<span class="number">1</span>]]-b[que[l]]) l++;</span><br><span class="line">f[i] = a[que[l]]*s[i]+b[que[l]]; <span class="keyword">while</span> (l &lt; r &amp;&amp; chk(i, l, r)) r--; que[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = f[i]-s[i]*s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2014】序列分割&quot;&gt;&lt;a href=&quot;#【APIO2014】序列分割&quot; class=&quot;headerlink&quot; title=&quot;【APIO2014】序列分割&quot;&gt;&lt;/a&gt;【APIO2014】序列分割&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;40\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{小H}$最近迷上了一个分隔序列的游戏。&lt;br&gt;在这个游戏里，$\mathrm{小H}$需要将一个长度为$n$的非负整数序列分割成$k+1$个非空的子序列。&lt;br&gt;为了得到$k+1$个子序列，$\mathrm{小H}$需要重复$k$次以下的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\mathrm{小H}$首先选择一个长度超过$1$的序列（一开始$\mathrm{小H}$只有一个长度为$n$的序列，也就是一开始得到的整个序列）&lt;/li&gt;
&lt;li&gt;选择一个位置，并通过这个位置将这个序列分割成连续的两个非空的新序列&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每次进行上述步骤之后，$\mathrm{小H}$将会得到一定的分数。这个分数为两个新序列中元素和的乘积。&lt;br&gt;$\mathrm{小H}$希望选择一种最佳的分割方式，使得$k$轮之后，$\mathrm{小H}$的总得分最大。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入第一行包含两个整数$n,k\;(k+1\le n)$。&lt;br&gt;第二行包含$n$个非负整数$a_1,a_2,\cdots,a_n\;(0\le a_i\le10^4)$，表示一开始$\mathrm{小H}$得到的序列。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出第一行包含一个整数，为$\mathrm{小H}$可以得到的最大分数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="斜率优化" scheme="http://azrael.top/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3730 震波 &lt;动态点分治&gt;</title>
    <link href="http://azrael.top/BZOJ3730%20%E9%9C%87%E6%B3%A2%20%E5%8A%A8%E6%80%81%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>http://azrael.top/BZOJ3730 震波 动态点分治/</id>
    <published>2018-04-09T16:00:00.000Z</published>
    <updated>2018-04-14T08:43:17.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="震波"><a href="#震波" class="headerlink" title="震波"></a>震波</h3><p>$\mathrm{Time\;Limit:\;15\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一片土地上有$N$个城市，通过$N-1$条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为$1$，其中第i个城市的价值为$value_i$。<br>不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。<br>接下来你需要在线处理$M$次操作：</p><ul><li>$0\;x\;k$ 表示发生了一次地震，震中城市为$x$，影响范围为$k$，所有与$x$距离不超过$k$的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。</li><li>$1\;x\;y$ 表示第$x$个城市的价值变成了$y$。</li></ul><p>为了体现程序的在线性，操作中的$x,y,k$都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为$0$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个正整数$N$和$M$。<br>第二行包含$N$个正整数，第$i$个数表示$value_i$。<br>接下来$N-1$行，每行包含两个正整数$u,v$，表示$u$和$v$之间有一条无向边。<br>接下来$M$行，每行包含三个数，表示$M$次操作。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>包含若干行，对于每个询问输出一行一个正整数表示答案。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8 1</span><br><span class="line">1 10 100 1000 10000 100000 1000000 10000000</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br><span class="line">3 7</span><br><span class="line">3 8</span><br><span class="line">0 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11100101</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$1\le N,M\le10^5$<br>$1\le u,v,x\le N$<br>$1\le value_i,y\le10^4$<br>$0\le k\le N-1$</p><p>标签：<code>动态点分治</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>终于学会动态点分辣QAQ~<br>赶快来肝几道基础题</p><p>先不考虑时间复杂度，那么对于每个$0$操作显然可以暴力从震源向上爬统计答案。每次加上当前子树中距离符合题意的点，再减去其儿子（就是向上爬时此点的前驱）的子树中与其算重复的点。这样维护两个树状数组即可。<br>但是树高可以构造比$\log n$大，这时就需要建立点分树，把树高降成$\log n$。</p><p>提取重心建立点分树，对每个分治中心维护两个树状数组，第一个是其子树中到此分治中心的每种距离的所有点的点权和，第二个是其子树中到此分治中心的上一层分治中心的每种距离的所有点的点权和。<br>这样对于询问，每次$\log n$向上爬，爬到每个分治中心$\log size$统计；对于修改，每次$\log n$向上爬，爬到每个分治中心$\log size$更新树状数组即可。这样总复杂度是$O(Q\log^2n)$。</p><p>不过此题有些卡常，有三种策略：</p><ol><li>用$\mathrm{RMQ}$做$\mathrm{LCA}$</li><li>带<code>fread</code>大读优</li><li>将$n$棵树状数组建到同一个大数组上，每个$\mathrm{BIT}$记录其起始指针和终止指针，可以避免<code>vector</code>的一些常数</li></ol><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, e, c[MAX_N+<span class="number">5</span>], fa[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> w[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>], rt, tot;</span><br><span class="line"><span class="keyword">int</span> anc[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>], dep[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> *p0[MAX_N+<span class="number">5</span>], *p1[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> BIT0[MAX_N*<span class="number">100</span>], BIT1[MAX_N*<span class="number">100</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, nxt;&#125; E[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;E[e] = (node)&#123;v, pr[u]&#125;, pr[u] = e++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> *tr, <span class="keyword">int</span> p, <span class="keyword">int</span> x, <span class="keyword">int</span> l)</span> </span>&#123;<span class="keyword">for</span> (p = min(p+<span class="number">1</span>, l); p &lt;= l; p += (p&amp;-p)) tr[p] += x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *tr, <span class="keyword">int</span> p, <span class="keyword">int</span> l)</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; <span class="keyword">for</span> (p = min(p+<span class="number">1</span>, l); p; p -= (p&amp;-p)) ret += tr[p]; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOG; i++)</span><br><span class="line">anc[u][i] =anc[anc[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> ((v = E[i].v) ^ anc[u][<span class="number">0</span>])</span><br><span class="line">anc[v][<span class="number">0</span>] = u, dep[v] = dep[u]+<span class="number">1</span>, init(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[a] &lt; dep[b]) swap(a, b);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (dep[a]-(<span class="number">1</span>&lt;&lt;i) &gt;= dep[b]) a = anc[a][i];</span><br><span class="line"><span class="keyword">if</span> (a == b) <span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--) <span class="keyword">if</span> (anc[a][i]^anc[b][i])</span><br><span class="line">a = anc[a][i], b = anc[b][i];</span><br><span class="line"><span class="keyword">return</span> anc[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> dep[u]+dep[v]<span class="number">-2</span>*dep[LCA(u, v)];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsz</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (((v = E[i].v) ^ f) &amp;&amp; !mrk[v])</span><br><span class="line">ret += getsz(v, u);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>, w[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (((v = E[i].v) ^ f) &amp;&amp; !mrk[v])</span><br><span class="line">getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]);</span><br><span class="line">w[u] = max(w[u], tot-sz[u]); <span class="keyword">if</span> (w[u] &lt; w[rt]) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">rt = <span class="number">0</span>, tot = getsz(u, <span class="number">0</span>), getrt(u, <span class="number">0</span>);</span><br><span class="line">fa[u = rt] = f, mrk[u] = <span class="literal">true</span>, sz[u] = tot+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v]) divide(v, u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">inc(p0[x], <span class="number">0</span>, y, sz[x]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = x; fa[u]; u = fa[u]) &#123;</span><br><span class="line"><span class="keyword">int</span> dis = dist(fa[u], x);</span><br><span class="line">inc(p1[u], dis, y, sz[u]);</span><br><span class="line">inc(p0[fa[u]], dis, y, sz[fa[u]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = sum(p0[x], y, sz[x]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = x, dis; fa[u]; u = fa[u]) <span class="keyword">if</span> ((dis = dist(fa[u], x)) &lt;= y)</span><br><span class="line">ret += sum(p0[fa[u]], y-dis, sz[fa[u]])-sum(p1[u], y-dis, sz[u]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), w[<span class="number">0</span>] = n;</span><br><span class="line"><span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(c[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++)</span><br><span class="line">read(u), read(v), addedge(u, v), addedge(v, u);</span><br><span class="line">init(<span class="number">1</span>), divide(<span class="number">1</span>, <span class="number">0</span>); <span class="keyword">int</span> cnt = <span class="number">0</span>, lst = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; cnt += sz[i++]+<span class="number">1</span>)</span><br><span class="line">p0[i] = BIT0+cnt, p1[i] = BIT1+cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) modify(i, c[i]);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, x, y; read(opt);</span><br><span class="line">read(x), read(y), x ^= lst, y ^= lst;</span><br><span class="line"><span class="keyword">if</span> (opt) modify(x, y-c[x]), c[x] = y;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, lst = query(x, y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;震波&quot;&gt;&lt;a href=&quot;#震波&quot; class=&quot;headerlink&quot; title=&quot;震波&quot;&gt;&lt;/a&gt;震波&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;15\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在一片土地上有$N$个城市，通过$N-1$条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为$1$，其中第i个城市的价值为$value_i$。&lt;br&gt;不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。&lt;br&gt;接下来你需要在线处理$M$次操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$0\;x\;k$ 表示发生了一次地震，震中城市为$x$，影响范围为$k$，所有与$x$距离不超过$k$的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。&lt;/li&gt;
&lt;li&gt;$1\;x\;y$ 表示第$x$个城市的价值变成了$y$。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了体现程序的在线性，操作中的$x,y,k$都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为$0$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个正整数$N$和$M$。&lt;br&gt;第二行包含$N$个正整数，第$i$个数表示$value_i$。&lt;br&gt;接下来$N-1$行，每行包含两个正整数$u,v$，表示$u$和$v$之间有一条无向边。&lt;br&gt;接下来$M$行，每行包含三个数，表示$M$次操作。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;包含若干行，对于每个询问输出一行一个正整数表示答案。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树分治" scheme="http://azrael.top/tags/%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>SCOI2018总结</title>
    <link href="http://azrael.top/SCOI2018%E6%80%BB%E7%BB%93/"/>
    <id>http://azrael.top/SCOI2018总结/</id>
    <published>2018-04-07T16:00:00.000Z</published>
    <updated>2018-04-25T14:45:48.762Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SCOI2018模拟退役记"><a href="#SCOI2018模拟退役记" class="headerlink" title="SCOI2018模拟退役记"></a>SCOI2018模拟退役记</h1><a id="more"></a><h2 id="集训"><a href="#集训" class="headerlink" title="集训"></a>集训</h2><h3 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h3><p>到成电打校赛，中午吃饭碰到$\mathrm{Joker}$和$\mathrm{dxymaster}$，一起骑车去考场。<br>结果走错门了，绕了$20\;\mathrm{min}$才绕过去。</p><p>比赛$14:20$才开始，貌似是内网出了点小锅。刚刚拿到题我们三人都蒙了，看了$40\;\mathrm{min}$才找到签到题。$\mathrm{D}$和$\mathrm{G}$都很水，$\mathrm{OwenOwl}$和$\mathrm{Joker}$各做一道，我在看$\mathrm{Joker}$给的一道类似文理分科建模的网络流图。先过了两道签到题，接着$\mathrm{OwenOwl}$就看出$\mathrm{J}$的贪心了。于是三道签到题就搞定了。</p><p>接着我和$\mathrm{Joker}$开始肛$\mathrm{K}$，这时全场没人过$\mathrm{K}$，所以我们有点虚。发现和文理分科不一样的是这个模的贡献可能有负数，然后我就懵逼了…$\mathrm{Joker}$机智地想到了把正负拆成差的方法，这样边权都是正的了。我直接套上我洛谷的网络流板，一发过样例，交了，然后…然后…$\mathrm{Wrong\;Answer\;on\;test\;1}$…</p><p>我和$\mathrm{Joker}$开始肉眼查错，发现我的当前弧是错的…洛谷的板题是给出$S$和$T$，所以当前弧每次复原是循环$1\sim n$，而$\mathrm{K}$中建模$S$时$0$号点，$T$是$n+m+1$，然后就$\mathrm{GG}$了。改了再交，$\mathrm{Accepted}$，惊奇地发现一血了。过了两分钟，柱神他们也过了$\mathrm{K}$。</p><p>接下来$\mathrm{Joker}$和$\mathrm{OwenOwl}$开始肛$\mathrm{B}$，傻逼主席树，不过容易写错。封榜的时候交了$\mathrm{A}$，然后我们队就$\mathrm{rank\;5}$了。</p><p>话说我好像全程抱大腿…<br>$\mathrm{\%\%\%Joker\;\;\;\%\%\%OwenOwl}$</p><h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>到中和中学参加省选集训，本来还期待能学些东西，结果上午全程骑车。某天津老师来讲异或方程组，先水了$40\;\mathrm{min}$高消，然后用了各种技巧避开线性基水了若干线性基裸题…只能说这老师$拖时间能力\to\infty$。</p><p>下午去体验机房，在初中生高度的座位上颓颓颓。神机安了$5$个五笔输入法，而且开新页面会默认调成拼音输入法。什么编译器都没有，分辨率出翔…</p><p>晚上回酒店，刷水搞了几道线性基，然后颓颓颓。厕所漏水严重，水管工貌似修不好，凑合凑合。</p><h3 id="Day-2"><a href="#Day-2" class="headerlink" title="Day 2"></a>Day 2</h3><p>$\mathrm{THU}$巨佬讲博弈论，讲得挺好。前半场很简单，开热点刷题。最后讲了尼姆积，玄学玩意儿，不过听懂了，这东西虽然精妙，但是题目并不是很常见。</p><p>下午继续刷题，居然没颓。</p><p>晚上继续刷题，十点过和$\mathrm{YY}$颓了一会儿炉石。</p><h3 id="Day-3"><a href="#Day-3" class="headerlink" title="Day 3"></a>Day 3</h3><p>成电学生来讲数论，全程划水。讲了一些并无卵用的东西，而且就讲了一些素数论的皮毛，$\mathrm{NOIp}$难度。补觉补觉。</p><p>下午刷题，刷完颓颓颓。</p><p>晚上打了几个板子，继续颓。</p><h3 id="Day-4"><a href="#Day-4" class="headerlink" title="Day 4"></a>Day 4</h3><p>上午省选模拟，抱着划水的心态边打弹球边写（中和中学机房最好的地方就是有三维弹球）。$\mathrm{T1}$状压$\mathrm{DP}$，打了一个玄学做法，考完发现有锅，结果考试的时候并没有$\mathrm{WA}$，最后两个点卡常$\mathrm{TLE}$了。$\mathrm{T2}$没想到贪心，暴力滚粗。$\mathrm{T3}$暴力，不过评测的时候貌似$\mathrm{CE}$了，而且好像好几个人都$\mathrm{CE}$了。</p><p>下午赶到清水河，晚上打了几个板子，睡前膜一膜$\mathrm{OwenOwl}$和$\mathrm{Joker}$</p><h2 id="正式考试"><a href="#正式考试" class="headerlink" title="正式考试"></a>正式考试</h2><h3 id="Day-1-1"><a href="#Day-1-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>考前听到$\mathrm{XXX}$说不能用<code>bits/stdc++.h</code>，我信了。</p><p>上考场先看了看题，黑人问号$\mathrm{.jpg}$。没$\mathrm{DP}$？$\mathrm{T1}$动态点分？$\mathrm{T2}$数据结构？（考完才发现我有多$\mathrm{naive}$）$\mathrm{T3}$什么玄学玩意儿？</p><p>先肛$\mathrm{T2}$，并没有想出去除$c_u\times c_v$影响的办法，于是打$45\;\mathrm{pts}$翻译滚粗。</p><p>回去看$\mathrm{T1}$，写不熟动态点分，而且貌似不好维护，再加上卡点分树空间，直接想如何骗分。$\mathrm{yy}$出一种暴力爬树高统计的方法，期待数据有随机点。对拍+调试花了$\mathrm{2h}$。$0.6\;s$过了大样例，感觉挺稳。</p><p>最后剩$\mathrm{30\;min}$做$\mathrm{T3}$。好不容易把题读懂，打了暴力$\mathrm{BFS}$，不过貌似并没有暴力分。</p><p>考完下来预估$\mathrm{50+45=95\;pts}$。</p><p>下午接到成绩，心态崩了…爆$0$滚粗。查分发现前两道都$\mathrm{CE}$了，最后一道肯定没分。电子科大神机的$\mathrm{MinGW}$版本很低，然后和$\mathrm{vim}$适配的时候出锅了。所以在$\mathrm{vim}$下编辑，用<code>memset</code>可以不开<code>cstring</code>，用<code>sort</code>可以不开<code>algorithm</code>。我的$\mathrm{95\;pts}$就这样送了。</p><p>晚上开会发现$\mathrm{myjs}$和我$\mathrm{T1}$写的一样的算法，他拿了$\mathrm{70\;pts}$，我：……</p><h3 id="Day-2-1"><a href="#Day-2-1" class="headerlink" title="Day 2"></a>Day 2</h3><p>改用<code>bits/stdc++.h</code>，不要又$\mathrm{CE}$。</p><p>前一天$\mathrm{CE}$爆$0$整个心态都炸了。于是抱着划水的心态考$\mathrm{Day\;2}$。一鼓作气，三道暴力，先花$\mathrm{1.5\;h}$把三道暴力写了，发现$\mathrm{T1}$可做，开始肛。</p><p>考试的时候有点懵，没直接用绝对值函数分开维护，而是分$9$种情况维护凸函数。写了$\mathrm{1.5\;h}$才大致理清楚。结果过了小样例，没过$n=50$的另一个小样例。赶紧对拍，然后补锅。耗了$\mathrm{1.5\;h}$才过$n=50$的样例。然后随手造了一个$n=100$的数据，崩溃地发现$\mathrm{WA}$了…弃疗扫雷（我貌似没有找到做蛋糕）。</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>在退役的边缘试探$\mathrm{.jpg}$</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SCOI2018模拟退役记&quot;&gt;&lt;a href=&quot;#SCOI2018模拟退役记&quot; class=&quot;headerlink&quot; title=&quot;SCOI2018模拟退役记&quot;&gt;&lt;/a&gt;SCOI2018模拟退役记&lt;/h1&gt;
    
    </summary>
    
    
      <category term="总结" scheme="http://azrael.top/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3944 Sum &lt;杜教筛&gt;</title>
    <link href="http://azrael.top/BZOJ3944%20Sum%20%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    <id>http://azrael.top/BZOJ3944 Sum 杜教筛/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-04-12T14:45:55.652Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/upload/201504/aaa.PNG" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一共$T+1$行<br>第$1$行为数据组数$T(T\le10)$<br>第$2\sim T+1$行每行一个非负整数$N$，代表一组询问</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一共$T$行，每行两个用空格分隔的数$ans_1,ans_2$<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">13</span><br><span class="line">30</span><br><span class="line">2333</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">2 0</span><br><span class="line">22 -2</span><br><span class="line">58 -3</span><br><span class="line">278 -3</span><br><span class="line">1655470 2</span><br></pre></td></tr></table></figure><p>标签：<code>杜教筛</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>杜教筛板题。</p><p>首先推杜教筛通式。<br>对于积性函数$f,g,h$，若$h=f\otimes g$，即$h(n)=\sum_{d|n}f(d)g(\frac{n}{d})$，那么可以得到<br>$$<br>\begin{aligned}<br>\sum_{i=1}^{n}h(i)&amp;=\sum_{i=1}^{n}\sum_{d|i}f(d)g(\frac{n}{d})\\<br>&amp;=\sum_{i=1}^{n}g(i)\sum_{d=1}^{\lfloor n/i\rfloor}f(d)\\<br>&amp;=\sum_{i=1}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)\\<br>&amp;=\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)+g(1)S(n)\\<br>\therefore S(n)&amp;=\frac{\sum_{i=1}^{n}h(i)-\sum_{i=2}^{n}g(i)S(\lfloor\frac{n}{i}\rfloor)}{g(1)}<br>\end{aligned}<br>$$<br>这样就可以预处理较小的$S$后数论分块求解。</p><p>然后对于题目中的两问分别推式子：<br>$$<br>Calculate\;\sum_{i=1}^{n}\mu(i).\\<br>\begin{aligned}<br>&amp;\because\sum_{d|n}\mu(d)=[n=1]=e(n)\\<br>&amp;\therefore e=\mu\otimes1\\<br>&amp;\Rightarrow S(n)=1-\sum_{i=2}^{n}S(\lfloor\frac{n}{i}\rfloor)<br>\end{aligned}<br>$$<br>$$<br>Calculate\;\sum_{i=1}^{n}\varphi(i).\\<br>\begin{aligned}<br>&amp;\because\sum_{d|n}\varphi(d)=n=id(n)\\<br>&amp;\therefore id=\varphi\otimes1\\<br>&amp;\Rightarrow S(n)=\frac{n\times(n+1)}{2}-\sum_{i=2}^{n}S(\lfloor\frac{n}{i}\rfloor)<br>\end{aligned}<br>$$</p><p>注意将两个答案的求解放在一起，用<code>pair&lt;long,long&gt;</code>返回，否则可能$\mathrm{TLE}$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MX 2500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pll pair<span class="meta-string">&lt;lnt,lnt&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt, pri[MX+<span class="number">5</span>]; lnt phi[MX+<span class="number">5</span>], mu[MX+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> NotPri[MX+<span class="number">5</span>]; <span class="built_in">map</span> &lt;lnt, lnt&gt; ex1, ex2;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">phi[<span class="number">1</span>] = mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MX; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, phi[i] = i<span class="number">-1</span>, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MX) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) phi[i*pri[j]] = phi[i]*(pri[j]<span class="number">-1</span>), mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;phi[i*pri[j]] = phi[i]*pri[j], mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">phi[i] += phi[i<span class="number">-1</span>], mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pll <span class="title">sum</span><span class="params">(lnt n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= MX) <span class="keyword">return</span> mp(phi[n], mu[n]);</span><br><span class="line"><span class="keyword">if</span> (ex1[n]) <span class="keyword">return</span> mp(ex1[n], ex2[n]);</span><br><span class="line">lnt ret1 = <span class="number">1L</span>L*n*(n+<span class="number">1</span>)/<span class="number">2</span>, ret2 = <span class="number">1L</span>L; pll t;</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">2</span>, r; l &lt;= n; l = r+<span class="number">1</span>)</span><br><span class="line">r = n/(n/l), t = sum(n/l), </span><br><span class="line">ret1 -= <span class="number">1L</span>L*(r-l+<span class="number">1</span>)*t.fir, </span><br><span class="line">ret2 -= <span class="number">1L</span>L*(r-l+<span class="number">1</span>)*t.sec;</span><br><span class="line"><span class="keyword">return</span> mp(ex1[n] = ret1, ex2[n] = ret2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(lnt n)</span> </span>&#123;</span><br><span class="line">pll ans = sum(n);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans.fir, ans.sec);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lnt T, n;read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) read(n), sol(n);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;Sum&quot;&gt;&lt;a href=&quot;#Sum&quot; class=&quot;headerlink&quot; title=&quot;Sum&quot;&gt;&lt;/a&gt;Sum&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/upload/201504/aaa.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一共$T+1$行&lt;br&gt;第$1$行为数据组数$T(T\le10)$&lt;br&gt;第$2\sim T+1$行每行一个非负整数$N$，代表一组询问&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一共$T$行，每行两个用空格分隔的数$ans_1,ans_2$&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="杜教筛" scheme="http://azrael.top/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2756【SCOI2012】奇怪的游戏 &lt;二分答案+网络流&gt;</title>
    <link href="http://azrael.top/BZOJ2756%E3%80%90SCOI2012%E3%80%91%E5%A5%87%E6%80%AA%E7%9A%84%E6%B8%B8%E6%88%8F%20%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ2756【SCOI2012】奇怪的游戏 网络流/</id>
    <published>2018-04-03T16:00:00.000Z</published>
    <updated>2018-04-17T04:43:22.432Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2012】奇怪的游戏"><a href="#【SCOI2012】奇怪的游戏" class="headerlink" title="【SCOI2012】奇怪的游戏"></a>【SCOI2012】奇怪的游戏</h3><p>$\mathrm{Time\;Limit:\;40\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Blinker}$最近喜欢上一个奇怪的游戏。<br>这个游戏在一个$N\times M$的棋盘上玩，每个格子有一个数。每次$\mathrm{Blinker}$会选择两个相邻的格子，并使这两个数都加上$1$。<br>现在$\mathrm{Blinker}$想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出$-1$。 </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行是一个整数$T$，表示输入数据有$T$轮游戏组成。<br>每轮游戏的第一行有两个整数$N$和$M$， 分别代表棋盘的行数和列数。<br>接下来有$N$行，每行$M$个数。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2 </span><br><span class="line">2 2 </span><br><span class="line">1 2 </span><br><span class="line">2 3 </span><br><span class="line">3 3 </span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">4 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">-1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$30\%$的数据，保证$T\le10,\;1\le N,M\le8$<br>对于$100\%$的数据，保证$T\le10,\;1\le N,M\le40$，所有数为正整数且小于$10^9$ </p><p>标签：<code>网络流</code> <code>黑白染色</code> <code>二分答案</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>黑白染色，两色个数为$c_1$和$c_2$，两色初始数字和为$s_1$和$s_2$。则有<br>$$<br>c_1\times x-s_1=c_2\times x-s_2\\<br>(c_1-c_2)\times x=s_1-s_2\\<br>$$<br>当$c_1\ne c_2$时，可以直接解出$x$，这时网络流$check$一下是否可能达到即可。<br>当$c_1=c_2$时，每次操作都会使一定能在某一基础上将所有格子都$+1$，那么所有大于等于最小$x$的值都可以达到，具有二分性。那么二分$x$，网络流$check$即可。</p><p>对于网络流$check$，建图如下：</p><ul><li>对于白格$i$，连接$S\to i\;[cap=x-val_i]$</li><li>对于黑格$i$，连接$i\to T\;[cap=x-val_i]$</li><li>对于每组相邻点$x,y$，连接$x\to y\;[cap=\infty]$</li></ul><p>再计算一个$tot=所有白格的值与x的差之和$<br>若$最大流=tot$，则当前$x$可行。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF (1LL&lt;&lt;50)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> nxt[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, nxt; lnt c;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> col[<span class="number">50</span>][<span class="number">50</span>], c0, c1; lnt a[<span class="number">50</span>][<span class="number">50</span>], s0, s1, mx;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">p</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="keyword">return</span> x*m-m+y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n*m+<span class="number">1</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;E[cnt] = (node)&#123;v, pr[u], c&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v;lnt c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, lnt flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;lnt ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v;lnt c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">lnt tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function">lnt <span class="title">Dinic</span><span class="params">()</span> </span>&#123;lnt ret = <span class="number">0</span>; cpy(); <span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec(); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(lnt x)</span> </span>&#123;</span><br><span class="line">init();lnt tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (col[i][j])</span><br><span class="line">addedge(s, p(i, j), x-a[i][j]), tot += x-a[i][j];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (!col[i][j])</span><br><span class="line">addedge(p(i, j), t, x-a[i][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (col[i][j])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i+nxt[k][<span class="number">0</span>], y = j+nxt[k][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">1</span> || x &gt; n || y &lt; <span class="number">1</span> || y &gt; m) <span class="keyword">continue</span>;</span><br><span class="line">addedge(p(i, j), p(x, y), INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Dinic() == tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">bi_search</span><span class="params">(lnt l, lnt r)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = mid, r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">color</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mx = c0 = c1 = s0 = s1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">col[i][j] = (i+j)&amp;<span class="number">1</span>, </span><br><span class="line">(col[i][j] ? c1++ : c0++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">read(n), read(m), color();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">read(a[i][j]), mx = max(mx, a[i][j]), </span><br><span class="line">(col[i][j] ? s1 += a[i][j] : s0 += a[i][j]);</span><br><span class="line"><span class="keyword">if</span> (c0^c1) &#123;</span><br><span class="line"><span class="keyword">if</span> ((s0-s1)/(c0-c1) &gt;= m &amp;&amp; chk((s0-s1)/(c0-c1)))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (s0-s1)/(c0-c1)*c0-s0);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (s0^s1) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, bi_search(mx, INF)*c0-s0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2012】奇怪的游戏&quot;&gt;&lt;a href=&quot;#【SCOI2012】奇怪的游戏&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2012】奇怪的游戏&quot;&gt;&lt;/a&gt;【SCOI2012】奇怪的游戏&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;40\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Blinker}$最近喜欢上一个奇怪的游戏。&lt;br&gt;这个游戏在一个$N\times M$的棋盘上玩，每个格子有一个数。每次$\mathrm{Blinker}$会选择两个相邻的格子，并使这两个数都加上$1$。&lt;br&gt;现在$\mathrm{Blinker}$想知道最少多少次能使棋盘上的数都变成同一个数，如果永远不能变成同一个数则输出$-1$。 &lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行是一个整数$T$，表示输入数据有$T$轮游戏组成。&lt;br&gt;每轮游戏的第一行有两个整数$N$和$M$， 分别代表棋盘的行数和列数。&lt;br&gt;接下来有$N$行，每行$M$个数。 &lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每个游戏输出最少能使游戏结束的次数，如果永远不能变成同一个数则输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="二分答案" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
</feed>
