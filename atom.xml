<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NIRVANA</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-03T10:59:20.437Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Azrael_Death</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ4407 于神之怒加强版 &lt;莫比乌斯反演&gt;</title>
    <link href="http://yoursite.com/2018/03/02/BZOJ4407%20%E4%BA%8E%E7%A5%9E%E4%B9%8B%E6%80%92%E5%8A%A0%E5%BC%BA%E7%89%88%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://yoursite.com/2018/03/02/BZOJ4407 于神之怒加强版 莫比乌斯反演/</id>
    <published>2018-03-01T16:00:00.000Z</published>
    <updated>2018-03-03T10:59:20.437Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="DZY-Loves-Math"><a href="#DZY-Loves-Math" class="headerlink" title="DZY Loves Math"></a>DZY Loves Math</h3><p>Time Limit: $80 Sec$<br>Memory Limit: $512 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给下$N,M,K$，计算$\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k\mod(10^9+7)$的值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入有多组数据，输入数据的第一行两个正整数$T,K$，代表有$T$组数据，$K$的意义如上所示，下面第$2$行到第$T+1$行，每行为两个正整数$N,M$，其意义如上式所示。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一个询问，输出一行一个数作为回答。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N,M,K\le5\times 10^6,\;1\le T\le2000$<br><a href="http://www.lydsy.com/JudgeOnline/upload/201603/4407.rar" target="_blank" rel="noopener">官方题解</a></p><p>标签：莫比乌斯反演</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>先套路转换出$\mu$：<br>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k\\<br>&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=d]\\<br>&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{i=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{m}{d}\rfloor}\sum_{x|\gcd(i ,j)}\mu(x)\\<br>&amp;=\sum_{d=1}^{\min(n,m)}d^k\sum_{x=1}^{\lfloor\frac{\min(n,m)}{d}\rfloor}\mu(x)\lfloor\frac{n}{x\cdot d}\rfloor\lfloor\frac{m}{x\cdot d}\rfloor\\<br>&amp;=\sum_{t=1}^{\min(n,m)}\sum_{d=1}^{t}d^k\mu(\frac{t}{d})\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\\<br>&amp;=\sum_{t=1}^{\min(n,m)}\lfloor\frac{n}{t}\rfloor\lfloor\frac{m}{t}\rfloor\sum_{d=1}^{t}d^k\mu(\frac{t}{d})\\<br>\end{aligned}<br>$$<br>那么每次询问对于前半部分可以根号分块，随后需要$O(1)$计算后半部分的值，因而需要线筛预处理后半部分的值。</p><p>令$f(t)=\sum_{d=1}^{t}d^k\mu(\frac{t}{d})$，$t=p_1^{a_1}\times p_2^{q_2}\times\cdots p_l^{a_l}$<br>由于$y=d^k$和$y=\mu(d)$均为积性函数，因而$f$也为积性函数。<br>那么就有<br>$$<br>\begin{aligned}<br>f(t)&amp;=\prod_{i=1}^{l}f(p_i^{a_i})\\&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(\frac{p_i^{a_i}}{p_i^j})\\<br>&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(p_i^{a_i-j})\\<br>\end{aligned}<br>$$<br>易知当$j\in[0,a_i-1)$时，均有$\mu(p_i^{a_i-j})=0$，因此有<br>$$<br>\begin{aligned}<br>f(t)&amp;=\prod_{i=1}^{l}\sum_{j=0}^{a_i}p_i^{j\cdot k}\mu(p_i^{a_i-j})\\<br>&amp;=\prod_{i=1}^{l}(\mu(p_i)\cdot p_i^{k\cdot(a_i-1)}+\mu(1)\cdot p_i^{k\cdot a_i})\\<br>&amp;=\prod_{i=1}^{l}(p_i^{k\cdot a_i}-p_i^{k\cdot(a_i-1)})\\<br>&amp;=\prod_{i=1}^{l}p_i^{k\cdot(a_i-1)}(p_i-1)<br>\end{aligned}<br>$$<br>接下来考虑在线筛中如何处理。<br>首先，对于所有质数，均有$f(p)=p^k-1$。<br>而对于合数，假设当前筛到的数是$x$，对于一个比它小的素数$p$，有两种情况：</p><ol><li>若$p|x$，设$p$在$x$分解质因数中的次数为$a$，那么$f(x\times p)$相比于$f(x)$而言，在含$p$的约数中$p$的次数都增加了$1$，否则$\mu=0$无贡献。因此$k\cdot(a-1)$增加了$k$，这样总共扩大了$p^k$倍，故$f(x\times p)=f(x)\times p^k$；</li><li>若$p\nmid x$，由积性函数可知$f(x\times p)=f(x)\times f(p)$。</li></ol><p>这样就可以$O(n\log{n})$筛出$f$的函数值，每次询问$O(T\sqrt{n})$根号分块，总复杂度$O(n\log{n}+T\sqrt{n})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">lnt k, cnt, ans, f[MAX_N+<span class="number">5</span>], p[MAX_N+<span class="number">5</span>], pri[MAX_N+<span class="number">5</span>];<span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">lnt <span class="title">PM</span><span class="params">(lnt x, lnt y)</span> </span>&#123;<span class="keyword">if</span> (!y) <span class="keyword">return</span> <span class="number">1L</span>L; lnt ret = PM(x, y&gt;&gt;<span class="number">1</span>); <span class="keyword">return</span> (y&amp;<span class="number">1</span>) ? ret*ret%MOD*x%MOD : ret*ret%MOD;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">NotPri[<span class="number">1</span>] = <span class="literal">true</span>, f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, p[i] = PM(i, k), f[i] = p[i]<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>; NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) f[i*pri[j]] = f[i]*f[pri[j]]%MOD;</span><br><span class="line"><span class="keyword">else</span> &#123;f[i*pri[j]] = f[i]*p[pri[j]]%MOD; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) (f[i] += f[i<span class="number">-1</span>]) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T), read(k), init();</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">lnt n, m;read(n), read(m), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), (ans += (n/l)*(m/l)%MOD*(f[r]-f[l<span class="number">-1</span>]+MOD)%MOD) %= MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;DZY-Loves-Math&quot;&gt;&lt;a href=&quot;#DZY-Loves-Math&quot; class=&quot;headerlink&quot; title=&quot;DZY Loves Math&quot;&gt;&lt;/a&gt;DZY Loves Math&lt;/h3&gt;&lt;p&gt;Time Limit: $80 Sec$&lt;br&gt;Memory Limit: $512 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给下$N,M,K$，计算$\sum_{i=1}^{n}\sum_{j=1}^{m}\gcd(i,j)^k\mod(10^9+7)$的值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入有多组数据，输入数据的第一行两个正整数$T,K$，代表有$T$组数据，$K$的意义如上所示，下面第$2$行到第$T+1$行，每行为两个正整数$N,M$，其意义如上式所示。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每一个询问，输出一行一个数作为回答。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3309 DZY Loves Math &lt;莫比乌斯反演&gt;</title>
    <link href="http://yoursite.com/2018/02/28/BZOJ3309%20DZY%20Loves%20Math%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://yoursite.com/2018/02/28/BZOJ3309 DZY Loves Math 莫比乌斯反演/</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2018-03-03T11:00:03.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="DZY-Loves-Math"><a href="#DZY-Loves-Math" class="headerlink" title="DZY Loves Math"></a>DZY Loves Math</h3><p>Time Limit: $20 Sec$<br>Memory Limit: $512 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>对于正整数$n$，定义$f(n)$为$n$所含质因子的最大幂指数。例如$f(1960)=f(2^3\times5^1\times7\times2)=3$, $f(10007)=1$, $f(1)=0$。<br>给定正整数$a,b$，求$\sum_{i=1}^{a}\sum_{j=1}^{b}{f(\gcd(i,j))}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个数$T$，表示询问数。<br>接下来$T$行，每行两个数$a,b$，表示一个询问。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一个询问，输出一行一个非负整数作为回答。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">7558588 9653114</span><br><span class="line">6514903 4451211</span><br><span class="line">7425644 1189442</span><br><span class="line">6335198 4957</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">35793453939901</span><br><span class="line">14225956593420</span><br><span class="line">4332838845846</span><br><span class="line">15400094813</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$T\le 10^4$<br>$1\le a,b\le 10^7$</p><p>标签：莫比乌斯反演</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>好题，$get$线筛新姿势。</p><p>首先套路转化出莫比乌斯函数：<br>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{i=1}^{a}\sum_{j=1}^{b}f(\gcd(i,j))\\<br>&amp;=\sum_{d=1}^{\min(a,b)}\sum_{i=1}^{a}\sum_{j=1}^{b}f(d)[\gcd(i,j)=d]\\<br>&amp;=\sum_{d=1}^{\min(a,b)}f(d)\sum_{i=1}^{\lfloor\frac{a}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{b}{d}\rfloor}\sum_{k|\gcd(i,j)}\mu(k)\\<br>&amp;=\sum_{d=1}^{\min(a,b)}f(d)\sum_{k=1}^{\lfloor\frac{\min(a,b)}{d}\rfloor}\mu(k)\times\lfloor\frac{a}{d\times k}\rfloor\times\lfloor\frac{b}{d\times k}\rfloor\\<br>&amp;=\sum_{t=1}^{\min(a,b)}\lfloor\frac{a}{t}\rfloor\lfloor\frac{b}{t}\rfloor\sum_{d|t}\mu(\frac{t}{d})\times f(d)\\<br>\end{aligned}<br>$$<br>这时会发现前面用根号分块很好处理，而后面的部分需要$O(1)$计算，所以需要线性筛预处理。</p><p>令$g(t)=\sum_{d|t}\mu(\frac{t}{d})\times f(d)$，考虑通过$\mu$与$f$的性质找到其积性关系。</p><p>设$t=p_1^{a_1}\times p_2^{a_2}\times\cdots\times p_k^{a_k}$，$\frac{t}{d}=p_1^{a_1’}\times p_2^{a_2’}\times\cdots\times p_k^{a_k’}$，$d=p_1^{a_1-a_1’}\times p_2^{a_2-a_2’}\times\cdots\times p_k^{a_k-a_k’}$<br>那么一定有$0\le a_1’,a_2’,\cdots,a_k’\le 1$，否则$\mu(\lfloor\frac{t}{d}\rfloor)=0$，不计入总贡献。</p><ol><li>若$a_1=a_2=\cdots=a_k=\max{a}$<ul><li>对于$f(d)=\max{a}-1$的情况，只有一种，即$a_1’=a_2’=\cdots=a_k’=0$。而$\mu(\frac{t}{d})=(-1)^k$。故贡献为$(a-1)\times(-1)^k=a\times(-1)^k-(-1)^k$；</li><li>对于$f(d)=\max{a}$的情况，根据组合原理，有$\sum_{i=0}^{k-1}(-1)^i\binom{i}{k}$，而又由二项式基本定理知$\sum_{i=0}^{k}(-1)^k\binom{i}{k}=0$，因而贡献为$(-1)^k\binom{k}{k}=(-1)^k$。</li><li>故此情况$g(d)=a\times(-1)^k-(-1)^k+(-1)^k=a\times(-1)^k$。</li></ul></li><li>若$\exists i,j$使得$i\ne j,\;a_i\ne a_j$<ul><li>不论$f(d)=\max{a}$还是$f(d)=\max{a}-1$，都存在至少一个质因数$p_r$使得$a_r’$不论取$0$还是$1$对$f(d)$的取值都没有影响。然而$a_r’$取$0$或$1$会使得$\mu(\frac{t}{d})$取到$-1$或$1$，此处的贡献为$f(d)+(-f(d))=0$，一定全部被抵消。</li><li>故此情况$g(d)=0$。</li></ul></li></ol><p>综上，线性筛预处理$g(t)$需要知道每个数最小的质因数的次数$num$和最小质因数的幂指数次幂$sp$，这样看是否有$num[i\times pri[j]]=num[i/sp[i]]$即可知$i\times pri[j]$的最小与次小质因数的次数是否相等，由此可判断是情况$1$还是情况$2$。这样先线性筛预处理后，对每次询问$O(\sqrt{\min(a,b)})$进行根号分块，即可达到$O(T\sqrt{\min(a,b)})$的复杂度。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> g[MAX_N+<span class="number">5</span>], sp[MAX_N+<span class="number">5</span>], num[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], cnt;lnt ans;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">NotPri[<span class="number">0</span>] = NotPri[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = sp[i] = i, g[i] = num[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; n) <span class="keyword">break</span>;NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) sp[i*pri[j]] = pri[j], num[i*pri[j]] = <span class="number">1</span>, g[i*pri[j]] = num[i] == <span class="number">1</span> ? -g[i] : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> sp[i*pri[j]] = sp[i]*pri[j], num[i*pri[j]] = num[i]+<span class="number">1</span>, </span><br><span class="line">g[i*pri[j]] = sp[i] == i ? <span class="number">1</span> : (num[i/sp[i]] == num[i*pri[j]] ? -g[i/sp[i]] : <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (i%pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) g[i] += g[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T), init(MAX_N);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> a, b;read(a), read(b), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min(a,b); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(a/(a/l), b/(b/l)), ans += <span class="number">1L</span>L*(a/l)*(b/l)*(g[r]-g[l<span class="number">-1</span>]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;DZY-Loves-Math&quot;&gt;&lt;a href=&quot;#DZY-Loves-Math&quot; class=&quot;headerlink&quot; title=&quot;DZY Loves Math&quot;&gt;&lt;/a&gt;DZY Loves Math&lt;/h3&gt;&lt;p&gt;Time Limit: $20 Sec$&lt;br&gt;Memory Limit: $512 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;对于正整数$n$，定义$f(n)$为$n$所含质因子的最大幂指数。例如$f(1960)=f(2^3\times5^1\times7\times2)=3$, $f(10007)=1$, $f(1)=0$。&lt;br&gt;给定正整数$a,b$，求$\sum_{i=1}^{a}\sum_{j=1}^{b}{f(\gcd(i,j))}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个数$T$，表示询问数。&lt;br&gt;接下来$T$行，每行两个数$a,b$，表示一个询问。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每一个询问，输出一行一个非负整数作为回答。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2693 jzptab &lt;莫比乌斯反演&gt;</title>
    <link href="http://yoursite.com/2018/02/26/BZOJ2693%20jzptab%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://yoursite.com/2018/02/26/BZOJ2693 jzptab 莫比乌斯反演/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2018-03-03T11:43:41.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="jzptab"><a href="#jzptab" class="headerlink" title="jzptab"></a>jzptab</h3><p>Time Limit: $10 Sec$<br>Memory Limit: $512 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>求$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$，答案模$10^9+9$输出。<br>多组询问。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个正整数$T$表示数据组数。<br>接下来$T$行，每行两个正整数 表示$N,M$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>$T$行，每行一个整数，表示第$i$组数据的结果。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">122</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$T\le 10^4$<br>$N,M\le 10^7$</p><h3 id="Sourse"><a href="#Sourse" class="headerlink" title="Sourse"></a>Sourse</h3><p>版权所有者：倪泽堃</p><p>标签：莫比乌斯反演</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>此题和$BZOJ2154$所求相同，只是又多组询问，如果每次都像$BZOJ2154$那样$O(n)$做为$TLE$。故需要改变求和方式。这里将使用$BZOJ2154$的最终推导结果来继续恒等变形。前面的推导见：<a href="http://azrael.top/2018/02/26/BZOJ2154%20Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/" target="_blank" rel="noopener">BZOJ2154</a>。<br>$$<br>\begin{aligned}<br>Answer&amp;=\sum_{d=1}^{\min(n,m)}{d}\sum_{k=1}^{\min(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor)}\mu(k)\times k^2\times\frac{\lfloor\frac{n}{d\times k}\rfloor\times(\lfloor\frac{n}{d\times k}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{d\times k}\rfloor\times(\lfloor\frac{m}{d\times k}\rfloor+1)}{2}\\<br>&amp;=\sum_{d=1}^{\min(n,m)}\sum_{t=k\times d(k\in\mathbb{N^*})}^{\min(n,m)}\mu(\frac{t}{d})\times\frac{t^2}{d^2}\times\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}\times{d}\\<br>&amp;=\sum_{t=1}^{\min(n,m)}{\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}}\sum_{k|t}\mu(k)\times k^2\times\frac{t}{k}\\<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>&amp;Let\;F(t)=\sum_{k|t}\mu(k)\times k^2\times \frac{t}{k} ,\\<br>&amp;then\;S=\sum_{t=1}^{\min(n,m)}{\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}}\times F(t)\\<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>&amp;\because f(x)=\mu(x),\;g(x)=x^2,\;h(x)=\frac{t}{x}\;are\;all\;multiplicative\;functions\\<br>&amp;\therefore F(x)=\sum_{t|x}f(t)\times g(t)\times h(t)\;is\;a\;multiplicative\;function\\<br>&amp;\Longrightarrow We\;can\;use\;a\;Linear\;Seive\;to\;calculate\;F(x)\\<br>&amp;If\;x\equiv1\sim y-1\mod{y}\;\;(y\;is\;a\;prime\;number)\\<br>&amp;\;\;\;\;then\;F(x\times y)=F(x)\times F(y)\\<br>&amp;If\;x\equiv0\mod{y}\;\;(y\;is\;a\;prime\;number)\\<br>&amp;\;\;\;\;then\;\mu(x\times y)=0,\;F(x\times y)=F(x)\times y<br>\end{aligned}<br>$$<br>综上，$F(x)$的前缀和可用线性筛预处理，对于每次询问对$\frac{\lfloor\frac{n}{t}\rfloor\times(\lfloor\frac{n}{t}\rfloor+1)}{2}\times\frac{\lfloor\frac{m}{t}\rfloor\times(\lfloor\frac{m}{t}\rfloor+1)}{2}$根号分块，即可做到$O(T\sqrt{n})$的复杂度。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 100000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">lnt n, m, cnt, ans, s[MAX_N+<span class="number">5</span>], pri[MAX_N+<span class="number">5</span>];<span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">NotPri[<span class="number">1</span>] = <span class="literal">true</span>, s[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (lnt i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, s[i] = (i-i*i%MOD)%MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) s[i*pri[j]] = s[i]*s[pri[j]]%MOD;</span><br><span class="line"><span class="keyword">else</span> &#123;s[i*pri[j]] = s[i]*pri[j]; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_N; i++) (s[i] += s[i<span class="number">-1</span>]) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">lnt n, m;read(n), read(m), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), (ans += (n/l*(n/l+<span class="number">1</span>)/<span class="number">2</span>%MOD)*(m/l*(m/l+<span class="number">1</span>)/<span class="number">2</span>%MOD)%MOD*(s[r]-s[l<span class="number">-1</span>])%MOD) %= MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans+MOD)%MOD);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;jzptab&quot;&gt;&lt;a href=&quot;#jzptab&quot; class=&quot;headerlink&quot; title=&quot;jzptab&quot;&gt;&lt;/a&gt;jzptab&lt;/h3&gt;&lt;p&gt;Time Limit: $10 Sec$&lt;br&gt;Memory Limit: $512 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;求$\sum_{i=1}^{n}\sum_{j=1}^{m}lcm(i,j)$，答案模$10^9+9$输出。&lt;br&gt;多组询问。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一个正整数$T$表示数据组数。&lt;br&gt;接下来$T$行，每行两个正整数 表示$N,M$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;$T$行，每行一个整数，表示第$i$组数据的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2154 Crash的数字表格 &lt;莫比乌斯反演&gt;</title>
    <link href="http://yoursite.com/2018/02/26/BZOJ2154%20Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://yoursite.com/2018/02/26/BZOJ2154 Crash的数字表格 莫比乌斯反演/</id>
    <published>2018-02-25T16:00:00.000Z</published>
    <updated>2018-03-03T11:44:15.563Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Crash的数字表格"><a href="#Crash的数字表格" class="headerlink" title="Crash的数字表格"></a>Crash的数字表格</h3><p>Time Limit: $20 Sec$<br>Memory Limit: $259 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>今天的数学课上，$Crash$小朋友学习了最小公倍数$(Least\;Common\;Multiple)$。对于两个正整数$a$和$b$，$LCM(a, b)$表示能同时被a和b整除的最小正整数。例如，$LCM(6, 8) = 24$。回到家后，$Crash$还在想着课上学的东西，为了研究最小公倍数，他画了一张$N\times M$的表格。每个格子里写了一个数字，其中第$i$行第$j$列的那个格子里写着数为$LCM(i, j)$。看着这个表格，$Crash$想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当$N$和$M$很大时，$Crash$就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，$Crash$只想知道表格里所有数的和$\mod 20101009\;\;$的值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含两个正整数，分别表示$N$和$M$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个正整数，表示表格中所有数的和$\mod 20101009\;\;$的值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">122</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$100\%$的数据满足$N,M\le10^7$。</p><p>标签：莫比乌斯反演</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{x=1}^{n}\sum_{y=1}^{m}\frac{x\times y}{\gcd(x,y)}\\<br>&amp;=\sum_{d=1}^{\min(n,m)}\sum_{x=1}^{n}\sum_{y=1}^{m}[\gcd(x,y)=d]\frac{x\times y}{d}\\<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>&amp;Let\;f(n,m,d)=\sum_{x=1}^{n}\sum_{y=1}^{m}[\gcd(x,y)=d]\cdot x\cdot y\\<br>&amp;then\;f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)=\sum_{x=1}^{\lfloor\frac{n}{d}\rfloor}\sum_{y=1}^{\lfloor\frac{m}{d}\rfloor}[\gcd(x,y)=1]\cdot x\cdot y\\<br>&amp;\therefore Ans=\sum_{d=1}^{\min(n,m)}\frac{f(n,m,d)}{d}=\sum_{d=1}^{\min(n,m)}f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)\times d\\<br>&amp;\;\;\;\;If\;we\;can\;calculate\;f(p,q,1)\;in\;a\;rapid\;way,\\&amp;\;\;\;\;we\;can\;calculate\;the\;answer\;rapidly.\\<br>\end{aligned}<br>$$<br>$$<br>\begin{aligned}<br>f(p,q,1)&amp;=\sum_{i=1}^{p}\sum_{j=1}^{q}\sum_{d|\gcd(i,j)}\mu(d)\cdot i\cdot j\\<br>&amp;=\sum_{d=1}^{\min(p,q)}\mu(d)\times d^2\;\sum_{i=1}^{\lfloor\frac{p}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{q}{d}\rfloor}i\times j\\<br>&amp;=\sum_{d=1}^{\min(p,q)}\mu(d)\times d^2\times\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}\\<br>\end{aligned}<br>$$<br>由以上推导，可见$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$和$\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}$是可以根号分块的，在外层对$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$进行分块，在每个值相同的块中，对$\frac{\lfloor\frac{p}{d}\rfloor\times(\lfloor\frac{p}{d}\rfloor+1)}{2}\times\frac{\lfloor\frac{q}{d}\rfloor\times(\lfloor\frac{q}{d}\rfloor+1)}{2}$进行分块以求出$f(\lfloor\frac{n}{d}\rfloor,\lfloor\frac{m}{d}\rfloor,1)$带回外层算贡献。</p><p>综上，外层复杂度为$O(\sqrt{n})$，内层复杂度为$O(\sqrt{n})$，总时间复杂度为$O(n)$。</p><p>其实可以做得更块，详见加强版<a href="http://azrael.top/2018/02/26/BZOJ2693%20jzptab%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/" target="_blank" rel="noopener">BZOJ2693</a>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 20101009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">lnt n, m, ans, s[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> cnt, pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getMu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">NotPri[<span class="number">1</span>] = <span class="literal">true</span>, mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= min(n,m); i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; min(n,m)) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min(n,m); i++) s[i] = (s[i<span class="number">-1</span>]+<span class="number">1L</span>L*mu[i]*i*i%MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">f</span><span class="params">(lnt p, lnt q)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">1</span>, r; l &lt;= min(p, q); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(p/(p/l), q/(q/l)), </span><br><span class="line">(ret += (p/l*(p/l+<span class="number">1</span>)/<span class="number">2</span>%MOD)*(q/l*(q/l+<span class="number">1</span>)/<span class="number">2</span>%MOD)%MOD*(s[r]-s[l<span class="number">-1</span>])%MOD) %= MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), getMu();</span><br><span class="line"><span class="keyword">for</span> (lnt l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), (ans += (l+r)*(r-l+<span class="number">1</span>)/<span class="number">2</span>%MOD*f(n/l, m/l)%MOD) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (ans+MOD)%MOD), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;Crash的数字表格&quot;&gt;&lt;a href=&quot;#Crash的数字表格&quot; class=&quot;headerlink&quot; title=&quot;Crash的数字表格&quot;&gt;&lt;/a&gt;Crash的数字表格&lt;/h3&gt;&lt;p&gt;Time Limit: $20 Sec$&lt;br&gt;Memory Limit: $259 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;今天的数学课上，$Crash$小朋友学习了最小公倍数$(Least\;Common\;Multiple)$。对于两个正整数$a$和$b$，$LCM(a, b)$表示能同时被a和b整除的最小正整数。例如，$LCM(6, 8) = 24$。回到家后，$Crash$还在想着课上学的东西，为了研究最小公倍数，他画了一张$N\times M$的表格。每个格子里写了一个数字，其中第$i$行第$j$列的那个格子里写着数为$LCM(i, j)$。看着这个表格，$Crash$想到了很多可以思考的问题。不过他最想解决的问题却是一个十分简单的问题：这个表格中所有数的和是多少。当$N$和$M$很大时，$Crash$就束手无策了，因此他找到了聪明的你用程序帮他解决这个问题。由于最终结果可能会很大，$Crash$只想知道表格里所有数的和$\mod 20101009\;\;$的值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含两个正整数，分别表示$N$和$M$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个正整数，表示表格中所有数的和$\mod 20101009\;\;$的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1096【ZJOI2007】仓库建设 &lt;斜率优化&gt;</title>
    <link href="http://yoursite.com/2018/02/22/BZOJ1096%E3%80%90ZJOI2007%E3%80%91%E4%BB%93%E5%BA%93%E5%BB%BA%E8%AE%BE%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/02/22/BZOJ1096【ZJOI2007】仓库建设 斜率优化/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-03-03T11:46:37.514Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【ZJOI2007】仓库建设"><a href="#【ZJOI2007】仓库建设" class="headerlink" title="【ZJOI2007】仓库建设"></a>【ZJOI2007】仓库建设</h3><p>Time Limit: $10 Sec$<br>Memory Limit: $162 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$L$公司有$N$个工厂，由高到底分布在一座山上。如图所示，工厂$1$在山顶，工厂$N$在山脚。由于这座山处于高原内陆地区（干燥少雨），$L$公司一般把产品直接堆放在露天，以节省费用。突然有一天，$L$公司的总裁$L$先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是$L$先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第$i$个工厂目前已有成品$P_i$件，在第$i$个工厂位置建立仓库的费用是$C_i$。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于$L$公司产品的对外销售处设置在山脚的工厂$N$，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送$1$个单位距离的费用是$1$。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：</p><ol><li>工厂$i$距离工厂$1$的距离$X_i$（其中$X_1=0$）</li><li>工厂$i$目前已有成品数量$P_i$</li><li>在工厂$i$建立仓库的费用$C_i$</li></ol><p>请你帮助$L$公司寻找一个仓库建设的方案，使得总的费用（$建造费用+运输费用$）最小。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数$N$，表示工厂的个数。接下来$N$行每行包含两个整数$X_i, P_i, C_i$, 意义如题中所述。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个整数，为可以找到最优方案的费用。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 5 10</span><br><span class="line">5 3 100</span><br><span class="line">9 6 10</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><p>标签：斜率优化$DP$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由题意，易得到$DP$方程：$f[i]=c[i]+\min_{j=0}^{i-1}{f[j]+\sum_{k=j+1}^{i}p[k]\times(x[i]-x[k])}$<br>那么对于当前$DP$到的位置$i$，一定存在$p,q\in[0,i)$使得<br>$$<br>\begin{aligned}<br>f[p]+\sum_{k=p+1}^{i}p[k]\times(x[i]-x[k])&amp;\le f[q]+\sum_{k=q+1}^{i}p[k]\times(x[i]-x[k])\\<br>f[p]+\sum_{k=p+1}^{i}p[k]\times x[i]-\sum_{k=p+1}^{i}p[k]\times x[k]&amp;\le f[q]+\sum_{k=q+1}^{i}p[k]\times x[i]-\sum_{k=q+1}^{i}p[k]\times x[k]\\<br>Let\;s_1[i]=\sum_{j=1}^{i}p[j]\times x[j]&amp;,\;s_2[i]=\sum_{j=1}^{i}p[j]\\<br>f[p]+(s_2[i]-s_2[p])\times x[i]-s_1[i]+s_1[p]&amp;\le f[q]+(s_2[i]-s_2[q])\times x[i]-s_1[i]+s_1[q]\\<br>f[p]-s_2[p]\times x[i]+s_1[p]&amp;\le f[q]-s_2[q]\times x[i]+s_1[q]\\<br>\frac{(f[p]-f[q])+(s_1[p]-s_1[q])}{s_2[p]-s_2[q]}&amp;\le x[i]\\<br>\end{aligned}<br>$$<br>$$<br>\therefore k(p,q)=\frac{(f[p]-f[q])+(s_1[p]-s_1[q])}{s_2[p]-s_2[q]}\le x[i]\iff p\;is\;better\;than\;q<br>$$<br>按照此斜率维护单调栈即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, c[MAX_N+<span class="number">5</span>], x[MAX_N+<span class="number">5</span>], m[MAX_N+<span class="number">5</span>];</span><br><span class="line">lnt s1[MAX_N+<span class="number">5</span>], s2[MAX_N+<span class="number">5</span>], f[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> l, r, sta[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">dnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;<span class="keyword">return</span> (dnt)(f[p]-f[q]+s1[p]-s1[q])/(dnt)(s2[p]-s2[q]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(x[i]), read(m[i]), read(c[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) s1[i] = s1[i<span class="number">-1</span>]+<span class="number">1L</span>L*m[i]*x[i], s2[i] = s2[i<span class="number">-1</span>]+m[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; calc(sta[l+<span class="number">1</span>], sta[l]) &lt;= x[i]) l++;</span><br><span class="line">f[i] = f[sta[l]]+<span class="number">1L</span>L*x[i]*(s2[i]-s2[sta[l]])-s1[i]+s1[sta[l]]+c[i];</span><br><span class="line"><span class="keyword">while</span> (l &lt; r &amp;&amp; calc(sta[r], sta[r<span class="number">-1</span>]) &gt; calc(i, sta[r])) r--;</span><br><span class="line">sta[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【ZJOI2007】仓库建设&quot;&gt;&lt;a href=&quot;#【ZJOI2007】仓库建设&quot; class=&quot;headerlink&quot; title=&quot;【ZJOI2007】仓库建设&quot;&gt;&lt;/a&gt;【ZJOI2007】仓库建设&lt;/h3&gt;&lt;p&gt;Time Limit: $10 Sec$&lt;br&gt;Memory Limit: $162 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$L$公司有$N$个工厂，由高到底分布在一座山上。如图所示，工厂$1$在山顶，工厂$N$在山脚。由于这座山处于高原内陆地区（干燥少雨），$L$公司一般把产品直接堆放在露天，以节省费用。突然有一天，$L$公司的总裁$L$先生接到气象部门的电话，被告知三天之后将有一场暴雨，于是$L$先生决定紧急在某些工厂建立一些仓库以免产品被淋坏。由于地形的不同，在不同工厂建立仓库的费用可能是不同的。第$i$个工厂目前已有成品$P_i$件，在第$i$个工厂位置建立仓库的费用是$C_i$。对于没有建立仓库的工厂，其产品应被运往其他的仓库进行储藏，而由于$L$公司产品的对外销售处设置在山脚的工厂$N$，故产品只能往山下运（即只能运往编号更大的工厂的仓库），当然运送产品也是需要费用的，假设一件产品运送$1$个单位距离的费用是$1$。假设建立的仓库容量都都是足够大的，可以容下所有的产品。你将得到以下数据：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工厂$i$距离工厂$1$的距离$X_i$（其中$X_1=0$）&lt;/li&gt;
&lt;li&gt;工厂$i$目前已有成品数量$P_i$&lt;/li&gt;
&lt;li&gt;在工厂$i$建立仓库的费用$C_i$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;请你帮助$L$公司寻找一个仓库建设的方案，使得总的费用（$建造费用+运输费用$）最小。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含一个整数$N$，表示工厂的个数。接下来$N$行每行包含两个整数$X_i, P_i, C_i$, 意义如题中所述。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅包含一个整数，为可以找到最优方案的费用。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://yoursite.com/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="斜率优化" scheme="http://yoursite.com/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1010【HNOI2008】玩具装箱toy &lt;斜率优化&gt;</title>
    <link href="http://yoursite.com/2018/02/22/BZOJ1010%E3%80%90HNOI2008%E3%80%91%E7%8E%A9%E5%85%B7%E8%A3%85%E7%AE%B1toy%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2018/02/22/BZOJ1010【HNOI2008】玩具装箱toy 斜率优化/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-03-03T11:44:48.489Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【HNOI2008】玩具装箱toy"><a href="#【HNOI2008】玩具装箱toy" class="headerlink" title="【HNOI2008】玩具装箱toy"></a>【HNOI2008】玩具装箱toy</h3><p>Time Limit: $10 Sec$<br>Memory Limit: $162 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$P$教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。$P$教授有编号为$1\sim N$的$N$件玩具，第$i$件玩具经过压缩后变成一维长度为$C_i$.为了方便整理，$P$教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第$i$件玩具到第$j$个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum_{k=i}^{j}C_k$制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$X$,其制作费用为$(X-L)^2$.其中$L$是一个常量。$P$教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望费用最小.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入两个整数$N,L$.接下来$N$行输入$C_i$.<br>$1\le N\le50000,1\le L,C_i\le10^7$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出最小费用.<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>标签：斜率优化$DP$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>令$L=L+1$，有如下$DP$方程：$f[i]=\min_{j=0}^{i-1}{f[j]+[(i-j+\sum_{k=j}^{i}C_k)-L]^2}$。</p><p>预处理$s[i]=\sum_{j=1}^{i}C_j,\;w[i]=s[i]+i$。对于当前$DP$到的位置$i$，必然存在$p,q\in[0,i)$，使得<br>$$<br>\begin{aligned}<br>f[p]+[(i-p+\sum_{k=p}^{i}C_k)-L]^2&amp;\le f[q]+[(i-q+\sum_{k=q}^{i}C_k)-L]^2\\<br>&amp;\Updownarrow\\<br>f[p]+(w[i]-w[p]-L)^2&amp;\le f[q]+(w[i]-w[q]-L)^2\\<br>&amp;\Updownarrow\\<br>f[p]+w[i]^2+w[p]^2+L^2-2\times w[i]&amp;\times w[p]-2\times w[i]\times L+2\times w[p]\times L\\<br>&amp;\le\\<br>f[q]+w[i]^2+w[q]^2+L^2-2\times w[i]&amp;\times w[q]-2\times w[i]\times L+2\times w[q]\times L\\<br>&amp;\Updownarrow\\<br>f[p]+(w[p]+L)^2-2\times w[i]\times w[p]&amp;\le f[q]+(w[q]+L)^2-2\times w[i]\times w[q]\\<br>&amp;\Updownarrow\\<br>\frac{(f[p]-f[q])+((w[p]+L)^2-(w[q]+L)^2)}{2\times(w[p]-w[q])}&amp;\le w[i]\\<br>\end{aligned}<br>$$<br>$$<br>\therefore k(p,q)=\frac{(f[p]-f[q])+((w[p]+L)^2-(w[q]+L)^2)}{2\times(w[p]-w[q])}\le w[i]\iff p\;is\;better\;than\;q<br>$$<br>按照此斜率维护单调栈即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, l, sta[MAX_N+<span class="number">5</span>], s, t;lnt f[MAX_N+<span class="number">5</span>], w[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">dnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;<span class="keyword">return</span> (f[p]-f[q]+(w[p]+l)*(w[p]+l)-(w[q]+l)*(w[q]+l))/(<span class="number">2.0</span>*(w[p]-w[q]));&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(l), l++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(w[i]), w[i] += w[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) w[i] += i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (s &lt; t &amp;&amp; calc(sta[s+<span class="number">1</span>], sta[s]) &lt;= w[i]) s++;</span><br><span class="line">f[i] = f[sta[s]]+(w[i]-w[sta[s]]-l)*(w[i]-w[sta[s]]-l);</span><br><span class="line"><span class="keyword">while</span> (s &lt; t &amp;&amp; calc(sta[t], sta[t<span class="number">-1</span>]) &gt; calc(i, sta[t])) t--;</span><br><span class="line">sta[++t] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【HNOI2008】玩具装箱toy&quot;&gt;&lt;a href=&quot;#【HNOI2008】玩具装箱toy&quot; class=&quot;headerlink&quot; title=&quot;【HNOI2008】玩具装箱toy&quot;&gt;&lt;/a&gt;【HNOI2008】玩具装箱toy&lt;/h3&gt;&lt;p&gt;Time Limit: $10 Sec$&lt;br&gt;Memory Limit: $162 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$P$教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。$P$教授有编号为$1\sim N$的$N$件玩具，第$i$件玩具经过压缩后变成一维长度为$C_i$.为了方便整理，$P$教授要求在一个一维容器中的玩具编号是连续的。同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物，形式地说如果将第$i$件玩具到第$j$个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum_{k=i}^{j}C_k$制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为$X$,其制作费用为$(X-L)^2$.其中$L$是一个常量。$P$教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过$L$。但他希望费用最小.&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行输入两个整数$N,L$.接下来$N$行输入$C_i$.&lt;br&gt;$1\le N\le50000,1\le L,C_i\le10^7$&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出最小费用.&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://yoursite.com/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="斜率优化" scheme="http://yoursite.com/tags/%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>HDU4560 我是歌手 &lt;二分+网络流&gt;</title>
    <link href="http://yoursite.com/2018/02/21/HDU4560%20%E6%88%91%E6%98%AF%E6%AD%8C%E6%89%8B%20%E4%BA%8C%E5%88%86+%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://yoursite.com/2018/02/21/HDU4560 我是歌手 二分+网络流/</id>
    <published>2018-02-20T16:00:00.000Z</published>
    <updated>2018-03-03T11:59:28.566Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="我是歌手"><a href="#我是歌手" class="headerlink" title="我是歌手"></a>我是歌手</h3><p>Time Limit: $2000 MS$<br>Memory Limit: $32768 KB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$2013$年一开始，一档音乐节目“我是歌手”就惊艳了大家一回。闲话少说，现在，你成为了这档节目的总导演，你的任务很简单，安排每一期节目的内容。<br>现在有$N$个歌手，$M$种歌曲流派（$Rock$，$Pop$之类），每个歌手都有自己擅长的流派领域，这些资料都已整理。你的工作是，安排尽可能多场的演唱比赛。每一场比赛所有歌手都必须上场，为了提高收视率，每个人演唱的歌曲类型不能相同，即便一些歌手要被迫选择一些他们不擅长的。同时，为了展现全面性，在不同的演唱比赛上，每个歌手都会安排不同的歌曲流派。<br>但是问题是，对于任何一个歌曲流派的歌迷，如果超过$K$个不擅长的歌手演唱了这种歌曲，他们就会表示不满，比如，发一些宣泄不满的帖子微博，为了表示观点挑起事端等等。你当然不希望这些事情与你的节目有关，在这个前提下，你可以任意安排尽可能多的比赛场次。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行为$T$，表示有$T$组测试数据。<br>每组数据以四个数字$N$，$M$，$L$，$K$开始。$L$表示有$L$组擅长关系，接下来的$L$行，每一行有两个数字$A_i$，$B_i$，表示歌手$A_i$擅长$B_i$类型的歌曲。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对每组数据，先输出为第几组数据，然后输出最多比赛场次。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 1 1 0</span><br><span class="line">1 1</span><br><span class="line">1 3 0 1</span><br><span class="line">3 3 5 1</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">2 2</span><br><span class="line">2 3</span><br><span class="line">3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Case 1: 1</span><br><span class="line">Case 2: 3</span><br><span class="line">Case 3: 2</span><br></pre></td></tr></table></figure><p><strong>Explanation</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对第三组样例，可以如此安排：</span><br><span class="line">第一场三位歌手分别演唱(2,3,1)类型的歌曲，第二场分别演唱(1,2,3)。</span><br><span class="line">这样只有类型3被不擅长的歌手演唱过1次，挑剔的歌迷观众还可以接受。</span><br></pre></td></tr></table></figure></p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$1\le T \le 100 $<br>$1\le N \le M \le 74, 0 \le K \le N $<br>$0\le L \le N\times M$<br>$1\le A_i \le N, 1 \le B_i \le M$<br>相同关系不会重复出现</p><p>标签：带修主席树</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>挺好的一道$二分+网络流$套路建模题。</p><p>二分最多能安排的场次，得到当前答案进行判定。</p><p>首先，如果保证每个人唱每种流派最多仅一次，并且$n$个流派均会被唱至少$tans$次，那么一定能找到一组解。这样就可以用最大流判定。<br>由于有“每个流派仅能有$k$个不擅长的选手唱”，我们需要把每个流派又擅长的选手唱和不擅长的选手唱分开，而限制不擅长的选手的数量。可将每个流派拆成两个点，即第$i$个流派$Style_i$拆成$Style_i$和$Style_i’$。从$Style_i$向擅长的选手连边，从$Style_i’$向不擅长的选手连边，而由于从源点向$Style_i$连有$tans$的边，因而所有可用流量都在$Style_i$中，$Style_i’$的流量需要限制，故要在$Style_i$和$Style_i’$间连$K$的边来限制不擅长选手的数量。</p><p>建模总述：<br>$$<br>\begin{aligned}<br>S &amp;\to Style_i(i\in [1,m]):Capacity=tans\\<br>Style_i &amp;\to Style_i’(i\in [1,m]):Capacity=K\\<br>Style_i &amp;\to Competitor_j(Competitor_j is good at Style_i):Capacity=1\\<br>Style_i’ &amp;\to Competitor_j(Competitor_j is not good at Style_i):Capacity = 1\\<br>Competitor_j &amp;\to T(j\in [1,n]):Capacity=tans\\<br>\end{aligned}<br>$$<br>建模后跑最大流，看是否有$MaxFlow=tans\times n$即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 2000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, f, s, t, cnt, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="keyword">bool</span> G[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;cnt = s = <span class="number">0</span>, t = <span class="number">3</span>*m+<span class="number">1</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>;cpy();<span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec();<span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> tans)</span> </span>&#123;</span><br><span class="line">init();<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(i+<span class="number">2</span>*m, t, tans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) addedge(s, i, tans), addedge(i, i+m, k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) addedge(G[i][j] ? i : i+m, j+<span class="number">2</span>*m, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Dinic() == n*tans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid)) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = mid, l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T;read(T);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> C = <span class="number">1</span>; C &lt;= T; C++) &#123;</span><br><span class="line">read(n), read(m), read(f), read(k), <span class="built_in">memset</span>(G, <span class="literal">false</span>, <span class="keyword">sizeof</span> G);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x, y; i &lt; f; i++) read(x), read(y), G[y][x] = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Case %d: %d\n"</span>, C, bi_search(<span class="number">1</span>, m));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;我是歌手&quot;&gt;&lt;a href=&quot;#我是歌手&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="http://yoursite.com/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="HDU" scheme="http://yoursite.com/tags/HDU/"/>
    
  </entry>
  
  <entry>
    <title>CF446C DZY Loves Fibonacci Numbers &lt;线段树&gt;</title>
    <link href="http://yoursite.com/2018/02/20/CF446C%20DZY%20Loves%20Fibonacci%20Numbers%20%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://yoursite.com/2018/02/20/CF446C DZY Loves Fibonacci Numbers 线段树/</id>
    <published>2018-02-19T16:00:00.000Z</published>
    <updated>2018-03-03T11:47:40.435Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="DZY-Loves-Fibonacci-Numbers"><a href="#DZY-Loves-Fibonacci-Numbers" class="headerlink" title="DZY Loves Fibonacci Numbers"></a>DZY Loves Fibonacci Numbers</h3><p>Time limit: $4Sec$<br>Memory limit: $256MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>In mathematical terms, the sequence $F_n$ of $Fibonacci$ $numbers$ is defined by the recurrence relation $F_1 = 1,F_2 = 1,F_3=F_1+F_2=3,\cdots F_n = F_{n-1}+F_{n-2}$.<br>$DZY$ loves Fibonacci numbers very much. Today $DZY$ gives you an array consisting of $n$ integers: $a_1, a_2,cdots , a_n$. Moreover, there are $m$ queries, each query has one of the two types:</p><ol><li>Format of the query “$1$ $l$ $r$”. In reply to the query, you need to add $F_{i-l+1}$ to each element $a_i$, where $l\le i\le r$.</li><li>Format of the query “$2$ $l$ $r$”. In reply to the query you should output the value of  $\sum_{i=l}^{r}{a_i}$ modulo $10^9+9$.</li></ol><p>Help $DZY$ reply to all the queries.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains two integers $n$ and $m$ $(1 \le n, m \le 3\times 10^5)$. The second line contains <em>n</em> integers $a_1, a_2, \cdots, a_n (1 ≤ a_i \le10^9)$ — initial array $a$.<br>Then, <em>m</em> lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality $1 \le l \le r \le n$ holds.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each query of the second type, print the value of the sum on a single line.<br><a id="more"></a></p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p><strong>Input</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 3 4</span><br><span class="line">1 1 4</span><br><span class="line">2 1 4</span><br><span class="line">1 2 4</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure></p><p><strong>Output</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">17</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>After the first query, $a = [2, 3, 5, 7]$.<br>For the second query, $sum = 2 + 3 + 5 + 7 = 17$.<br>After the third query, $a = [2, 4, 6, 9]$.<br>For the fourth query, $sum = 2 + 4 + 6 = 12$.</p><p>标签：线段树</p><h2 id="Translation"><a href="#Translation" class="headerlink" title="Translation"></a>Translation</h2><p>题目大意：<br>给出一个长为$3\times 10^5$级别的初始数组，要求维护两种操作：</p><ol><li>将$a_l \sim a_r$中的每个数对应加上从$Fib_1\sim Fib_{l-r+1}$的斐波那契数，即使$a_i(i\in[l,r])$加上$Fib_{i-l+1}$</li><li>询问$\sum_{i=l}^{r}{a_i}$模$10^9+9$的值</li></ol><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不难想到此题需要用线段树维护。不过难点在于如何合并标记。</p><p>初步想法是每次打标记时记录下此区间是从斐波那契数列的多少项开始一一对应地加进去，不过这样是无法合并标记的，每个结点只能有一个标记，可以被卡成$O(n^2\log n)$。</p><p>考虑把标记换一种存法。对于一个数列$x_1=a,x_2=b,x_3=a+b,x_4=a+b\times 2,\cdots x_n=x_{n-1}+x_{n-2}$，我们将其称为一个“伪斐波那契数列”，不难发现其等于几个斐波那契数列的子序列之和，即在原题中，不管如何加，每个区间最后加的数列都是一个伪斐波那契数列。而此序列可以仅通过最前面的两项$a$和$b$推出后面的任意项以及前若干项之和，即<br>$$<br>\begin{aligned}<br>x_n &amp;= x_{n-1}+x_{n-2}\\<br>&amp;= 2\times x_{n-2}+x_{n-3}\\<br>&amp;= 3\times x_{n-3}+2\times x_{n-4}\\<br>&amp;= Fib_{n-2}\times x_1+Fib_{n-1}\times x_2\\<br>\sum_{i=1}^{n}{x_i} &amp;= x_1+x_2+x_3+\cdots x_n\\<br>&amp;= x_1+x_2+x_2+x_3+\cdots +x_n-x_2\\<br>&amp;= x_3+x_4+x_4+x_5+\cdots +x_n-x_2\\<br>&amp;= x_5+x_6+x_6+x_7+\cdots +x_n-x_2\\<br>&amp;= x_{n-2}+x_{n-1}+x_{n-1}+x_{n}-x_2\\<br>&amp;= x_n+x_{n+1}-x_2\\<br>&amp;= x_{n+2}-x_{2}<br>\end{aligned}<br>$$<br>用这两个公式我们可以$O(1)$计算任意项及前任意项的和。<br>每个标记为一个数对$(a,b)$，那么合并标记的时候将两个标记的$a$和$b$分别相加，得到$(a_1+a_2,b_1+b_2)$即可。<br>总时间复杂度$O(n\log n)$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000009</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;lnt fib[MAX_N+<span class="number">5</span>] = &#123;<span class="number">0L</span>L, <span class="number">1L</span>L&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>lnt c, f1, f2;&#125; tr[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function">lnt <span class="title">fn</span><span class="params">(lnt f1, lnt f2, <span class="keyword">int</span> len)</span> </span>&#123;<span class="keyword">return</span> len == <span class="number">1</span> ? f1 : (len == <span class="number">2</span> ? f2 : (f1*fib[len<span class="number">-2</span>]%MOD+f2*fib[len<span class="number">-1</span>]%MOD)%MOD);&#125;</span><br><span class="line"><span class="function">lnt <span class="title">sum</span><span class="params">(lnt f1, lnt f2, <span class="keyword">int</span> len)</span> </span>&#123;<span class="keyword">return</span> len == <span class="number">1</span> ? f1 : (len == <span class="number">2</span> ? (f1+f2)%MOD : (fn(f1, f2, len+<span class="number">2</span>)-f2+MOD)%MOD);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;tr[v].c = (tr[v&lt;&lt;<span class="number">1</span>].c+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].c)%MOD;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tr[v].f1) <span class="keyword">return</span>;</span><br><span class="line">lnt lf1 = tr[v].f1, lf2 = tr[v].f2, rf1 = fn(lf1, lf2, mid-s+<span class="number">2</span>), rf2 = fn(lf1, lf2, mid-s+<span class="number">3</span>);</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>].f1 += lf1) %= MOD, (tr[v&lt;&lt;<span class="number">1</span>].f2 += lf2) %= MOD, (tr[v&lt;&lt;<span class="number">1</span>].c += sum(lf1, lf2, mid-s+<span class="number">1</span>)) %= MOD;</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].f1 += rf1) %= MOD, (tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].f2 += rf2) %= MOD, (tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].c += sum(rf1, rf2, t-mid)) %= MOD;</span><br><span class="line">tr[v].f1 = tr[v].f2 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;read(tr[v].c); <span class="keyword">return</span>;&#125;</span><br><span class="line">build(v&lt;&lt;<span class="number">1</span>, s, mid), build(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t);</span><br><span class="line">updata(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">(tr[v].f1 += fib[s-l+<span class="number">1</span>]) %= MOD, (tr[v].f2 += fib[s-l+<span class="number">2</span>]) %= MOD;</span><br><span class="line">(tr[v].c += sum(fib[s-l+<span class="number">1</span>], fib[s-l+<span class="number">2</span>], t-s+<span class="number">1</span>)) %= MOD;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) modify(v&lt;&lt;<span class="number">1</span>, s, mid, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) modify(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r);</span><br><span class="line">updata(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].c;</span><br><span class="line">lnt ret = <span class="number">0</span>;downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) (ret += query(v&lt;&lt;<span class="number">1</span>, s, mid, l, r)) %= MOD;</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) (ret += query(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r)) %= MOD;</span><br><span class="line">updata(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) fib[i] = (fib[i<span class="number">-2</span>]+fib[i<span class="number">-1</span>])%MOD;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), init(), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, l, r;read(opt), read(l), read(r);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) modify(<span class="number">1</span>, <span class="number">1</span>, n, l, r);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;DZY-Loves-Fibonacci-Numbers&quot;&gt;&lt;a href=&quot;#DZY-Loves-Fibonacci-Numbers&quot; class=&quot;headerlink&quot; title=&quot;DZY Loves Fibonacci Numbers&quot;&gt;&lt;/a&gt;DZY Loves Fibonacci Numbers&lt;/h3&gt;&lt;p&gt;Time limit: $4Sec$&lt;br&gt;Memory limit: $256MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;In mathematical terms, the sequence $F_n$ of $Fibonacci$ $numbers$ is defined by the recurrence relation $F_1 = 1,F_2 = 1,F_3=F_1+F_2=3,\cdots F_n = F_{n-1}+F_{n-2}$.&lt;br&gt;$DZY$ loves Fibonacci numbers very much. Today $DZY$ gives you an array consisting of $n$ integers: $a_1, a_2,cdots , a_n$. Moreover, there are $m$ queries, each query has one of the two types:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Format of the query “$1$ $l$ $r$”. In reply to the query, you need to add $F_{i-l+1}$ to each element $a_i$, where $l\le i\le r$.&lt;/li&gt;
&lt;li&gt;Format of the query “$2$ $l$ $r$”. In reply to the query you should output the value of  $\sum_{i=l}^{r}{a_i}$ modulo $10^9+9$.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Help $DZY$ reply to all the queries.&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;The first line of the input contains two integers $n$ and $m$ $(1 \le n, m \le 3\times 10^5)$. The second line contains &lt;em&gt;n&lt;/em&gt; integers $a_1, a_2, \cdots, a_n (1 ≤ a_i \le10^9)$ — initial array $a$.&lt;br&gt;Then, &lt;em&gt;m&lt;/em&gt; lines follow. A single line describes a single query in the format given in the statement. It is guaranteed that for each query inequality $1 \le l \le r \le n$ holds.&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;For each query of the second type, print the value of the sum on a single line.&lt;br&gt;
    
    </summary>
    
    
      <category term="线段树" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="CodeForces" scheme="http://yoursite.com/tags/CodeForces/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2671 Calc &lt;莫比乌斯反演&gt;</title>
    <link href="http://yoursite.com/2018/02/12/BZOJ2671%20Calc%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://yoursite.com/2018/02/12/BZOJ2671 Calc 莫比乌斯反演/</id>
    <published>2018-02-11T16:00:00.000Z</published>
    <updated>2018-03-03T11:58:02.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Calc"><a href="#Calc" class="headerlink" title="Calc"></a>Calc</h3><p>Time Limit: $10 Sec$<br>Memory Limit: $128 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给出$N$，统计满足下面条件的数对$(a,b)$的个数：</p><ul><li>$1\le a&lt;b\le N$</li><li>$(a+b)|(a\cdot b)$</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一行一个数$N$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个数表示答案。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><table><thead><tr><th style="text-align:center"><font color="#000000">测试点编号</font></th><th style="text-align:center"><font color="#000000">数据规模</font></th><th style="text-align:center"><font color="#000000">测试点编号</font></th><th style="text-align:center"><font color="#000000">数据规模</font></th></tr></thead><tbody><tr><td style="text-align:center">$01$</td><td style="text-align:center">$N\le 10$</td><td style="text-align:center">$11$</td><td style="text-align:center">$N\le 5\times 10^7$</td></tr><tr><td style="text-align:center">$02$</td><td style="text-align:center">$N \le 50$</td><td style="text-align:center">$12$</td><td style="text-align:center">$N\le 10^8$</td></tr><tr><td style="text-align:center">$03$</td><td style="text-align:center">$N\le 10^3$</td><td style="text-align:center">$13$</td><td style="text-align:center">$N\le 2\times 10^8$</td></tr><tr><td style="text-align:center">$04$</td><td style="text-align:center">$N\le 5\times 10^3$</td><td style="text-align:center">$14$</td><td style="text-align:center">$N\le 3\times 10^8$</td></tr><tr><td style="text-align:center">$05$</td><td style="text-align:center">$N\le 2\times 10^4$</td><td style="text-align:center">$15$</td><td style="text-align:center">$N\le 5\times 10^8$</td></tr><tr><td style="text-align:center">$06$</td><td style="text-align:center">$N\le 2\times 10^5$</td><td style="text-align:center">$16$</td><td style="text-align:center">$N\le 10^9$</td></tr><tr><td style="text-align:center">$07$</td><td style="text-align:center">$N\le 2\times 10^6$</td><td style="text-align:center">$17$</td><td style="text-align:center">$N\le 10^9$</td></tr><tr><td style="text-align:center">$08$</td><td style="text-align:center">$N\le 10^7$</td><td style="text-align:center">$18$</td><td style="text-align:center">$N\le 2^{31}-1$</td></tr><tr><td style="text-align:center">$09$</td><td style="text-align:center">$N\le 2\times 10^7$</td><td style="text-align:center">$19$</td><td style="text-align:center">$N\le 2^{31}-1$</td></tr><tr><td style="text-align:center">$10$</td><td style="text-align:center">$N\le 3\times 10^7$</td><td style="text-align:center">$20$</td><td style="text-align:center">$N\le 2^{31}-1$</td></tr></tbody></table><p>标签：莫比乌斯反演</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>一道稍有变形的莫比乌斯反演，$blutrex$有$O(n^{\frac{3}{4}})$的算法，但我只会小常数的$O(n)$算法，不过可以过$BZOJ$数据。</p><p>问题即求$\sum_{i=1}^{n}\sum_{j=i+1}^{n}{[(i+j)|(i\times j)]}$的值。设$\gcd(i,j)=d$, $i=x\times d$, $j=y\times d$，易知$\gcd(x,y)=1$。<br>那么$(i+j)|(i\times j)$$\iff$$((x+y)\times d)|(x\times y\times d^2)$$\iff$$(x+y)|(x\times y\times d)$$\iff$$(x+y)|d$。<br>不妨设$d=k\times(x+y)​$，那么$a=x\times d=k\times x\times(x+y)​$, $b=y\times d=k\times y\times(x+y)​$。<br>有<br>$$<br>\begin{equation}<br>\begin{aligned}<br>原式 =&amp; \sum_{x=1}^{n}\sum_{y=x+1}^{n}[\gcd(x,y)=1 \&amp;\&amp; a&lt;b\le n]\\<br>=&amp; \sum_{y=1}^{\lfloor\sqrt{n}-1\rfloor}\sum_{x=1}^{y-1}\sum_{k\in \mathbb{Z}^*}{[\gcd(x,y)=1 \&amp;\&amp; k\times y\times (x+y)\le n]}\\<br>=&amp; \sum_{y=1}^{\lfloor\sqrt{n}-1\rfloor}\sum_{x=1}^{y-1}[\gcd(x,y)=1]\times \lfloor\frac{n}{y\times(x+y)}\rfloor\\<br>\end{aligned}<br>\end{equation}<br>$$<br>显然$val=\lfloor\frac{n}{y\times(x+y)}\rfloor$只有$\sqrt{n}$级别种取值，可以根号分块来算，即枚举$y$，每次找到$val$相等的一段$x\in[lo,hi]$，统计$[lo,hi]$间满足$\gcd(x,y)=1$的$x$的个数，可以套用基础莫比乌斯反演公式，即$\sum_{d|y}{\mu(d)\cdot(\lfloor\frac{hi}{d}\rfloor-\lfloor\frac{lo-1}{d}\rfloor)}$。</p><p>此算法先枚举$y$的取值，再枚举$val$的取值，最后枚举$y$的约数$d$计算反演。其中$y$有$\sqrt{n}$级别种取值，$val$所对应的$[lo,hi]$都在$(0,y)$之间，即共有$\sqrt{y}\thickapprox\sqrt[4]{n}$级别种取值，而最后的$d$又有$\sqrt{y}\thickapprox\sqrt[4]{n}$级别种取值，故总时间复杂度应为$O(n)$。但是由于$val$的取值总数通常到不了$\sqrt[4]{n}$级别，且$d$的取值总数通常也到不了$\sqrt[4]{n}$级别，因此常数非常小，跑得贼快，可以过此题$2\times 10^9$级别的数据。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>], fac[MAX_N+<span class="number">5</span>], cnt;<span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PriS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((x = i*pri[j]) &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[x] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[x] = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;read(n), PriS();lnt ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (lnt i = <span class="number">1</span>, l, r; i &lt; <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line">cnt = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">sqrt</span>(i); j++) <span class="keyword">if</span> (i%j == <span class="number">0</span>) fac[cnt++] = j;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span>; l &lt; i; l = r+<span class="number">1</span>) &#123;</span><br><span class="line">lnt val = n/(i*(i+l)); <span class="keyword">if</span> (!val) <span class="keyword">break</span>;r = min(n/val/i-i, i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (lnt k = <span class="number">0</span>, j; k &lt; cnt; k++) &#123;</span><br><span class="line">j = fac[k], ans += mu[j]*(r/j-(l<span class="number">-1</span>)/j)*val;lnt t = i/j;</span><br><span class="line"><span class="keyword">if</span> (i%t == <span class="number">0</span> &amp;&amp; (j^t)) ans += mu[t]*(r/t-(l<span class="number">-1</span>)/t)*val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;Calc&quot;&gt;&lt;a href=&quot;#Calc&quot; class=&quot;headerlink&quot; title=&quot;Calc&quot;&gt;&lt;/a&gt;Calc&lt;/h3&gt;&lt;p&gt;Time Limit: $10 Sec$&lt;br&gt;Memory Limit: $128 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给出$N$，统计满足下面条件的数对$(a,b)$的个数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$1\le a&amp;lt;b\le N$&lt;/li&gt;
&lt;li&gt;$(a+b)|(a\cdot b)$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一行一个数$N$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一行一个数表示答案。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://yoursite.com/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://yoursite.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2339【HNOI2011】卡农 &lt;计数DP+组合数学&gt;</title>
    <link href="http://yoursite.com/2018/02/11/BZOJ2339%E3%80%90HNOI2011%E3%80%91%E5%8D%A1%E5%86%9C%20%E8%AE%A1%E6%95%B0DP+%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <id>http://yoursite.com/2018/02/11/BZOJ2339【HNOI2011】卡农 计数DP+组合数学/</id>
    <published>2018-02-10T16:00:00.000Z</published>
    <updated>2018-03-03T11:53:47.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【HNOI2011】卡农"><a href="#【HNOI2011】卡农" class="headerlink" title="【HNOI2011】卡农"></a>【HNOI2011】卡农</h3><p>Time Limit: $10 Sec$<br>Memory Limit: $128MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="https://i.loli.net/2018/02/11/5a8034a027595.jpg" alt=""></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p><img src="https://i.loli.net/2018/02/11/5a8034c89c9e6.jpg" alt=""></p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p><img src="https://i.loli.net/2018/02/11/5a8034e3bc6fd.jpg" alt=""><br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p><img src="https://i.loli.net/2018/02/11/5a8034f8900b2.jpg" alt=""> </p><p>标签：计数$DP$</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>考试时没想出来，不过听了觉得挺简单的。</p><p>首先把每个片段看成一个数，每个音阶看成该数的一位，则每位为$0$或$1$，题意可以转化为求在$1\sim 2^n-1$中选$m$个数使其异或和为$0$的方案数。我们先不考虑无序性，求出所有排列后除$m!$即为答案。</p><p>设$f[i]$为选$i$个数的方案数，考虑先选$i-1$个数，最后一个数即为前面的数的异或和，这样才能使总异或和位$0$。那么如果不考虑限制，直接选则有$P_{2^n-1}^{i-1}=(2^n-1)\times (2^n-2)\times (2^n-3)\times \cdots \times (2^n-i+1)$种选法。</p><p>只可能有两种不合法的情况，即最后一个数位$0$或最后一个数在前面$i-1$个数种出现过。对于第一种情况，不合法方案数为选$i-1$个数的合法方案数，即为$f[i-1]$。而对于第二种情况，去掉相同的数后，其他数异或和为$0$，这样就有$f[i-2]$中方案，而去掉的数的位置有$i-1$种选法，去掉的数的值有$2^n-1-(i-2)$种选法，故共会去掉$f[i-2]\times (i-1)\times (2^n-i+1)$种不合法方案。</p><p>于是，$DP$方程为<br>$$<br>f[i]=<br>\begin{cases}<br>            1 &amp;\mbox{$(i=0)$}\\<br>            0 &amp;\mbox{$(i=1)$}\\<br>(2^n-1)\times (2^n-2)\times \cdots \times (2^n-i+1)-f[i-1]-f[i-2]\times (i-1)\times (2^n-i+1) &amp;\mbox{$(i\ge 2)$}<br>\end{cases}<br>$$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 100000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;lnt p, q, c, f[MAX_N+<span class="number">5</span>], g[MAX_N+<span class="number">5</span>], inv[MAX_N+<span class="number">5</span>] = &#123;<span class="number">1L</span>L, <span class="number">1L</span>L&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) inv[i] = (MOD-MOD/i*inv[MOD%i]%MOD)%MOD;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(m), read(n), init(n), p = f[<span class="number">0</span>] = c = <span class="number">1L</span>L, f[<span class="number">1</span>] = <span class="number">0L</span>L, g[<span class="number">1</span>] = <span class="number">1L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) (p *= <span class="number">2</span>) %= MOD; (p += MOD<span class="number">-1</span>) %= MOD, q = p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++, (q += MOD<span class="number">-1</span>) %= MOD) g[i] = g[i<span class="number">-1</span>]*q%MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) f[i] = (g[i]-(f[i<span class="number">-1</span>]+<span class="number">1L</span>L*(i<span class="number">-1</span>)*(p-i+<span class="number">2</span>)%MOD*f[i<span class="number">-2</span>]%MOD)%MOD+MOD)%MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) (c *= inv[i]) %= MOD;<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>, f[n]*c%MOD), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【HNOI2011】卡农&quot;&gt;&lt;a href=&quot;#【HNOI2011】卡农&quot; class=&quot;headerlink&quot; title=&quot;【HNOI2011】卡农&quot;&gt;&lt;/a&gt;【HNOI2011】卡农&lt;/h3&gt;&lt;p&gt;Time Limit: $10 Sec$&lt;br&gt;Memory Limit: $128MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/11/5a8034a027595.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/11/5a8034c89c9e6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/02/11/5a8034e3bc6fd.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://yoursite.com/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="DP" scheme="http://yoursite.com/tags/DP/"/>
    
      <category term="组合数学" scheme="http://yoursite.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="计数" scheme="http://yoursite.com/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4334【JSOI2012】铁拳 &lt;上下界网络流&gt;</title>
    <link href="http://yoursite.com/2018/02/10/BZOJ4334%E3%80%90JSOI2012%E3%80%91%E9%93%81%E6%8B%B3%20%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://yoursite.com/2018/02/10/BZOJ4334【JSOI2012】铁拳 上下界网络流/</id>
    <published>2018-02-09T16:00:00.000Z</published>
    <updated>2018-02-10T12:51:57.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote><h2 id="【JSOI2012】铁拳"><a href="#【JSOI2012】铁拳" class="headerlink" title="【JSOI2012】铁拳"></a>【JSOI2012】铁拳</h2><p>Time Limit: $10 Sec$<br>Memory Limit: $256 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>经过了可怕的第三次世界大战后，国家政府崩溃，各大财团趁机夺取掌控世界。长年战争后，八大财团幸存并割据一方，其中最强的当属掌控北美的铁拳。<br>在铁拳财团所维护的文明区域中，有一项最为光荣、重要的赛事——$Iron Fist$，也就是铁拳大赛。$I$F中云集了世界各地各财团鼎力资助的世外高手，只为了赢得$IF Champion$，得到无上的荣耀，当然还有随之而来的权力。本来一切秩序井然，但一个来自贫民窟的少年风间仁意外地在海选中赢了$IF$正式选手，获得了决赛资格，从此格局被打乱……<br>为了应对这突如其来的变数，$IF$管理层决定先对联盟中所有的选手进行评估，以更好地掌握大局。<br>知最近$m$届比赛出现过的$n$位选手，背后都有着各自财团的资助，并且签下了合同。由于这是各财团的高度机密，合同的具体细节无从得知，但铁拳财团的间谍们通过各种渠道得知了每个选手的薪金范围（显然薪金是非负数）。<br>对于最近$m$届的$IF$比赛（从$1$开始编号），每一届联盟都会进行清算，通过国际金融手段准确计算出这一届联盟选手身价总和的变化。每一届中，会有一些新选手加入，也会有部分选手在比赛中丧失了战斗能力，而被踢出联盟，流放到贫民窟。<br>现在给出联盟中$n$位选手的身价范围，以及他们 进入联盟的届数（$0$表示在$m+1$届以前就已经是联盟选手） 和 离开联盟的届数（$0$表示是现役选手）。同时给出最近$m$届中，每一届联盟选手身价总和减去上一届的值。<br>请你根据现有信息，尽可能准确地给出每个选手可能的薪金范围。各选手之间的薪金范围可以不同时成立，但对于一位选手的范围中的每一个数，都必须至少存在一种合法方案使该选手能得到相应薪金，而且这个范围跨度要尽可能大。<br>如果输入信息有误，请输出$-1$，表示无解。 </p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个正整数$m$，意义见上（下同）。<br>第二行包含$m$个整数，第$i$个表示第$i$届中 选手身价总和 的变化情况。<br>第三行一个正整数$n$。<br>接下来n行，每行包含四个整数，分别表示 身价下限 、 身价上限 、 出道届数 、 退役届数，细节请参照上文。<br>保证出道时间严格比退役时间小（$0$除外）。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，输出最小的答案。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5 -1</span><br><span class="line">3</span><br><span class="line">1 4 1 0</span><br><span class="line">2 3 1 0</span><br><span class="line">1 5 1 2</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.00 2.00</span><br><span class="line">2.00 3.00</span><br><span class="line">1.00 1.00</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>【样例解释】<br>第二届只有$3$号离开了，可以锁定$3$号的薪金是$1$。<br>如此一来，$1$号和$2$号薪金之和为$4$，那么$1$号最少能拿$1$，最多能拿$2$；$2$号最少能拿到$2$，最多能拿到$3$。<br>【数据规模】<br>对于$100\%$的数据，$n\le 200$，$m\le 100$，给定薪金范围不超过$20000$。<br>应上传者要求，此题不公开，如有异议，请提出.</p></blockquote><p>标签：线性规划，上下界网络流</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>线性规划转上下界网络流。<br>挺麻烦的。</p><p>首先这些条件可以看作$m$个等式，故可转化为线性规划。而解线性规划只有网络流和单纯形两种，不会单纯形，所以用了网络流。</p><p>将每个等式作为一个点，每个变量作为一条边，不难发现一个变量只会进入等式一次，出等式一次。若此变量从$l$等式进，从$r$等式出，范围为$[lo, hi]$，则连边$l\to r$，容量为$[lo,hi]$。对于$l=0$的变量，则连边$s\to r$；对于$r=0$的变量，则连边$l\to t$。<br>接下来处理每个等式的差值。可以发现等式$i-1$与$i$的差值可以用边$s\to i$或$i\to t$表示，即为从源点补进来多少流量或从汇点分出去多少流量。因而可以连边：设等式$i-1$与$i$的差值为$gap_i$，若$gap_i&gt;0$，则连边$S\to i$，容量为$gap_i$；若$gap_i&lt;0$，则连边$i\to T$，容量为$-gap_i$。<br>这样就可以构建出一个上下界网络流的模型。</p><p>建模后，可以在一开始就跑一遍可行流，判断是否有解。</p><p>之后有两种做法：</p><p>法$1$：对每条边的取值进行二分，分别去找最大值和最小值，每次$check$的时候把重设当前边的范围，跑可行流验证。</p><p>法$2$：对于每条边，找到先前求可行流时它的流量，考虑它最多可以再少承担多少流量或多承担多少流量。那么可以在残量网络上断掉当前边，以起点为源，终点为汇，跑最大流得到它最多可以减少多少流量；再以终点为汇，起点为源，跑最大流得到它最多可以增加多少流量。设最多可以减少$maxDecrease$，最多可以增加$maxIncrease$，此边的下限为$lo$，上限为$hi$，可行流中此边的流量为$cur$，则答案为$lo+cur-maxDecrease$和$lo+cur+maxIncrease$。这里需要注意两个答案都需要在$[lo,hi]$之间，即最终答案应该为$max(lo,lo+cur-maxDecrease)$和$min(hi,lo+cur+maxIncrease)$。</p><p>建议使用法$2$，同时$\%\%\%巨佬Joker$提供优质法$2$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>], cpy[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, ss, tt, cnt, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], mat[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> gap[MAX_N+<span class="number">5</span>], range[MAX_N+<span class="number">5</span>][<span class="number">2</span>], zone[MAX_N+<span class="number">5</span>][<span class="number">2</span>];<span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;ss = m+<span class="number">1</span>, tt = m+<span class="number">2</span>, s = <span class="number">0</span>, t = m+<span class="number">3</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;<span class="keyword">return</span> insert(u, v, c), insert(v, u, <span class="number">0</span>), cnt<span class="number">-2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c || mrk[i]) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c || mrk[i]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>;<span class="keyword">while</span> (BFS()) ret += DFS(s, INF);<span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">get_ava</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> into = <span class="number">0</span>, outo = <span class="number">0</span>;</span><br><span class="line">init(), <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);addedge(tt, ss, INF);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (gap[i] &gt; <span class="number">0</span>) d[ss] += gap[i], d[i] -= gap[i];</span><br><span class="line"><span class="keyword">if</span> (gap[i] &lt; <span class="number">0</span>) d[i] -= gap[i], d[tt] += gap[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = zone[i][<span class="number">0</span>] == <span class="number">0</span> ? ss : zone[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> v = zone[i][<span class="number">1</span>] == <span class="number">0</span> ? tt : zone[i][<span class="number">1</span>];</span><br><span class="line">mat[i] = addedge(u, v, range[i][<span class="number">1</span>]-range[i][<span class="number">0</span>]);</span><br><span class="line">d[u] += range[i][<span class="number">0</span>], d[v] -= range[i][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = s+<span class="number">1</span>; i &lt;= t<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; <span class="number">0</span>) addedge(s, i, -d[i]), into -= d[i];</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) addedge(i, t, d[i]), outo += d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> into == outo &amp;&amp; Dinic() == into;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) E[i] = cpy[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(m);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(gap[i]);</span><br><span class="line">read(n);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(range[i][<span class="number">0</span>]), read(range[i][<span class="number">1</span>]), read(zone[i][<span class="number">0</span>]), read(zone[i][<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!get_ava()) &#123;<span class="built_in">puts</span>(<span class="string">"-1"</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) cpy[i] = E[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> eid = mat[i], base = E[eid^<span class="number">1</span>].c, ori = E[eid].c+base;mrk[eid] = mrk[eid^<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">s = E[eid^<span class="number">1</span>].v, t = E[eid].v, <span class="built_in">printf</span>(<span class="string">"%d.00 "</span>, range[i][<span class="number">0</span>]+max(base-Dinic(), <span class="number">0</span>)), rec();</span><br><span class="line">s = E[eid].v, t = E[eid^<span class="number">1</span>].v, <span class="built_in">printf</span>(<span class="string">"%d.00\n"</span>, range[i][<span class="number">0</span>]+min(base+Dinic(), ori)), rec();</span><br><span class="line">mrk[eid] = mrk[eid^<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;【JSOI2012】铁拳&quot;&gt;&lt;a href=&quot;#【JSOI201
      
    
    </summary>
    
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="上下界网络流" scheme="http://yoursite.com/tags/%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="线性规划" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1069【SCOI2007】最大土地面积 &lt;旋转卡壳&gt;</title>
    <link href="http://yoursite.com/2018/02/09/BZOJ1069%E3%80%90SCOI2007%E3%80%91%E6%9C%80%E5%A4%A7%E5%9C%9F%E5%9C%B0%E9%9D%A2%E7%A7%AF%20%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    <id>http://yoursite.com/2018/02/09/BZOJ1069【SCOI2007】最大土地面积 旋转卡壳/</id>
    <published>2018-02-08T16:00:00.000Z</published>
    <updated>2018-02-09T12:25:46.967Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote><h2 id="【SCOI2007】最大土地面积"><a href="#【SCOI2007】最大土地面积" class="headerlink" title="【SCOI2007】最大土地面积"></a>【SCOI2007】最大土地面积</h2><p>Time Limit: $1 Sec$<br>Memory Limit: $128 MB$</p></blockquote><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在某块平面土地上有$N$个点，你可以选择其中的任意四个点，使得这四个点围成的土地面积最大。</p><blockquote></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第$1$行一个正整数$N$，接下来$N$行，每行$2$个数$x,y$，表示该点的横坐标和纵坐标。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>最大的多边形面积，答案精确到小数点后$3$位。</p><blockquote></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">0 0</span><br><span class="line">1 0</span><br><span class="line">1 1</span><br><span class="line">0 1</span><br><span class="line">0.5 0.5</span><br></pre></td></tr></table></figure><blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.000</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>数据范围: $n\le 2000$，$|x|,|y|\le 10^5$</p></blockquote><p>标签：旋转卡壳</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>基础旋转卡壳。</p><p>首先这四个点一定在凸包上，先求凸包。</p><p>考虑枚举每条对角线，找出其两边最远的点，即可找到该对角线对应的最大四边形。<br>这样就是一个$O(n^3)$的暴力。</p><p>枚举对角线的一段，移动另一端，发现两边最远的点都是单调移动的，于是可以带上旋转卡壳，这样内层循环的总复杂度时$O(n)$，就有了一个$O(n^2)$的优质算法。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnt</span> &#123;</span></span><br><span class="line">dnt x, y;</span><br><span class="line">dnt <span class="keyword">operator</span> * (<span class="keyword">const</span> pnt &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x*t.y-y*t.x;&#125;</span><br><span class="line">pnt <span class="keyword">operator</span> - (<span class="keyword">const</span> pnt &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (pnt)&#123;x-t.x, y-t.y&#125;;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> pnt &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x == t.x ? y &lt; t.y : x &lt; t.x;&#125;</span><br><span class="line">&#125; p[MAX_N+<span class="number">5</span>], c[MAX_N*<span class="number">2</span>+<span class="number">5</span>], mat[MAX_N*<span class="number">2</span>+<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function">dnt <span class="title">S</span><span class="params">(pnt a, pnt b, pnt c, pnt d)</span> </span>&#123;<span class="keyword">return</span> (a*b+b*c+c*d+d*a)/<span class="number">2</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConvexHull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>), c[++m] = p[<span class="number">1</span>], c[++m] = p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; c[++m] = p[i++])</span><br><span class="line"><span class="keyword">while</span> (m &gt; <span class="number">1</span> &amp;&amp; (p[i]-c[m<span class="number">-1</span>])*(c[m]-c[m<span class="number">-1</span>]) &gt;= <span class="number">0</span>) m--;</span><br><span class="line"><span class="keyword">int</span> t = m;c[++m] = p[n<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>; i; c[++m] = p[i--])</span><br><span class="line"><span class="keyword">while</span> (m &gt; t &amp;&amp; (p[i]-c[m<span class="number">-1</span>])*(c[m]-c[m<span class="number">-1</span>]) &gt;= <span class="number">0</span>) m--;</span><br><span class="line">m--;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) c[i+m] = c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">dnt <span class="title">RotatingCalipers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">dnt ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">3</span>) <span class="keyword">return</span> (c[<span class="number">1</span>]*c[<span class="number">2</span>]+c[<span class="number">2</span>]*c[<span class="number">3</span>]+c[<span class="number">3</span>]*c[<span class="number">1</span>])/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">2</span>, t = j<span class="number">-1</span>; j &lt;= i+m<span class="number">-2</span>; j++)</span><br><span class="line">&#123;<span class="keyword">while</span> (t &lt; j &amp;&amp; (c[t+<span class="number">1</span>]-c[t])*(c[j]-c[i]) &gt;= <span class="number">0</span>) t++;mat[j][<span class="number">0</span>] = c[t];&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+m<span class="number">-2</span>, t = j+<span class="number">1</span>; j &gt;= i+<span class="number">2</span>; j--)</span><br><span class="line">&#123;<span class="keyword">while</span> (t &gt; j &amp;&amp; (c[t<span class="number">-1</span>]-c[t])*(c[j]-c[i]) &lt;= <span class="number">0</span>) t--;mat[j][<span class="number">1</span>] = c[t];&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">2</span>; j &lt;= i+m<span class="number">-2</span>; j++) ret = max(ret, S(c[i], mat[j][<span class="number">0</span>], c[j], mat[j][<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y);</span><br><span class="line"><span class="keyword">return</span> ConvexHull(), <span class="built_in">printf</span>(<span class="string">"%.3lf"</span>, RotatingCalipers()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;【SCOI2007】最大土地面积&quot;&gt;&lt;a href=&quot;#【SCO
      
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://yoursite.com/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="旋转卡壳" scheme="http://yoursite.com/tags/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    
      <category term="计算几何" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2406 矩阵 &lt;上下界网络流&gt;</title>
    <link href="http://yoursite.com/2018/02/07/BZOJ2406%20%E7%9F%A9%E9%98%B5%20%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://yoursite.com/2018/02/07/BZOJ2406 矩阵 上下界网络流/</id>
    <published>2018-02-06T16:00:00.000Z</published>
    <updated>2018-02-10T12:10:40.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>Time Limit: $10 Sec$  Memory Limit: $128 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><img src="http://www.lydsy.com/JudgeOnline/upload/201107/2(1).jpg" alt=""></p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个数$n$、$m$，表示矩阵的大小。<br>接下来$n$行，每行$m$列，描述矩阵$A$。<br>最后一行两个数$L$，$R$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，输出最小的答案。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">0 1</span><br><span class="line">2 1</span><br><span class="line">0 1</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$N,M\le 200$, $0\le L\le R\le 1000$, $0\le A_{i,j}\le 1000$</p></blockquote><p>标签：线性规划，上下界网络流</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>线性规划转上下界网络流。<br>看到所求为最大值中的最小，可想到二分答案。<br>对于当前答案$tans​$，验证是否能构造矩阵B使得：</p><ul><li>对于$\forall i\in [1,n], \forall j\in[1,m]$，$L\le B_{i,j}\le R$</li><li>对于$\forall i \in [1,n]$，$\sum_{j=1}^{m}{A_{i,j}}-tans \le \sum_{j=1}^{m}{B_{i,j}} \le \sum_{j=1}^{m}{A_{i,j}}+tans$</li><li>对于$\forall j\in [1,m]$，$\sum_{i=1}^{n}{A_{i,j}}-tans \le \sum_{i=1}^{n}{B_{i,j}} \le \sum_{i=1}^{n}{A_{i,j}}+tans$<br>而$n,m$又只有200，不难想到跑网络流验证。</li></ul><p>将每行每列设为点（共$n+m$个），建图:</p><ul><li>$S\to row_i$ 容量$[\sum_{j=1}^{m}{A_{i,j}}-tans,  \sum_{j=1}^{m}{A_{i,j}}+tans]$</li><li>$column_j \to T$ 容量$[\sum_{i=1}^{n}{A_{i,j}}-tans,   \sum_{i=1}^{n}{A_{i,j}}+tans]$</li><li>$row_i\to column_j$ 容量$[L,  R]$</li></ul><p>赫然是个上下界网络流。<br>建虚拟源虚拟汇跑最大流看是否等于补流即可。<br>建图，$SS,TT$为上下界网络流的原源和原汇，$S,T$为虚拟源和汇，$d[]$记录补流：</p><ul><li>$TT\to SS$ 容量$\infty$</li><li>$row_i\to column_j​$ 容量$R-L​$，$d[row_i] +L,  d[column_j] - L​$</li><li>$SS\to row_i$ 容量$\sum_{j=1}^{m}{A_{i,j}}-tans$，$d[SS]+2\times tans,  d[row_i]-2\times tans$</li><li>$column_j \to TT$ 容量$\sum_{i=1}^{n}{A_{i,j}}-tans$，$d[column_j]+2\times tans,  d[TT]-2\times tans$</li></ul><p>随后将此图和虚拟源汇接上：<br>对于$x\in {row_{1\sim n}}\cup {column_{1\sim m}}\cup {SS,TT}$</p><ul><li>若$d[x] &lt; 0$，连接$S\to x$ 容量$-d[x]$，$tot_补-d[x]$</li><li>若$d[x] &gt; 0$，连接$x \to T$ 容量$d[x]$，$tot_分+d[x]$</li></ul><p>最后判断$tot_补=tot_分=MaxFlow$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((p+q)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> r, c, x[<span class="number">205</span>], y[<span class="number">205</span>], P, Q;</span><br><span class="line"><span class="keyword">int</span> n, s, t, ss, tt, cnt, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;cnt = <span class="number">0</span>, s = <span class="number">0</span>, t = r+c+<span class="number">1</span>, ss = t+<span class="number">1</span>, tt = t+<span class="number">2</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr), <span class="built_in">memset</span>(d, <span class="number">0</span>, <span class="keyword">sizeof</span> d);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>;<span class="keyword">while</span> (BFS()) ret += DFS(s, INF);<span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> tans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> into = <span class="number">0</span>, outo = <span class="number">0</span>;init(), n = r+c+<span class="number">2</span>, addedge(tt, ss, INF);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">addedge(i, j+r, Q-P), d[i] += P, d[j+r] -= P;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++) addedge(ss, i, <span class="number">2</span>*tans), d[ss] += x[i]-tans, d[i] -= x[i]-tans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= c; i++) addedge(i+r, tt, <span class="number">2</span>*tans), d[i+r] += y[i]-tans, d[tt] -= y[i]-tans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tt; i++) <span class="keyword">if</span> (i^t) &#123;</span><br><span class="line"><span class="keyword">if</span> (d[i] &lt; <span class="number">0</span>) addedge(s, i, -d[i]), into -= d[i];</span><br><span class="line"><span class="keyword">if</span> (d[i] &gt; <span class="number">0</span>) addedge(i, t, d[i]), outo += d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> into == outo &amp;&amp; Dinic() == into;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">-1</span>; <span class="keyword">while</span> (p &lt;= q) <span class="keyword">if</span> (check(mid)) ret = mid, q = mid<span class="number">-1</span>; <span class="keyword">else</span> p = mid+<span class="number">1</span>; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(r), read(c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, val; j &lt;= c; j++)</span><br><span class="line">read(val), x[i] += val, y[j] += val;</span><br><span class="line"><span class="keyword">return</span> read(P), read(Q), <span class="built_in">printf</span>(<span class="string">"%d"</span>, bi_search(<span class="number">0</span>, <span class="number">200000</span>)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;矩阵&quot;&gt;&lt;a href=&quot;#矩阵&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="上下界网络流" scheme="http://yoursite.com/tags/%E4%B8%8A%E4%B8%8B%E7%95%8C%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="线性规划" scheme="http://yoursite.com/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3676【APIO2014】回文串 &lt;回文自动机&gt;</title>
    <link href="http://yoursite.com/2018/02/06/BZOJ3676%E3%80%90APIO2014%E3%80%91%E5%9B%9E%E6%96%87%E4%B8%B2%20%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://yoursite.com/2018/02/06/BZOJ3676【APIO2014】回文串 回文自动机/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-02-07T02:20:00.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote><h2 id="BZOJ3676【APIO2014】回文串"><a href="#BZOJ3676【APIO2014】回文串" class="headerlink" title="BZOJ3676【APIO2014】回文串"></a>BZOJ3676【APIO2014】回文串</h2><p>Time Limit: $20 Sec$  Memory Limit: $128 MB$</p></blockquote><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。<br>对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。</p><blockquote></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入只有一行，为一个只包含小写字母$(a-z)$的非空字符串 $s$。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示所有回文子串中的最大存在值。</p><blockquote></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p>【样例输入$1$】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abacaba</span><br></pre></td></tr></table></figure></p><blockquote><p>【样例输入$2$】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p>【样例输出$1$】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>【样例输出$2$】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>一个串是回文的，当且仅当它从左到右读和从右到左读完全一样。<br>在第一个样例中，回文子串有$7$个：$a$，$b$，$c$，$aba$，$aca$，$bacab$，$abacaba$，其中： </p><ul><li>a出现$4$次，其出现值为$4$：$4\times 1=4$ </li><li>b出现$2$次，其出现值为$2$：$2\times 1=2$ </li><li>c出现$1$次，其出现值为$1$：$1\times 1=1$</li><li>aba出现$2$次，其出现值为$6$：$2\times 3=6$ </li><li>aca出现$1$次，其出现值为$3$：$1\times 3=3$ </li><li>bacab出现$1$次，其出现值为$5$：$1\times 5=5$ </li><li>abacaba出现$1$次，其出现值为$7$：$1\times 7=7$<br>故最大回文子串出现值为$7$。<br>【数据规模与评分】<br>数据满足 $1\le 字符串长度\le 3\times 10^5$。</li></ul></blockquote><p>标签：回文自动机</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>回文自动机建出来直接统计答案。<br>具体回文自动机讲解参见 $poursoul$ 的博客：<a href="http://blog.csdn.net/u013368721/article/details/42100363" target="_blank" rel="noopener">http://blog.csdn.net/u013368721/article/details/42100363</a></p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICNUM 26</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 300000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">char</span> s[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> cnt, trie[MAX_N+<span class="number">5</span>][DICNUM], fail[MAX_N+<span class="number">5</span>], end[MAX_N+<span class="number">5</span>], len[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> l)</span> </span>&#123;len[++cnt] = l;<span class="keyword">return</span> cnt;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;fail[<span class="number">0</span>] = newnode(<span class="number">-1</span>), s[<span class="number">0</span>] = <span class="string">'$'</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l)</span> </span>&#123;<span class="keyword">while</span> (s[l-len[x]<span class="number">-1</span>]^s[l]) x = fail[x];<span class="keyword">return</span> x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>), init();<span class="keyword">int</span> n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>, x=s[<span class="number">1</span>]-<span class="string">'a'</span>, pre=<span class="number">0</span>, cur=getf(pre,<span class="number">1</span>); i&lt;=n; end[pre=trie[cur][x]]++, x=s[++i]-<span class="string">'a'</span>, cur=getf(pre,i))</span><br><span class="line"><span class="keyword">if</span> (!trie[cur][x]) newnode(len[cur]+<span class="number">2</span>), fail[cnt] = trie[getf(fail[cur], i)][x], trie[cur][x] = cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cnt; i; i--) end[fail[i]] += end[i];lnt ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) ans = max(ans, <span class="number">1L</span>L*len[i]*end[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;BZOJ3676【APIO2014】回文串&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="APIO" scheme="http://yoursite.com/tags/APIO/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="回文自动机" scheme="http://yoursite.com/tags/%E5%9B%9E%E6%96%87%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3676【NOI2015】品酒大会 &lt;后缀数组+并查集&gt;</title>
    <link href="http://yoursite.com/2018/02/06/BZOJ4199%E3%80%90NOI2015%E3%80%91%E5%93%81%E9%85%92%E5%A4%A7%E4%BC%9A%20%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    <id>http://yoursite.com/2018/02/06/BZOJ4199【NOI2015】品酒大会 后缀数组/</id>
    <published>2018-02-05T16:00:00.000Z</published>
    <updated>2018-02-09T02:53:56.834Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote><h2 id="BZOJ3676【NOI2015】品酒大会"><a href="#BZOJ3676【NOI2015】品酒大会" class="headerlink" title="BZOJ3676【NOI2015】品酒大会"></a>BZOJ3676【NOI2015】品酒大会</h2><p>Time Limit: $10 Sec$    Memory Limit: $512 MB$</p></blockquote><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一年一度的“幻影阁夏日品酒大会”隆重开幕了。大会包含品尝和趣味挑战两个环节，分别向优胜者颁发“首席品酒家”和“首席猎手”两个奖项，吸引了众多品酒师参加。<br>在大会的晚餐上，调酒师 $Rainbow$ 调制了 $n$ 杯鸡尾酒。这 $n$ 杯鸡尾酒排成一行，其中第 $i$ 杯酒 $(1\le i\le n)$ 被贴上了一个标签 $s_i$，每个标签都是 $26$ 个小写英文字母之一。设 $str(i,j)$ 表示第 $i$ 杯酒到第 $j$ 杯酒的 $j-i+1$ 个标签顺次连接构成的字符串。若 $str(l_1,r_1)=str(l_2,r_2)$，其中$1\le l_1\le r_1\le n$，$1\le l_2\le r_2\le n$，$l_1\ne l_2$，$r_1-l_1+1=r_2-l_2+1=p$，则称第 $l_1$ 杯酒与第 $l_2$ 杯酒是“$p$ 相似”的。当然两杯“$p$ 相似” $(p&gt;1)$ 的酒同时也是“$1$ 相似”、“$2$ 相似”、……、“$(p-1)$ 相似”的。特别地，对于任意的$1\le p,q\le n, p\ne q$，第 $p$ 杯酒和第 $q$ 杯酒都是“$0$ 相似”的。<br>在品尝环节上，品酒师 $Freda$ 轻松地评定了每一杯酒的美味度，凭借其专业的水准和经验成功夺取了“首席品酒家”的称号，其中第 $i$ 杯酒$(1\le i\le n)$ 的美味度为 $a_i$。现在 $Rainbow$ 公布了挑战环节的问题：本次大会调制的鸡尾酒有一个特点，如果把第 $i$ 杯酒与第 $j$ 杯酒调兑在一起，将得到一杯美味度为 $a_i\times a_j$ 的酒。现在请各位品酒师分别对于 $p = 0,1,2,\cdots ,p-1$，统计出有多少种方法可以选出 $2$ 杯“$p$ 相似”的酒，并回答选择 $2$ 杯“$p$相似”的酒调兑可以得到的美味度的最大值。 </p><blockquote></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第 $1$ 行包含 $1$ 个正整数 $n$，表示鸡尾酒的杯数。<br>第 $2$ 行包含一个长度为 $n$ 的字符串 $S$，其中第 i 个字符表示第 $i$ 杯酒的标签。<br>第 $3$ 行包含 $n$ 个整数，相邻整数之间用单个空格隔开，其中第 $i$ 个整数表示第 $i$ 杯酒的美味度 $a_i$。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出文件包括 $n$ 行。第 $i$ 行输出 $2$ 个整数，中间用单个空格隔开。第 $1$个整数表示选出两杯“$i-1$ 相似”的酒的方案数，第 $2$ 个整数表示选出两杯“$i-1$ 相似”的酒调兑可以得到的最大美味度。若不存在两杯“$i-1$ 相似”的酒，这两个数均为 $0$。 </p><blockquote></blockquote><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><h4 id="Sample-1"><a href="#Sample-1" class="headerlink" title="Sample 1"></a>Sample 1</h4><p><strong>Input</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">ponoiiipoi</span><br><span class="line">2 1 4 7 4 8 3 6 4 7</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>Output</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">45 56</span><br><span class="line">10 56</span><br><span class="line">3 32</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>Explanation</strong><br>二元组 $(p,q)$ 表示第 $p$ 杯酒与第 $q$ 杯酒。<br>$0$ 相似：所有 $45$ 对二元组都是 $0$ 相似的，美味度最大的是 $8\times 7=56$。<br>$1$ 相似：$(1,8)(2,4)(2,9)(4,9)(5,6)(5,7)(5,10)(6,7)(6,10)(7,10)，最大的是$$8\times 7=56$。<br>$2$ 相似：$(1,8)(4,9)(5,6)，最大的是 $4\times 8=32$。<br>没有 $3,4,5,\cdots ,9$ 相似的两杯酒，故均输出 $0$。</p><h4 id="Sample-2"><a href="#Sample-2" class="headerlink" title="Sample 2"></a>Sample 2</h4><p><strong>Input</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">abaabaabaaba</span><br><span class="line">1 -2 3 -4 5 -6 7 -8 9 -10 11 -12</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p><strong>Output</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">66 120</span><br><span class="line">34 120</span><br><span class="line">15 55</span><br><span class="line">12 40</span><br><span class="line">9 27</span><br><span class="line">7 16</span><br><span class="line">5 7</span><br><span class="line">3 -4</span><br><span class="line">2 -4</span><br><span class="line">1 -4</span><br><span class="line">0 0</span><br><span class="line">0 0</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p> 对于 $40\%$ 的数据， $n\le  2000$。<br> 有 $10\%$ 的数据，不存在“$10$ 相似”的酒。<br> 有 $20\%$ 的数据，所有 $a_i$ 的值都相等。<br> 对于 $100\%$ 的数据， $1\le n\le 300000, |a_i|\le 10^9$。</p></blockquote><p>标签：后缀数组，并查集</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>建后缀数组后统计每种$height$的后缀对有哪些，发现当从高向低枚举相似度$p$时，只会有越来越多的字符串满足，则每次合并新加进来的后缀对，用并查集维护。即若后缀$i$和$i-1$最高为$k$相似，则从$n$倒叙枚举到$k$时把$i$和$i-1$所在的集合合并。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 300000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">int</span> n, a[MAX_N+<span class="number">5</span>];<span class="keyword">char</span> s[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> sa[MAX_N+<span class="number">5</span>], rk[MAX_N+<span class="number">5</span>], height[MAX_N+<span class="number">5</span>], tsa[MAX_N+<span class="number">5</span>], cntA[MAX_N+<span class="number">5</span>], cntB[MAX_N+<span class="number">5</span>], A[MAX_N+<span class="number">5</span>], B[MAX_N+<span class="number">5</span>];</span><br><span class="line">lnt ans[MAX_N+<span class="number">5</span>][<span class="number">2</span>];<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; m[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> fa[MAX_N+<span class="number">5</span>], mina[MAX_N+<span class="number">5</span>], maxa[MAX_N+<span class="number">5</span>], size[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x == fa[x] ? x : fa[x] = getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CalcSA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) cntA[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cntA[s[i]-<span class="string">'a'</span>+<span class="number">1</span>]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) cntA[i] += cntA[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) sa[cntA[s[i]-<span class="string">'a'</span>+<span class="number">1</span>]--] = i;rk[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;rk[sa[i]] = rk[sa[i<span class="number">-1</span>]];<span class="keyword">if</span> (s[sa[i]] != s[sa[i<span class="number">-1</span>]]) rk[sa[i]]++;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; n; l &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cntA[i] = <span class="number">0</span>;<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cntB[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cntA[A[i] = rk[i]]++, cntB[B[i] = (i+l &lt;= n) ? rk[i+l] : <span class="number">0</span>]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cntB[i] += cntB[i<span class="number">-1</span>];<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) tsa[cntB[B[i]]--] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cntA[i] += cntA[i<span class="number">-1</span>];<span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) sa[cntA[A[tsa[i]]]--] = tsa[i];</span><br><span class="line">rk[sa[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">rk[sa[i]] = rk[sa[i<span class="number">-1</span>]];</span><br><span class="line"><span class="keyword">if</span> (A[sa[i]] != A[sa[i<span class="number">-1</span>]] || B[sa[i]] != B[sa[i<span class="number">-1</span>]]) rk[sa[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j)j--;</span><br><span class="line"><span class="keyword">while</span> (s[i+j] == s[sa[rk[i]<span class="number">-1</span>]+j]) j++;</span><br><span class="line">height[rk[i]] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n), <span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>);lnt tot = <span class="number">0</span>, pro = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, a+i);CalcSA();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) m[height[i]].push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i, size[i] = <span class="number">1</span>, mina[i] = maxa[i] = a[sa[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-1</span>; ~i; i--) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)m[i].size(); j++) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getf(m[i][j]), v = getf(m[i][j]<span class="number">-1</span>);<span class="keyword">if</span> (u == v)<span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (!tot) pro = max(<span class="number">1L</span>L*mina[u]*mina[v], <span class="number">1L</span>L*maxa[u]*maxa[v]);</span><br><span class="line"><span class="keyword">else</span> pro = max(pro, max(<span class="number">1L</span>L*mina[u]*mina[v], <span class="number">1L</span>L*maxa[u]*maxa[v]));</span><br><span class="line">tot += <span class="number">1L</span>L*size[u]*size[v], fa[v] = u, size[u] += size[v];</span><br><span class="line">mina[u] = min(mina[u], mina[v]), maxa[u] = max(maxa[u], maxa[v]);</span><br><span class="line">&#125;</span><br><span class="line">ans[i][<span class="number">0</span>] = tot, ans[i][<span class="number">1</span>] = pro;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans[i][<span class="number">0</span>], ans[i][<span class="number">1</span>]);<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;BZOJ3676【NOI2015】品酒大会&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="NOI" scheme="http://yoursite.com/tags/NOI/"/>
    
      <category term="字符串" scheme="http://yoursite.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀数组" scheme="http://yoursite.com/tags/%E5%90%8E%E7%BC%80%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3282 Tree &lt;LCT&gt;</title>
    <link href="http://yoursite.com/2018/01/15/BZOJ3282%20Tree%20LCT/"/>
    <id>http://yoursite.com/2018/01/15/BZOJ3282 Tree LCT/</id>
    <published>2018-01-14T16:00:00.000Z</published>
    <updated>2018-03-03T14:54:41.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Tree"><a href="#Tree" class="headerlink" title="Tree"></a>Tree</h3><p>Time Limit: $30 Sec$<br>Memory Limit: $512 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定$N$个点以及每个点的权值，要你处理接下来的$M$个操作。操作有$4$种。操作从$0$到$3$编号。点从$1$到$N$编号。</p><ol><li>后接两个整数 $(x, y)$，代表询问从$x$到$y$的路径上的点的权值的$xor$和。保证$x$到$y$是联通的。</li><li>后接两个整数 $(x, y)$，代表连接$x$到$y$，若x到y已经联通则无需连接。</li><li>后接两个整数 $(x, y)$，代表删除边$ (x, y)$，不保证边 $(x, y)$ 存在。</li><li>后接两个整数 $(x, y)$，代表将点$x$上的权值变成$y$。</li></ol><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第$1$行两个整数，分别为$N$和$M$，代表点数和操作数。<br>第$2$行到第$N+1$行，每行一个整数，整数在 $[1, 10^9]$ 内，代表每个点的权值。<br>第$N+2$行到第$N+M+1$行，每行三个整数，分别代表操作类型和操作所需的量。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一个$0$号操作，你须输出$x$到$y$的路径上点权的$xor$和。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 3 </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">1 1 2</span><br><span class="line">0 1 2 </span><br><span class="line">0 1 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$1\le N,M\le 3\times 10^5$</p><p>标签：LCT</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>LCT板子题<br>人生中的第一道LCT<br>用了没带保护指针的splay，有几个细节挺坑</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 300000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> flag (!tar(cur-&gt;fa-&gt;fa)&amp;&amp;cur-&gt;fa-&gt;fa-&gt;s[sn]==cur-&gt;fa)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SplayNode</span> &#123;</span></span><br><span class="line">SplayNode *s[<span class="number">2</span>], *fa;<span class="keyword">int</span> val, sum;<span class="keyword">bool</span> rev;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updata</span><span class="params">()</span> </span>&#123;sum = val^(s[<span class="number">0</span>]?s[<span class="number">0</span>]-&gt;sum:<span class="number">0</span>)^(s[<span class="number">1</span>]?s[<span class="number">1</span>]-&gt;sum:<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (fa &amp;&amp; (fa-&gt;s[<span class="number">0</span>] == <span class="keyword">this</span> || fa-&gt;s[<span class="number">1</span>] == <span class="keyword">this</span>)) fa-&gt;downtag();</span><br><span class="line"><span class="keyword">if</span> (rev &amp;&amp; s[<span class="number">0</span>]) swap(s[<span class="number">0</span>]-&gt;s[<span class="number">0</span>], s[<span class="number">0</span>]-&gt;s[<span class="number">1</span>]), s[<span class="number">0</span>]-&gt;rev ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (rev &amp;&amp; s[<span class="number">1</span>]) swap(s[<span class="number">1</span>]-&gt;s[<span class="number">0</span>], s[<span class="number">1</span>]-&gt;s[<span class="number">1</span>]), s[<span class="number">1</span>]-&gt;rev ^= <span class="number">1</span>;</span><br><span class="line">rev = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; *tr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkCutTree</span> &#123;</span></span><br><span class="line"><span class="function">SplayNode* <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">SplayNode* v = <span class="keyword">new</span> SplayNode;</span><br><span class="line">v-&gt;s[<span class="number">0</span>] = v-&gt;s[<span class="number">1</span>] = v-&gt;fa = <span class="literal">NULL</span>;</span><br><span class="line">v-&gt;val = v-&gt;sum = _val, v-&gt;rev = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SplayNode* <span class="title">get_rt</span><span class="params">(SplayNode* v)</span> </span>&#123;<span class="keyword">for</span> (; v-&gt;fa; v = v-&gt;fa) ;<span class="keyword">return</span> v;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tar</span><span class="params">(SplayNode* v)</span> </span>&#123;<span class="keyword">return</span> (v&amp;&amp;v-&gt;fa==<span class="literal">NULL</span>)||(v&amp;&amp;v-&gt;fa-&gt;s[<span class="number">0</span>]!=v&amp;&amp;v-&gt;fa-&gt;s[<span class="number">1</span>]!=v);&#125;</span><br><span class="line">LinkCutTree(<span class="keyword">int</span> n) &#123;<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>,_val;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;_val), tr[i]=newnode(_val);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(SplayNode* v, <span class="keyword">bool</span> sn)</span> </span>&#123;</span><br><span class="line">SplayNode* f = v-&gt;fa;</span><br><span class="line">f-&gt;s[sn^<span class="number">1</span>] = v-&gt;s[sn], v-&gt;fa = f-&gt;fa;</span><br><span class="line"><span class="keyword">if</span> (f-&gt;s[sn^<span class="number">1</span>]) f-&gt;s[sn^<span class="number">1</span>]-&gt;fa = f;</span><br><span class="line"><span class="keyword">if</span> (v-&gt;fa &amp;&amp; !tar(f)) v-&gt;fa-&gt;s[f == f-&gt;fa-&gt;s[<span class="number">1</span>]] = v;</span><br><span class="line">v-&gt;s[sn] = f, f-&gt;fa = v, f-&gt;updata(), v-&gt;updata();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">splay</span><span class="params">(SplayNode* cur)</span> </span>&#123;</span><br><span class="line">cur-&gt;downtag();</span><br><span class="line"><span class="keyword">while</span> (!tar(cur) &amp;&amp; !tar(cur-&gt;fa)) &#123;</span><br><span class="line"><span class="keyword">bool</span> sn = cur-&gt;fa-&gt;s[<span class="number">1</span>] == cur;</span><br><span class="line"><span class="function"><span class="keyword">if</span> flag <span class="title">rotate</span><span class="params">(cur-&gt;fa, sn^<span class="number">1</span>)</span></span>;</span><br><span class="line">rotate(cur, sn^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!tar(cur) &amp;&amp; tar(cur-&gt;fa))</span><br><span class="line">rotate(cur, cur-&gt;fa-&gt;s[<span class="number">0</span>] == cur);</span><br><span class="line">cur-&gt;updata();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">access</span><span class="params">(SplayNode* cur)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (SplayNode* cpy = <span class="literal">NULL</span>; cur; cpy = cur, cur = cur-&gt;fa)</span><br><span class="line">splay(cur), cur-&gt;s[<span class="number">1</span>] = cpy, cur-&gt;updata();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mroot</span><span class="params">(SplayNode* v)</span> </span>&#123;</span><br><span class="line">access(v), splay(v);</span><br><span class="line">swap(v-&gt;s[<span class="number">0</span>], v-&gt;s[<span class="number">1</span>]), v-&gt;rev ^= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">link</span><span class="params">(SplayNode* u, SplayNode* v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (get_rt(u) == get_rt(v)) <span class="keyword">return</span>;</span><br><span class="line">mroot(u), u-&gt;fa = v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cut</span><span class="params">(SplayNode* u, SplayNode* v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == v || get_rt(u) != get_rt(v)) <span class="keyword">return</span>;</span><br><span class="line">mroot(u), access(v), splay(v);</span><br><span class="line"><span class="keyword">if</span> (v-&gt;s[<span class="number">0</span>] == u) u-&gt;fa = v-&gt;s[<span class="number">0</span>] = <span class="literal">NULL</span>, v-&gt;updata();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(SplayNode* v, <span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">splay(v), v-&gt;val = _val, v-&gt;updata();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(SplayNode* u, SplayNode* v)</span> </span>&#123;</span><br><span class="line">mroot(u), access(v), splay(v);</span><br><span class="line"><span class="keyword">return</span> v-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="function">LinkCutTree <span class="title">LCT</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, x, y;<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;opt, &amp;x, &amp;y);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LCT.query(tr[x], tr[y]));</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) LCT.link(tr[x], tr[y]);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">2</span>) LCT.cut(tr[x], tr[y]);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">3</span>) LCT.modify(tr[x], y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;Tree&quot;&gt;&lt;a href=&quot;#Tree&quot; class=&quot;headerlink&quot; title=&quot;Tree&quot;&gt;&lt;/a&gt;Tree&lt;/h3&gt;&lt;p&gt;Time Limit: $30 Sec$&lt;br&gt;Memory Limit: $512 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定$N$个点以及每个点的权值，要你处理接下来的$M$个操作。操作有$4$种。操作从$0$到$3$编号。点从$1$到$N$编号。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;后接两个整数 $(x, y)$，代表询问从$x$到$y$的路径上的点的权值的$xor$和。保证$x$到$y$是联通的。&lt;/li&gt;
&lt;li&gt;后接两个整数 $(x, y)$，代表连接$x$到$y$，若x到y已经联通则无需连接。&lt;/li&gt;
&lt;li&gt;后接两个整数 $(x, y)$，代表删除边$ (x, y)$，不保证边 $(x, y)$ 存在。&lt;/li&gt;
&lt;li&gt;后接两个整数 $(x, y)$，代表将点$x$上的权值变成$y$。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第$1$行两个整数，分别为$N$和$M$，代表点数和操作数。&lt;br&gt;第$2$行到第$N+1$行，每行一个整数，整数在 $[1, 10^9]$ 内，代表每个点的权值。&lt;br&gt;第$N+2$行到第$N+M+1$行，每行三个整数，分别代表操作类型和操作所需的量。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每一个$0$号操作，你须输出$x$到$y$的路径上点权的$xor$和。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="LCT" scheme="http://yoursite.com/tags/LCT/"/>
    
  </entry>
  
  <entry>
    <title>201701219-30总结</title>
    <link href="http://yoursite.com/2018/01/06/20171219-30%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/06/20171219-30总结/</id>
    <published>2018-01-05T16:00:00.000Z</published>
    <updated>2018-01-06T02:06:41.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高新2017联训划水记"><a href="#高新2017联训划水记" class="headerlink" title="高新2017联训划水记"></a>高新2017联训划水记</h1><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>T1看到数论题就想放水…惊讶地发现貌似可以DP。不过状态定义出来推不出转移，就交了暴力…题解是个矩乘，我的状态没构造对。不过Joker貌似因为前置0出锅了。<br>T2怎么又是数论…不过化一化发现貌似底数和指数可以合到一起，就是BSGS的板子了。这时候发现了一个大问题…BSGS怎么写啊！BSGS怎么写啊！！BSGS怎么写啊！！！作为一个mr板都没写过的老年选手，我仍不会写BSGS。写了个随机化骗分，不过和暴力分一样。<br>T3好熟悉啊，FLOJ上出现三次的题呢，貌似叫什么重组病毒病毒重组之类的玩意。应该是个LCT吧。不过自己Splay板子都不熟，LCT就别说了，弃坑搞暴力。<br>水了三道低保，20+20+20=60pts。</p><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>T1没看到数据随机…打了一个n方的暴力，一直在想怎么搞到nlogn…结果是按长度排序后枚举且及时break…唯一的水题就这样甩了…<br>T2先想了想字典树，但是是没法搞的。又去推了推线性基，结果没推出了。打暴力弃坑。标解高消按两个关键字贪心。<br>T3由于T1的错误方向想太久已经没时间了，所幸交了暴力，水了30。标解线段树维护区间左右端黑白段长，需要线段树合并。<br>50+40+30=120pts</p><h2 id="Day3"><a href="#Day3" class="headerlink" title="Day3"></a>Day3</h2><p>T1数论，还好是水题。可知gcd一定是(a-b)的约数，(a-b)是固定的。因此枚举gcd即可。我和flx特判0写挂了，数据挺强，卡成70。<br>T2正解就别说了，连暴力都不好写。索性弃坑做T3。标解行列式，有点像矩阵树。<br>T3乱搞了一个KMP和一个Manacher，写完发现公用变量名了…调出*。按水50分写，最后因为常数得了40。<br>70+0+40=110pts</p><h2 id="Day4"><a href="#Day4" class="headerlink" title="Day4"></a>Day4</h2><p>T1nlogn二合一。后面nlogn的lcm会做，水20部分分，30的暴力打错了…标解前半段是平衡树维护做到nlogn，不过我下来看std发现可以值域线段树水过，反正是删排名为k的数。这样比平衡树快而且好写。<br>T2小学奥数。我没有推公式，直接打了一个30x30的表就把规律看出来了。水过。<br>T3看起来像是北京讲的群论。不过貌似不太会推。索性打暴力水20。<br>20+100+20=140pts</p><h2 id="Day5"><a href="#Day5" class="headerlink" title="Day5"></a>Day5</h2><p>YJQ的题目顺序huaji题。滚粗勒。<br>T1没推出公式…暴力滚粗<br>T2没思路…暴力滚粗<br>T3不会维护…暴力滚粗<br>T1正解数论错位相减推通项然后逆元搞搞<br>T2变成A走一步B走两步后最短路乱搞<br>T3维护max-min+L-R=0的区间。用单调栈+线段树搞搞即可<br>20+0+30=50pts</p><h2 id="Day6"><a href="#Day6" class="headerlink" title="Day6"></a>Day6</h2><p>唯一一次考好。<br>T1主席树套路题。有点卡常，不过把传参移到外面以后就瞬间快了6倍。<br>T2合并石子。不会做nlogn，但是会四边形优化的n^2和升序的贪心。水80pts。正解一个叫g什么的鬼畜算法，证明不详，平衡树维护一种贪心操作。<br>T3网络流，发现直接最小割是有锅的，写了分层暴力+错解最小割。正解把每条边建INF反边后跑最小割。<br>100+80+25=205pts</p><h2 id="Day8"><a href="#Day8" class="headerlink" title="Day8"></a>Day8</h2><p>T1推半天没推出来。用基本公式打暴力水60。正解通项是f(x)=φ(x)/2+μ(x)/2。杜教筛可过。<br>T2点分。不会合并信息，没做/QAQ。<br>T3网络流二合一。第二个写了，没写出第一个。贪心打第一个结果出锅了。<br>60+0+35=95pts</p><h2 id="Day9"><a href="#Day9" class="headerlink" title="Day9"></a>Day9</h2><p>T1没想到记忆化（我傻逼）打10pts暴力。正解记忆化，复杂度可证是玄学的O(nlogn√Q)。<br>T2是ZCY讲过的原题，树上背包，维护两个DP。我把两个DP打到一起了，互相更新答案，出锅QAQ。<br>T3丧心病狂WF网络流，不会建图没写。<br>10+40=50pts</p><h2 id="Day10"><a href="#Day10" class="headerlink" title="Day10"></a>Day10</h2><p>T1貌似可以CDQ但是没推出来。用单调栈写n^2部分分，结果定义了全局变量和局部变量n，以至于传进函数的n是0，然后就没输出…正解CDQ分治。<br>T2应该是DP，但是没推出来，按题目模拟水低保。正解n^3DP，wxh有O(n)的做法，学了学发现很精妙，不过很难想，细节也比较多。<br>T3想到是DP，但是细节太多，而且补集转换的全集不会求。标解DP，细节很多，转移方程一大堆。<br>0+40+30=70pts</p><h2 id="Day11"><a href="#Day11" class="headerlink" title="Day11"></a>Day11</h2><p>T1看出来是基环树森林里贪心，不过没调出来，交了n^2暴力，水60pts。正解和我想的一样。<br>T2水题没做起QAQ。暴力打错了，滚粗。<br>T3通讯题会前两个subtask，不会只染两种颜色。正解很精妙，用若干个四位二进制数表示倍增跑多少格，保证能识别三位就认出整个数，target当行位杂色行，上下方位交替杂色行和纯色行。<br>60+0+30=90pts</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>本次集训收获还是蛮大的。见识了一些比较新奇的玩意儿。不过考试也暴露出一些水题我想不出的情况，而且有时暴力还打错。另外，我貌似做套路题很上手，但是做一些灵活的题则很被动。需要多训练思维。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;高新2017联训划水记&quot;&gt;&lt;a href=&quot;#高新2017联训划水记&quot; class=&quot;headerlink&quot; title=&quot;高新2017联训划水记&quot;&gt;&lt;/a&gt;高新2017联训划水记&lt;/h1&gt;&lt;h2 id=&quot;Day1&quot;&gt;&lt;a href=&quot;#Day1&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="总结" scheme="http://yoursite.com/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>POJ2187 Beauty Contest &lt;旋转卡壳&gt;</title>
    <link href="http://yoursite.com/2017/12/30/POJ2187%20Beauty%20Contest%20%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    <id>http://yoursite.com/2017/12/30/POJ2187 Beauty Contest 旋转卡壳/</id>
    <published>2017-12-29T16:00:00.000Z</published>
    <updated>2018-02-09T12:46:45.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote><h2 id="Beauty-Contest"><a href="#Beauty-Contest" class="headerlink" title="Beauty Contest"></a>Beauty Contest</h2></blockquote><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>贝茜在牛的选美比赛中赢得了冠军”牛世界小姐”。因此,贝西会参观$N$($2\le N\le 50000$)个农场来传播善意。世界将被表示成一个二维平面,每个农场位于一对整数坐标$(x,y)$($-10000\le x,y \le 10000$)。没有两个农场共享相同的一对坐标。<br>尽管贝西沿直线前往下一个农场，但牧场之间的距离可能很大,所以她需要一个手提箱保证在每一段旅程中她有足够吃的食物。她想确定她可能需要旅行的最大可能距离,她要知道她必须带的手提箱的大小。帮助贝西计算农场的最大距离。</p><blockquote></blockquote><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第$1$行一个整数$n$，第$2\sim n+1$行两个整数$x_i y_i$表示$n$个农场中第$i$个的坐标</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，最远距离的平方</p><blockquote></blockquote><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 0</span><br><span class="line">0 1</span><br><span class="line">1 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure><blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure></blockquote><p>标签：旋转卡壳</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>平面最远点对。<br>旋转卡壳模板。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pnt</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> * (<span class="keyword">const</span> pnt &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x*t.y-y*t.x;&#125;</span><br><span class="line">pnt <span class="keyword">operator</span> - (<span class="keyword">const</span> pnt &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (pnt)&#123;x-t.x, y-t.y&#125;;&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> pnt &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x == t.x ? y &lt; t.y : x &lt; t.x;&#125;</span><br><span class="line">&#125; p[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sqr</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dis</span><span class="params">(pnt a, pnt b)</span> </span>&#123;<span class="keyword">return</span> sqr(a.x-b.x)+sqr(a.y-b.y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConvexHull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>), c[++m] = p[<span class="number">1</span>], c[++m] = p[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; c[++m] = p[i++])</span><br><span class="line"><span class="keyword">while</span> (m &gt; <span class="number">1</span> &amp;&amp; (p[i]-c[m<span class="number">-1</span>])*(c[m]-c[m<span class="number">-1</span>]) &gt;= <span class="number">0</span>) m--;</span><br><span class="line"><span class="keyword">int</span> t = m;c[++m] = p[n<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n<span class="number">-2</span>; i; c[++m] = p[i--])</span><br><span class="line"><span class="keyword">while</span> (m &gt; t &amp;&amp; (p[i]-c[m<span class="number">-1</span>])*(c[m]-c[m<span class="number">-1</span>]) &gt;= <span class="number">0</span>) m--;</span><br><span class="line">m--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RotatingCalipers</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m == <span class="number">2</span>) <span class="keyword">return</span> dis(c[<span class="number">1</span>], c[<span class="number">2</span>]);<span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (c[i] &lt; c[a]) a = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (c[b] &lt; c[i]) b = i;</span><br><span class="line"><span class="keyword">int</span> ret = dis(c[a], c[b]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> sa = a, sb = b; a^sb || b^sa; ret = max(ret, dis(c[a], c[b])))</span><br><span class="line">(c[a%m+<span class="number">1</span>]-c[a])*(c[b%m+<span class="number">1</span>]-c[b]) &lt;= <span class="number">0</span> ? a = a%m+<span class="number">1</span> : b = b%m+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(p[i].x), read(p[i].y);</span><br><span class="line"><span class="keyword">return</span> ConvexHull(), <span class="built_in">printf</span>(<span class="string">"%d"</span>, RotatingCalipers()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;Beauty-Contest&quot;&gt;&lt;a href=&quot;#Beauty
      
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://yoursite.com/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="旋转卡壳" scheme="http://yoursite.com/tags/%E6%97%8B%E8%BD%AC%E5%8D%A1%E5%A3%B3/"/>
    
      <category term="计算几何" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1930【SHOI2003】Pacman 吃豆豆 &lt;费用流&gt;</title>
    <link href="http://yoursite.com/2017/12/27/BZOJ1930%E3%80%90SHOI2003%E3%80%91Pacman%20%E5%90%83%E8%B1%86%E8%B1%86%20%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://yoursite.com/2017/12/27/BZOJ1930【SHOI2003】Pacman 吃豆豆 费用流/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-02-07T03:48:47.805Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote><h2 id="【SHOI2003】Pacman-吃豆豆"><a href="#【SHOI2003】Pacman-吃豆豆" class="headerlink" title="【SHOI2003】Pacman 吃豆豆"></a>【SHOI2003】Pacman 吃豆豆</h2><p>Time Limit: $10 Sec$  Memory Limit: $64 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>两个$PACMAN$吃豆豆。一开始的时候，$PACMAN$都在坐标原点的左下方，豆豆都在右上方。$PACMAN$走到豆豆处就会吃掉它。$PACMAN$行走的路线很奇怪，只能向右走或者向上走，他们行走的路线不可以相交。 请你帮这两个$PACMAN$计算一下，他们俩加起来最多能吃掉多少豆豆。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行为一个整数$N$，表示豆豆的数目。 接下来 $N$ 行，每行一对正整数，表示第$i$个豆豆的坐标。任意两个豆豆的坐标都不会重合。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅有一行包含一个整数，即两个$PACMAN$加起来最多能吃掉的豆豆数量</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">8 1</span><br><span class="line">1 5</span><br><span class="line">5 7</span><br><span class="line">2 2</span><br><span class="line">7 8</span><br><span class="line">4 6</span><br><span class="line">3 3</span><br><span class="line">6 4</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$N \le 2000$<br>【样例解释】</p><center><br><img src="http://www.lydsy.com/JudgeOnline/images/1930.jpg" alt=""><br></center></blockquote><p>标签：费用流</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>貌似是可以用$DP$肝的。<br>费用流建模细节挺多。<br>首先可以发现不相交时废话。若穿过则互换名字即可。<br>由于点数很多，所以不能两两连边，发现只需要把按$x$和$y$排序后相邻两点连边即可。<br>首先需要限制每个点的流量，需要将每个点拆成两个点，连边限流。<br>这里由于两条线可以经过同一个点，但贡献只算一个，则需要连两条边，流量均为$1$，而费用则是一条为$1$另一条为$0$。<br>注意源点也需要限制$2$的流量，即需要把源点拆成两个点，中间连流量$2$费用$0$的边。<br>相邻两点间连流量为$2$费用为$0$的边。<br>总结建图：<br>源点拆成两个点$S$和$SS$<br>$S\to SS$ 流量$2$ 费用$0$<br>把每个点拆成$i$和$i’$<br>$SS\to i$ 流量$2$ 费用$0$<br>$i’\to T$ 流量$2$ 费用$0$<br>$i\to i’$ 流量$1$ 费用$1$<br>$i\to i’$ 流量$1$ 费用$0$<br>可连边的相邻两点$i$和$j$间有<br>$i’\to j$ 流量$2$ 费用$0$<br>最后跑大费流即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 5000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span><span class="keyword">int</span> x, y;&#125; p[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, s, ss, t, cnt, pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>], mxf, mxc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, w, nxt;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, ss = n*<span class="number">2</span>+<span class="number">1</span>, t = n*<span class="number">2</span>+<span class="number">2</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span> <span class="params">(<span class="keyword">const</span> P &amp;a, <span class="keyword">const</span> P &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;insert(u, v, c, w), insert(v, u, <span class="number">0</span>, -w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;<span class="keyword">bool</span> inq[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> d[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq), <span class="built_in">memset</span>(cr, <span class="number">-1</span>, <span class="keyword">sizeof</span> cr);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d);d[s] = <span class="number">0</span>, que.push(s), inq[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop(), inq[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c, w = E[i].w;</span><br><span class="line"><span class="keyword">if</span> (c &amp;&amp; d[u]+w &gt; d[v]) &#123;</span><br><span class="line">d[v] = d[u]+w, cr[v] = i;</span><br><span class="line"><span class="keyword">if</span> (!inq[v]) que.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">int</span> flow = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) flow = min(flow, E[i].c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) E[i].c -= flow, E[i^<span class="number">1</span>].c += flow;</span><br><span class="line">mxf += flow, mxc += d[t];<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);init(), addedge(s, ss, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(ss, i, <span class="number">2</span>, <span class="number">0</span>), addedge(i+n, t, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(i, i+n, <span class="number">1</span>, <span class="number">1</span>), addedge(i, i+n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;p[i].x, &amp;p[i].y);sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, mi = INF; i &lt;= n; i++, mi = INF) <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (p[i].y &lt;= p[j].y &amp;&amp; p[j].y &lt;= mi) addedge(i+n, j, <span class="number">2</span>, <span class="number">0</span>), mi = p[j].y;</span><br><span class="line"><span class="keyword">while</span> (SPFA()) ;<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, mxc), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;【SHOI2003】Pacman-吃豆豆&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://yoursite.com/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="费用流" scheme="http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3442 学习小组 &lt;费用流&gt;</title>
    <link href="http://yoursite.com/2017/12/27/BZOJ3442%20%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%84%20%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://yoursite.com/2017/12/27/BZOJ3442 学习小组 费用流/</id>
    <published>2017-12-26T16:00:00.000Z</published>
    <updated>2018-02-07T01:22:38.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><blockquote><h2 id="学习小组"><a href="#学习小组" class="headerlink" title="学习小组"></a>学习小组</h2><p>Time Limit: $5 Sec$  Memory Limit: $128 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>坑校准备鼓励学生参加学习小组。<br>共有$n$个学生，$m$个学习小组，每个学生有一定的喜好，只愿意参加其中的一些学习小组，但是校领导为学生考虑，规定一个学生最多参加$k$个学习小组。财务处的大叔就没那么好了，他想尽量多收钱，因为每个学生参加学习小组都要交一定的手续费，不同的学习小组有不同的手续费。然而，事与愿违，校领导又决定对学习小组组织者进行奖励，若有$a$个学生参加第i个学习小组，那么给这个学习小组组织者奖励$C_i\times a^2$元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱（若为负数，则输出负数）（$支出=总奖励费-总手续费$）。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入有若干行，第一行有三个用空格隔开的正整数$n、m、k$。接下来的一行有$m$个正整数，表示每个$C_i$。第三行有$m$个正整数，表示参加每个学习小组需要交的手续费$F_i$。再接下来有一个$n$行$m$列的矩阵，表若第$i$行$j$列的数字是$1$，则表示第$i$个学生愿意参加第$j$个学习小组，若为$0$，则为不愿意。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出只有一个整数，为最小的支出。</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3 3 1</span><br><span class="line">1 2 3</span><br><span class="line">3 2 1</span><br><span class="line">111</span><br><span class="line">111</span><br><span class="line">111</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-2</span><br></pre></td></tr></table></figure></blockquote><blockquote><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>【样例解释】<br>参与学生最多为$3$，每个学生参加一个学习小组，若有两个学生参加第一个学习小组，一个学生参加第二个学习小组（一定要有人参加第二个学习小组），支出为$-2$，可以证明没有更优的方案了。<br>【数据范围与约定】<br>$100\%$的数据，$0＜n\le 100，0＜m\le 90，0＜k\le m，0＜Ci\le 10，0＜Fi\le 100$。</p></blockquote><p>标签：费用流</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>常规费用流建模。<br>建图：<br>每个学生为一个点，每个小组为一个点，共$n+m$个点。<br>对每个学生$p_i$，<br>$S\to p_i$ 流量$k$ 费用$0$ （限制最多选$k$个组）<br>$p_i\to T$ 流量$k-1$ 费用$0$ （限制至少选一个组）<br>对每个组$g_i$，<br>$g_i\to T$ 流量$1$ 费用$C_i\times (2j-1)$ 其中$j\in [1, n]$<br>即当前若有$x$个人，再多一个人会带来$C_i\times (x+1)^2-C_i\times x^2=C_i\times (2x+1)=C_i\times [2(x+1)-1]$的收益<br>学生和组之间则连边 $p_i\to g_j$ 流量$1$ 费用$-F_i$<br>跑小费流即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, k, s, t, cnt, pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>], mxf, mic;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, w, nxt;&#125; E[MAX_M+<span class="number">5</span>];<span class="keyword">int</span> f[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n+m+<span class="number">1</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;insert(u, v, c, w), insert(v, u, <span class="number">0</span>, -w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;<span class="keyword">bool</span> inq[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> d[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq), <span class="built_in">memset</span>(d, INF, <span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>, que.push(s), inq[s] = <span class="literal">true</span>, <span class="built_in">memset</span>(cr, <span class="number">-1</span>, <span class="keyword">sizeof</span> cr);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop(), inq[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c, w = E[i].w;</span><br><span class="line"><span class="keyword">if</span> (c &amp;&amp; d[u]+w &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u]+w, cr[v] = i;</span><br><span class="line"><span class="keyword">if</span> (!inq[v]) que.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == INF) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">int</span> flow = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) flow = min(flow, E[i].c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) E[i].c -= flow, E[i^<span class="number">1</span>].c += flow;</span><br><span class="line">mxf += flow, mic += d[t];<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;n, &amp;m, &amp;k), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(s, i, k, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(i, t, k<span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> c;<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">addedge(i+n, t, <span class="number">1</span>, c*(<span class="number">2</span>*j<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, f+i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> s[MAX_N];<span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) <span class="keyword">if</span> (s[j] == <span class="string">'1'</span>)</span><br><span class="line">addedge(i, j+n, <span class="number">1</span>, -f[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (SPFA()) ;<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, mic), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;学习小组&quot;&gt;&lt;a href=&quot;#学习小组&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="网络流" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://yoursite.com/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="费用流" scheme="http://yoursite.com/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
</feed>
