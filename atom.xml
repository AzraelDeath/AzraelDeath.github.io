<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NIRVANA</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://azrael.top/"/>
  <updated>2018-05-16T15:14:29.176Z</updated>
  <id>http://azrael.top/</id>
  
  <author>
    <name>Azrael_Death</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ2527【POI2011】Meteors &lt;整体二分&gt;</title>
    <link href="http://azrael.top/BZOJ2527%E3%80%90POI2011%E3%80%91Meteors%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    <id>http://azrael.top/BZOJ2527【POI2011】Meteors 整体二分/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-16T15:14:29.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【POI2011】Meteors"><a href="#【POI2011】Meteors" class="headerlink" title="【POI2011】Meteors"></a>【POI2011】Meteors</h3><p>$\mathrm{Time\;Limit:\;60\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Byteotian\;Interstellar\;Union}$有$N$个成员国。<br>现在它发现了一颗新的星球，这颗星球的轨道被分为$M$份（第$M$份和第$1$份相邻），第$i$份上有第$A_i$个国家的太空站。<br>这个星球经常会下陨石雨。$\mathrm{BIU}$已经预测了接下来$K$场陨石雨的情况。$\mathrm{BIU}$的第$i$个成员国希望能够收集$P_i$单位的陨石样本。<br>你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行输入两个数$N,M$。<br>第二行有$M$个数，第$i$个数$O_i$表示第$i$段轨道上有第$O_i$个国家的太空站。<br>第三行有$N$个数，第$i$个数$P_i$表示第$i$个国家希望收集的陨石数量。<br>第四行有一个数$K$，表示预测了接下来的$K$场陨石雨。<br>接下来$K$行，每行有三个数$L_i,R_i,A_i$，表示第$K$场陨石雨的发生地点在从$L_i$顺时针到$R_i$的区间中（如果$L_i\le R_i$，就是$L_i,L_i+1,\cdots,R_i$，否则就是$R_i,R_i+1,\cdots,m-1,m,1,\cdots,L_i$），向区间中的每个太空站提供$A_i$单位的陨石样本。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共$N$行。<br>第$i$行的数$W_i$表示第$i$个国家在第$W_i$波陨石雨之后能够收集到足够的陨石样本。<br>如果到第$K$波结束后仍然收集不到，输出<code>NIE</code>。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">1 3 2 1 3</span><br><span class="line">10 5 7</span><br><span class="line">3</span><br><span class="line">4 2 4</span><br><span class="line">1 3 1</span><br><span class="line">3 5 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">NIE</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le n,m,k\le3\times10^5$，$1\le P_i\le10^9$，$1\le A_i&lt;10^9$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>鸣谢<code>Object022</code></p><p>标签：<code>整体二分</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>整体二分模板题。</p><p>将所有询问离线下来一起做二分答案。对于二分中点$tans$，考虑每个国家是否能在前$tans$波流星雨之内达到收集要求。对每个国家用树状数组统计出会有多少陨石落到它的所有卫星上，即可判断每个询问的答案在$[s,tans]$中还是$[tans+1,t]$中。<br>注意每次判的时候不要将$1\sim tans$区间内的所有流星雨都加入树状数组修改，这样复杂度是伪的。应当对于每个答案区间在$[tans+1,t]$中的询问累加前面的陨石总数，即累加前面区间对后面的贡献。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M, Q, cnt, val[MAX_N+<span class="number">5</span>], ans[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> id, tp, a, b, k, s;&#125; p[MAX_N+<span class="number">5</span>], q[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> num[MAX_N+<span class="number">5</span>], tr[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">for</span> (; p &lt;= N; p += (p&amp;-p)) tr[p]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">for</span> (; p &lt;= N; p += (p&amp;-p)) tr[p]--;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; <span class="keyword">for</span> (; p; p -= (p&amp;-p)) ret += tr[p]; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bi_solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i].tp == <span class="number">3</span>) ans[p[i].id] = s;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i].tp == <span class="number">1</span> &amp;&amp; p[i].b &lt;= mid) inc(p[i].a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i].tp == <span class="number">2</span> &amp;&amp; p[i].b &lt;= mid) dec(p[i].a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i].tp == <span class="number">3</span>) num[i] = sum(p[i].b)-sum(p[i].a<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i].tp == <span class="number">1</span> &amp;&amp; p[i].b &lt;= mid) dec(p[i].a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i].tp == <span class="number">2</span> &amp;&amp; p[i].b &lt;= mid) inc(p[i].a);</span><br><span class="line"><span class="keyword">int</span> lsz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i].tp == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i].k &lt;= p[i].s+num[i]) lsz++, mrk[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> p[i].s += num[i], mrk[i] = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> lsz += (p[i].b &lt;= mid), mrk[i] = (p[i].b &gt; mid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l, p1 = l, p2 = l+lsz; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (!mrk[i]) q[p1++] = p[i]; <span class="keyword">else</span> q[p2++] = p[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) p[i] = q[i];</span><br><span class="line">bi_solve(l, l+lsz<span class="number">-1</span>, s, mid), bi_solve(l+lsz, r, mid+<span class="number">1</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(N), read(M);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">read(val[i]), p[++cnt] = (node)&#123;<span class="number">0</span>, <span class="number">1</span>, i, val[i], <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, k; i &lt;= M; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">2</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line"><span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">read(a), read(b), </span><br><span class="line">p[++cnt] = (node)&#123;<span class="number">0</span>, <span class="number">2</span>, a, val[a], <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">p[++cnt] = (node)&#123;<span class="number">0</span>, <span class="number">1</span>, a, (val[a] = b), <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">read(a), read(b), read(k), </span><br><span class="line">p[++cnt] = (node)&#123;++Q, <span class="number">3</span>, a, b, k, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">bi_solve(<span class="number">1</span>, cnt, <span class="number">0</span>, INF);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【POI2011】Meteors&quot;&gt;&lt;a href=&quot;#【POI2011】Meteors&quot; class=&quot;headerlink&quot; title=&quot;【POI2011】Meteors&quot;&gt;&lt;/a&gt;【POI2011】Meteors&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;60\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Byteotian\;Interstellar\;Union}$有$N$个成员国。&lt;br&gt;现在它发现了一颗新的星球，这颗星球的轨道被分为$M$份（第$M$份和第$1$份相邻），第$i$份上有第$A_i$个国家的太空站。&lt;br&gt;这个星球经常会下陨石雨。$\mathrm{BIU}$已经预测了接下来$K$场陨石雨的情况。$\mathrm{BIU}$的第$i$个成员国希望能够收集$P_i$单位的陨石样本。&lt;br&gt;你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行输入两个数$N,M$。&lt;br&gt;第二行有$M$个数，第$i$个数$O_i$表示第$i$段轨道上有第$O_i$个国家的太空站。&lt;br&gt;第三行有$N$个数，第$i$个数$P_i$表示第$i$个国家希望收集的陨石数量。&lt;br&gt;第四行有一个数$K$，表示预测了接下来的$K$场陨石雨。&lt;br&gt;接下来$K$行，每行有三个数$L_i,R_i,A_i$，表示第$K$场陨石雨的发生地点在从$L_i$顺时针到$R_i$的区间中（如果$L_i\le R_i$，就是$L_i,L_i+1,\cdots,R_i$，否则就是$R_i,R_i+1,\cdots,m-1,m,1,\cdots,L_i$），向区间中的每个太空站提供$A_i$单位的陨石样本。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出共$N$行。&lt;br&gt;第$i$行的数$W_i$表示第$i$个国家在第$W_i$波陨石雨之后能够收集到足够的陨石样本。&lt;br&gt;如果到第$K$波结束后仍然收集不到，输出&lt;code&gt;NIE&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="POI" scheme="http://azrael.top/tags/POI/"/>
    
      <category term="整体二分" scheme="http://azrael.top/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1901 Dynamic Rankings &lt;整体二分&gt;</title>
    <link href="http://azrael.top/BZOJ1901%20Dynamic%20Rankings%20%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    <id>http://azrael.top/BZOJ1901 Dynamic Rankings 整体二分/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-14T06:17:36.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="Dynamic-Rankings"><a href="#Dynamic-Rankings" class="headerlink" title="Dynamic Rankings"></a>Dynamic Rankings</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个含有$n$个数的序列$a[1],a[2],a[3],\cdots,a[n]$。<br>对于给定的$i,j,k$，请回答在$a[i],a[i+1],a[i+2],\cdots,a[j]$中第$k$小的数是多少$(1\le k\le j-i+1)$。<br>在询问中会有操作改变一些$a[i]$的值，改变后，需要针对改变后的$a$继续回答上面的问题。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有两个正整数$n,m$。<br>分别表示序列的长度和指令的个数。<br>第二行有$n$个数，表示$a[1],a[2]\cdots,a[n]$，这些数都小于$10^9$。<br>接下来的$m$行描述每条指令，每行的格式是下面两种格式中的一种。 </p><ul><li>$Q\;i\;j\;k\;(1\le i\le j\le n,1\le k\le j-i+1)$表示询问指令，询问$a[i],a[i+1],\cdots,a[j]$中第$k$小的数。</li><li>$C\;i\;t\;(1\le i\le n,0\le t\le10^9)$表示把$a[i]$改变成为$t$。</li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">3 2 1 4 7</span><br><span class="line">Q 1 4 3</span><br><span class="line">C 2 6</span><br><span class="line">Q 2 5 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$n,m\le10^4$</p><p>标签：<code>整体二分</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>整体二分经典题，直接上整体二分即可。</p><p>考虑将所有询问离线下来，对所有询问同时进行二分答案，二分函数有四个参数$l,r,s,t$，表示答案在$[s,t]$区间内的询问为在询问序列上位置在$[l,r]$之间的所有询问。<br>如果$s=t$，则可知询问序列上位置在$[l,r]$间的所有询问答案均为$s$。否则，我们需要把$[l,r]$间的所有询问分为前后两部分，前一部分为答案在$[s,\frac{s+t}{2}]$间的所有询问，后一部分为答案在$[\frac{s+t}{2}+1,t]$间的所有询问。这个过程用一棵树状数组判断一下$[l,r]$间每个询问的答案在哪边即可。<br>然而我们还需要维护修改操作。对于修改操作，我们同样将其加入整体二分。当询问函数将答案限制到$[s,t]$时，只有参数$t$在$[s,t]$间的修改操作才会对这个$[l,r]$间的询问答案产生影响。于是将每个修改拆成两个操作，即在某位置上删除一个数和加入一个数。<br>用树状数组维护时，若删除或加入的数在$[s,\frac{s+t}{2}]$间，在树状数组上对应位置$-1$或$+1$。对于询问，若询问区间为$[tl,tr]$，那么该询问的$num$值为树状数组上$[tl,tr]$位置上的值之和。这样一来，$num$统计的是每个询问区间内小于等于$\frac{s+t}{2}$的数的个数，若$num\ge k$，则答案一定在$[s,\frac{s+t}{2}]$间；否则，答案一定大于$\frac{s+t}{2}$。分治处理即可。</p><p>由于整体二分会带来一个$\log{n}$，枚举每个询问并用树状数组判断其答案在左边还是右边需要$n\log{n}$，故总复杂度为$O(n\log^{2}{n})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> N, M, Q, cnt, val[MAX_N+<span class="number">5</span>], ans[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> id, tp, a, b, k, s;&#125; p[MAX_N+<span class="number">5</span>], q[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> num[MAX_N+<span class="number">5</span>], tr[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">for</span> (; p &lt;= N; p += (p&amp;-p)) tr[p]++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">for</span> (; p &lt;= N; p += (p&amp;-p)) tr[p]--;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; <span class="keyword">for</span> (; p; p -= (p&amp;-p)) ret += tr[p]; <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bi_solve</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i].tp == <span class="number">3</span>) ans[p[i].id] = s;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i].tp == <span class="number">1</span> &amp;&amp; p[i].b &lt;= mid) inc(p[i].a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i].tp == <span class="number">2</span> &amp;&amp; p[i].b &lt;= mid) dec(p[i].a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i].tp == <span class="number">3</span>) num[i] = sum(p[i].b)-sum(p[i].a<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i].tp == <span class="number">1</span> &amp;&amp; p[i].b &lt;= mid) dec(p[i].a);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (p[i].tp == <span class="number">2</span> &amp;&amp; p[i].b &lt;= mid) inc(p[i].a);</span><br><span class="line"><span class="keyword">int</span> lsz = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i].tp == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p[i].k &lt;= p[i].s+num[i]) lsz++, mrk[i] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> p[i].s += num[i], mrk[i] = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> lsz += (p[i].b &lt;= mid), mrk[i] = (p[i].b &gt; mid);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l, p1 = l, p2 = l+lsz; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">if</span> (!mrk[i]) q[p1++] = p[i]; <span class="keyword">else</span> q[p2++] = p[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) p[i] = q[i];</span><br><span class="line">bi_solve(l, l+lsz<span class="number">-1</span>, s, mid), bi_solve(l+lsz, r, mid+<span class="number">1</span>, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(N), read(M);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">read(val[i]), p[++cnt] = (node)&#123;<span class="number">0</span>, <span class="number">1</span>, i, val[i], <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, a, b, k; i &lt;= M; i++) &#123;</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">2</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line"><span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'C'</span>)</span><br><span class="line">read(a), read(b), </span><br><span class="line">p[++cnt] = (node)&#123;<span class="number">0</span>, <span class="number">2</span>, a, val[a], <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">p[++cnt] = (node)&#123;<span class="number">0</span>, <span class="number">1</span>, a, (val[a] = b), <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">read(a), read(b), read(k), </span><br><span class="line">p[++cnt] = (node)&#123;++Q, <span class="number">3</span>, a, b, k, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">bi_solve(<span class="number">1</span>, cnt, <span class="number">0</span>, INF);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;Dynamic-Rankings&quot;&gt;&lt;a href=&quot;#Dynamic-Rankings&quot; class=&quot;headerlink&quot; title=&quot;Dynamic Rankings&quot;&gt;&lt;/a&gt;Dynamic Rankings&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定一个含有$n$个数的序列$a[1],a[2],a[3],\cdots,a[n]$。&lt;br&gt;对于给定的$i,j,k$，请回答在$a[i],a[i+1],a[i+2],\cdots,a[j]$中第$k$小的数是多少$(1\le k\le j-i+1)$。&lt;br&gt;在询问中会有操作改变一些$a[i]$的值，改变后，需要针对改变后的$a$继续回答上面的问题。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行有两个正整数$n,m$。&lt;br&gt;分别表示序列的长度和指令的个数。&lt;br&gt;第二行有$n$个数，表示$a[1],a[2]\cdots,a[n]$，这些数都小于$10^9$。&lt;br&gt;接下来的$m$行描述每条指令，每行的格式是下面两种格式中的一种。 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$Q\;i\;j\;k\;(1\le i\le j\le n,1\le k\le j-i+1)$表示询问指令，询问$a[i],a[i+1],\cdots,a[j]$中第$k$小的数。&lt;/li&gt;
&lt;li&gt;$C\;i\;t\;(1\le i\le n,0\le t\le10^9)$表示把$a[i]$改变成为$t$。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每一次询问，你都需要输出他的答案，每一个输出占单独的一行。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="整体二分" scheme="http://azrael.top/tags/%E6%95%B4%E4%BD%93%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1064【NOI2008】假面舞会 &lt;连通分量&gt;</title>
    <link href="http://azrael.top/BZOJ1064%E3%80%90NOI2008%E3%80%91%E5%81%87%E9%9D%A2%E8%88%9E%E4%BC%9A%20%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    <id>http://azrael.top/BZOJ1064【NOI2008】假面舞会 连通分量/</id>
    <published>2018-05-09T16:00:00.000Z</published>
    <updated>2018-05-17T14:55:32.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【NOI2008】假面舞会"><a href="#【NOI2008】假面舞会" class="headerlink" title="【NOI2008】假面舞会"></a>【NOI2008】假面舞会</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。<br>今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一 个自己喜欢的面具。<br>每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。为了使舞会更有神秘感，主办方把面具分为$k\;(k\ge3)$类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第$i$类面具的人才能看到戴第$i+1$类面具的人的编号，戴第$k$类面具的人能看到戴第$1$类面具的人的编号。<br>参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。 栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第$2$号面具的人看到了第$5$号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信 息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了$k\ge3$，所以你必须将这条信息也考虑进去。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数$n,m$，用一个空格分隔，$n$表示主办方总共准备了多少个面具，$m$表示栋栋收集了多少条信息。<br>接下来$m$行，每行为两个用空格分开的整数$a,b$，表示戴第$a$号面具的人看到了第$b$号面具的编号。相同的数对$a,b$在输入文件中可能出现多次。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>包含两个数，第一个数为最大可能的面具类数，第二个数为最小可能的面具类数。<br>如果无法将所有的面具分为至少$3$类，使得这些信息都满足，则认为栋栋收集的信息有错误，输出两个$-1$。<br><a id="more"></a></p><h3 id="Sample"><a href="#Sample" class="headerlink" title="Sample"></a>Sample</h3><p><strong>Sample Input 1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6 5</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">4 1</span><br><span class="line">3 5</span><br></pre></td></tr></table></figure></p><p><strong>Sample Output 1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br></pre></td></tr></table></figure></p><p><strong>Sample Input 2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure></p><p><strong>Sample Output 2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 -1</span><br></pre></td></tr></table></figure></p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$100\%$的数据，满足$n\le10^5,m\le10^6$。</p><p>标签：<code>连通分量</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>图论好题，比较常规的连通分量做法，不过有几个细节容易出错。</p><p>对于给定的有向图，只会有两种情况：</p><ul><li>存在环：所有环长度的最大公约数$\mathrm{gcd}$为最大类数，大于$3$且整除$\mathrm{gcd}$的最小数为最小类数。</li><li>不存在环：所有连通块的最长链之和为最大类数，$3$为最小类数。</li></ul><p>特判一下最大类数是否大于等于$3$即可判断是否无解。</p><p>注意这里直接跑<code>tarjan</code>是无法找出所有环长的，需要$\mathrm{DFS}$直接找。<br>对每条边建长为$-1$的反边，即可跑$\mathrm{DFS}$找出环长和最长链，分情况讨论即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 1000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, mi, mx, mid, mxd, cnt, pr[MAX_N+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M&lt;&lt;<span class="number">1</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>], vis[MAX_M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> b ? gcd(b, a%b) : a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (edge)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;insert(u, v, <span class="number">1</span>), insert(v, u, <span class="number">-1</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">mrk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v]) d[v] = d[u]+E[i].c, DFS(v);</span><br><span class="line"><span class="keyword">else</span> mx = gcd(mx, <span class="built_in">abs</span>(d[u]-d[v]+E[i].c));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getD</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">mrk[u] = <span class="literal">true</span>, mxd = max(mxd, d[u]), mid = min(mid, d[u]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) <span class="keyword">if</span> (!vis[i])</span><br><span class="line">vis[i] = vis[i^<span class="number">1</span>] = <span class="literal">true</span>, d[E[i].v] = d[u]+E[i].c, getD(E[i].v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++)</span><br><span class="line">read(u), read(v), addedge(u, v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!mrk[i]) DFS(i);</span><br><span class="line"><span class="keyword">if</span> (mx) &#123;</span><br><span class="line"><span class="keyword">if</span> (mx &lt; <span class="number">3</span>) &#123;<span class="built_in">puts</span>(<span class="string">"-1 -1"</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">for</span> (mi = <span class="number">3</span>; mi &lt;= mx; mi++) <span class="keyword">if</span> (!(mx%mi)) <span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(mrk, <span class="literal">false</span>, <span class="keyword">sizeof</span> mrk), mi = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!mrk[i])</span><br><span class="line">mxd = mid = d[i] = <span class="number">0</span>, getD(i), mx += mxd-mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (mx &lt; <span class="number">3</span>) &#123;<span class="built_in">puts</span>(<span class="string">"-1 -1"</span>); <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, mx, mi), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【NOI2008】假面舞会&quot;&gt;&lt;a href=&quot;#【NOI2008】假面舞会&quot; class=&quot;headerlink&quot; title=&quot;【NOI2008】假面舞会&quot;&gt;&lt;/a&gt;【NOI2008】假面舞会&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。&lt;br&gt;今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一 个自己喜欢的面具。&lt;br&gt;每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。为了使舞会更有神秘感，主办方把面具分为$k\;(k\ge3)$类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第$i$类面具的人才能看到戴第$i+1$类面具的人的编号，戴第$k$类面具的人能看到戴第$1$类面具的人的编号。&lt;br&gt;参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。 栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第$2$号面具的人看到了第$5$号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信 息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了$k\ge3$，所以你必须将这条信息也考虑进去。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个整数$n,m$，用一个空格分隔，$n$表示主办方总共准备了多少个面具，$m$表示栋栋收集了多少条信息。&lt;br&gt;接下来$m$行，每行为两个用空格分开的整数$a,b$，表示戴第$a$号面具的人看到了第$b$号面具的编号。相同的数对$a,b$在输入文件中可能出现多次。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;包含两个数，第一个数为最大可能的面具类数，第二个数为最小可能的面具类数。&lt;br&gt;如果无法将所有的面具分为至少$3$类，使得这些信息都满足，则认为栋栋收集的信息有错误，输出两个$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="NOI" scheme="http://azrael.top/tags/NOI/"/>
    
      <category term="连通分量" scheme="http://azrael.top/tags/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4816【SDOI2017】数字表格 &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ4816%E3%80%90SDOI2017%E3%80%91%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ4816【SDOI2017】数字表格 莫比乌斯反演/</id>
    <published>2018-05-04T16:00:00.000Z</published>
    <updated>2018-05-05T05:55:14.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SDOI2017】数字表格"><a href="#【SDOI2017】数字表格" class="headerlink" title="【SDOI2017】数字表格"></a>【SDOI2017】数字表格</h3><p>$\mathrm{Time\;Limit:\;50\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Doris}$刚刚学习了$\mathrm{fibonacci}$数列。用$f[i]$表示数列的第$i$项，那么<br>$$<br>f[n]=<br>\begin{cases}<br>0&amp;n=0\\<br>1&amp;n=1\\<br>f[n-1]+f[n-2]&amp;n\ge2<br>\end{cases}<br>$$<br>$\mathrm{Doris}$用老师的超级计算机生成了一个$n\times m$的表格，第$i$行第$j$列的格子中的数是$f[\gcd(i,j)]$，其中$\gcd(i,j)$表示$i,j$的最大公约数。<br>$\mathrm{Doris}$的表格中共有$n\times m$个数，她想知道这些数的乘积是多少。答案对$10^9+7$取模。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>有多组测试数据。<br>第一个一个数$T$，表示数据组数。<br>接下来$T$行，每行两个数$n,m$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$T$行，第$i$行的数是第$i$组数据的结果。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">6 7</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">960</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$T\le1000,\;1\le n,m\le10^6$</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>鸣谢<code>infinityedge</code>上传</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>转换题目求和的角度为枚举$\gcd(i,j)$，求$f[\gcd(i,j)]$对答案的贡献。<br>那么有<br>$$<br>\begin{aligned}<br>Ans&amp;=\prod_{d=1}^{n}f(d)^{\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=d]}\\<br>&amp;=\prod_{d=1}^{n}f(d)^{\sum_{t=1}^{\lfloor\frac{\min(n,m)}{d}\rfloor}\mu(t)\lfloor\frac{n}{dt}\rfloor\lfloor\frac{m}{dt}\rfloor}\\<br>&amp;=\prod_{T=1}^{n}\prod_{d|T}f(d)^{\mu(\frac{T}{d})\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}\\<br>&amp;=\prod_{T=1}^{n}(\prod_{d|T}f(d)^{\mu(\frac{T}{d})})^{\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}\\<br>\end{aligned}<br>$$<br>将中间$\prod_{d|T}f(d)^{\mu(\frac{T}{d})}$单独分开，设$g(T)=\prod_{d|T}f(d)^{\mu(\frac{T}{d})}$，那么$Ans=\prod_{T=1}^{n}g(T)^{\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor}$，预处理出$\lbrace g\rbrace$的前缀<strong>积</strong>后数论分块即可。</p><p>发现对于每个$d\in[1,n]$，$f(d)^{\mu(\frac{T}{d})}$最多只会对$\frac{n}{d}$个$g(T)$的值产生贡献，枚举$d$累加贡献的时间复杂度是调和级数。于是枚举$d$，枚举$d$在$[1,n]$内的倍数$t$，将$f(d)^{\mu(\frac{t}{d})}$乘到$g(t)$中即可处理出所有$g$。而$\mu$只能取$\pm1$，于是需要预处理出$f(d)$和$f(d)^{-1}$即$f(d)$在模意义下的逆元。处理出$g$后再处理$g$的前缀<strong>积</strong>即可。</p><p>时间复杂度$O(n\log{n}+T(\sqrt{n}+\sqrt{m})\log\mathrm{MOD})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> cnt, pri[MAX_N+<span class="number">5</span>]; lnt ans, gp;</span><br><span class="line">lnt mu[MAX_N+<span class="number">5</span>], f[MAX_N+<span class="number">5</span>], g[MAX_N+<span class="number">5</span>], inv[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">lnt <span class="title">Pow</span><span class="params">(lnt x, lnt k)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">1L</span>L;</span><br><span class="line"><span class="keyword">for</span> (; k; k &gt;&gt;= <span class="number">1</span>, (x *= x) %= MOD)</span><br><span class="line"><span class="keyword">if</span> (k&amp;<span class="number">1</span>) (ret *= x) %= MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = f[<span class="number">1</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAX_N; i++) g[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++)</span><br><span class="line">f[i] = (f[i<span class="number">-1</span>]+f[i<span class="number">-2</span>])%MOD, inv[i] = Pow(f[i], MOD<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAX_N; i++) <span class="keyword">if</span> (mu[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= MAX_N; j += i)</span><br><span class="line"><span class="keyword">if</span> (mu[i] == <span class="number">1</span>) (g[j] *= f[j/i]) %= MOD;</span><br><span class="line"><span class="keyword">else</span> (g[j] *= inv[j/i]) %= MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++)</span><br><span class="line">(g[i] *= g[i<span class="number">-1</span>]) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T; read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> n, m; read(n), read(m), ans = <span class="number">1L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), </span><br><span class="line">gp = g[r]*Pow(g[l<span class="number">-1</span>], MOD<span class="number">-2</span>)%MOD, </span><br><span class="line">gp = Pow(gp, <span class="number">1L</span>L*(n/l)*(m/l)%(MOD<span class="number">-1</span>)), </span><br><span class="line">(ans *= gp) %= MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SDOI2017】数字表格&quot;&gt;&lt;a href=&quot;#【SDOI2017】数字表格&quot; class=&quot;headerlink&quot; title=&quot;【SDOI2017】数字表格&quot;&gt;&lt;/a&gt;【SDOI2017】数字表格&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;50\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Doris}$刚刚学习了$\mathrm{fibonacci}$数列。用$f[i]$表示数列的第$i$项，那么&lt;br&gt;$$&lt;br&gt;f[n]=&lt;br&gt;\begin{cases}&lt;br&gt;0&amp;amp;n=0\\&lt;br&gt;1&amp;amp;n=1\\&lt;br&gt;f[n-1]+f[n-2]&amp;amp;n\ge2&lt;br&gt;\end{cases}&lt;br&gt;$$&lt;br&gt;$\mathrm{Doris}$用老师的超级计算机生成了一个$n\times m$的表格，第$i$行第$j$列的格子中的数是$f[\gcd(i,j)]$，其中$\gcd(i,j)$表示$i,j$的最大公约数。&lt;br&gt;$\mathrm{Doris}$的表格中共有$n\times m$个数，她想知道这些数的乘积是多少。答案对$10^9+7$取模。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;有多组测试数据。&lt;br&gt;第一个一个数$T$，表示数据组数。&lt;br&gt;接下来$T$行，每行两个数$n,m$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$T$行，第$i$行的数是第$i$组数据的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2565 最长双回文串 &lt; Manacher &gt;</title>
    <link href="http://azrael.top/BZOJ2565%20%E6%9C%80%E9%95%BF%E5%8F%8C%E5%9B%9E%E6%96%87%E4%B8%B2%20Manacher/"/>
    <id>http://azrael.top/BZOJ2565 最长双回文串 Manacher/</id>
    <published>2018-05-03T16:00:00.000Z</published>
    <updated>2018-05-05T04:37:32.480Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="最长双回文串"><a href="#最长双回文串" class="headerlink" title="最长双回文串"></a>最长双回文串</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>顺序和逆序读起来完全一样的串叫做回文串。比如<code>acbca</code>是回文串，而<code>abc</code>不是（<code>abc</code>的顺序为<code>abc</code>，逆序为<code>cba</code>，不相同）。<br>输入长度为$n$的串$S$，求$S$的最长双回文子串$T$，即可将$T$分为两部分$X,Y\;(|X|,|Y|\ge1)$且$X$和$Y$都是回文串。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一行由小写英文字母组成的字符串$S$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行一个整数，表示最长双回文子串的长度。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baacaabbacabb</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>从第二个字符开始的字符串<code>aacaabbacabb</code>可分为<code>aacaa</code>与<code>bbacabb</code>两部分，且两者都是回文串。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据，$2\le|S|\le10^5$<br>$2015.4.25$新加数据一组</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>$2012$国家集训队$\mathrm{Round\;1\;Day\;2}$</p><p>标签：<code>Manacher</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{Manacher}$上稍加变化。</p><p>首先跑$\mathrm{Manacher}$得到以每个位置为中心的回文串最大长度。然后考虑计算出$\lbrace L\rbrace$和$\lbrace R\rbrace$，分别表示以每个位置为终点和起点的最长回文串的<strong>中心点位置</strong>。如此枚举每个位置作为中间断点打擂得到最长双回文字串。</p><p>那么如何计算$\lbrace L\rbrace$和$\lbrace R\rbrace$呢？<br>对于位置$i$，其最长回文串半径长为$r_i$，那么区间$[i,i+r_i)$中的所有位置都可以作为这个串的右端点（终点）。于是这些位置的$L$值一定不大于$i$，这是因为$L$值越小，回文串越长，这样更优。所以从前往后枚举$i$，如果$[i,i+r_i)$中的某个点的$L$值在前面没有确定到，那么这个点的$L$值一定最小为$i$。发现这样的点一定在一个区间中，所以可以记录每次更新$L$更新到的位置，即可$O(n)$扫一遍得到$\lbrace L\rbrace$。反着这样扫一遍即可得到$\lbrace R\rbrace$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 200000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, f[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> L[MAX_N+<span class="number">5</span>], R[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">f[i] = i &lt; r ? min(f[p*<span class="number">2</span>-i], r-i) : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i-f[i] &gt;= <span class="number">1</span> &amp;&amp; i+f[i] &lt;= n)</span><br><span class="line"><span class="keyword">if</span> (s[i-f[i]] == s[i+f[i]]) f[i]++;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (i+f[i] &gt; r) p = i, r = i+f[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[MAX_N+<span class="number">5</span>]; <span class="built_in">scanf</span>(<span class="string">"%s"</span>, str), n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) s[i*<span class="number">2</span>+<span class="number">1</span>] = <span class="string">'#'</span>, s[i*<span class="number">2</span>+<span class="number">2</span>] = str[i];</span><br><span class="line">s[n = n*<span class="number">2</span>+<span class="number">1</span>] = <span class="string">'#'</span>, manacher(); <span class="keyword">int</span> mx = <span class="number">1</span>, mi = n, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (f[i] &gt; <span class="number">1</span> &amp;&amp; i+f[i] &gt; mx) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = mx; j &lt; i+f[i]; j++) L[j] = i;</span><br><span class="line">mx = i+f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line"><span class="keyword">if</span> (f[i] &gt; <span class="number">1</span> &amp;&amp; i-f[i] &lt; mi) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = mi; j &gt; i-f[i]; j--) R[j] = i;</span><br><span class="line">mi = i-f[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans = max(ans, R[i]-L[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;最长双回文串&quot;&gt;&lt;a href=&quot;#最长双回文串&quot; class=&quot;headerlink&quot; title=&quot;最长双回文串&quot;&gt;&lt;/a&gt;最长双回文串&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;顺序和逆序读起来完全一样的串叫做回文串。比如&lt;code&gt;acbca&lt;/code&gt;是回文串，而&lt;code&gt;abc&lt;/code&gt;不是（&lt;code&gt;abc&lt;/code&gt;的顺序为&lt;code&gt;abc&lt;/code&gt;，逆序为&lt;code&gt;cba&lt;/code&gt;，不相同）。&lt;br&gt;输入长度为$n$的串$S$，求$S$的最长双回文子串$T$，即可将$T$分为两部分$X,Y\;(|X|,|Y|\ge1)$且$X$和$Y$都是回文串。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一行由小写英文字母组成的字符串$S$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一行一个整数，表示最长双回文子串的长度。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="字符串" scheme="http://azrael.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="Manacher" scheme="http://azrael.top/tags/Manacher/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3143【HNOI2013】游走 &lt;高斯消元&gt;</title>
    <link href="http://azrael.top/BZOJ3143%E3%80%90HNOI2013%E3%80%91%E6%B8%B8%E8%B5%B0%20%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    <id>http://azrael.top/BZOJ3143【HNOI2013】游走 高斯消元/</id>
    <published>2018-05-03T16:00:00.000Z</published>
    <updated>2018-05-04T14:52:13.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【HNOI2013】游走"><a href="#【HNOI2013】游走" class="headerlink" title="【HNOI2013】游走"></a>【HNOI2013】游走</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一个无向连通图，顶点从$1$编号到$N$，边从$1$编号到$M$。<br>$\mathrm{小Z}$在该图上进行随机游走，初始时$\mathrm{小Z}$在$1$号顶点，每一步$\mathrm{小Z}$以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当$\mathrm{小Z}$到达$N$号顶点时游走结束，总分为所有获得的分数之和。<br>现在请你对这$M$条边进行编号，使得$\mathrm{小Z}$获得的总分的期望值最小。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是正整数$N$和$M$，分别表示该图的顶点数和边数。<br>接下来$M$行每行是整数$u,v\;(1\le u,v\le N)$，表示顶点$u$与顶点$v$之间存在一条边。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个实数，表示最小的期望值，保留$3$位小数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.333</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>边$(1,2)$编号为$1$，边$(1,3)$编号$2$，边$(2,3)$编号为$3$。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$2\le N\le500$<br>保证图为无向简单连通图</p><p>标签：<code>高斯消元</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>大致思路是求出每条边的期望经过次数，然后贪心选择边权。<br>然而对于边来说，并不好确定其期望经过次数，而点的期望经过次数则更好求。</p><p>设$x_i$为到达点$i$<strong>并继续向下一个点移动</strong>的期望次数。那么对于普通的点（非起点$1$或终点$n$），其只能从与其相邻的点走过来，于是对于点$i$，从$i$连出去的点的集合为$S_i$，那么$x_i=\sum_{j\in S_i}\frac{x_j}{d_j}$，其中$d$为点的度数。而对于$1$号点，初始时一定在$1$号点上，因此一定初始就有$1$次的经过次数，而游走过程中的情况与普通点相同，于是$x_1=\sum_{j\in S_1}\frac{x_j}{d_j}$。对于$n$号点，由于到了$n$后不能继续走动，即只进不出，于是一定不会经过（因为前面经过的定义是要有向下一个点移动的可能），因此$x_n=0$。<br>于是有方程组<br>$$<br>\begin{cases}<br>x_1=1+\sum_{i\in S_1}\frac{x_i}{d_i}\\<br>x_2=\sum_{i\in S_2}\frac{x_i}{d_i}\\<br>x_3=\sum_{i\in S_3}\frac{x_i}{d_i}\\<br>\;\;\;\;\vdots\;\;\;\;\;\;\vdots\\<br>x_{n-1}=\sum_{i\in S_{n-1}}\frac{x_i}{d_i}\\<br>x_n=0\\<br>\end{cases}<br>$$<br>用高斯消元可以解得$\lbrace x\rbrace$。</p><p>对于一条边$i$，其端点为$u$和$v$，要经过$i$必定只能是从$u$到$v$或从$v$到$u$。在$u$时有$\frac{1}{d_u}$的概率走这条边，在$v$时有$\frac{1}{d_v}$的概率走这条边，于是第$i$条边的期望经过次数为$y_i=\frac{x_u}{d_u}+\frac{x_v}{d_v}$。<br>求出$\lbrace y\rbrace$后从大到小排序，贪心使得期望经过次数越大的边权越小，即可得到最小的期望路径长度。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 250000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, u[MAX_M+<span class="number">5</span>], v[MAX_M+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>];</span><br><span class="line">dnt f[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>], x[MAX_N+<span class="number">5</span>], y[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (t = i; t &lt;= n; t++) <span class="keyword">if</span> (<span class="built_in">fabs</span>(f[i][t]) &gt;= EPS) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (t &gt; n) <span class="keyword">continue</span>; swap(f[i], f[t]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (i^j) &#123;</span><br><span class="line">dnt div = f[j][i]/f[i][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n+<span class="number">1</span>; k++)</span><br><span class="line">f[j][k] -= f[i][k]*div;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) x[i] = f[i][n+<span class="number">1</span>]/f[i][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m); dnt ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">read(u[i]), read(v[i]), d[u[i]]++, d[v[i]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">f[u[i]][v[i]] -= <span class="number">1.0</span>/d[v[i]], </span><br><span class="line">f[v[i]][u[i]] -= <span class="number">1.0</span>/d[u[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[n][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][i] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>][n+<span class="number">1</span>] = <span class="number">1</span>, Gauss();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) y[i] = x[u[i]]/d[u[i]]+x[v[i]]/d[v[i]];</span><br><span class="line">sort(y+<span class="number">1</span>, y+m+<span class="number">1</span>); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ans += y[i]*(m-i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%.3lf\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【HNOI2013】游走&quot;&gt;&lt;a href=&quot;#【HNOI2013】游走&quot; class=&quot;headerlink&quot; title=&quot;【HNOI2013】游走&quot;&gt;&lt;/a&gt;【HNOI2013】游走&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一个无向连通图，顶点从$1$编号到$N$，边从$1$编号到$M$。&lt;br&gt;$\mathrm{小Z}$在该图上进行随机游走，初始时$\mathrm{小Z}$在$1$号顶点，每一步$\mathrm{小Z}$以相等的概率随机选择当前顶点的某条边，沿着这条边走到下一个顶点，获得等于这条边的编号的分数。当$\mathrm{小Z}$到达$N$号顶点时游走结束，总分为所有获得的分数之和。&lt;br&gt;现在请你对这$M$条边进行编号，使得$\mathrm{小Z}$获得的总分的期望值最小。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行是正整数$N$和$M$，分别表示该图的顶点数和边数。&lt;br&gt;接下来$M$行每行是整数$u,v\;(1\le u,v\le N)$，表示顶点$u$与顶点$v$之间存在一条边。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅包含一个实数，表示最小的期望值，保留$3$位小数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="高斯消元" scheme="http://azrael.top/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1013【JSOI2008】球形空间产生器 &lt;高斯消元&gt;</title>
    <link href="http://azrael.top/BZOJ1013%E3%80%90JSOI2008%E3%80%91%E7%90%83%E5%BD%A2%E7%A9%BA%E9%97%B4%E4%BA%A7%E7%94%9F%E5%99%A8%20%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83%20-%20Copy/"/>
    <id>http://azrael.top/BZOJ1013【JSOI2008】球形空间产生器 高斯消元 - Copy/</id>
    <published>2018-05-03T16:00:00.000Z</published>
    <updated>2018-05-04T12:09:58.132Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【JSOI2008】球形空间产生器"><a href="#【JSOI2008】球形空间产生器" class="headerlink" title="【JSOI2008】球形空间产生器"></a>【JSOI2008】球形空间产生器</h3><p>$\mathrm{Time\;Limit:\;1\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>有一个球形空间产生器能够在$n$维空间中产生一个坚硬的球体。<br>现在，你被困在了这个$n$维球体中，你只知道球面上$n+1$个点的坐标，你需要以最快的速度确定这个$n$维球体的球心坐标，以便于摧毁这个球形空间产生器。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是一个整数$n\;(1\le n\le10)$。<br>接下来的$n+1$行，每行有$n$个实数，表示球面上一点的$n$维坐标。<br>每一个实数精确到小数点后$6$位，且其绝对值都不超过$20000$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>有且只有一行，依次给出球心的$n$维坐标（$n$个实数），两个实数之间用一个空格隔开。<br>每个实数精确到小数点后$3$位，数据保证有解，你的答案必须和标准输出一模一样才能够得分。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">0.0 0.0</span><br><span class="line">-1.0 1.0</span><br><span class="line">1.0 0.0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.500 1.500</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>给出两个定义：</p><ul><li>球心：到球面上任意一点距离都相等的点。</li><li>距离：设两个$n$维空间上的点$A,B$的坐标为$(a_1,a_2,\cdots,a_n)$,$(b_1,b_2,\cdots,b_n)$，则$AB$的距离定义为：$dist=\sqrt{(a_1-b_1)^2+(a_2-b_2)^2+\cdots+(a_n-b_n)^2}$</li></ul><p>标签：<code>高斯消元</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>高消裸题。</p><p>将第$n+1$个点单独分出来，将其与前$n$个点分别联立形成$n$个方程，高消即可求得球心坐标。</p><p>设球心为$(x_1, x_2,\cdots,x_n)$，第$n+1$个点为$(t_1,t_2,\cdots,t_n)$。对于前$n$个点中的一个点$A$，设$A$坐标为$(a_1, a_2,\cdots,a_n)$。那么一定有<br>$$<br>(a_1-x_1)^2+(a_2-x_2)^2+\cdots+(a_n-x_n)^2=(t_1-x_1)^2+(t_2-x_2)^2+\cdots+(t_n-x_n)^2<br>$$<br>展开得<br>$$<br>\sum_{i=1}^{n}a_i^2+\sum_{i=1}^{n}x_i^2-2\sum_{i=1}^{n}a_ix_i=\sum_{i=1}^{n}t_i^2+\sum_{i=1}^{n}x_i^2-2\sum_{i=1}^{n}t_ix_i<br>$$<br>移项化简<br>$$<br>2\sum_{i=1}^{n}(a_i-t_i)x_i=\sum_{i=1}^{n}a_i^2-\sum_{i=1}^{n}t_i^2<br>$$<br>直接高斯消元解方程组，时间复杂度$O(n^3)$。</p><p>$\bigstar$注意行末不要输出空格</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-8</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">int</span> n; dnt p[<span class="number">15</span>][<span class="number">15</span>], f[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="function">dnt <span class="title">sqr</span><span class="params">(dnt x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (t = i; t &lt;= n; t++) <span class="keyword">if</span> (<span class="built_in">fabs</span>(f[t][i]) &gt;= EPS) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span> (t &gt; n) <span class="keyword">return</span> <span class="literal">false</span>; swap(f[i], f[t]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (i^j) &#123;</span><br><span class="line">dnt div = f[j][i]/f[i][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n+<span class="number">1</span>; k++)</span><br><span class="line">f[j][k] -= f[i][k]*div;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i][n+<span class="number">1</span>] /= f[i][i];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>, p[i]+j);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = n+<span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">f[i][k] = p[i][k]-p[j][k], </span><br><span class="line">f[i][n+<span class="number">1</span>] += (sqr(p[i][k])-sqr(p[j][k]))/<span class="number">2</span>;</span><br><span class="line">Gauss();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (i^n) <span class="built_in">printf</span>(<span class="string">"%.3lf "</span>, f[i][n+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%.3lf"</span>, f[i][n+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【JSOI2008】球形空间产生器&quot;&gt;&lt;a href=&quot;#【JSOI2008】球形空间产生器&quot; class=&quot;headerlink&quot; title=&quot;【JSOI2008】球形空间产生器&quot;&gt;&lt;/a&gt;【JSOI2008】球形空间产生器&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;1\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;有一个球形空间产生器能够在$n$维空间中产生一个坚硬的球体。&lt;br&gt;现在，你被困在了这个$n$维球体中，你只知道球面上$n+1$个点的坐标，你需要以最快的速度确定这个$n$维球体的球心坐标，以便于摧毁这个球形空间产生器。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行是一个整数$n\;(1\le n\le10)$。&lt;br&gt;接下来的$n+1$行，每行有$n$个实数，表示球面上一点的$n$维坐标。&lt;br&gt;每一个实数精确到小数点后$6$位，且其绝对值都不超过$20000$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;有且只有一行，依次给出球心的$n$维坐标（$n$个实数），两个实数之间用一个空格隔开。&lt;br&gt;每个实数精确到小数点后$3$位，数据保证有解，你的答案必须和标准输出一模一样才能够得分。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="高斯消元" scheme="http://azrael.top/tags/%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2006【NOI2010】超级钢琴 &lt; ST表+堆 &gt;</title>
    <link href="http://azrael.top/BZOJ2006%E3%80%90NOI2010%E3%80%91%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%20ST%E8%A1%A8+%E5%A0%86/"/>
    <id>http://azrael.top/BZOJ2006【NOI2010】超级钢琴 ST表+堆/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-05-03T09:04:38.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【NOI2010】超级钢琴"><a href="#【NOI2010】超级钢琴" class="headerlink" title="【NOI2010】超级钢琴"></a>【NOI2010】超级钢琴</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;512\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{小Z}$是一个小有名气的钢琴家，最近$\mathrm{C博士}$送给了$\mathrm{小Z}$一架超级钢琴，$\mathrm{小Z}$希望能够用这架钢琴创作出世界上最美妙的音乐。<br>这架超级钢琴可以弹奏出$n$个音符，编号为$1\sim n$。第$i$个音符的美妙度为$A_i$，其中$A_i$可正可负。<br>一个“超级和弦“由若干个编号连续的音符组成，包含的音符个数不少于$L$且不多于$R$。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。<br>$\mathrm{小Z}$决定创作一首由$k$个超级和弦组成的乐曲，为了使得乐曲更加动听，$\mathrm{小Z}$要求该乐曲由$k$个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。$\mathrm{小Z}$想知道他能够创作出来的乐曲美妙度最大值是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含四个正整数$n,k,L,R$。其中$n$为音符的个数，$k$为乐曲所包含的超级和弦个数，$L$和$R$分别是超级和弦所包含音符个数的下限和上限。<br>接下来$n$行，每行包含一个整数$A_i$，表示按编号从小到大每个音符的美妙度。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一个整数，表示乐曲美妙度的最大值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">-6</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>共有$5$种不同的超级和弦：<br>音符$1\sim2$，美妙度为$3 + 2 = 5$<br>音符$2\sim3$，美妙度为$2 + (-6) = -4$<br>音符$3\sim4$，美妙度为$(-6) + 8 = 2$<br>音符$1\sim3$，美妙度为$3 + 2 + (-6) = -1$<br>音符$2\sim4$，美妙度为$2 + (-6) + 8 = 4$<br>最优方案为：乐曲由和弦$1$,和弦$3$,和弦$5$组成，美妙度为$5 + 2 + 4 = 11$。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$N\le5\times10^5$，$k\le5\times10^5$，$-1000\le A_i\le1000$，$1\le L\le R\le N$<br>数据保证一定存在满足条件的乐曲</p><p>标签：<code>堆</code> <code>ST表</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>经典线段树例题，不过我用的是一种精妙的<code>ST表</code>。</p><p>找出第$k$大的差值，可以用一个堆维护，每次弹出堆顶。<br>首先将区间和处理为前缀和，这样问题变为给出一个数组$\lbrace s_n\rbrace$，求第$k$大的$s_i-s_j$，其中$i,j\in[1,n],\;i-R\le j\le i-L$。<br>考虑对于一个确定的$s_j$，使差值最大的$s_i$一定是$s_{i-R}\sim s_{i-L}$中的最小值，这个最小值可以在$O(1)$时间内用<code>ST表</code>找到。这个值取完后，对于其他以$j$作为终点的区间可以分成两部分，一部分为起点在$i-R\sim j-1$间的区间，另一部分为起点在$j+1\sim i-L$的区间，在这两个区间中分别找最大值插入堆中。<br>对于以每个位置为右端点的区间，我们维护四元组$(p,l,r,val)$，代表右端点位置，左端点的左右界，以及在此左右界中的最大差值。一开始插入以每个位置为右端点的区间中和最大的区间，随后每次弹出最大区间，将这个四元组拆成两部分，即若当前四元组为$(p,l,r,val)$，左端点取$t$时得到最大差值，以后不能取$t$，将四元组拆为$(p,l,t-1,val_1)$和$(p,t+1,r,val_2)$，其中$val_1$和$val_2$分别表示左端点在$[l,t-1]$和$[t+1,r]$间时的最大差值。<br>如此即可在$O(n\log{n})$的时间内找到前$k$大差值的和。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG Log[t-s]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, L, R, s[MAX_N+<span class="number">5</span>], st[MAX_N+<span class="number">5</span>][<span class="number">25</span>], Log[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> p, l, r, val; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> t.val &gt; val;&#125;&#125; ;</span><br><span class="line">priority_queue &lt;node&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> s[a] &lt; s[b] ? a : b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;<span class="keyword">return</span> s &gt; t ? <span class="number">-1</span> : Min(st[s][LOG], st[t-(<span class="number">1</span>&lt;&lt;LOG)+<span class="number">1</span>][LOG]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), read(L), read(R); lnt ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) Log[i] = Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(s[i]), s[i] += s[i<span class="number">-1</span>], st[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n; j++) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>; i++)</span><br><span class="line">st[i][j] = Min(st[i][j<span class="number">-1</span>], st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= n; i++)</span><br><span class="line">que.push((node)&#123;i, max(i-R, <span class="number">0</span>), i-L, s[i]-s[query(max(i-R, <span class="number">0</span>), i-L)]&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t, p; i &lt;= m; i++) &#123;</span><br><span class="line">node tp = que.top(); que.pop(), ans += tp.val, p = tp.p;</span><br><span class="line"><span class="keyword">int</span> ll = tp.l, rr = tp.r, lr = query(ll, rr)<span class="number">-1</span>, rl = query(ll, rr)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (~(t = query(ll, lr))) que.push((node)&#123;p, ll, lr, s[p]-s[t]&#125;);</span><br><span class="line"><span class="keyword">if</span> (~(t = query(rl, rr))) que.push((node)&#123;p, rl, rr, s[p]-s[t]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【NOI2010】超级钢琴&quot;&gt;&lt;a href=&quot;#【NOI2010】超级钢琴&quot; class=&quot;headerlink&quot; title=&quot;【NOI2010】超级钢琴&quot;&gt;&lt;/a&gt;【NOI2010】超级钢琴&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;512\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{小Z}$是一个小有名气的钢琴家，最近$\mathrm{C博士}$送给了$\mathrm{小Z}$一架超级钢琴，$\mathrm{小Z}$希望能够用这架钢琴创作出世界上最美妙的音乐。&lt;br&gt;这架超级钢琴可以弹奏出$n$个音符，编号为$1\sim n$。第$i$个音符的美妙度为$A_i$，其中$A_i$可正可负。&lt;br&gt;一个“超级和弦“由若干个编号连续的音符组成，包含的音符个数不少于$L$且不多于$R$。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。&lt;br&gt;$\mathrm{小Z}$决定创作一首由$k$个超级和弦组成的乐曲，为了使得乐曲更加动听，$\mathrm{小Z}$要求该乐曲由$k$个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。$\mathrm{小Z}$想知道他能够创作出来的乐曲美妙度最大值是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含四个正整数$n,k,L,R$。其中$n$为音符的个数，$k$为乐曲所包含的超级和弦个数，$L$和$R$分别是超级和弦所包含音符个数的下限和上限。&lt;br&gt;接下来$n$行，每行包含一个整数$A_i$，表示按编号从小到大每个音符的美妙度。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;只有一个整数，表示乐曲美妙度的最大值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="NOI" scheme="http://azrael.top/tags/NOI/"/>
    
      <category term="ST表" scheme="http://azrael.top/tags/ST%E8%A1%A8/"/>
    
      <category term="堆" scheme="http://azrael.top/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3784 树上的路径 &lt;点分治序+ST表+堆&gt;</title>
    <link href="http://azrael.top/BZOJ3784%20%E6%A0%91%E4%B8%8A%E7%9A%84%E8%B7%AF%E5%BE%84%20%E7%82%B9%E5%88%86%E6%B2%BB+ST%E8%A1%A8+%E5%A0%86/"/>
    <id>http://azrael.top/BZOJ3784 树上的路径 点分治+ST表+堆/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-05-03T09:31:40.157Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="树上的路径"><a href="#树上的路径" class="headerlink" title="树上的路径"></a>树上的路径</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定一个$N$个结点的树，结点用正整数$1\sim N$编号，每条边有一个正整数权值。<br>用$d(a,b)$表示从结点$a$到结点$b$路边上经过边的权值，其中要求$a&lt;b$。<br>将这$\frac{n\times(n-1)}{2}$个距离从大到小排序，输出前$M$个距离值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个正整数$N,M$。<br>下面$N-1$行，每行三个正整数$a,b,c\;(a,b\le N,\;c\le10000)$，表示结点$a$到结点$b$有一条权值为$c$的边。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共$M$行，如题所述。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">1 2 1</span><br><span class="line">1 3 2</span><br><span class="line">2 4 3</span><br><span class="line">2 5 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">7</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$N\le 5\times10^4,\;M\le \min(3\times10^5,\frac{n\times(n-1)}{2})$</p><p>标签：<code>点分治序</code> <code>ST表</code> <code>堆</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{BZOJ2006超级钢琴}$的加强版，将问题移到了树上。</p><p>对于关系到树上所有路径的问题，一般用点分治解决。此题需要用到点分治序。<br>点分时，记录下每个分治中心，并在从分治中心向外$\mathrm{DFS}$的过程中记录下走到结点的顺序，这样的排列叫做点分治序。其实就是点分树上的$\mathrm{DFS}$序中插入每个点子树的$\mathrm{DFS}$序。</p><p>对于一个分治中心$u$，其在点分治序上的第$x$个位置出现，并且从$u$开始做$\mathrm{DFS}$，每个子树的$\mathrm{DFS}$序分别在位置区间$x+1\sim x+sz_1$，$x+sz_1+1\sim x+sz_1+sz_2$，$x+sz_1+sz_2+1\sim x+sz_1+sz_2+sz_3$……对于$u$第$i$个子树中的一点$v$，以$v$为起点，其路径另一端点只能落在点分治序位置区间$x\sim x+sz_1+sz_2+\cdots+sz_{i-1}$内，发现以每个点为一端，形成的路径的另一端在点分治序上一定对应一个区间。</p><p>这样问题又转化到了数列上，即已知对于每个数$x$，其二元组$(x,y)$中另一个数$y$的范围$[l,r]$，二元组$(x,y)$的权值为$d_x+d_y$，求前$k$大的二元组权值。</p><p>这个问题可以用类似<a href="http://azrael.top/BZOJ2006%E3%80%90NOI2010%E3%80%91%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%20ST%E8%A1%A8+%E5%A0%86/">BZOJ2006</a>的方法解决，在此不再赘述。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 800000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG Log[t-s]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, rt, tot;</span><br><span class="line"><span class="keyword">int</span> sz[MAX_N+<span class="number">5</span>], w[MAX_N+<span class="number">5</span>], L[MAX_M+<span class="number">5</span>], R[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> d[MAX_M+<span class="number">5</span>], st[MAX_M+<span class="number">5</span>][<span class="number">25</span>], Log[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> p, l, r, val; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> t.val &gt; val;&#125;&#125; ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>], E[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>]; priority_queue &lt;node&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;G[u].push_back(v), E[u].push_back(c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>, w[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v])</span><br><span class="line">getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]);</span><br><span class="line"><span class="keyword">if</span> ((w[u] = max(w[u], tot-sz[u])) &lt; w[rt]) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis)</span> </span>&#123;</span><br><span class="line">d[++m] = dis, L[m] = L[m<span class="number">-1</span>]; <span class="keyword">if</span> (!R[m]) R[m] = R[m<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v])</span><br><span class="line">getdis(v, u, dis+E[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">d[++m] = <span class="number">0</span>, L[m] = m, R[m] = m<span class="number">-1</span>, mrk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = G[u][i]]) R[m+<span class="number">1</span>] = m, getdis(v, u, E[u][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++) <span class="keyword">if</span> (!mrk[v = G[u][i]])</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = sz[v], getrt(v, u), DFS(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> d[a] &gt; d[b] ? a : b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_ST</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) Log[i] = Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) st[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= m; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>; i++)</span><br><span class="line">st[i][j] = Max(st[i][j<span class="number">-1</span>], st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;<span class="keyword">return</span> s &gt; t ? <span class="number">-1</span> : Max(st[s][LOG], st[t-(<span class="number">1</span>&lt;&lt;LOG)+<span class="number">1</span>][LOG]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt; n; i++)</span><br><span class="line">read(u), read(v), read(c), addedge(u, v, c);</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = n, getrt(<span class="number">1</span>, <span class="number">0</span>), DFS(rt), init_ST();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (L[i] &lt;= R[i])</span><br><span class="line">que.push((node)&#123;i, L[i], R[i], d[i]+d[query(L[i], R[i])]&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t, p; i &lt;= k; i++) &#123;</span><br><span class="line">node tp = que.top(); que.pop(), p = tp.p, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tp.val);</span><br><span class="line"><span class="keyword">int</span> ll = tp.l, rr = tp.r, lr = query(ll, rr)<span class="number">-1</span>, rl = query(ll, rr)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (~(t = query(ll, lr))) que.push((node)&#123;p, ll, lr, d[p]+d[t]&#125;);</span><br><span class="line"><span class="keyword">if</span> (~(t = query(rl, rr))) que.push((node)&#123;p, rl, rr, d[p]+d[t]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;树上的路径&quot;&gt;&lt;a href=&quot;#树上的路径&quot; class=&quot;headerlink&quot; title=&quot;树上的路径&quot;&gt;&lt;/a&gt;树上的路径&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定一个$N$个结点的树，结点用正整数$1\sim N$编号，每条边有一个正整数权值。&lt;br&gt;用$d(a,b)$表示从结点$a$到结点$b$路边上经过边的权值，其中要求$a&amp;lt;b$。&lt;br&gt;将这$\frac{n\times(n-1)}{2}$个距离从大到小排序，输出前$M$个距离值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行两个正整数$N,M$。&lt;br&gt;下面$N-1$行，每行三个正整数$a,b,c\;(a,b\le N,\;c\le10000)$，表示结点$a$到结点$b$有一条权值为$c$的边。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;共$M$行，如题所述。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树分治" scheme="http://azrael.top/tags/%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
      <category term="ST表" scheme="http://azrael.top/tags/ST%E8%A1%A8/"/>
    
      <category term="堆" scheme="http://azrael.top/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3219 巡游 &lt;二分答案+点分治+单调队列&gt;</title>
    <link href="http://azrael.top/BZOJ3219%20%E5%B7%A1%E6%B8%B8%20%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88+%E7%82%B9%E5%88%86%E6%B2%BB+%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <id>http://azrael.top/BZOJ3219 巡游 二分答案+点分治+单调队列/</id>
    <published>2018-05-01T16:00:00.000Z</published>
    <updated>2018-05-03T08:31:09.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="巡游"><a href="#巡游" class="headerlink" title="巡游"></a>巡游</h3><p>$\mathrm{Time\;Limit:\;25\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Tar}$国正在准备每年一次的巡游活动。国王将会在一个城市$S$里召集人群，沿着城市间的道路进行游览，最终在一个城市$T$里发表他每年一次的著名演讲。<br>$\mathrm{Tar}$国有$N$个城市，由于国家的特殊要求，每两个城市之间存在一条唯一的简单通路。国王希望借着这个机会视察$\mathrm{Tar}$国的城市建设，因此他提出$S$到$T$的距离不能少于$L$条道路。<br>同时，国王的私人医生检查了他的身体情况后，断定国王的身体不适合做长途旅行，因此他要求$S$到$T$的距离不能多于$R$条道路。<br>另外，政府希望跟随国王的人民沿途不仅能看到城市风景，还能看到城市外的美丽乡村。因此每条道路定义了一个魅力值$C_i$，一条路径的魅力值定义为这条路径的中位数。更详细的说法是这样的：将路径上所有边的魅力值排序，得到序列$\lbrace A_i\rbrace$。假设$i=2k+c\;(0\le c\le 1)$，中位数就是$A_{k+1}$。<br>你的任务就是求出魅力值最大的路径，并输出这个魅力值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是三个整数$N,L,R$，表示$\mathrm{Tar}$国的城市个数、路径的最小和最大长度。<br>接下来$N-1$行，每行$3$个整数$A_i,B_i,C_i$，表示有一条连接$A_i$和$B_i$且魅力值$C_i$的道路。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅一行，表示最大的魅力值。如果不存在这样的路径，输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 1 4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 4</span><br><span class="line">3 4 7</span><br><span class="line">3 5 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据：$N\le10^5$，$1\le L\le R\le N-1$，$1\le C_i\le10^9$。</p><p>标签：<code>点分治</code> <code>二分答案</code> <code>单调队列</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>稍有码量的点分题。</p><p>首先策略是$二分答案+点分治验证$，二分答案魅力值，将所有的边权变为$1$和$-1$，分别表示大于等于魅力值和小于魅力值。这样验证问题转化为判断是否有一条长度在$[L,R]$间路径使得边权和大于等于$0$。</p><p>这个判断过程可以用点分治实现。对于每个分治中心，只考虑经过其的路径。在其点分树的不同子树中找两个点，使得其到分治中心的路径长度和在$[L,R]$之间，可以用两个桶，分别存已枚举的子树和当前子树中各个深度的最大路径边权和，需要用单调队列维护一下。这部分有些细节需要注意。</p><p>此题卡常，注意一些减小常数的细节：</p><ul><li>二分答案时，将原边权记下来排序，在排好的数组上二分，这样只会二分到边权值</li><li>一开始将点分树记下来，记录所有分治中心，这样每次二分$check$可以不用重新找重心</li><li>点分时在当前分治中心统计答案时用$\mathrm{BFS}$</li><li>预处理点分时在当前分治中心$\mathrm{BFS}$，若下一个点的距离大于$R$则退出</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, L, R, rt, cnt, ind, tot, f[MAX_N+<span class="number">5</span>], g[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pr[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>], w[MAX_N+<span class="number">5</span>], dfn[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> val[MAX_N+<span class="number">5</span>], dep[MAX_N+<span class="number">5</span>], d[MAX_N&lt;&lt;<span class="number">1</span>], ord[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>], vis[MAX_N+<span class="number">5</span>]; <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que, bin;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> v, c, w, nxt;&#125; E[MAX_N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;<span class="keyword">return</span> d[x] &lt; d[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (edge)&#123;v, c, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>, w[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (((v = E[i].v) ^ fa) &amp;&amp; !mrk[v])</span><br><span class="line">getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]);</span><br><span class="line"><span class="keyword">if</span> ((w[u] = max(w[u], tot-sz[u])) &lt; w[rt]) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; dfn[++ind] = u, mrk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v, mxd = <span class="number">0</span>; ~i; i = E[i].nxt, mxd = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v]) &#123;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">que.push(v), dep[v] = <span class="number">1</span>, vis[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = que.front(); que.pop();</span><br><span class="line"><span class="keyword">if</span> (dep[p] &gt;= R) <span class="keyword">continue</span>; mxd = max(mxd, dep[p]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = pr[p], q; ~j; j = E[j].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[q = E[j].v] &amp;&amp; !vis[q])</span><br><span class="line">que.push(q), dep[q] = dep[p]+<span class="number">1</span>, vis[q] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">d[ord[++num] = i] = mxd;</span><br><span class="line">&#125; <span class="keyword">else</span> d[ord[++num] = i] = n;</span><br><span class="line">sort(ord+<span class="number">1</span>, ord+num+<span class="number">1</span>, cmp), pr[u] = ord[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) E[ord[i]].nxt = ord[i+<span class="number">1</span>];</span><br><span class="line">E[ord[num]].nxt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (sz[u] &lt; sz[v = E[i].v]) sz[v] = tot-sz[u];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v] &amp;&amp; sz[v] &gt; L)</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = sz[v], getrt(v, u), init(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> stp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stp &gt; ind) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> u = dfn[stp], mxd = <span class="number">0</span>; f[<span class="number">0</span>] = <span class="number">0</span>, mrk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v]) &#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line"><span class="keyword">while</span> (!bin.empty()) bin.pop();</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = mxd; j &gt;= L; d[++t] = j--)</span><br><span class="line"><span class="keyword">while</span> (s &lt;= t &amp;&amp; f[d[t]] &lt;= f[j]) t--;</span><br><span class="line">que.push(v), dep[v] = <span class="number">1</span>, g[v] = E[i].c, vis[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = que.front(); que.pop(), bin.push(p);</span><br><span class="line"><span class="keyword">while</span> (s &lt;= t &amp;&amp; d[s]+dep[p] &gt; R) s++;</span><br><span class="line"><span class="keyword">if</span> (dep[p] &lt;= L) &#123;</span><br><span class="line"><span class="keyword">while</span> (s &lt;= t &amp;&amp; f[d[t]] &lt;= f[L-dep[p]]) t--;</span><br><span class="line">d[++t] = L-dep[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s &lt;= t &amp;&amp; f[d[s]]+g[p] &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (dep[p] &gt;= R) <span class="keyword">continue</span>; mxd = max(mxd, dep[p]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = pr[p], q; ~j; j = E[j].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[q = E[j].v] &amp;&amp; !vis[q])</span><br><span class="line">que.push(q), dep[q] = dep[p]+<span class="number">1</span>, </span><br><span class="line">g[q] = g[p]+E[j].c, vis[q] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x; !bin.empty(); bin.pop())</span><br><span class="line">x = bin.front(), f[dep[x]] = max(f[dep[x]], g[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mxd; i++) f[i] = -n;</span><br><span class="line"><span class="keyword">return</span> DFS(stp+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> tans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">E[i].c = E[i].w &lt; tans ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i] = -n;</span><br><span class="line"><span class="built_in">memset</span>(mrk, <span class="literal">false</span>, <span class="keyword">sizeof</span> mrk);</span><br><span class="line"><span class="keyword">return</span> DFS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(val[mid])) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = val[mid], l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(L), read(R), <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt; n; i++)</span><br><span class="line">read(u), read(v), read(c), </span><br><span class="line">addedge(u, v, c), val[i] = c;</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = n, getrt(<span class="number">1</span>, <span class="number">0</span>), init(rt);</span><br><span class="line">sort(val+<span class="number">1</span>, val+n), m = (<span class="keyword">int</span>)(unique(val+<span class="number">1</span>, val+n)-val<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bi_search(<span class="number">1</span>, m)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;巡游&quot;&gt;&lt;a href=&quot;#巡游&quot; class=&quot;headerlink&quot; title=&quot;巡游&quot;&gt;&lt;/a&gt;巡游&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;25\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Tar}$国正在准备每年一次的巡游活动。国王将会在一个城市$S$里召集人群，沿着城市间的道路进行游览，最终在一个城市$T$里发表他每年一次的著名演讲。&lt;br&gt;$\mathrm{Tar}$国有$N$个城市，由于国家的特殊要求，每两个城市之间存在一条唯一的简单通路。国王希望借着这个机会视察$\mathrm{Tar}$国的城市建设，因此他提出$S$到$T$的距离不能少于$L$条道路。&lt;br&gt;同时，国王的私人医生检查了他的身体情况后，断定国王的身体不适合做长途旅行，因此他要求$S$到$T$的距离不能多于$R$条道路。&lt;br&gt;另外，政府希望跟随国王的人民沿途不仅能看到城市风景，还能看到城市外的美丽乡村。因此每条道路定义了一个魅力值$C_i$，一条路径的魅力值定义为这条路径的中位数。更详细的说法是这样的：将路径上所有边的魅力值排序，得到序列$\lbrace A_i\rbrace$。假设$i=2k+c\;(0\le c\le 1)$，中位数就是$A_{k+1}$。&lt;br&gt;你的任务就是求出魅力值最大的路径，并输出这个魅力值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行是三个整数$N,L,R$，表示$\mathrm{Tar}$国的城市个数、路径的最小和最大长度。&lt;br&gt;接下来$N-1$行，每行$3$个整数$A_i,B_i,C_i$，表示有一条连接$A_i$和$B_i$且魅力值$C_i$的道路。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅一行，表示最大的魅力值。如果不存在这样的路径，输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="二分答案" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="树分治" scheme="http://azrael.top/tags/%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
      <category term="单调队列" scheme="http://azrael.top/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4974【Lydsy月赛201708】字符串大师 &lt;KMP+贪心构造&gt;</title>
    <link href="http://azrael.top/BZOJ4974%E3%80%90Lydsy1708%E6%9C%88%E8%B5%9B%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B8%88%20KMP+%E8%B4%AA%E5%BF%83%E6%9E%84%E9%80%A0/"/>
    <id>http://azrael.top/BZOJ4974【Lydsy1708月赛】字符串大师 KMP+贪心构造/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-05-02T07:19:00.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【Lydsy1708月赛】字符串大师"><a href="#【Lydsy1708月赛】字符串大师" class="headerlink" title="【Lydsy1708月赛】字符串大师"></a>【Lydsy1708月赛】字符串大师</h3><p>$\mathrm{Time\;Limit:\;1\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一个串$T$是$S$的循环节，当且仅当存在正整数$k$，使得$S$是$T$重复$k$次的前缀，比如<code>abcd</code>是<code>abcdabcdab</code>的循环节。<br>给定一个长度为$n$的仅由小写字符构成的字符串$S$，请对于每个$k\;(1\le k\le n)$，求出$S$长度为$k$的前缀的最短循环节的长度$per_i$。<br>字符串大师$\mathrm{小Q}$觉得这个问题过于简单，于是花了一分钟将其$\mathrm{AC}$了，他想检验你是否也是字符串大师。<br>$\mathrm{小Q}$告诉你$n$以及$per_1,per_2,\cdots,per_n$，请找到一个长度为$n$的小写字符串$S$，使得$S$能对应上$per$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个正整数$n\;(1\le n\le10^5)$，表示字符串的长度。<br>第二行包含$n$个正整数$per_1,per_2,\cdots,per_n\;(1\le per_i\le i)$，表示每个前缀的最短循环节长度。<br>输入数据保证至少存在一组可行解。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个长度为$n$的小写字符串$S$，即某个满足条件的$S$。<br>若有多个可行的$S$，输出字典序最小的那一个。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 2 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ababb</span><br></pre></td></tr></table></figure><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p><code>Claris</code>原创，本$\mathrm{OJ}$版权所有，翻版必究</p><p>标签：<code>KMP</code> <code>贪心</code> <code>构造</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{KMP}$好题。</p><p>$\bigstar$本文中所有数组和字符串下标从$0$开始。</p><p>首先有一个结论：$nxt_i=i-per_i$<br>证明：<br>对于字符串$P$，其最短循环节为$R$，除去循环节后多余的部分为$Q$，如图所示。</p><center><br><img src="https://i.loli.net/2018/05/02/5ae96516e82ca.png" alt="1.PNG"><br></center><p>那么再在上面接一个$R$，一定可以包含$P$，于是可以知道$Q$一定是$R$的前缀，所以有下图：</p><center><br><img src="https://i.loli.net/2018/05/02/5ae96516e8d6d.png" alt="2.PNG"><br></center><p>将$P$末尾循环节长度那么长去掉，得到$P_1$，将$P$第一个循环节去掉，得到$P_2$，发现两者是相同的（如下图）。而这显然是$P$的$boarder$，所以$P_1$的末尾位置为$n-per$，即$nxt[n]=n-per$</p><center><br><img src="https://i.loli.net/2018/05/02/5ae965170167b.png" alt="3.PNG"><br></center><p>这样根据给出的$per$可以将$nxt$数组处理出来。<br>从前往后构造，对于位置$i$：</p><ul><li>$nxt_i\ne-1$，一定有$s[i]=s[nxt_i]$，可以直接赋值</li><li>$nxt_i=-1$，那么在计算$nxt$的过程中，即将这个串与自己做匹配的时候，不断根据$nxt$向前跳到的位置一定不会和当前位置匹配，否则$nxt_i=最先能匹配的位置$。于是将能向前跳到的位置上的字符存下来，找一个最小的没有跳到过的字符作为这一位置的字符</li></ul><p>如此贪心构造即可得到最优解。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, nxt[MAX_N+<span class="number">5</span>], s[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) read(nxt[i]), nxt[i] = i-nxt[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; n; p++) &#123;</span><br><span class="line"><span class="keyword">if</span> (~nxt[p]) s[p] = s[nxt[p]];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(mrk, <span class="literal">false</span>, <span class="keyword">sizeof</span> mrk);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = nxt[p<span class="number">-1</span>]; ~q; q = nxt[q])</span><br><span class="line">mrk[s[q+<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; <span class="number">26</span>; c++)</span><br><span class="line"><span class="keyword">if</span> (!mrk[c]) &#123;s[p] = c; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="string">'a'</span>+s[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【Lydsy1708月赛】字符串大师&quot;&gt;&lt;a href=&quot;#【Lydsy1708月赛】字符串大师&quot; class=&quot;headerlink&quot; title=&quot;【Lydsy1708月赛】字符串大师&quot;&gt;&lt;/a&gt;【Lydsy1708月赛】字符串大师&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;1\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一个串$T$是$S$的循环节，当且仅当存在正整数$k$，使得$S$是$T$重复$k$次的前缀，比如&lt;code&gt;abcd&lt;/code&gt;是&lt;code&gt;abcdabcdab&lt;/code&gt;的循环节。&lt;br&gt;给定一个长度为$n$的仅由小写字符构成的字符串$S$，请对于每个$k\;(1\le k\le n)$，求出$S$长度为$k$的前缀的最短循环节的长度$per_i$。&lt;br&gt;字符串大师$\mathrm{小Q}$觉得这个问题过于简单，于是花了一分钟将其$\mathrm{AC}$了，他想检验你是否也是字符串大师。&lt;br&gt;$\mathrm{小Q}$告诉你$n$以及$per_1,per_2,\cdots,per_n$，请找到一个长度为$n$的小写字符串$S$，使得$S$能对应上$per$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含一个正整数$n\;(1\le n\le10^5)$，表示字符串的长度。&lt;br&gt;第二行包含$n$个正整数$per_1,per_2,\cdots,per_n\;(1\le per_i\le i)$，表示每个前缀的最短循环节长度。&lt;br&gt;输入数据保证至少存在一组可行解。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一行一个长度为$n$的小写字符串$S$，即某个满足条件的$S$。&lt;br&gt;若有多个可行的$S$，输出字典序最小的那一个。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="贪心" scheme="http://azrael.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="字符串" scheme="http://azrael.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="构造" scheme="http://azrael.top/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="KMP" scheme="http://azrael.top/tags/KMP/"/>
    
      <category term="Lydsy月赛" scheme="http://azrael.top/tags/Lydsy%E6%9C%88%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3697 采药人的路径 &lt;点分治&gt;</title>
    <link href="http://azrael.top/BZOJ3697%20%E9%87%87%E8%8D%AF%E4%BA%BA%E7%9A%84%E8%B7%AF%E5%BE%84%20%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>http://azrael.top/BZOJ3697 采药人的路径 点分治/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-05-02T06:31:23.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="采药人的路径"><a href="#采药人的路径" class="headerlink" title="采药人的路径"></a>采药人的路径</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>采药人的药田是一个树状结构，每条路径上都种植着同种药材。<br>采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。<br>采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。<br>采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。<br>他想知道他一共可以选择多少种不同的路径。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第$1$行包含一个整数$N$。<br>接下来$N-1$行，每行包含三个整数$a_i,b_i,t_i$，表示$a_i$到$b_i$这条路上药材的类型为$t_i$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出符合采药人要求的路径数目。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 0</span><br><span class="line">3 1 1</span><br><span class="line">2 4 0</span><br><span class="line">5 2 0</span><br><span class="line">6 3 1</span><br><span class="line">5 7 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据，$N\le10^5$。</p><p>标签：<code>点分治</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>点分治基础题。</p><p>每次找重心作分治中心，同一子树内的路径数递归计算，只考虑经过当前分治中心的路径数。<br>对于当前分治中心，处理出其余未分治到的点与其的路径上有多少阴性和阳性道路。设阴性道路边权为$-1$，阳性为$1$，那么若两个点到分治中心的路径拼起来可以构成一条合法道路，一定需要满足两个条件：</p><ul><li>路径总长为$0$</li><li>在两条路径中一定有至少一条在路径上存在两个点，使得分治中心到这个两点的长度相同，并且这个长度不为$0$。特殊情况是两条路径的长度都为$0$也可。</li></ul><p>用$f[i][0/1]$表示现在枚举到的子树中，与当前分治中心距离为$i$的路径上有/没有两个离分治中心距离相同的点的路径条数；用$g[i][0/1]$表示同样的意义，只是是在前面已枚举的子树中这样的路径条数。那么从当前子树和前面的子树各选一条路径，拼成新路径，这样对答案的贡献是$f[x][0]\times g[-x][1]+f[x][1]\times g[-x][0]+f[x][1]\times g[-x][1]$。除此之外还需要加上两条不同子树中到分治中心长为$0$的路径组成的路径条数，即$f[0][0]\times g[0][0]$。</p><p>点分时每次$\mathrm{DFS}$预处理$f$,$g$统计即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, rt, tot, cnt[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>]; lnt ans;</span><br><span class="line"><span class="keyword">int</span> sz[MAX_N+<span class="number">5</span>], w[MAX_N+<span class="number">5</span>], dis[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> f[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>][<span class="number">2</span>], g[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>], E[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;G[u].push_back(v), E[u].push_back(c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;<span class="keyword">if</span> (!c) c = <span class="number">-1</span>; insert(u, v, c), insert(v, u, c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>, w[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v])</span><br><span class="line">getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]);</span><br><span class="line"><span class="keyword">if</span> ((w[u] = max(w[u], tot-sz[u])) &lt; w[rt]) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = dep;f[dis[u]][cnt[dis[u]]&gt;<span class="number">0</span>]++, cnt[dis[u]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v])</span><br><span class="line">dis[v] = dis[u]+E[u][i], ret = max(ret, getdis(v, u, dep+<span class="number">1</span>));</span><br><span class="line">cnt[dis[u]]--;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;mrk[u] = <span class="literal">true</span>, g[n][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v, d; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = G[u][i]]) &#123;</span><br><span class="line">dis[v] = n+E[u][i], d = getdis(v, u, <span class="number">1</span>);</span><br><span class="line">r = max(r, d), ans += <span class="number">1L</span>L*f[n][<span class="number">0</span>]*(g[n][<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -d; j &lt;= +d; j++)</span><br><span class="line">ans += <span class="number">1L</span>L*f[n+j][<span class="number">1</span>]*g[n-j][<span class="number">1</span>], </span><br><span class="line">ans += <span class="number">1L</span>L*f[n+j][<span class="number">0</span>]*g[n-j][<span class="number">1</span>], </span><br><span class="line">ans += <span class="number">1L</span>L*f[n+j][<span class="number">1</span>]*g[n-j][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -d; j &lt;= +d; j++)</span><br><span class="line">g[n+j][<span class="number">0</span>] += f[n+j][<span class="number">0</span>], f[n+j][<span class="number">0</span>] = <span class="number">0</span>, </span><br><span class="line">g[n+j][<span class="number">1</span>] += f[n+j][<span class="number">1</span>], f[n+j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -r; i &lt;= +r; i++) g[n+i][<span class="number">0</span>] = g[n+i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++) <span class="keyword">if</span> (!mrk[v = G[u][i]])</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = sz[v], getrt(v, u), DFS(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt; n; i++)</span><br><span class="line">read(u), read(v), read(c), addedge(u, v, c);</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = n, getrt(<span class="number">1</span>, <span class="number">0</span>), DFS(rt);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;采药人的路径&quot;&gt;&lt;a href=&quot;#采药人的路径&quot; class=&quot;headerlink&quot; title=&quot;采药人的路径&quot;&gt;&lt;/a&gt;采药人的路径&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;采药人的药田是一个树状结构，每条路径上都种植着同种药材。&lt;br&gt;采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。&lt;br&gt;采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。&lt;br&gt;采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。&lt;br&gt;他想知道他一共可以选择多少种不同的路径。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第$1$行包含一个整数$N$。&lt;br&gt;接下来$N-1$行，每行包含三个整数$a_i,b_i,t_i$，表示$a_i$到$b_i$这条路上药材的类型为$t_i$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出符合采药人要求的路径数目。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树分治" scheme="http://azrael.top/tags/%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4174 tty的求助 &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ4174%20tty%E7%9A%84%E6%B1%82%E5%8A%A9%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ4174 tty的求助 莫比乌斯反演/</id>
    <published>2018-04-28T16:00:00.000Z</published>
    <updated>2018-05-01T00:39:30.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="tty的求助"><a href="#tty的求助" class="headerlink" title="tty的求助"></a>tty的求助</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>求$\sum_{n=1}^{N}\sum_{m=1}^{M}\sum_{k=0}^{m-1}\lfloor\frac{nk+x}{m}\rfloor$，其中$x$为实数。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入仅有一行。<br>第一行仅有两个正整数$N,M$和一个实数$x$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共一行，由于结果过大，所以请输出上式对$998244353$取模的结果。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>当$n=1,m=1$时，$sum=1$<br>当$n=1,m=2$时，$sum=1$<br>当$n=1,m=3$时，$sum=1$<br>当$n=2,m=1$时，$sum=1$<br>当$n=2,m=2$时，$sum=1$<br>当$n=2,m=3$时，$sum=2$<br>所以答案是$7$</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$N,M\le5\times10^5$，$0&lt;x\le10^5$，$x$精确到小数点后8位。</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$$<br>Ans=\sum_{n=1}^{N}\sum_{m=1}^{M}\sum_{k=0}^{m-1}\lfloor\frac{nk+x}{m}\rfloor\\<br>$$</p><p>对于最后一次求和：<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{k=0}^{m-1}\lfloor\frac{nk+x}{m}\rfloor\\<br>&amp;=\sum_{k=0}^{m-1}\lfloor\frac{nk-nk\%m+x+nk\%m}{m}\rfloor\\<br>&amp;=\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}+\frac{nk-nk\%m}{m}\rfloor\\<br>&amp;=\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}\rfloor+\sum_{k=0}^{m-1}\frac{nk}{m}-\sum_{k=0}^{m-1}\frac{nk\%m}{m}\\<br>\end{aligned}<br>$$</p><p>先考虑前一项：<br>设$d=\gcd(n,m)$，那么$n\cdot\frac{m}{d}\equiv0\mod{m}$。于是有$n(k+\frac{m}{d})\%m=nk\%m+\frac{nm}{d}\%m=nk\%m$，即可知$nk\%m=n(k\%\frac{m}{d})\%m$。<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=\sum_{k=0}^{m-1}\lfloor\frac{n(k\%\frac{m}{d})\%m+x}{m}\rfloor\\<br>&amp;=\frac{m}{\frac{m}{d}}\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{n(k\%\frac{m}{d})\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>\end{aligned}<br>$$</p><p>对于$k$取遍$\frac{0}{d},\frac{d}{d},\frac{2d}{d},\cdots,\frac{m-d}{d}$，$nk$的值依次为$\frac{n}{d}\cdot 0,\frac{n}{d}\cdot d,\frac{n}{d}\cdot 2d,\cdots,\frac{n}{d}\cdot (\frac{m}{d}-1)d$。由于$\frac{n}{d}$与$\lfloor\frac{m}{d}\rfloor$互质，所以$\frac{n}{d}\cdot k\%m$一定取遍$0,1,2,\cdots,(\frac{m}{d}-1)$，因而$nk\%m$一定取遍$0,d,2d,\cdots,(\frac{m}{d}-1)d$。故而有<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{kd+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{kd+x\%m+x-x\%m}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{kd+x\%m}{m}\rfloor+d\cdot\frac{m}{d}\cdot\frac{x-x\%m}{m}\\<br>\end{aligned}<br>$$</p><p>又发现$0\le kd+x\%m&lt;2m\Rightarrow0\le\lfloor\frac{kd+x\%m}{m}\rfloor&lt;2$，故<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{kd+x\%m}{m}\rfloor+d\cdot\frac{m}{d}\cdot\frac{x-x\%m}{m}\\<br>&amp;=d\times(\sum_{k=0}^{\frac{m}{d}-1}[kd\ge m-x\%m]+\frac{x-x\%m}{d})\\<br>&amp;=d\times(\sum_{k=0}^{\frac{m}{d}-1}[k\ge\lceil\frac{m-x\%m}{d}\rceil]+\frac{x-x\%m}{d})\\<br>&amp;=d\times(\lfloor\frac{x\%m}{d}\rfloor+\lfloor\frac{x}{d}\rfloor-\lfloor\frac{x\%m}{d}\rfloor)\\<br>&amp;=d\lfloor\frac{x}{d}\rfloor\\<br>\end{aligned}<br>$$</p><p>对于后两项：<br>$$<br>\sum_{k=0}^{m-1}\frac{nk}{m}=\frac{n\cdot m\cdot(m-1)}{2m}=\frac{nm-n}{2}\\<br>\sum_{k=0}^{m-1}\frac{nk\%m}{m}=d\sum_{k=0}^{\frac{m}{d}-1}\frac{kd}{m}=\frac{m-d}{2}\\<br>$$</p><p>将三项和前面两个求和连起来：<br>$$<br>\begin{aligned}<br>Let\;&amp;S_i=1+2+\cdots+i=\frac{i\times(i+1)}{2},\\<br>Ans&amp;=\sum_{n=1}^{N}\sum_{m=1}^{M}(d\lfloor\frac{x}{d}\rfloor+\frac{nm-n-m+d}{2})\\<br>&amp;=\sum_{n=1}^{N}\sum_{m=1}^{M}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})+\frac{1}{2}S_NS_M-\frac{M}{2}S_N-\frac{N}{2}S_M\\<br>&amp;=\sum_{n=1}^{N}\sum_{m=1}^{M}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})+\frac{1}{2}S_NS_M-\frac{M}{2}S_N-\frac{N}{2}S_M\\<br>\end{aligned}<br>$$</p><p>对前面的和式做莫比乌斯反演：<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{n=1}^{N}\sum_{m=1}^{M}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})\\<br>&amp;=\sum_{d=1}^{\min(N,M)}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}[\gcd(i,j)=1]\\<br>&amp;=\sum_{d=1}^{\min(N,M)}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\sum_{t|i,j}\mu(t)\\<br>&amp;=\sum_{d=1}^{\min(N,M)}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})\sum_{t=1}^{\min(\lfloor\frac{N}{d}\rfloor,\lfloor\frac{M}{d}\rfloor)}\mu(t)\lfloor\frac{N}{td}\rfloor\lfloor\frac{M}{td}\rfloor\\<br>\end{aligned}<br>$$</p><p>直接枚举$d$数论分块即可，总时间复杂度约为$O(2n-2\sqrt{n})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inv2 499122177</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];dnt x;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), </span><br><span class="line">(ret += <span class="number">1L</span>L*(mu[r]-mu[l<span class="number">-1</span>])*(n/l)%MOD*(m/l)%MOD) %= MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;n, &amp;m, &amp;x), init();</span><br><span class="line">lnt sn = <span class="number">1L</span>L*n*(n+<span class="number">1</span>)/<span class="number">2</span>%MOD, sm = <span class="number">1L</span>L*m*(m+<span class="number">1</span>)/<span class="number">2</span>%MOD;</span><br><span class="line">lnt ans = sn*sm%MOD<span class="number">-1L</span>L*m*sn%MOD<span class="number">-1L</span>L*n*sm%MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= min(n, m); d++)</span><br><span class="line">(ans += (<span class="number">2L</span>L*d*(lnt)(x/d)+d)%MOD*calc(n/d, m/d)%MOD) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans*inv2%MOD+MOD)%MOD), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;tty的求助&quot;&gt;&lt;a href=&quot;#tty的求助&quot; class=&quot;headerlink&quot; title=&quot;tty的求助&quot;&gt;&lt;/a&gt;tty的求助&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;求$\sum_{n=1}^{N}\sum_{m=1}^{M}\sum_{k=0}^{m-1}\lfloor\frac{nk+x}{m}\rfloor$，其中$x$为实数。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入仅有一行。&lt;br&gt;第一行仅有两个正整数$N,M$和一个实数$x$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出共一行，由于结果过大，所以请输出上式对$998244353$取模的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3994【SDOI2015】约数个数和 &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ3994%E3%80%90SDOI2015%E3%80%91%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ3994【SDOI2015】约数个数和 莫比乌斯反演/</id>
    <published>2018-04-27T16:00:00.000Z</published>
    <updated>2018-04-30T11:46:43.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SDOI2015】约数个数和"><a href="#【SDOI2015】约数个数和" class="headerlink" title="【SDOI2015】约数个数和"></a>【SDOI2015】约数个数和</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>设$d(x)$为$x$的约数个数，给定$N,M$，求$\sum_{i=1}^{n}\sum_{j=1}^{m}d(i\cdot j)$</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入文件包含多组测试数据。<br>第一行，一个整数$T$，表示测试数据的组数。<br>接下来的$T$行，每行两个整数$N,M$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>$T$行，每行一个整数，表示你所求的答案。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">7 4</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">110</span><br><span class="line">121</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N,M\le50000,\;1\le T\le50000$</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>挺神的反演，没推出来，需要一个结论。</p><p>首先考虑如何把$d(x)$变为我们更为熟悉的数学语言。<br>对于$d(x\cdot y)$，考虑$x\times y$的约数，每个约数均可表示为$i\times \frac{y}{j}$，其中$i|x,j|y$。那么用$\sum_{i|x}\sum_{j|y}1$统计约数，一定会不漏地枚举到所有约数，但显然是有重复的。注意到这种重复的造成只有一种情况，即若$(i,j)$符合条件，那么$(i\times t,j\times t)$也符合条件，而两者所代表的最终约数是相同的，重复计数。也就是说只要$\gcd(i,j)\ne1$，那么一定是重复计算的。于是不重不漏地计算只需要把$\sum_{i|x}\sum_{j|y}1$中的$1$加上$\gcd(i,j)=1$的限制即可。<br>因此推出重要结论$d(x\cdot y)=\sum_{i|x}\sum_{j|y}[\gcd(i,j)=1]$。</p><p>接下来就可以推反演了：<br>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{k=1}^{n}\sum_{w=1}^{m}d(k\cdot w)\\<br>&amp;=\sum_{k=1}^{n}\sum_{w=1}^{m}\sum_{i|k}\sum_{j|w}[\gcd(i,j)=1]\\<br>&amp;=\sum_{i=1}^{n}\sum_{j=1}^{m}\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{j}\rfloor[\gcd(i,j)=1]\\<br>&amp;=\sum_{i=1}^{n}\sum_{j=1}^{m}\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{j}\rfloor\sum_{d|i,d|j}\mu(d)\\<br>&amp;=\sum_{d=1}^{n}\mu(d)\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\lfloor\frac{n}{i\cdot d}\rfloor\lfloor\frac{m}{j\cdot d}\rfloor\\<br>&amp;=\sum_{d=1}^{n}\mu(d)\sum_{i=1}^{\lfloor n/d\rfloor}\lfloor\frac{n}{i\cdot d}\rfloor\sum_{j=1}^{\lfloor m/d\rfloor}\lfloor\frac{m}{j\cdot d}\rfloor\\<br>\end{aligned}<br>$$<br>如果能预处理出$F(x)=\sum_{i=1}^{x}\lfloor\frac{x}{i}\rfloor$的值，就可以根号分块计算答案。</p><p>考虑$\sum_{i=1}^{x}\lfloor\frac{x}{i}\rfloor​$的意义，即枚举一个数，统计其在$[1,x]​$内的倍数有多少个，可以理解为枚举约数，计算它在$1\sim x​$中是多少个数的约数，即计算其对$\sum_{i=1}^{x}d(i)​$的贡献。于是$F(x)=\sum_{i=1}^{x}d(i)​$，我们需要预处理出$d(x)​$。</p><p>由于$d(x)$是积性函数，对于$d(x\cdot p)\;(x\in \mathbb{N}^*,\;p&lt;x,\;p是质数)$，我们有：</p><ol><li>$p\nmid x$：$d(x\cdot p)=d(x)\cdot d(p)$</li><li>$p\mid x$：$d(x\cdot p)=d(\frac{x}{p^k}\cdot p^{k+1})=d(\frac{x}{p^k})\cdot d(p^{k+1})=\frac{d(x)\cdot(k+2)}{k+1}$，其中$p$一定为$x$的最小质因子</li></ol><p>为了应对情况$2$，我们需要预处理最小质因子次数$c(x)$，注意到$c(x)$也可以线性筛预处理：</p><ol><li>对于质数$p$，$c(p)=1$</li><li>对于正整数$x$和质数$p$，<ul><li>$p\nmid x$：$c(x\cdot p)=1$</li><li>$p\mid x$：$c(x\cdot p)=c(x)+1$</li></ul></li></ol><p>如此我们即可线性筛预处理出$c(x),\;d(x)$，计算$d(x)$前缀和$F(x)$，对于询问进行数论分块统计答案，时间复杂度$O(T\sqrt{n})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line">lnt mu[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>, d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>, c[i] = <span class="number">1</span>, d[i] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i], c[i*pri[j]] = <span class="number">1</span>, d[i*pri[j]] = d[i]*d[pri[j]];</span><br><span class="line"><span class="keyword">else</span> mu[i*pri[j]] = <span class="number">0</span>, c[i*pri[j]] = c[i]+<span class="number">1</span>, d[i*pri[j]] = d[i]*(c[i]+<span class="number">2</span>)/(c[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (i%pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) mu[i] += mu[i<span class="number">-1</span>], d[i] += d[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, T; read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">read(n), read(m), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), </span><br><span class="line">ans += (mu[r]-mu[l<span class="number">-1</span>])*d[n/l]*d[m/l];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SDOI2015】约数个数和&quot;&gt;&lt;a href=&quot;#【SDOI2015】约数个数和&quot; class=&quot;headerlink&quot; title=&quot;【SDOI2015】约数个数和&quot;&gt;&lt;/a&gt;【SDOI2015】约数个数和&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;设$d(x)$为$x$的约数个数，给定$N,M$，求$\sum_{i=1}^{n}\sum_{j=1}^{m}d(i\cdot j)$&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入文件包含多组测试数据。&lt;br&gt;第一行，一个整数$T$，表示测试数据的组数。&lt;br&gt;接下来的$T$行，每行两个整数$N,M$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;$T$行，每行一个整数，表示你所求的答案。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3438 小M的作物 &lt;最小割&gt;</title>
    <link href="http://azrael.top/BZOJ3438%20%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9%20%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <id>http://azrael.top/BZOJ3438 小M的作物 最小割/</id>
    <published>2018-04-25T16:00:00.000Z</published>
    <updated>2018-04-26T14:49:47.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="小M的作物"><a href="#小M的作物" class="headerlink" title="小M的作物"></a>小M的作物</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{小M}$在$\mathrm{MC}$里开辟了两块巨大的耕地$A$和$B$（你可以认为容量是无穷）。<br>现在，$\mathrm{小M}$有种$n$作物的种子，每种作物的种子有$1$个（就是可以种一棵作物）（用$1\sim n$编号），第$i$种作物种植在$A$中种植可以获得$a_i$的收益，在$B$中种植可以获得$b_i$的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益。<br>$\mathrm{小M}$找到了规则中共有$m$种作物组合，第$i$个组合中的作物共同种在$A$中可以获得$c_{i,1}$的额外收益，共同总在$B$中可以获得$c_{i,2}$的额外收益。<br>$\mathrm{小M}$很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包括一个整数$n$<br>第二行包括$n$个整数，表示$a_i$<br>第三行包括$n$个整数，表示$b_i$<br>第四行包括一个整数$m$<br>接下来$m$行，第$i$行依次输入：</p><ul><li>一个整数$k_i$，表示第$i$个作物组合中共有$k_i$种作物</li><li>两个整数$c_{i,1},c_{i,2}$，表示两种收益分别是多少</li><li>$k_i$个整数，表示该组合中的作物编号</li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一行，包括一个整数，表示最大收益<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1</span><br><span class="line">2 3 2 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>$A$耕地种$1,2$，$B$耕地种$3$，收益$4+2+3+2=11$</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le k&lt;n\le1000$, $0&lt;m\le1000$，保证所有数据及结果不超过$2\times10^9$</p><p>标签：<code>最小割</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>文理分科加强版，建模稍有变化。</p><p>首先容易想到将每个作物作为结点，对于作物$i$，连接$S\to i$容量$a_i$，连接$i\to T$容量$b_i$。割掉一条边表示不选对应的那片田，就可以以最小割的形式处理只考虑选$A$和选$B$收益，不考虑集团收益的问题。</p><p>对于每个组合，由于作物个数很多，不能像文理分科一样把失去的收益拆到$S\to i$和$i\to T$上。这里可以建立辅助结点，即给每个组合建立结点。由于存在两种贡献，需要拆成两个节点$p$和$q$，连接$S\to p$容量$c_1$，$q\to T$容量$c_2$。以$p$为例，$S\to p$需要被割去当且仅当此组合中任意作物选择$A$而非$B$，即此组合中存在作物$t$，$t\to T$并未被割掉。因此需要串联，即从$p$连边到此组合中的所有作物，容量$\infty$（从中间割断是没有意义的）。对应地，$q$的连法相同。</p><p>建模：</p><ul><li>对于每个作物$i\in[1,n]$，连接$S\to i$容量$a_i$，$i\to T$容量$b_i$</li><li>对于每个组合$i$，建立结点$p_i,q_i$，连接$S\to p_i$容量$c_1$，$q_i\to T$容量$c_2$</li><li>对于每个组合$i$，设其内作物为$x_1\sim x_k$，那么对每个作物$x_j$，连接$p_i\to x_j$容量$\infty$，$x_j\to q_i$容量$\infty$</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, sum, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = <span class="number">4000</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; cpy(); <span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec(); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) read(x), addedge(s, i, x), sum += x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) read(x), addedge(i, t, x), sum += x;</span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c1, c2, k; i &lt;= m; i++) &#123;</span><br><span class="line">read(k), read(c1), read(c2), sum += c1+c2;</span><br><span class="line">addedge(s, n+i*<span class="number">2</span><span class="number">-1</span>, c1), addedge(n+i*<span class="number">2</span>, t, c2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; k; j++)</span><br><span class="line">read(x), addedge(n+i*<span class="number">2</span><span class="number">-1</span>, x, INF), addedge(x, n+i*<span class="number">2</span>, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum-Dinic()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;小M的作物&quot;&gt;&lt;a href=&quot;#小M的作物&quot; class=&quot;headerlink&quot; title=&quot;小M的作物&quot;&gt;&lt;/a&gt;小M的作物&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{小M}$在$\mathrm{MC}$里开辟了两块巨大的耕地$A$和$B$（你可以认为容量是无穷）。&lt;br&gt;现在，$\mathrm{小M}$有种$n$作物的种子，每种作物的种子有$1$个（就是可以种一棵作物）（用$1\sim n$编号），第$i$种作物种植在$A$中种植可以获得$a_i$的收益，在$B$中种植可以获得$b_i$的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益。&lt;br&gt;$\mathrm{小M}$找到了规则中共有$m$种作物组合，第$i$个组合中的作物共同种在$A$中可以获得$c_{i,1}$的额外收益，共同总在$B$中可以获得$c_{i,2}$的额外收益。&lt;br&gt;$\mathrm{小M}$很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包括一个整数$n$&lt;br&gt;第二行包括$n$个整数，表示$a_i$&lt;br&gt;第三行包括$n$个整数，表示$b_i$&lt;br&gt;第四行包括一个整数$m$&lt;br&gt;接下来$m$行，第$i$行依次输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个整数$k_i$，表示第$i$个作物组合中共有$k_i$种作物&lt;/li&gt;
&lt;li&gt;两个整数$c_{i,1},c_{i,2}$，表示两种收益分别是多少&lt;/li&gt;
&lt;li&gt;$k_i$个整数，表示该组合中的作物编号&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;只有一行，包括一个整数，表示最大收益&lt;br&gt;
    
    </summary>
    
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最小割" scheme="http://azrael.top/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3626【LNOI2014】LCA &lt;离线+树链剖分&gt;</title>
    <link href="http://azrael.top/BZOJ3626%E3%80%90LNOI2014%E3%80%91LCA%20%E7%A6%BB%E7%BA%BF+%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>http://azrael.top/BZOJ3626【LNOI2014】LCA 离线+树链剖分/</id>
    <published>2018-04-25T16:00:00.000Z</published>
    <updated>2018-04-26T15:09:01.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【LNOI2014】LCA"><a href="#【LNOI2014】LCA" class="headerlink" title="【LNOI2014】LCA"></a>【LNOI2014】LCA</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给出一个$n$个节点的有根树（编号为$0$到$n-1$，根节点为$0$）。一个点的深度定义为$这个节点到根的距离+1$。设$dep_i$表示点$i$的深度，$lca_{i,j}$表示$i$与$j$的最近公共祖先。<br>有$q$次询问，每次询问给出$l,r,z$，求$\sum_{l&lt;=i&lt;=r}dep_{lca_{i,z}}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行$2$个整数$n,q$。<br>接下来$n-1$行，分别表示点$1$到点$n-1$的父节点编号。<br>接下来$q$行，每行$3$个整数$l,r,z$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$q$行，每行表示一个询问的答案。每个答案对$201314$取模输出<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 4 3</span><br><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>共$5$组数据，$n$与$q$的规模分别为$10000$,$20000$,$30000$,$40000$,$50000$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>数据已加强$\;\mathrm{By\;}$<code>saffah</code></p><p>标签：<code>树链剖分</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>傻逼树链剖分，练手居然还$\mathrm{WA}$了一发…</p><p>首先有一个这样的暴力：对于每个询问，将$z$到根的路径打标记，枚举$l\sim r$，每次累加当前节点最近的标记节点的深度。<br>然后发现可以反转一下：对于每个询问，枚举$l\sim r$，每次将当前结点到根路径上的所有结点权值$+1$，统计$z$到根路径上的总权值即可。（权值$+1$相当于深度累加）。<br>这道题没有强制在线，于是可以把所有的询问都离线下来，拆成两个前缀询问$[1,l-1]$和$[1,r]$分别计算。如果将所有前缀询问按右端点位置排序，不难发现可以依次操作，每次将一个新的结点到根路径上的所有结点权值$+1$，操作完统计右端点在此结点上的所有前缀询问的答案。<br>注意模完两个前缀答案相减后可能出现负数，需要先加上$\mathrm{MOD}$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 201314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> t, p, id; <span class="keyword">bool</span> f;&#125; opt[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, ind, ans[MAX_N+<span class="number">5</span>], tr[MAX_N&lt;&lt;<span class="number">2</span>], tag[MAX_N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dep[MAX_N+<span class="number">5</span>], fa[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>], son[MAX_N+<span class="number">5</span>], top[MAX_N+<span class="number">5</span>], dfn[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;x, <span class="keyword">const</span> node &amp;y)</span> </span>&#123;<span class="keyword">return</span> x.t &lt;= y.t;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[u].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i]; <span class="keyword">if</span> (v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v] = dep[u]+<span class="number">1</span>, fa[v] = u, DFS(v), sz[u] += sz[v];</span><br><span class="line"><span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">top[u] = tp, dfn[u] = ++ind; <span class="keyword">if</span> (son[u]) DFS(son[u], tp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i])^fa[u]) &amp;&amp; (v^son[u])) DFS(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;tr[v] = tr[v&lt;&lt;<span class="number">1</span>]+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tag[v]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> x = tag[v]; tag[v] = <span class="number">0</span>;</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>] += x*(mid-s+<span class="number">1</span>)%MOD) %= MOD;</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += x*(t-mid)%MOD) %= MOD;</span><br><span class="line">(tag[v&lt;&lt;<span class="number">1</span>] += x) %= MOD, (tag[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += x) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">(tr[v] += x*(t-s+<span class="number">1</span>)%MOD) %= MOD;</span><br><span class="line">(tag[v] += x) %= MOD; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) modify(v&lt;&lt;<span class="number">1</span>, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) modify(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> (tr[v]+MOD)%MOD;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>; downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) (ret += query(v&lt;&lt;<span class="number">1</span>, s, mid, l, r)) %= MOD;</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) (ret += query(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r)) %= MOD;</span><br><span class="line"><span class="keyword">return</span> (ret%MOD+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; u; u = fa[top[u]])</span><br><span class="line">modify(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[u]], dfn[u], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; u; u = fa[top[u]])</span><br><span class="line">(ret += query(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[u]], dfn[u])) %= MOD;</span><br><span class="line"><span class="keyword">return</span> (ret += MOD) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), G[x+<span class="number">1</span>].push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r, p; i &lt;= m; i++)</span><br><span class="line">read(l), read(r), read(p), </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].p = opt[i*<span class="number">2</span>].p = p+<span class="number">1</span>, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].id = opt[i*<span class="number">2</span>].id = i, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].t = l, opt[i*<span class="number">2</span>].t = r+<span class="number">1</span>, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].f = <span class="literal">false</span>, opt[i*<span class="number">2</span>].f = <span class="literal">true</span>;</span><br><span class="line">sort(opt+<span class="number">1</span>, opt+m*<span class="number">2</span>+<span class="number">1</span>, cmp), DFS(<span class="number">1</span>), DFS(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m*<span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; opt[i].t) change(++j);</span><br><span class="line"><span class="keyword">if</span> (opt[i].f) (ans[opt[i].id] += getsum(opt[i].p)) %= MOD;</span><br><span class="line"><span class="keyword">else</span> (ans[opt[i].id] += MOD-getsum(opt[i].p)) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans[i]%MOD+MOD)%MOD);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【LNOI2014】LCA&quot;&gt;&lt;a href=&quot;#【LNOI2014】LCA&quot; class=&quot;headerlink&quot; title=&quot;【LNOI2014】LCA&quot;&gt;&lt;/a&gt;【LNOI2014】LCA&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给出一个$n$个节点的有根树（编号为$0$到$n-1$，根节点为$0$）。一个点的深度定义为$这个节点到根的距离+1$。设$dep_i$表示点$i$的深度，$lca_{i,j}$表示$i$与$j$的最近公共祖先。&lt;br&gt;有$q$次询问，每次询问给出$l,r,z$，求$\sum_{l&amp;lt;=i&amp;lt;=r}dep_{lca_{i,z}}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行$2$个整数$n,q$。&lt;br&gt;接下来$n-1$行，分别表示点$1$到点$n-1$的父节点编号。&lt;br&gt;接下来$q$行，每行$3$个整数$l,r,z$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$q$行，每行表示一个询问的答案。每个答案对$201314$取模输出&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树链剖分" scheme="http://azrael.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1061【NOI2008】志愿者招募 &lt;线性规划转费用流&gt;</title>
    <link href="http://azrael.top/BZOJ1061%E3%80%90NOI2008%E3%80%91%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%BD%AC%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ1061【NOI2008】志愿者招募 线性规划转费用流/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-26T12:40:25.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【NOI2008】志愿者招募"><a href="#【NOI2008】志愿者招募" class="headerlink" title="【NOI2008】志愿者招募"></a>【NOI2008】志愿者招募</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。<br>经过估算，这个项目需要$N$天才能完成，其中第$i$天至少需要$A_i$个人。布布通过了解得知，一共有$M$类志愿者可以招募。其中第$i$类可以从第$S_i$天工作到第$T_i$天，招募费用是每人$C_i$元。<br>新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数$N,M$，表示完成项目的天数和可以招募的志愿者的种类。<br>接下来的一行中包含$N$个非负整数，表示每天至少需要的志愿者人数。<br>接下来的$M$行中每行包含三个整数$S_i,T_i,C_i$，含义如上文所述。<br>为了方便起见，我们可以认为每类志愿者的数量都是无限多的。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个整数，表示你所设计的最优方案的总费用。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 3 4</span><br><span class="line">1 2 2</span><br><span class="line">2 3 5</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N\le1000$，$1\le M\le10000$，题目中其他所涉及的数据均不超过$2^{31}-1$。</p><p>标签：<code>线性规划</code> <code>费用流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>经典线性规划转网络流。</p><p>由题意可知，共会有$N$个限制条件，还有一个需要最小化的表达式。以样例作例子，第$i$种招募$x_i$人，则有<br>$$<br>\begin{aligned}<br>x_1&amp;\ge2\\<br>x_2+x_3&amp;\ge3\\<br>x_2+x_3&amp;\ge4\\<br>we\;need\;to\;minimize\;&amp;2x_1+5x_2+2x_3\\<br>\end{aligned}<br>$$<br>接着设三个辅助变量$y_1,y_2,y_3\;(y_1,y_2,y_3\ge0)$，使得<br>$$<br>\begin{aligned}<br>x_1-y_1&amp;=2\\<br>x_2+x_3-y_2&amp;=3\\<br>x_2+x_3-y_3&amp;=4\\<br>\end{aligned}<br>$$<br>在最前面和最后面加入两个$0=0$，差分一下，得到<br>$$<br>\begin{aligned}<br>x_1-y_1-2&amp;=0\\<br>x_2+x_3-y_2-x_1+y_1-1&amp;=0\\<br>y_2-y_3-1&amp;=0\\<br>-x_2-x_3+y_3+4&amp;=0\\<br>\end{aligned}<br>$$<br>发现每个变量只出现两次，并且正、负各一次。这个性质其实一定成立。因为每种志愿者只在一个区间内出现，即每个变量只会在连续的式子中出现，这样差分后就会只剩一次正和一次负。辅助变量也有这个性质是显然的。<br>如果将每个式子看成一个结点，等式可以看作这个点的流量平衡方程。将正看成出流，负看成入流，即可构图。例如，对于$x_2$，其在第二个式子中出现正，在第四个式子中出现负，可以想成是从二号结点流出的$x_2$流量进入四号结点。对于辅助变量也是一样。而对于每个式子中的常数项，可以看成从源点流出或流入汇点，即若移到左边后为负，则为从源点流出这么多流量；若为正，则为向汇点流这么多流量。<br>这样一来，根据费用流一定跑出最大流（废话），跑出的流一定满足流量平衡方程（废话$\times$2），最后跑出的方案一定能满足所有限制。如果加上边权（即所要取最小值的式子的系数），可以跑最小费用最大流解出最小值。</p><p>建模：</p><ul><li>对于$\forall i\in[1,n+1]$，<ul><li>若$A_i\ge A_{i-1}$，连接$S\to i$，容量$A_i-A_{i-1}$，单位费用$0$</li><li>若$A_i&lt;A_{i-1}$，连接$i\to T$，容量$A_{i-1}-A_i$，单位费用$0$</li></ul></li><li>对于一种志愿者$l,r,w$，连接$l\to r+1$，容量$\infty$，单位费用$w$</li><li>辅助变量：对于$\forall i\in[2,n+1]$，连接$i\to i-1$，容量$\infty$，单位费用$0$</li></ul><p>跑最小费用最大流即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>], mxf, mic;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, w, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="keyword">int</span> a[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n+<span class="number">2</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;insert(u, v, c, w), insert(v, u, <span class="number">0</span>, -w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; <span class="keyword">bool</span> inq[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> d[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq), <span class="built_in">memset</span>(d, INF, <span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>, que.push(s), inq[s] = <span class="literal">true</span>, <span class="built_in">memset</span>(cr, <span class="number">-1</span>, <span class="keyword">sizeof</span> cr);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop(), inq[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c, w = E[i].w;</span><br><span class="line"><span class="keyword">if</span> (c &amp;&amp; d[u]+w &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u]+w, cr[v] = i;</span><br><span class="line"><span class="keyword">if</span> (!inq[v]) que.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == INF) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">int</span> flow = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) flow = min(flow, E[i].c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) E[i].c -= flow, E[i^<span class="number">1</span>].c += flow;</span><br><span class="line">mxf += flow, mic += d[t]*flow;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= a[i<span class="number">-1</span>]) addedge(s, i, a[i]-a[i<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> addedge(i, t, a[i<span class="number">-1</span>]-a[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; i++)</span><br><span class="line">read(u), read(v), read(w), addedge(u, v+<span class="number">1</span>, INF, w);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n+<span class="number">1</span>; i++) addedge(i, i<span class="number">-1</span>, INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (SPFA()) ;<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mic), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【NOI2008】志愿者招募&quot;&gt;&lt;a href=&quot;#【NOI2008】志愿者招募&quot; class=&quot;headerlink&quot; title=&quot;【NOI2008】志愿者招募&quot;&gt;&lt;/a&gt;【NOI2008】志愿者招募&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。&lt;br&gt;经过估算，这个项目需要$N$天才能完成，其中第$i$天至少需要$A_i$个人。布布通过了解得知，一共有$M$类志愿者可以招募。其中第$i$类可以从第$S_i$天工作到第$T_i$天，招募费用是每人$C_i$元。&lt;br&gt;新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个整数$N,M$，表示完成项目的天数和可以招募的志愿者的种类。&lt;br&gt;接下来的一行中包含$N$个非负整数，表示每天至少需要的志愿者人数。&lt;br&gt;接下来的$M$行中每行包含三个整数$S_i,T_i,C_i$，含义如上文所述。&lt;br&gt;为了方便起见，我们可以认为每类志愿者的数量都是无限多的。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅包含一个整数，表示你所设计的最优方案的总费用。&lt;br&gt;
    
    </summary>
    
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="线性规划" scheme="http://azrael.top/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
      <category term="费用流" scheme="http://azrael.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="NOI" scheme="http://azrael.top/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2440【中山市选2011】完全平方数 &lt;二分+莫比乌斯容斥&gt;</title>
    <link href="http://azrael.top/BZOJ2440%E3%80%90%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892011%E3%80%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20%E4%BA%8C%E5%88%86+%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%AE%B9%E6%96%A5/"/>
    <id>http://azrael.top/BZOJ2440【中山市选2011】完全平方数 二分+莫比乌斯容斥/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-25T04:52:39.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【中山市选2011】完全平方数"><a href="#【中山市选2011】完全平方数" class="headerlink" title="【中山市选2011】完全平方数"></a>【中山市选2011】完全平方数</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小$\mathrm{X}$自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。<br>这天是小$\mathrm{X}$的生日，小$\mathrm{W}$想送一个数给他作为生日礼物。当然他不能送一个小$\mathrm{X}$讨厌的数。他列出了所有小$\mathrm{X}$不讨厌的数，然后选取了第$K$个数送给了小$\mathrm{X}$。小$\mathrm{X}$很开心地收下了。<br>然而现在小$\mathrm{W}$却记不起送给小$\mathrm{X}$的是哪个数了。你能帮他一下吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>包含多组测试数据。文件第一行有一个整数$T$，表示测试数据的组数。<br>第$2$至第$T+1$行每行有一个整数$K_i$，描述一组数据，含义如题目中所描述。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>含$T$行，分别对每组数据作出回答。第$i$行输出相应的第$K_i$个不是完全平方数的正整数倍的数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">13</span><br><span class="line">100</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">19</span><br><span class="line">163</span><br><span class="line">2030745</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据有$1\le K_i\le10^9,\;T\le50$</p><p>标签：<code>二分答案</code> <code>莫比乌斯容斥</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{QAQ}$没做起水题…</p><p>似乎答案不超过$2\times K$？不会证。</p><p>二分答案，对于当前尝试的答案$n$，统计$n$以下有多少个符合条件的数。<br>$符合条件的数的个数=n-完全平方数的倍数的个数$<br>容易发现为了避免算重复，可以约数容斥来算。另外，如果完全平方数的底数有平方因子，一定不会产生贡献。<br>设所有质数的集合为$S_1$，所有由两个不同质数相乘而得数的集合为$S_2$，…，由$q$个不同质数相乘而得的数的集合为$S_q$，那么符合条件的数的个数为：<br>$$<br>cnt=\sum_{i_2\in S_1}\lfloor\frac{n}{i^2}\rfloor-\sum_{i_2\in S_2}\lfloor\frac{n}{i_2^2}\rfloor+\sum_{i_3\in S_3}\lfloor\frac{n}{i_3^2}\rfloor-\cdots\\<br>$$<br>发现上面的式子可以用莫比乌斯函数简化，即<br>$$<br>cnt=\sum_{i=1}^{\sqrt{n}}\mu(i)\cdot\lfloor\frac{n}{i^2}\rfloor<br>$$<br>这样每次用$O(\sqrt{n})$时间$check$，总复杂度为$O(\sqrt{K}\log{K})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l+((r-l)&gt;&gt;1))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n); i; i--)</span><br><span class="line">rk += mu[i]*(n/i/i);</span><br><span class="line"><span class="keyword">return</span> rk &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">2</span>*k, ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid, k)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans = mid, r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, k;read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) read(k), sol(k);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【中山市选2011】完全平方数&quot;&gt;&lt;a href=&quot;#【中山市选2011】完全平方数&quot; class=&quot;headerlink&quot; title=&quot;【中山市选2011】完全平方数&quot;&gt;&lt;/a&gt;【中山市选2011】完全平方数&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;小$\mathrm{X}$自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。&lt;br&gt;这天是小$\mathrm{X}$的生日，小$\mathrm{W}$想送一个数给他作为生日礼物。当然他不能送一个小$\mathrm{X}$讨厌的数。他列出了所有小$\mathrm{X}$不讨厌的数，然后选取了第$K$个数送给了小$\mathrm{X}$。小$\mathrm{X}$很开心地收下了。&lt;br&gt;然而现在小$\mathrm{W}$却记不起送给小$\mathrm{X}$的是哪个数了。你能帮他一下吗？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;包含多组测试数据。文件第一行有一个整数$T$，表示测试数据的组数。&lt;br&gt;第$2$至第$T+1$行每行有一个整数$K_i$，描述一组数据，含义如题目中所描述。 &lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;含$T$行，分别对每组数据作出回答。第$i$行输出相应的第$K_i$个不是完全平方数的正整数倍的数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="容斥" scheme="http://azrael.top/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4293【PA2015】Siano &lt;线段树&gt;</title>
    <link href="http://azrael.top/BZOJ4293%E3%80%90PA2015%E3%80%91Siano%20%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ4293【PA2015】Siano 线段树/</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2018-04-24T09:10:30.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【PA2015】Siano"><a href="#【PA2015】Siano" class="headerlink" title="【PA2015】Siano"></a>【PA2015】Siano</h3><p>$\mathrm{Time\;Limit:\;30\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>农夫$\mathrm{Byteasar}$买了一片$n$亩的土地，他要在这上面种草。<br>他在每一亩土地上都种植了一种独一无二的草，其中，第$i$亩土地的草每天会长高$a_i$厘米。<br>$\mathrm{Byteasar}$一共会进行$m$次收割，其中第$i$次收割在第$d_i$天，并把所有高度大于等于$b_i$的部分全部割去。<br>$\mathrm{Byteasar}$想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个正整数$n,m$，分别表示亩数和收割次数。<br>第二行包含$n$个正整数，其中第$i$个数为$a_i$，依次表示每亩种植的草的生长能力。<br>接下来$m$行，每行包含两个正整数$d_i,b_i$，依次描述每次收割。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$m$行，每行一个整数，依次回答每次收割能得到的草的高度总和。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 4 3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 0</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br><span class="line">18</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>第$1$天，草的高度分别为$1,2,4,3$，收割后变为$1,1,1,1$。<br>第$2$天，草的高度分别为$2,3,5,4$，收割后变为$2,2,2,2$。<br>第$3$天，草的高度分别为$3,4,6,5$，收割后变为$0,0,0,0$。<br>第$4$天，草的高度分别为$1,2,4,3$，收割后变为$1,2,4,3$。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le n,m\le5\times10^5$, $1\le a_i\le10^6$, $1\le d_i,b_i\le10^{12}$<br>数据保证$d_1&lt;d_2&lt;\cdots&lt;d_m$，并且任何时刻没有任何一亩草的高度超过$10^12$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>By <code>Claris</code></p><p>标签：<code>线段树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>比较灵活的线段树。</p><p>观察题目可以发现一个性质，即长速快的在任意时刻都比长速慢的高度高。这是由于每次修剪都是将所有的剪到同一高度，这样长速快的在修剪后的高度一定大于等于长速慢的在修剪后的高度。</p><p>将长速从低到高排序，不会影响询问，并且每次询问剪去的部分一定是一个后缀。那么可以在线段树上分治寻找剪和不剪的分界点，同时累加答案。</p><p>对于每个区间需要维护其长速之和、高度和两个基础元素。为了方便询问，需要维护高度的最大和最小值，即该区间最右边和最左边的苗的高度。这样如果当前区间的最大高度$mx\le b$，可知不用继续递归；如果当前区间最小高度$mi\ge b$，可知整个区间都要修剪，打区间标记后返回。而对于标记，每个区间需要维护三个元素$tc,td,ld$，分别表示该区间中的所有高度均变为$tc$，这个变化发生在$td$时刻，上一次递归到该区间的时间是$ld$。询问每次递归进入一个区间先计算从上次递归到该区间也就是$ld$到现在总共长了多少，更新信息。注意$td$和$ld$不能合并为一个变量，这是由于该区间上次被递归到时可能先更新了信息，但是并未打标记，即其下面的子区间没有更新信息，故$td$和$ld$不同。</p><p>一棵线段树即可维护，某些细节注意一下即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;lnt a[MAX_N+<span class="number">5</span>], b, d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>lnt v, s, tc, td, ld, lv, rv;&#125; tr[MAX_N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">tr[v].v = tr[v&lt;&lt;<span class="number">1</span>].v+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v;</span><br><span class="line">tr[v].s = tr[v&lt;&lt;<span class="number">1</span>].s+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s;</span><br><span class="line">tr[v].lv = tr[v&lt;&lt;<span class="number">1</span>].lv, tr[v].rv = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].tc == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].s = tr[v].tc*(mid-s+<span class="number">1</span>);</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s = tr[v].tc*(t-mid);</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].lv = tr[v&lt;&lt;<span class="number">1</span>].rv = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lv = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rv = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].tc = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tc = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].td = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].td = tr[v].td;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].ld = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ld = tr[v].td;</span><br><span class="line">tr[v].tc = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">tr[v].tc = <span class="number">-1</span>;<span class="keyword">if</span> (s == t) &#123;tr[v].v = a[s]; <span class="keyword">return</span>;&#125;</span><br><span class="line">build(v&lt;&lt;<span class="number">1</span>, s, mid), build(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t), update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0L</span>L;tr[v].s += (d-tr[v].ld)*tr[v].v;</span><br><span class="line">tr[v].lv += a[s]*(d-tr[v].ld), tr[v].rv += a[t]*(d-tr[v].ld);</span><br><span class="line"><span class="keyword">if</span> (tr[v].lv &gt;= b) &#123;</span><br><span class="line">ret = tr[v].s-b*(t-s+<span class="number">1</span>), tr[v].s = b*(t-s+<span class="number">1</span>);</span><br><span class="line">tr[v].lv = tr[v].rv = tr[v].tc = b, tr[v].td = d;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tr[v].rv &gt; b) &#123;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line">ret += query(v&lt;&lt;<span class="number">1</span>, s, mid);</span><br><span class="line">ret += query(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tr[v].ld = d, ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line">sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span> (m--) read(d), read(b), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【PA2015】Siano&quot;&gt;&lt;a href=&quot;#【PA2015】Siano&quot; class=&quot;headerlink&quot; title=&quot;【PA2015】Siano&quot;&gt;&lt;/a&gt;【PA2015】Siano&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;30\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;农夫$\mathrm{Byteasar}$买了一片$n$亩的土地，他要在这上面种草。&lt;br&gt;他在每一亩土地上都种植了一种独一无二的草，其中，第$i$亩土地的草每天会长高$a_i$厘米。&lt;br&gt;$\mathrm{Byteasar}$一共会进行$m$次收割，其中第$i$次收割在第$d_i$天，并把所有高度大于等于$b_i$的部分全部割去。&lt;br&gt;$\mathrm{Byteasar}$想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个正整数$n,m$，分别表示亩数和收割次数。&lt;br&gt;第二行包含$n$个正整数，其中第$i$个数为$a_i$，依次表示每亩种植的草的生长能力。&lt;br&gt;接下来$m$行，每行包含两个正整数$d_i,b_i$，依次描述每次收割。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$m$行，每行一个整数，依次回答每次收割能得到的草的高度总和。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PA" scheme="http://azrael.top/tags/PA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4299 FRBSUM &lt;主席树&gt;</title>
    <link href="http://azrael.top/BZOJ4299%20FRBSUM%20%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ4299 FRBSUM 主席树/</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2018-04-24T09:17:30.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="FRBSUM"><a href="#FRBSUM" class="headerlink" title="FRBSUM"></a>FRBSUM</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>数集$S$的$\mathrm{Forbidden\;Sum}$定义为无法用$S$的某个子集（可以为空）的和表示的最小的非负整数。<br>例如，$S={1,1,3,7}$，则它的子集和中包含$0(S’=\emptyset)$，$1(S’={1})$，$2(S’={1,1})$，$3(S’={3})$，$4(S’={1,3})$，$5(S’={1,1,3})$，但是它无法得到$6$。因此$S$的$\mathrm{Forbidden\;Sum}$为$6$。<br>给定一个序列$A$，你的任务是回答该数列的一些子区间所形成的数集的$\mathrm{Forbidden\;Sum}$是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行包含一个整数$N$，表示序列的长度。<br>接下来一行包含$N$个数，表示给定的序列$A$（从$1$标号）。<br>接下来一行包含一个整数$M$，表示询问的组数。<br>接下来$M$行，每行一对整数，表示一组询问。</p><h3 id="Ouput"><a href="#Ouput" class="headerlink" title="Ouput"></a>Ouput</h3><p>对于每组询问，输出一行表示对应的答案。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 4 9 10</span><br><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于$100\%$的数据，$1\le N,M\le10^5$, $1\le A_i\le10^9$, $1\le A_1+A_2+\cdots+A_N\le10^9$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>By <code>yts1999</code></p><p>标签：<code>主席树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>本题和<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4408" target="_blank" rel="noopener">【FJOI2016】神秘数</a>相同，双倍经验。</p><p>首先不难发现一个结论，若某集合当前能凑出$0\sim mx$中的所有数，加入一个数$x$，可凑出的数的值域扩展当且仅当$x\le mx+1$，并且会将值域扩展到$0\sim mx+x$。<br>如此，对于每个区间$[l,r]$，从小到大逐一将每个数加入到集合中，像上面那样不断扩展值域，如果加入某个数时$x&gt;mx+1$，值域无法继续扩充，那么$mx+1$即为最小的不能凑成的数。<br>这个过程可以用一棵值域主席树维护，每次将所有小于等于$mx+1$的数求和，作为新的$mx$，若$mx$在某次这样的操作中不变，则无法继续扩展，输出答案$mx+1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, rt[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> ls, rs, s;&#125; tr[MAX_N*<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> o, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">tr[v] = tr[o], tr[v].s += p;<span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, p);</span><br><span class="line"><span class="keyword">else</span> modify(tr[v].rs = ++cnt, tr[o].rs, mid+<span class="number">1</span>, t, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) <span class="keyword">return</span> tr[r].s-tr[l].s;</span><br><span class="line"><span class="keyword">int</span> lsum = tr[tr[r].ls].s-tr[tr[l].ls].s;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= mid) <span class="keyword">return</span> query(tr[l].ls, tr[r].ls, s, mid, p);</span><br><span class="line"><span class="keyword">return</span> lsum+query(tr[l].rs, tr[r].rs, mid+<span class="number">1</span>, t, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), modify(rt[i] = ++cnt, rt[i<span class="number">-1</span>], <span class="number">1</span>, INF, x);</span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> l, r;read(l), read(r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mx = <span class="number">0</span>, lst = <span class="number">0</span>; ; lst = mx) &#123;</span><br><span class="line">mx = query(rt[l<span class="number">-1</span>], rt[r], <span class="number">1</span>, INF, mx+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (mx == lst) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mx+<span class="number">1</span>); <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;FRBSUM&quot;&gt;&lt;a href=&quot;#FRBSUM&quot; class=&quot;headerlink&quot; title=&quot;FRBSUM&quot;&gt;&lt;/a&gt;FRBSUM&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;数集$S$的$\mathrm{Forbidden\;Sum}$定义为无法用$S$的某个子集（可以为空）的和表示的最小的非负整数。&lt;br&gt;例如，$S={1,1,3,7}$，则它的子集和中包含$0(S’=\emptyset)$，$1(S’={1})$，$2(S’={1,1})$，$3(S’={3})$，$4(S’={1,3})$，$5(S’={1,1,3})$，但是它无法得到$6$。因此$S$的$\mathrm{Forbidden\;Sum}$为$6$。&lt;br&gt;给定一个序列$A$，你的任务是回答该数列的一些子区间所形成的数集的$\mathrm{Forbidden\;Sum}$是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入数据的第一行包含一个整数$N$，表示序列的长度。&lt;br&gt;接下来一行包含$N$个数，表示给定的序列$A$（从$1$标号）。&lt;br&gt;接下来一行包含一个整数$M$，表示询问的组数。&lt;br&gt;接下来$M$行，每行一对整数，表示一组询问。&lt;/p&gt;
&lt;h3 id=&quot;Ouput&quot;&gt;&lt;a href=&quot;#Ouput&quot; class=&quot;headerlink&quot; title=&quot;Ouput&quot;&gt;&lt;/a&gt;Ouput&lt;/h3&gt;&lt;p&gt;对于每组询问，输出一行表示对应的答案。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="http://azrael.top/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="CodeChef" scheme="http://azrael.top/tags/CodeChef/"/>
    
  </entry>
  
</feed>
