<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NIRVANA</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://azrael.top/"/>
  <updated>2018-04-02T13:17:52.375Z</updated>
  <id>http://azrael.top/</id>
  
  <author>
    <name>Azrael_Death</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ4568【SCOI2016】幸运数字 &lt;LCA+线性基&gt;</title>
    <link href="http://azrael.top/BZOJ4568%E3%80%90SCOI2016%E3%80%91%E5%B9%B8%E8%BF%90%E6%95%B0%E5%AD%97%20LCA+%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>http://azrael.top/BZOJ4568【SCOI2016】幸运数字 LCA+线性基/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-04-02T13:17:52.375Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2016】幸运数字"><a href="#【SCOI2016】幸运数字" class="headerlink" title="【SCOI2016】幸运数字"></a>【SCOI2016】幸运数字</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$A$国共有$n$座城市，这些城市由$n-1$条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览$A$国。旅行者计划乘飞机降落在$x$号城市，沿着$x$号城市到$y$号城市之间那条唯一的路径游览，最终从$y$城市起飞离开$A$国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，游览者拍了$3$张照片，幸运值分别是$5,7,11$，那么最终保留在自己身上的幸运值就是 $\mathrm{9\;(5\otimes7\otimes11)}$。有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择$5$和$11$，可以保留的幸运值为$14$ 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含$2$个正整数$n,q$，分别表示城市的数量和旅行者数量。第二行包含$n$个非负整数，其中第$i$个整数$G_i$表示$i$号城市的幸运值。随后$n-1$行，每行包含两个正整数$x,y$，表示$x$号城市和$y$号城市之间有一条道路相连。随后$q$行，每行包含两个正整数$x,y$，表示这名旅行者的旅行计划是从$x$号城市到$y$号城市。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出需要包含$q$行，每行包含$1$个非负整数，表示这名旅行者可以保留的最大幸运值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="number">11</span> <span class="number">5</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span></span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$N\le2\times10^4,\;Q\le2\times10^5,\;G_i\le2^{60}$</p><p>标签：<code>线性基</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>最大子集异或和上树…</p><p>树上两点间路径，容易联想到倍增$\mathrm{LCA}$；最大子集异或和，容易联想到线性基。<br>因此把两者结合起来，预处理出每个结点到其$2^i$祖先结点路径上的线性基，对于倍增的合并，可以暴力合并线性基，即将一个线性基中的数暴力插到另一个线性基中。<br>求$\mathrm{LCA}$的过程照常，只是将单个值合并换成了两个数组合并。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vl vector<span class="meta-string">&lt;lnt&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">lnt a[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, q, fa[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>], dep[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;lnt&gt; b[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>]; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;G[u].push_back(v), G[v].push_back(u);&#125;</span><br><span class="line"><span class="function">lnt <span class="title">get_mx</span><span class="params">(vl base)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--) <span class="keyword">if</span> (base[i])</span><br><span class="line"><span class="keyword">if</span> ((ret^base[i]) &gt; ret) ret ^= base[i];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vl <span class="title">merge</span><span class="params">(vl x, vl y)</span> </span>&#123;</span><br><span class="line">vl ret = x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--) <span class="keyword">if</span> (y[i])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; ~j; j--) <span class="keyword">if</span> (y[i]&gt;&gt;j&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (ret[j]) y[i] ^= ret[j];</span><br><span class="line"><span class="keyword">else</span> &#123;ret[j] = y[i]; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">b[u][<span class="number">0</span>].resize(SZ+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (a[u]&gt;&gt;i&amp;<span class="number">1</span>) &#123;b[u][<span class="number">0</span>][i] = a[u]; <span class="keyword">break</span>;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOG; i++)</span><br><span class="line">fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>], b[u][i].resize(SZ+<span class="number">1</span>), </span><br><span class="line">b[u][i] = merge(b[u][i<span class="number">-1</span>], b[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> ((v = G[u][i]) ^ fa[u][<span class="number">0</span>])</span><br><span class="line">fa[v][<span class="number">0</span>] = u, dep[v] = dep[u]+<span class="number">1</span>, DFS(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">vl ub, vb;ub.resize(SZ+<span class="number">1</span>), vb.resize(SZ+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (dep[u] &lt; dep[v]) swap(u, v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--) <span class="keyword">if</span> (dep[u]-dep[v] &gt;= (<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">ub = merge(ub, b[u][i]), u = fa[u][i];</span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span> get_mx(merge(ub, b[u][<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--) <span class="keyword">if</span> (fa[u][i]^fa[v][i])</span><br><span class="line">ub = merge(ub, b[u][i]), u = fa[u][i],</span><br><span class="line">vb = merge(vb, b[v][i]), v = fa[v][i];</span><br><span class="line">ub = merge(ub, b[u][<span class="number">0</span>]), vb = merge(vb, b[v][<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> get_mx(merge(merge(ub, vb), b[fa[u][<span class="number">0</span>]][<span class="number">0</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(q);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++)</span><br><span class="line">read(u), read(v), addedge(u, v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= LOG; i++) b[<span class="number">0</span>][i].resize(SZ+<span class="number">1</span>);</span><br><span class="line">DFS(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (q--) &#123;</span><br><span class="line"><span class="keyword">int</span> u, v;read(u), read(v);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(u, v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2016】幸运数字&quot;&gt;&lt;a href=&quot;#【SCOI2016】幸运数字&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2016】幸运数字&quot;&gt;&lt;/a&gt;【SCOI2016】幸运数字&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$A$国共有$n$座城市，这些城市由$n-1$条道路相连，使得任意两座城市可以互达，且路径唯一。每座城市都有一个幸运数字，以纪念碑的形式矗立在这座城市的正中心，作为城市的象征。一些旅行者希望游览$A$国。旅行者计划乘飞机降落在$x$号城市，沿着$x$号城市到$y$号城市之间那条唯一的路径游览，最终从$y$城市起飞离开$A$国。在经过每一座城市时，游览者就会有机会与这座城市的幸运数字拍照，从而将这份幸运保存到自己身上。然而，幸运是不能简单叠加的，这一点游览者也十分清楚。他们迷信着幸运数字是以异或的方式保留在自己身上的。例如，游览者拍了$3$张照片，幸运值分别是$5,7,11$，那么最终保留在自己身上的幸运值就是 $\mathrm{9\;(5\otimes7\otimes11)}$。有些聪明的游览者发现，只要选择性地进行拍照，便能获得更大的幸运值。例如在上述三个幸运值中，只选择$5$和$11$，可以保留的幸运值为$14$ 。现在，一些游览者找到了聪明的你，希望你帮他们计算出在他们的行程安排中可以保留的最大幸运值是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含$2$个正整数$n,q$，分别表示城市的数量和旅行者数量。第二行包含$n$个非负整数，其中第$i$个整数$G_i$表示$i$号城市的幸运值。随后$n-1$行，每行包含两个正整数$x,y$，表示$x$号城市和$y$号城市之间有一条道路相连。随后$q$行，每行包含两个正整数$x,y$，表示这名旅行者的旅行计划是从$x$号城市到$y$号城市。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出需要包含$q$行，每行包含$1$个非负整数，表示这名旅行者可以保留的最大幸运值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="LCA" scheme="http://azrael.top/tags/LCA/"/>
    
      <category term="线性基" scheme="http://azrael.top/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2115【WC2011】Xor &lt;线性基&gt;</title>
    <link href="http://azrael.top/BZOJ2115%E3%80%90WC2011%E3%80%91Xor%20%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    <id>http://azrael.top/BZOJ2115【WC2011】Xor 线性基/</id>
    <published>2018-04-01T16:00:00.000Z</published>
    <updated>2018-04-02T13:03:14.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【WC2011】Xor"><a href="#【WC2011】Xor" class="headerlink" title="【WC2011】Xor"></a>【WC2011】Xor</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;259MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/2606_1.jpg" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数$N$和$M$，表示该无向图中点的数目与边的数目。<br>接下来$M$行描述$M$条边，每行三个整数$S_i,T_i,D_i$，表示$S_i$与$T_i$之间存在 一条权值为$D_i$的无向边。<br>图中可能有重边或自环。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个整数，表示最大的$\mathrm{Xor}$和（十进制结果），注意输出后加换行回车。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/2606_3.jpg" alt=""><br></center><p>标签：<code>线性基</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>线性基经典题。</p><p>对于一条非简单的路径，其异或和等于其中的简单路径异或和异或上经过的环的异或和，即选取一条简单路径和若干环，此简单路径到环的那段路径会经过两次，因而异或和消成$0$。<br>因此只用选出一条从$1$到$n$的简单路径异或和，再异或上若干环的异或和使总和最大即可。<br>于是暴力$\mathrm{DFS}$找到简单路径异或和和所有环的异或和，对所有环的异或和求线性基，贪心选最大和即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SZ 60</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">lnt b[SZ+<span class="number">5</span>], dis[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="built_in">vector</span> &lt;lnt&gt; E[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(lnt x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--) <span class="keyword">if</span> (x&gt;&gt;i&amp;<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i]) x ^= b[i];</span><br><span class="line"><span class="keyword">else</span> &#123;b[i] = x; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (mrk[v = G[u][i]]) insert(dis[u]^dis[v]^E[u][i]);</span><br><span class="line"><span class="keyword">else</span> dis[v] = dis[u]^E[u][i], mrk[v] = <span class="literal">true</span>, DFS(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, u, v; i &lt; m; i++) &#123;</span><br><span class="line">lnt c;read(u), read(v), read(c);</span><br><span class="line">G[u].push_back(v), E[u].push_back(c);</span><br><span class="line">G[v].push_back(u), E[v].push_back(c);</span><br><span class="line">&#125;</span><br><span class="line">DFS(<span class="number">1</span>);lnt mx = dis[n];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = SZ; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (!(mx&gt;&gt;i&amp;<span class="number">1</span>)) mx ^= b[i];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mx), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【WC2011】Xor&quot;&gt;&lt;a href=&quot;#【WC2011】Xor&quot; class=&quot;headerlink&quot; title=&quot;【WC2011】Xor&quot;&gt;&lt;/a&gt;【WC2011】Xor&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;259MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/2606_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个整数$N$和$M$，表示该无向图中点的数目与边的数目。&lt;br&gt;接下来$M$行描述$M$条边，每行三个整数$S_i,T_i,D_i$，表示$S_i$与$T_i$之间存在 一条权值为$D_i$的无向边。&lt;br&gt;图中可能有重边或自环。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅包含一个整数，表示最大的$\mathrm{Xor}$和（十进制结果），注意输出后加换行回车。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="线性基" scheme="http://azrael.top/tags/%E7%BA%BF%E6%80%A7%E5%9F%BA/"/>
    
      <category term="WC" scheme="http://azrael.top/tags/WC/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2177 曼哈顿最小生成树 &lt;树状数组优化建边&gt;</title>
    <link href="http://azrael.top/BZOJ2177%20%E6%9B%BC%E5%93%88%E9%A1%BF%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96%E5%BB%BA%E8%BE%B9/"/>
    <id>http://azrael.top/BZOJ2177 曼哈顿最小生成树 树状数组优化建边/</id>
    <published>2018-03-28T16:00:00.000Z</published>
    <updated>2018-03-30T12:38:44.771Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="曼哈顿最小生成树"><a href="#曼哈顿最小生成树" class="headerlink" title="曼哈顿最小生成树"></a>曼哈顿最小生成树</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>平面坐标系$\mathrm{xOy}$内，给定$n$个顶点$V=(x,y)$。对于顶点$u,\;v$，$u$与$v$之间的距离$d$定义为$|x_u-x_v|+|y_u-y_v|$。你的任务是求出这$n$个顶点的最小生成树。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个正整数$n$，表示定点个数。<br>接下来$n$行每行两个正整数$x,\;y$，描述一个顶点。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一行，为最小生成树的边的距离和。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 0</span><br><span class="line">0 1</span><br><span class="line">0 -1</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据，$n\le5\times10^4,\;0\le x, y\le10^5$。</p><p>标签：<code>树状数组</code> <code>MST</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{MMST}$裸题。</p><p>对于曼哈顿最小生成树，直接建边肯定是不行的，考虑优化建边，去掉一些一定不会在$\mathrm{MST}$中的边。<br>考虑一个点$A(x_1,y_1)$，以$A$为中心将整个图分为$8$个部分。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2e2a1e453.png" alt="0.PNG"><br></center><p>对于一个在右上角的点$B(x_2,y_2)$，一定有$x_2-x_1&lt;y_2-y_1且x_2&gt;x_1$，若其使$x_2+y_2-x_1-y_1$最小，则所有在右上角的点的曼哈顿距离都没有$A\to B$小。因此在$A$右上角的所有点中，只连$AB$即可。同理在$A$周围的八个方向中，每个方向只需连曼哈顿距离最小的点。</p><p>对于如何寻找这样的点，拿找右上角的最近点做例子：<br>最近的点$B(x_2,y_2)$一定使$x_2+y_2-x_1-y_1$最小，即使$x_2+y_2$最小。同时要满足$x_2-x_1&lt;y_2-y_1和x_2&gt;x_1$，即满足$x_2-y_2&lt;x_1-y_1且x_2&gt;x_1$。可以发现这就是以$x$为第一维，$x-y$为第二维做偏序，找到符合的位置中的最小值，用$排序+树状数组$维护。<br>这样我们就可以连每个点到其右上角的最近点的边了。考虑到边可以每次都连双向，因此每个点只用枚举一半即可。这里默认向$y$坐标比当前点大的点连边。其实是可以把每种情况都转化为右上角的。<br>一开始的时候，我们总共需要考虑的是下图区域$1,2,3,4$中的最近点。第一次连边将$1$中的最近点连边。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2f41874f2.png" alt="1.PNG"><br></center><p>接下来将每个点的$x,y$坐标互换，即关于直线$y=x$对称，可以得到下图。第二次连边将$2$中的最近点连边。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2f40e03f2.png" alt="2.PNG"><br></center><p>然后将每个点的$x$坐标取反，即可得到下图。这时第三次连边将$3$中的最近点连边。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2f40e1a74.png" alt="3.PNG"><br></center><p>最后再次互换每个点的$x,y$坐标，得到下图。第四次连边将$4$中的最近点连边。</p><center><br><img src="https://i.loli.net/2018/03/30/5abe2f40e3226.png" alt="4.PNG"><br></center><p>由此，我们可以不改回原值就将$8$个方向连边。<br>建图后，直接跑$\mathrm{Kruskal}$或$\mathrm{Prim}$即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 4020010910LL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, cnt, fa[MAX_N+<span class="number">5</span>];</span><br><span class="line">lnt tr[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> mi[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> u, v; lnt c;&#125; E[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span><span class="keyword">int</span> id; lnt x, y;&#125; p[MAX_N+<span class="number">5</span>], q[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpe</span> <span class="params">(<span class="keyword">const</span> edge &amp;a, <span class="keyword">const</span> edge &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.c &lt; b.c;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpp</span> <span class="params">(<span class="keyword">const</span> P &amp;a, <span class="keyword">const</span> P &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.x == b.x ? a.y &lt; b.y : a.x &lt; b.x;&#125;</span><br><span class="line"><span class="function">lnt <span class="title">dist</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(q[u].x-q[v].x)+<span class="built_in">abs</span>(q[u].y-q[v].y);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;E[++cnt] = (edge)&#123;u, v, dist(u, v)&#125;;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? x : fa[x] = getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> pos, lnt x, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; pos; pos -= pos&amp;-pos)</span><br><span class="line"><span class="keyword">if</span> (tr[pos] &gt; x) tr[pos] = x, mi[pos] = id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;lnt mc = INF;</span><br><span class="line"><span class="keyword">for</span> (; pos &lt;= n; pos += pos&amp;-pos)</span><br><span class="line"><span class="keyword">if</span> (tr[pos] &lt; mc) mc = tr[pos], ret = mi[pos];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>], m;sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmpp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) a[i] = b[i] = p[i].y-p[i].x;</span><br><span class="line">sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>), m = (<span class="keyword">int</span>)(unique(b+<span class="number">1</span>, b+n+<span class="number">1</span>)-b<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) tr[i] = INF;</span><br><span class="line"><span class="built_in">memset</span>(mi, <span class="number">-1</span>, <span class="keyword">sizeof</span> mi);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n, rk, mp; i; i--) &#123;</span><br><span class="line">rk = (<span class="keyword">int</span>)(lower_bound(b+<span class="number">1</span>, b+m+<span class="number">1</span>, a[i])-b);</span><br><span class="line">mp = query(rk); <span class="keyword">if</span> (~mp) addedge(p[i].id, mp);</span><br><span class="line">modify(rk, p[i].x+p[i].y, p[i].id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">MST</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sort(E+<span class="number">1</span>, E+cnt+<span class="number">1</span>, cmpe); lnt ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= cnt; i++) &#123;</span><br><span class="line">u = getf(E[i].u), v = getf(E[i].v);</span><br><span class="line"><span class="keyword">if</span> (u^v) fa[u] = v, ret += E[i].c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">p[i].id = i, read(p[i].x), read(p[i].y), q[i] = p[i];</span><br><span class="line">build(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) swap(p[i].x, p[i].y);</span><br><span class="line">build(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].x *= <span class="number">-1</span>;</span><br><span class="line">build(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) swap(p[i].x, p[i].y);</span><br><span class="line">build(); <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].y *= <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, MST()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;曼哈顿最小生成树&quot;&gt;&lt;a href=&quot;#曼哈顿最小生成树&quot; class=&quot;headerlink&quot; title=&quot;曼哈顿最小生成树&quot;&gt;&lt;/a&gt;曼哈顿最小生成树&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;平面坐标系$\mathrm{xOy}$内，给定$n$个顶点$V=(x,y)$。对于顶点$u,\;v$，$u$与$v$之间的距离$d$定义为$|x_u-x_v|+|y_u-y_v|$。你的任务是求出这$n$个顶点的最小生成树。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个正整数$n$，表示定点个数。&lt;br&gt;接下来$n$行每行两个正整数$x,\;y$，描述一个顶点。 &lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;只有一行，为最小生成树的边的距离和。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树状数组" scheme="http://azrael.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
      <category term="MST" scheme="http://azrael.top/tags/MST/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4695 最假女选手 &lt; SegBeats &gt;</title>
    <link href="http://azrael.top/BZOJ4695%20%E6%9C%80%E5%81%87%E5%A5%B3%E9%80%89%E6%89%8B%20SegBeats/"/>
    <id>http://azrael.top/BZOJ4695 最假女选手 SegBeats/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-03-27T12:22:40.679Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="最假女选手"><a href="#最假女选手" class="headerlink" title="最假女选手"></a>最假女选手</h3><p>$\mathrm{Time\;Limit:\;50\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在刚刚结束的水题嘉年华的压轴节目放水大赛中，$\mathrm{wyywyy}$如愿以偿的得到了最假女选手的奖项。但是作为主办人的$\mathrm{C_SUNSHINE}$为了证明$\mathrm{wyywyy}$确实在放水，决定出一道基础题考察$\mathrm{wyywyy}$的姿势水平。给定一个长度为$N$序列，编号从$1$到$N$。要求支持下面几种操作：</p><ol><li>给一个区间$[L,R]$加上一个数$x$ </li><li>把一个区间$[L,R]$里小于$x$的数变成$x$</li><li>把一个区间$[L,R]$里大于$x$的数变成$x$ </li><li>求区间$[L,R]$的和</li><li>求区间$[L,R]$的最大值</li><li>求区间$[L,R]$的最小值</li></ol><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数$N$表示序列长度<br>第二行$N$个整数$A_i$表示初始序列<br>第三行一个整数$M$表示操作个数<br>接下来$M$行，每行三或四个整数，第一个整数$Tp$表示操作类型，接下来$L,R,X$或$L,R$表述操作数</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每个$4,5,6$类型的操作，输出一行一个整数表示答案<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 2</span><br><span class="line">2</span><br><span class="line">2 1 2 2</span><br><span class="line">4 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le Tp\le6,\;N,M\le5\times10^5,\;|A_i|\le10^8$<br>$Tp=1$时,$|x|\le1000$<br>$Tp=2$或$3$时，$|x|\le10^8$</p><p>标签：<code>SegBeats</code> <code>线段树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{Segment\;Tree\;Beats!}$<br>参见<a href="https://pan.baidu.com/s/1o7xSSQ2" target="_blank" rel="noopener">吉老师的冬令营课件</a>。</p><p>像课件里那样维护最大值、最大值个数、严格次大值、最小值、最小值个数、严格次小值、区间加标记、区间和，丧心病狂分类更新即可。注意只有区间和需要开$\mathrm{long\;long}$，这样即省空间又省常数。</p><p>好久没写过上$140$行的代码了…<br>强烈建议先对拍再交，否则容易卡住评测…</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls (v&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs (v&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> mx1, mx2, mxc, mi1, mi2, mic, tag;lnt s;&#125; tr[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">tr[v].s = tr[ls].s+tr[rs].s;</span><br><span class="line"><span class="keyword">if</span> (tr[ls].mx1 == tr[rs].mx1)</span><br><span class="line">tr[v].mx1 = tr[ls].mx1, </span><br><span class="line">tr[v].mxc = tr[ls].mxc+tr[rs].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx2, tr[rs].mx2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].mx1 &gt; tr[rs].mx1)</span><br><span class="line">tr[v].mx1 = tr[ls].mx1, </span><br><span class="line">tr[v].mxc = tr[ls].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx2, tr[rs].mx1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx1 = tr[rs].mx1, </span><br><span class="line">tr[v].mxc = tr[rs].mxc, </span><br><span class="line">tr[v].mx2 = max(tr[ls].mx1, tr[rs].mx2);</span><br><span class="line"><span class="keyword">if</span> (tr[ls].mi1 == tr[rs].mi1)</span><br><span class="line">tr[v].mi1 = tr[ls].mi1, </span><br><span class="line">tr[v].mic = tr[ls].mic+tr[rs].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi2, tr[rs].mi2);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].mi1 &lt; tr[rs].mi1)</span><br><span class="line">tr[v].mi1 = tr[ls].mi1, </span><br><span class="line">tr[v].mic = tr[ls].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi2, tr[rs].mi1);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mi1 = tr[rs].mi1, </span><br><span class="line">tr[v].mic = tr[rs].mic, </span><br><span class="line">tr[v].mi2 = min(tr[ls].mi1, tr[rs].mi2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">tr[v].s -= <span class="number">1L</span>L*tr[v].mxc*(tr[v].mx1-x);</span><br><span class="line">tr[v].mx1 = x, tr[v].mi1 = min(x, tr[v].mi1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1^tr[v].mi1) tr[v].mi2 = min(x, tr[v].mi2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, </span><br><span class="line">tr[v].s = <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x, tr[v].mxc = tr[v].mic = t-s+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">tr[v].s += <span class="number">1L</span>L*tr[v].mic*(x-tr[v].mi1);</span><br><span class="line">tr[v].mi1 = x, tr[v].mx1 = max(x, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1^tr[v].mi1) tr[v].mx2 = max(x, tr[v].mx2);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, </span><br><span class="line">tr[v].s = <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x, tr[v].mxc = tr[v].mic = t-s+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = tr[v].tag;tr[v].tag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x)</span><br><span class="line">tr[ls].mx1 += x, tr[ls].mx2 += x, </span><br><span class="line">tr[ls].mi1 += x, tr[ls].mi2 += x, </span><br><span class="line">tr[ls].s += <span class="number">1L</span>L*(mid-s+<span class="number">1</span>)*x, tr[ls].tag += x, </span><br><span class="line">tr[rs].mx1 += x, tr[rs].mx2 += x, </span><br><span class="line">tr[rs].mi1 += x, tr[rs].mi2 += x, </span><br><span class="line">tr[rs].s += <span class="number">1L</span>L*(t-mid)*x, tr[rs].tag += x;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt; tr[ls].mx1 &amp;&amp; tr[v].mx1 &gt; tr[ls].mx2) updmx(ls, s, mid, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt; tr[ls].mi1 &amp;&amp; tr[v].mi1 &lt; tr[ls].mi2) updmi(ls, s, mid, tr[v].mi1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt; tr[rs].mx1 &amp;&amp; tr[v].mx1 &gt; tr[rs].mx2) updmx(rs, mid+<span class="number">1</span>, t, tr[v].mx1);</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt; tr[rs].mi1 &amp;&amp; tr[v].mi1 &lt; tr[rs].mi2) updmi(rs, mid+<span class="number">1</span>, t, tr[v].mi1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;</span><br><span class="line"><span class="keyword">int</span> x;read(x);</span><br><span class="line">tr[v].mx1 = tr[v].mi1 = x, tr[v].mxc = tr[v].mic = <span class="number">1</span>;</span><br><span class="line">tr[v].mx2 = -INF, tr[v].mi2 = INF, tr[v].s = x;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">build(ls, s, mid), build(rs, mid+<span class="number">1</span>, t), update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">tr[v].mx1 += x, tr[v].mx2 += x;</span><br><span class="line">tr[v].mi1 += x, tr[v].mi2 += x;</span><br><span class="line">tr[v].s += <span class="number">1L</span>L*(t-s+<span class="number">1</span>)*x;</span><br><span class="line">tr[v].tag += x;<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) modify(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) modify(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mi1 &gt;= x) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r &amp;&amp; x &lt; tr[v].mi2)</span><br><span class="line">&#123;updmi(v, s, t, x);<span class="keyword">return</span>;&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) optmx(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) optmx(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">optmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].mx1 &lt;= x) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r &amp;&amp; x &gt; tr[v].mx2)</span><br><span class="line">&#123;updmx(v, s, t, x);<span class="keyword">return</span>;&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) optmi(ls, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) optmi(rs, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].s;</span><br><span class="line">downtag(v, s, t);lnt ret = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret += query(ls, s, mid, l, r);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret += query(rs, mid+<span class="number">1</span>, t, l, r);</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmx</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].mx1;</span><br><span class="line">downtag(v, s, t);<span class="keyword">int</span> ret = -INF;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret = max(ret, getmx(ls, s, mid, l, r));</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret = max(ret, getmx(rs, mid+<span class="number">1</span>, t, l, r));</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getmi</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> tr[v].mi1;</span><br><span class="line">downtag(v, s, t);<span class="keyword">int</span> ret = INF;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) ret = min(ret, getmi(ls, s, mid, l, r));</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) ret = min(ret, getmi(rs, mid+<span class="number">1</span>, t, l, r));</span><br><span class="line">update(v);<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, T;read(n), build(<span class="number">1</span>, <span class="number">1</span>, n), read(T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">int</span> opt, l, r, x;read(opt);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">1</span>) read(l), read(r), read(x), modify(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">2</span>) read(l), read(r), read(x), optmx(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">3</span>) read(l), read(r), read(x), optmi(<span class="number">1</span>, <span class="number">1</span>, n, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">4</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">5</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmx(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line"><span class="keyword">if</span> (opt == <span class="number">6</span>) read(l), read(r), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, getmi(<span class="number">1</span>, <span class="number">1</span>, n, l, r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;最假女选手&quot;&gt;&lt;a href=&quot;#最假女选手&quot; class=&quot;headerlink&quot; title=&quot;最假女选手&quot;&gt;&lt;/a&gt;最假女选手&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;50\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在刚刚结束的水题嘉年华的压轴节目放水大赛中，$\mathrm{wyywyy}$如愿以偿的得到了最假女选手的奖项。但是作为主办人的$\mathrm{C_SUNSHINE}$为了证明$\mathrm{wyywyy}$确实在放水，决定出一道基础题考察$\mathrm{wyywyy}$的姿势水平。给定一个长度为$N$序列，编号从$1$到$N$。要求支持下面几种操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;给一个区间$[L,R]$加上一个数$x$ &lt;/li&gt;
&lt;li&gt;把一个区间$[L,R]$里小于$x$的数变成$x$&lt;/li&gt;
&lt;li&gt;把一个区间$[L,R]$里大于$x$的数变成$x$ &lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的和&lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的最大值&lt;/li&gt;
&lt;li&gt;求区间$[L,R]$的最小值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个整数$N$表示序列长度&lt;br&gt;第二行$N$个整数$A_i$表示初始序列&lt;br&gt;第三行一个整数$M$表示操作个数&lt;br&gt;接下来$M$行，每行三或四个整数，第一个整数$Tp$表示操作类型，接下来$L,R,X$或$L,R$表述操作数&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每个$4,5,6$类型的操作，输出一行一个整数表示答案&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1071【SCOI2007】组队 &lt;双指针&gt;</title>
    <link href="http://azrael.top/BZOJ1071%E3%80%90SCOI2007%E3%80%91%E7%BB%84%E9%98%9F%20%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://azrael.top/BZOJ1071【SCOI2007】组队 双指针/</id>
    <published>2018-03-26T16:00:00.000Z</published>
    <updated>2018-03-28T12:32:31.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2007】组队"><a href="#【SCOI2007】组队" class="headerlink" title="【SCOI2007】组队"></a>【SCOI2007】组队</h3><p>$\mathrm{Time\;Limit:\;3\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$NBA$每年都有球员选秀环节。通常用速度和身高两项数据来衡量一个篮球运动员的基本素质。假如一支球队里速度最慢的球员速度为$min_V$，身高最矮的球员高度为$min_H$，那么这支球队的所有队员都应该满足：$A\times(height-min_H)+B\times(speed-min_V)\le C$。其中$A$和$B,C$为给定的经验值。这个式子很容易理解，如果一个球队的球员速度和身高差距太大，会造成配合的不协调。 请问作为球队管理层的你，在$N$名选秀球员中，最多能有多少名符合条件的候选球员。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行四个数$N,A,B,C$。<br>下接$N$行每行两个数描述一个球员的$height$和$speed$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>最多候选球员数目。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 1 2 10</span><br><span class="line">5 1</span><br><span class="line">3 2</span><br><span class="line">2 3</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$N\le5000$，$height$和$speed$不大于$10000$。$A,B,C$在长整型以内。<br>$2016.3.26$数据加强，$\mathrm{Nano_ape}$程序未重测。</p><p>标签：<code>双指针</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>挺神的题，两个序列上双指针的操作挺奇葩。</p><p>对于每个队员，令$s=v+h$，将队员数组$A$同时复制到$B$中，分别排序。$A$按照$h$从小到大排序，$B$按照$s$从小到大排序。<br>首先按任意顺序枚举$v$的最小值大小，不妨直接再$A$中枚举。这时定义左指针和右指针$l$和$r$，只是与普通双指针不同的是，$l$指向的是$A$中的元素，$r$指向的是$B$中的元素，可以理解为$A$中的右指针是不动的，$B$中的左指针是不动的。这样精妙设计是考虑到$A$中递增的$h$值如果不满足要求，即小于枚举到的$H$值，小于的部分一定是从前面开始的；同样地，$B$中递增的$s$值如果不满足要求，即大于$A\times min_H+B\times min_V+C$，大于的部分一定是从后面开始的。这样对每个数组跑“单指针”即可得到可行最大子段，更新答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 5000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;lnt A, B, C, miv, mxv;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>lnt h, v, s;&#125; p[MAX_N+<span class="number">5</span>], q[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmph</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.h &lt;= b.h;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmps</span><span class="params">(<span class="keyword">const</span> node &amp;a, <span class="keyword">const</span> node &amp;b)</span> </span>&#123;<span class="keyword">return</span> a.s &lt;= b.s;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(A), read(B), read(C);<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(p[i].h), read(p[i].v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i].s = A*p[i].h+B*p[i].v, q[i] = p[i];</span><br><span class="line">sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmph), sort(q+<span class="number">1</span>, q+n+<span class="number">1</span>, cmps);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r, cnt; i &lt;= n; i++) &#123;</span><br><span class="line">l = r = cnt = <span class="number">0</span>, miv = p[i].v, mxv = miv+C/B;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++, ans = max(ans, cnt)) &#123;</span><br><span class="line"><span class="keyword">while</span> (r &lt; n &amp;&amp; q[r+<span class="number">1</span>].s &lt;= A*p[j].h+B*p[i].v+C)</span><br><span class="line">r++, cnt += q[r].v &gt;= miv &amp;&amp; q[r].v &lt;= mxv;</span><br><span class="line"><span class="keyword">while</span> (l &lt; n &amp;&amp; p[l+<span class="number">1</span>].h &lt; p[j].h)</span><br><span class="line">l++, cnt -= p[l].v &gt;= miv &amp;&amp; p[l].v &lt;= mxv;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2007】组队&quot;&gt;&lt;a href=&quot;#【SCOI2007】组队&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2007】组队&quot;&gt;&lt;/a&gt;【SCOI2007】组队&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;3\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$NBA$每年都有球员选秀环节。通常用速度和身高两项数据来衡量一个篮球运动员的基本素质。假如一支球队里速度最慢的球员速度为$min_V$，身高最矮的球员高度为$min_H$，那么这支球队的所有队员都应该满足：$A\times(height-min_H)+B\times(speed-min_V)\le C$。其中$A$和$B,C$为给定的经验值。这个式子很容易理解，如果一个球队的球员速度和身高差距太大，会造成配合的不协调。 请问作为球队管理层的你，在$N$名选秀球员中，最多能有多少名符合条件的候选球员。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行四个数$N,A,B,C$。&lt;br&gt;下接$N$行每行两个数描述一个球员的$height$和$speed$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;最多候选球员数目。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="双指针" scheme="http://azrael.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1078【SCOI2008】斜堆 &lt;可并堆&gt;</title>
    <link href="http://azrael.top/BZOJ1078%E3%80%90SCOI2008%E3%80%91%E6%96%9C%E5%A0%86%20%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    <id>http://azrael.top/BZOJ1078【SCOI2008】斜堆 可并堆/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-03-28T12:46:40.985Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2008】斜堆"><a href="#【SCOI2008】斜堆" class="headerlink" title="【SCOI2008】斜堆"></a>【SCOI2008】斜堆</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>斜堆$\mathrm{(skew\;heap)}$是一种常用的数据结构。它也是二叉树，且满足与二叉堆相同的堆性质：每个非根结点的值都比它父亲大。因此在整棵斜堆中，根的值最小。但斜堆不必是平衡的，每个结点的左右儿子的大小关系也没有任何规定。在本题中，斜堆中各个元素的值均不相同。<br>在斜堆$H$中插入新元素$X$的过程是递归进行的：</p><ul><li>当$H$为空或者$X$小于$H$的根结点时X变为新的树根，而原来的树根（如果有的话）变为$X$的左儿子。</li><li>当$X$大于$H$的根结点时，$H$根结点的两棵子树交换，而$X$（递归）插入到交换后的左子树中。 </li></ul><p>给出一棵斜堆，包含值为$0\sim n$的结点各一次。求一个结点序列，使得该斜堆可以通过在空树中依次插入这些结点得到。<br>如果答案不惟一，输出字典序最小的解。输入保证有解。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数$n$。<br>第二行包含$n$个整数$d_1,d_2,\cdots,d_n$，$d_i&lt;100$表示$i$是$d_i$的左儿子，$d_i\ge100$表示$i$是$d_i-100$的右儿子。<br>显然$0$总是根，所以输入中不含$d_0$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅一行，包含$n+1$整数，即字典序最小的插入序列。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">100 0 101 102 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 2 3 4 5</span><br></pre></td></tr></table></figure><p>标签：<code>可并堆</code> <code>斜堆</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>探究斜堆性质的好题，可以围观<a href="http://www.cppblog.com/MatoNo1/archive/2013/03/03/192131.html" target="_blank" rel="noopener">$\mathrm{Mato}$的题解</a>。</p><p>考虑每次找到最后插入的结点，删除并维护到插入前的状态。那么我们需要探究一些斜堆的性质。</p><ol><li>最后插入的结点一定是一个极左结点，即从根到它的路径都是向左走，因为最后插入后没有再交换过子树。</li><li>最后插入的结点一定没有右子树。易发现所有右子树都是因为插入结点而从左结点交换而来，而最后插入的结点的子树中一定不会插入新的结点，故一定不会有右子树。</li><li>最后插入结点时，其到根的结点一定会交换左右子树，因此这个结点到根的路径上的所有结点一定都有左右子树。</li></ol><p>综上，最后插入的结点一定是从根结点一直向左走遇到的第一个无右子树的结点。特别地，如果此结点的左子结点是叶子，那么两者均可选，这时应该先选叶子结点以使字典序最小。模拟$n+1$次即可</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, rt, l[MAX_N+<span class="number">5</span>], r[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> f[MAX_N+<span class="number">5</span>];<span class="built_in">stack</span> &lt;<span class="keyword">int</span>&gt; sta;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = rt;<span class="keyword">while</span> (~r[u]) u = l[u];</span><br><span class="line"><span class="keyword">if</span> (~l[u] &amp;&amp; l[l[u]] == r[l[u]]) u = l[u];</span><br><span class="line">sta.push(u);<span class="keyword">if</span> (u == rt) rt = l[rt];</span><br><span class="line"><span class="keyword">if</span> (~f[u]) l[f[u]] = l[u], f[l[u]] = f[u];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = f[u]; ~v; v = f[v]) swap(l[v], r[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), f[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">memset</span>(l, <span class="number">-1</span>, <span class="keyword">sizeof</span> l), <span class="built_in">memset</span>(r, <span class="number">-1</span>, <span class="keyword">sizeof</span> r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, d; i &lt;= n; i++)</span><br><span class="line">read(d), (d &lt; <span class="number">100</span> ? l[d] = i : r[d<span class="number">-100</span>] = i), f[i] = d &lt; <span class="number">100</span> ? d : d<span class="number">-100</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) find();</span><br><span class="line"><span class="keyword">while</span> (!sta.empty()) <span class="built_in">printf</span>(<span class="string">"%d "</span>, sta.top()), sta.pop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2008】斜堆&quot;&gt;&lt;a href=&quot;#【SCOI2008】斜堆&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2008】斜堆&quot;&gt;&lt;/a&gt;【SCOI2008】斜堆&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;斜堆$\mathrm{(skew\;heap)}$是一种常用的数据结构。它也是二叉树，且满足与二叉堆相同的堆性质：每个非根结点的值都比它父亲大。因此在整棵斜堆中，根的值最小。但斜堆不必是平衡的，每个结点的左右儿子的大小关系也没有任何规定。在本题中，斜堆中各个元素的值均不相同。&lt;br&gt;在斜堆$H$中插入新元素$X$的过程是递归进行的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当$H$为空或者$X$小于$H$的根结点时X变为新的树根，而原来的树根（如果有的话）变为$X$的左儿子。&lt;/li&gt;
&lt;li&gt;当$X$大于$H$的根结点时，$H$根结点的两棵子树交换，而$X$（递归）插入到交换后的左子树中。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出一棵斜堆，包含值为$0\sim n$的结点各一次。求一个结点序列，使得该斜堆可以通过在空树中依次插入这些结点得到。&lt;br&gt;如果答案不惟一，输出字典序最小的解。输入保证有解。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含一个整数$n$。&lt;br&gt;第二行包含$n$个整数$d_1,d_2,\cdots,d_n$，$d_i&amp;lt;100$表示$i$是$d_i$的左儿子，$d_i\ge100$表示$i$是$d_i-100$的右儿子。&lt;br&gt;显然$0$总是根，所以输入中不含$d_0$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅一行，包含$n+1$整数，即字典序最小的插入序列。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="可并堆" scheme="http://azrael.top/tags/%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1006【HNOI2008】神奇的国度 &lt;弦图+MCS&gt;</title>
    <link href="http://azrael.top/BZOJ1006%E3%80%90HNOI2008%E3%80%91%E7%A5%9E%E5%A5%87%E7%9A%84%E5%9B%BD%E5%BA%A6%20%E5%BC%A6%E5%9B%BE+MCS/"/>
    <id>http://azrael.top/BZOJ1006【HNOI2008】神奇的国度 弦图+MCS/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-03-28T12:11:07.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【HNOI2008】神奇的国度"><a href="#【HNOI2008】神奇的国度" class="headerlink" title="【HNOI2008】神奇的国度"></a>【HNOI2008】神奇的国度</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$K$国是一个热衷三角形的国度，连人的交往也只喜欢三角原则。他们认为三角关系：即$A,B$相互认识，$B,C$相互认识，$C,A$相互认识，是简洁高效的。<br>为了巩固三角关系，$K$国禁止四边关系，五边关系等等的存在。所谓$N$边关系，是指$N$个人$A_1,A_2\cdots A_n$之间仅存在$N$对认识关系：$(A_1,A_2)(A_2,A_3)\cdots(A_n,A_1)$，而没有其它认识关系。比如四边关系指$A,B,C,D$四个人 $(A,B)$，$(B,C)$，$(C,D)$，$(D,A)$相互认识，而$(A,C)$，$(B,D)$不认识。<br>全民比赛时，为了防止做弊，规定任意一对相互认识的人不得在一队。国王想知道，最少可以分多少支队。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数$N,M$。表示有$N$个人，$M$对认识关系。<br>接下来$M$行每行输入一对朋友。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，最少可以分多少队。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 5</span><br><span class="line">1 2</span><br><span class="line">1 4</span><br><span class="line">2 4</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N\le10^4,\;1\le M\le10^6$</p><p>标签：<code>弦图</code> <code>MCS</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>弦图与$\mathrm{MCS}$算法参见<a href="https://wenku.baidu.com/view/07f4be196c175f0e7cd13784.html" target="_blank" rel="noopener">$\mathrm{CDQ}$讲义</a>。</p><p>结论：按照任意完美消除序列倒叙染色，每次贪心染能染的最小颜色，可以使颜色数最少。</p><p>套上$\mathrm{MCS}$然后模拟染色即可，复杂度$\mathrm{O(n+m)}$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, d[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>], seq[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="built_in">list</span> &lt;<span class="keyword">int</span>&gt; buk[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;G[u].push_back(v), G[v].push_back(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(mrk, <span class="literal">false</span>, <span class="keyword">sizeof</span> mrk);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) buk[<span class="number">0</span>].push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, mx = <span class="number">0</span>, u; i &lt; n; seq[++i] = u, mrk[u] = <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (!buk[mx+<span class="number">1</span>].empty()) mx++;</span><br><span class="line"><span class="keyword">for</span> (u = <span class="number">-1</span>; u == <span class="number">-1</span>; mx--) &#123;</span><br><span class="line"><span class="keyword">while</span> (!buk[mx].empty() &amp;&amp; mrk[buk[mx].front()])</span><br><span class="line">buk[mx].pop_front();</span><br><span class="line"><span class="keyword">if</span> (!buk[mx].empty()) u = buk[mx].front();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, v; j &lt; (<span class="keyword">int</span>)G[u].size(); j++) <span class="keyword">if</span> (!mrk[G[u][j]])</span><br><span class="line">d[v = G[u][j]]++, buk[d[v]].push_back(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Color</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(mrk, <span class="literal">false</span>, <span class="keyword">sizeof</span> mrk);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u = seq[<span class="number">1</span>]; i &lt;= n; u = seq[++i]) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)G[u].size(); j++)</span><br><span class="line">mrk[c[G[u][j]]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; !c[u]; j++) <span class="keyword">if</span> (!mrk[j]) c[u] = j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)G[u].size(); j++)</span><br><span class="line">mrk[c[G[u][j]]] = <span class="literal">false</span>;</span><br><span class="line">ret = max(ret, c[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= m; i++)</span><br><span class="line">read(u), read(v), addedge(u, v);</span><br><span class="line"><span class="keyword">return</span> MCS(), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Color()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【HNOI2008】神奇的国度&quot;&gt;&lt;a href=&quot;#【HNOI2008】神奇的国度&quot; class=&quot;headerlink&quot; title=&quot;【HNOI2008】神奇的国度&quot;&gt;&lt;/a&gt;【HNOI2008】神奇的国度&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$K$国是一个热衷三角形的国度，连人的交往也只喜欢三角原则。他们认为三角关系：即$A,B$相互认识，$B,C$相互认识，$C,A$相互认识，是简洁高效的。&lt;br&gt;为了巩固三角关系，$K$国禁止四边关系，五边关系等等的存在。所谓$N$边关系，是指$N$个人$A_1,A_2\cdots A_n$之间仅存在$N$对认识关系：$(A_1,A_2)(A_2,A_3)\cdots(A_n,A_1)$，而没有其它认识关系。比如四边关系指$A,B,C,D$四个人 $(A,B)$，$(B,C)$，$(C,D)$，$(D,A)$相互认识，而$(A,C)$，$(B,D)$不认识。&lt;br&gt;全民比赛时，为了防止做弊，规定任意一对相互认识的人不得在一队。国王想知道，最少可以分多少支队。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行两个整数$N,M$。表示有$N$个人，$M$对认识关系。&lt;br&gt;接下来$M$行每行输入一对朋友。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个整数，最少可以分多少队。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="弦图" scheme="http://azrael.top/tags/%E5%BC%A6%E5%9B%BE/"/>
    
      <category term="MCS" scheme="http://azrael.top/tags/MCS/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2820 YY的GCD &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ2820%20YY%E7%9A%84GCD%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ2820 YY的GCD 莫比乌斯反演/</id>
    <published>2018-03-25T16:00:00.000Z</published>
    <updated>2018-04-02T03:17:28.130Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="YY的GCD"><a href="#YY的GCD" class="headerlink" title="YY的GCD"></a>YY的GCD</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;512\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>神犇$\mathrm{YY}$虐完数论后给$\mathrm{傻叉kAc}$出了一题：<br>给定$N,M$，求$1\le x\le N,\;1\le y\le M$且$\gcd(x, y)$为质数的$(x, y)$有多少对<br>$\mathrm{kAc}$这种$\mathrm{傻叉}$必然不会了，于是向你来请教。<br>多组输入。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数$T$表述数据组数。<br>接下来$T$行，每行两个正整数，表示$N,M$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>$T$行，每行一个整数表示第$i$组数据的结果。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">10 10</span><br><span class="line">100 100</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">30</span><br><span class="line">2791</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$T=10^4$<br>$N,M\le10^7$</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>套路反演+积性函数预处理。</p><p>先套路推一波反演式：<br>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{p}\sum_{i=1}^{n}\sum_{j=1}^{m}[\gcd(i,j)=p]\\<br>&amp;=\sum_{p}\sum_{i=1}^{\lfloor n/p\rfloor}\sum_{j=1}^{\lfloor m/p\rfloor}\sum_{d|i,j}\mu(d)\\<br>&amp;=\sum_{p}\sum_{d=1}^{\lfloor\frac{\min(n,m)}{p}\rfloor}\mu(d)\times\lfloor\frac{n}{d\cdot p}\rfloor\times\lfloor\frac{m}{d\cdot p}\rfloor\\<br>&amp;=\sum_{T=1}^{n}\sum_{p|T}\mu(\frac{T}{p})\times\lfloor\frac{n}{T}\rfloor\times\lfloor\frac{m}{T}\rfloor\\<br>&amp;=\sum_{T=1}^{n}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor\sum_{p|T}\mu(\frac{T}{p})\\<br>\\<br>Let\;f(x)&amp;=\sum_{p|T}\mu(\frac{T}{p}),\\<br>then\;Ans&amp;=\sum_{T=1}\lfloor\frac{n}{T}\rfloor\lfloor\frac{m}{T}\rfloor f(T)<br>\end{aligned}<br>$$<br>那么我们需要用线筛预处理出所有$f$值。<br>对于当前预处理到的数$x$和枚举到的质数$p$，有<br>$$<br>f(x)=\sum_{d|x,\;d\in\;pri}\mu(\frac{x}{d})\\<br>f(x\cdot p)=\sum_{d|x\cdot p,\;d\in\;pri}\mu(\frac{x\cdot p}{d})\\<br>$$<br>下面的式子的一部分可以化为上面的式子，剩余部分直接加上去。<br>分类讨论：</p><ul><li>若$p|x$，则下式中$d\ne p$时，$\frac{x\cdot p}{d}$的分解式中$p$的指数一定大于$1$，于是只有$d=p$时会对答案产生$\mu(\frac{x\cdot p}{p})=\mu(x)$的贡献，所以$f(x\cdot p)=\mu(x)$。</li><li>若$p\nmid x$，则下式中对于任意$d|x$，其贡献都为上式中对应项的贡献乘$\mu(p)=-1$，即$d|x$的贡献为$f(x)$。当$d\nmid x$时，只存在$d=p$，此时贡献为$\mu(x)$。因此$f(x\cdot p)=\mu(x)-f(x)$。</li></ul><p>由此，可以线筛预处理出所有$f$值，然后根号分块计算答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>], fac[MAX_N+<span class="number">5</span>], cnt;<span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PriS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((x = i*pri[j]) &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[x] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[x] = <span class="number">0</span>;<span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;read(n), PriS();lnt ans = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (lnt i = <span class="number">1</span>, l, r; i &lt; <span class="built_in">sqrt</span>(n); i++) &#123;</span><br><span class="line">cnt = <span class="number">0</span>; <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">sqrt</span>(i); j++) <span class="keyword">if</span> (i%j == <span class="number">0</span>) fac[cnt++] = j;</span><br><span class="line"><span class="keyword">for</span> (l = <span class="number">1</span>; l &lt; i; l = r+<span class="number">1</span>) &#123;</span><br><span class="line">lnt val = n/(i*(i+l)); <span class="keyword">if</span> (!val) <span class="keyword">break</span>;r = min(n/val/i-i, i<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (lnt k = <span class="number">0</span>, j; k &lt; cnt; k++) &#123;</span><br><span class="line">j = fac[k], ans += mu[j]*(r/j-(l<span class="number">-1</span>)/j)*val;lnt t = i/j;</span><br><span class="line"><span class="keyword">if</span> (i%t == <span class="number">0</span> &amp;&amp; (j^t)) ans += mu[t]*(r/t-(l<span class="number">-1</span>)/t)*val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;YY的GCD&quot;&gt;&lt;a href=&quot;#YY的GCD&quot; class=&quot;headerlink&quot; title=&quot;YY的GCD&quot;&gt;&lt;/a&gt;YY的GCD&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;512\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;神犇$\mathrm{YY}$虐完数论后给$\mathrm{傻叉kAc}$出了一题：&lt;br&gt;给定$N,M$，求$1\le x\le N,\;1\le y\le M$且$\gcd(x, y)$为质数的$(x, y)$有多少对&lt;br&gt;$\mathrm{kAc}$这种$\mathrm{傻叉}$必然不会了，于是向你来请教。&lt;br&gt;多组输入。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个整数$T$表述数据组数。&lt;br&gt;接下来$T$行，每行两个正整数，表示$N,M$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;$T$行，每行一个整数表示第$i$组数据的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1052【HAOI2007】覆盖问题 &lt;二分答案&gt;</title>
    <link href="http://azrael.top/BZOJ1052%E3%80%90HAOI2007%E3%80%91%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98%20%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    <id>http://azrael.top/BZOJ1052【HAOI2007】覆盖问题 二分答案/</id>
    <published>2018-03-24T16:00:00.000Z</published>
    <updated>2018-03-28T11:59:08.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【HAOI2007】覆盖问题"><a href="#【HAOI2007】覆盖问题" class="headerlink" title="【HAOI2007】覆盖问题"></a>【HAOI2007】覆盖问题</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>某人在山上种了$N$棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定用$3$个$L\times L$的正方形塑料薄膜将小树遮起来。我们不妨将山建立一个平面直角坐标系，设第$i$棵小树的坐标为$(X_i,Y_i)$，$3$个$L\times L$的正方形的边要求平行与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有一个正整数$N$，表示有多少棵树。<br>接下来有$N$行，第$i+1$行有$2$个整数$X_i,Y_i$，表示第$i$棵树的坐标，保证不会有$2$个树的坐标相同。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，输出最小的$L$值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 1</span><br><span class="line">0 -1</span><br><span class="line">1 0</span><br><span class="line">-1 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$100\%$的数据，$N\le2\times10^4$</p><p>标签：<code>二分答案</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>二分水题。</p><p>考虑到当$L$大于等于答案时，一定能全部覆盖。因此可以二分答案。<br>对于当前二分到的答案$tans$，贪心选取前两个正方形，然后判断剩下的点能否被一个正方形包住。<br>贪心选取即每个正方形一定覆盖剩余点中左上、左下、右上、右下四个最远点中至少一个，因而枚举$16$种情况后判断即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 20000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;pii p[MAX_N+<span class="number">5</span>];<span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x1 = INF, y1 = INF, x2 = -INF, y2 = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!mrk[i])</span><br><span class="line">x1 = min(x1, p[i].x), y1 = min(y1, p[i].y), </span><br><span class="line">x2 = max(x2, p[i].x), y2 = max(y2, p[i].y);</span><br><span class="line"><span class="keyword">return</span> x2-x1 &lt;= r &amp;&amp; y2-y1 &lt;= r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> sx, <span class="keyword">int</span> sy, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!mrk[i])</span><br><span class="line"><span class="keyword">if</span> (p[i].x &gt;= sx &amp;&amp; p[i].x &lt;= sx+r) </span><br><span class="line"><span class="keyword">if</span> (p[i].y &gt;= sy &amp;&amp; p[i].y &lt;= sy+r)</span><br><span class="line">mrk[i] = <span class="literal">true</span>, ret++;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> stp, <span class="keyword">int</span> lft, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!lft) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (stp &gt; <span class="number">2</span>) <span class="keyword">return</span> chk(r);</span><br><span class="line"><span class="keyword">int</span> x1 = INF, y1 = INF, x2 = -INF, y2 = -INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (!mrk[i])</span><br><span class="line">x1 = min(x1, p[i].x), y1 = min(y1, p[i].y), </span><br><span class="line">x2 = max(x2, p[i].x), y2 = max(y2, p[i].y);</span><br><span class="line"><span class="keyword">bool</span> bk[MAX_N+<span class="number">5</span>];<span class="built_in">memcpy</span>(bk, mrk, <span class="keyword">sizeof</span> mrk);</span><br><span class="line"><span class="keyword">if</span> (DFS(stp+<span class="number">1</span>, lft-del(x1, y1, r), r)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="built_in">memcpy</span>(mrk, bk, <span class="keyword">sizeof</span> bk);</span><br><span class="line"><span class="keyword">if</span> (DFS(stp+<span class="number">1</span>, lft-del(x1, y2-r, r), r)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="built_in">memcpy</span>(mrk, bk, <span class="keyword">sizeof</span> bk);</span><br><span class="line"><span class="keyword">if</span> (DFS(stp+<span class="number">1</span>, lft-del(x2-r, y1, r), r)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="built_in">memcpy</span>(mrk, bk, <span class="keyword">sizeof</span> bk);</span><br><span class="line"><span class="keyword">if</span> (DFS(stp+<span class="number">1</span>, lft-del(x2-r, y2-r, r), r)) <span class="keyword">return</span> <span class="literal">true</span>;<span class="built_in">memcpy</span>(mrk, bk, <span class="keyword">sizeof</span> bk);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line"><span class="built_in">memset</span>(mrk, <span class="literal">false</span>, <span class="keyword">sizeof</span> mrk);</span><br><span class="line"><span class="keyword">if</span> (!DFS(<span class="number">1</span>, n, mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = mid, r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(p[i].x), read(p[i].y);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bi_search(<span class="number">1</span>, INF)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【HAOI2007】覆盖问题&quot;&gt;&lt;a href=&quot;#【HAOI2007】覆盖问题&quot; class=&quot;headerlink&quot; title=&quot;【HAOI2007】覆盖问题&quot;&gt;&lt;/a&gt;【HAOI2007】覆盖问题&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;某人在山上种了$N$棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定用$3$个$L\times L$的正方形塑料薄膜将小树遮起来。我们不妨将山建立一个平面直角坐标系，设第$i$棵小树的坐标为$(X_i,Y_i)$，$3$个$L\times L$的正方形的边要求平行与坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求L最小值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行有一个正整数$N$，表示有多少棵树。&lt;br&gt;接下来有$N$行，第$i+1$行有$2$个整数$X_i,Y_i$，表示第$i$棵树的坐标，保证不会有$2$个树的坐标相同。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一行，输出最小的$L$值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="二分答案" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1430 小猴打架 &lt; Prufer序列+组合数学 &gt;</title>
    <link href="http://azrael.top/BZOJ1430%20%E5%B0%8F%E7%8C%B4%E6%89%93%E6%9E%B6%20Prufer%E5%BA%8F%E5%88%97+%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    <id>http://azrael.top/BZOJ1430 小猴打架 Prufer序列+组合数学/</id>
    <published>2018-03-23T16:00:00.000Z</published>
    <updated>2018-03-27T12:23:19.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="小猴打架"><a href="#小猴打架" class="headerlink" title="小猴打架"></a>小猴打架</h3><p>$\mathrm{Time\;Limit:\;5\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一开始森林里面有$N$只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过$N-1$次打架之后，整个森林的小猴都会成为好朋友。 现在的问题是，总共有多少种不同的打架过程。 比如当$N=3$时，就有$\lbrace1-2,1-3\rbrace$ $\lbrace1-2,2-3\rbrace$ $\lbrace1-3,1-2\rbrace$ $\lbrace1-3,2-3\rbrace$ $\lbrace2-3,1-2\rbrace$ $\lbrace2-3,1-3\rbrace$六种不同的打架过程。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>一个整数N，$N\le10^6$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一行，方案数$\mod{9999991}$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">96</span><br></pre></td></tr></table></figure><p>标签：<code>Prufer序列</code> <code>组合数学</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>由$\mathrm{Prufer}序列$可知，一棵有$n$个点的树与一个长为$n-2$的序列一一对应。那么确定出这样的序列的方案数即可确定最后形成的树的形态。易知这样的序列共有$n^{n-2}$个。再考虑构建树的顺序，即为$n-1$个元素的全排列数，总数为$(n-1)!$。故答案为 $n^{n-2}-(n-1)!\mod{9999991}$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 9999991</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n;lnt ans = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-2</span>; i++) (ans *= <span class="number">1L</span>L*n) %= MOD; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++) (ans *= <span class="number">1L</span>L*i) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;小猴打架&quot;&gt;&lt;a href=&quot;#小猴打架&quot; class=&quot;headerlink&quot; title=&quot;小猴打架&quot;&gt;&lt;/a&gt;小猴打架&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;5\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一开始森林里面有$N$只互不相识的小猴子，它们经常打架，但打架的双方都必须不是好朋友。每次打完架后，打架的双方以及它们的好朋友就会互相认识，成为好朋友。经过$N-1$次打架之后，整个森林的小猴都会成为好朋友。 现在的问题是，总共有多少种不同的打架过程。 比如当$N=3$时，就有$\lbrace1-2,1-3\rbrace$ $\lbrace1-2,2-3\rbrace$ $\lbrace1-3,1-2\rbrace$ $\lbrace1-3,2-3\rbrace$ $\lbrace2-3,1-2\rbrace$ $\lbrace2-3,1-3\rbrace$六种不同的打架过程。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;一个整数N，$N\le10^6$&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一行，方案数$\mod{9999991}$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="组合数学" scheme="http://azrael.top/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="Prufer序列" scheme="http://azrael.top/tags/Prufer%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1027【JSOI2007】合金 &lt;凸包+Floyed&gt;</title>
    <link href="http://azrael.top/BZOJ1027%E3%80%90JSOI2007%E3%80%91%E5%90%88%E9%87%91%20%E5%87%B8%E5%8C%85+Floyed/"/>
    <id>http://azrael.top/BZOJ1027【JSOI2007】合金 凸包+Floyed/</id>
    <published>2018-03-22T16:00:00.000Z</published>
    <updated>2018-03-27T11:53:43.348Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【JSOI2007】合金"><a href="#【JSOI2007】合金" class="headerlink" title="【JSOI2007】合金"></a>【JSOI2007】合金</h3><p>$\mathrm{Time\;Limit:\;4\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了$n$种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个整数$m$和$n$$(m,n\le500)$，分别表示原材料种数和用户需要的合金种数。第$2$到$m+1$行，每行三个实数$a,b,c(a,b,c\ge0且a+b+c=1)$，分别表示铁铝锡在一种原材料中所占的比重。第$m+2$到$m+n+1$行，每行三个实数$a,b,c(a,b,c\ge0且a+b+c=1)$，分别表示铁铝锡在一种用户需要的合金中所占的比重。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个整数，表示最少需要的原材料种数。若无解，则输出$–1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br><span class="line">0.1 0.2 0.7</span><br><span class="line">0.2 0.3 0.5</span><br><span class="line">0.3 0.4 0.3</span><br><span class="line">0.4 0.5 0.1</span><br><span class="line">0.5 0.1 0.4</span><br><span class="line">0.6 0.2 0.2</span><br><span class="line">0.7 0.3 0</span><br><span class="line">0.8 0.1 0.1</span><br><span class="line">0.9 0.1 0</span><br><span class="line">1 0 0</span><br><span class="line">0.1 0.2 0.7</span><br><span class="line">0.2 0.3 0.5</span><br><span class="line">0.3 0.4 0.3</span><br><span class="line">0.4 0.5 0.1</span><br><span class="line">0.5 0.1 0.4</span><br><span class="line">0.6 0.2 0.2</span><br><span class="line">0.7 0.3 0</span><br><span class="line">0.8 0.1 0.1</span><br><span class="line">0.9 0.1 0</span><br><span class="line">1 0 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><p>标签：<code>凸包</code> <code>Floyed</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，给出的三个参数确定两个就能确定第三个，因此可以把参数缩减为两个。<br>考虑两种金属是否能造出第三种金属，若能造成，则第三种金属的两个参数必和这两种金属的参数成比例关系。<br>推广到用$k$种金属制造一种合金，若将这$k$种金属的两个参数作为横纵坐标描成点，那么合金所代表的点只要在这$k$个点形成的凸包内即可制造。<br>由此，题目转化为选出尽量少的点使得目标点都在选出点所构成的凸包内。</p><p>对于一个条有向线段，它能被选出到凸包上当且仅当所有目标点都在它的左侧。那么处理出所有这样的边后，我们就在点与点间连出了若干条边。我们需要尽量选尽量少的点，即选尽量少的边，使其构成凸包。这样直接跑$\mathrm{Floyed}$后枚举起始点即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;dnt,dnt&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">bool</span> G[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line">pdd p[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, f[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">pdd <span class="title">vec</span><span class="params">(pdd s, pdd t)</span> </span>&#123;<span class="keyword">return</span> mp(t.x-s.x, t.y-s.y);&#125;</span><br><span class="line"><span class="function">dnt <span class="title">dot</span><span class="params">(pdd a, pdd b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.x+a.y*b.y;&#125;</span><br><span class="line"><span class="function">dnt <span class="title">cross</span><span class="params">(pdd a, pdd b)</span> </span>&#123;<span class="keyword">return</span> a.x*b.y-a.y*b.x;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(pdd s, pdd t, pdd a)</span> </span>&#123;</span><br><span class="line">dnt mul = cross(vec(a, s), vec(a, t));</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(mul) &lt;= EPS &amp;&amp; dot(vec(a, s), vec(a, t)) &lt;= EPS) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line"><span class="keyword">if</span> (mul &lt; -EPS) <span class="keyword">return</span> <span class="literal">true</span>;<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">spj</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (<span class="built_in">fabs</span>(p[i].x-p[<span class="number">1</span>].x) &gt; EPS || <span class="built_in">fabs</span>(p[i].y-p[<span class="number">1</span>].y) &gt; EPS) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (<span class="built_in">fabs</span>(c[i].x-p[<span class="number">1</span>].x) &gt; EPS || <span class="built_in">fabs</span>(c[i].y-p[<span class="number">1</span>].y) &gt; EPS) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Floyed</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = INF;<span class="built_in">memset</span>(f, INF, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line"><span class="keyword">if</span> (G[i][j] &amp;&amp; i^j) f[i][j] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) f[i][j] = min(f[i][j], f[i][k]+f[k][j]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ret = min(ret, f[i][i]);</span><br><span class="line"><span class="keyword">return</span> spj() ? <span class="number">1</span> : (ret == INF ? <span class="number">-1</span> : ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m), <span class="built_in">memset</span>(G, <span class="literal">true</span>, <span class="keyword">sizeof</span> G);dnt t;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;p[i].x, &amp;p[i].y, &amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lf%lf"</span>, &amp;c[i].x, &amp;c[i].y, &amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (i^j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m &amp;&amp; G[i][j]; k++) G[i][j] &amp;= chk(p[i], p[j], c[k]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Floyed()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【JSOI2007】合金&quot;&gt;&lt;a href=&quot;#【JSOI2007】合金&quot; class=&quot;headerlink&quot; title=&quot;【JSOI2007】合金&quot;&gt;&lt;/a&gt;【JSOI2007】合金&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;4\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 现在，用户给出了$n$种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行两个整数$m$和$n$$(m,n\le500)$，分别表示原材料种数和用户需要的合金种数。第$2$到$m+1$行，每行三个实数$a,b,c(a,b,c\ge0且a+b+c=1)$，分别表示铁铝锡在一种原材料中所占的比重。第$m+2$到$m+n+1$行，每行三个实数$a,b,c(a,b,c\ge0且a+b+c=1)$，分别表示铁铝锡在一种用户需要的合金中所占的比重。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一个整数，表示最少需要的原材料种数。若无解，则输出$–1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="Floyed" scheme="http://azrael.top/tags/Floyed/"/>
    
      <category term="凸包" scheme="http://azrael.top/tags/%E5%87%B8%E5%8C%85/"/>
    
      <category term="计算机和" scheme="http://azrael.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1095【ZJOI2007】Hide捉迷藏 &lt;括号序列+线段树&gt;</title>
    <link href="http://azrael.top/BZOJ1095%E3%80%90ZJOI2007%E3%80%91Hide%E6%8D%89%E8%BF%B7%E8%97%8F%20%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97+%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ1095【ZJOI2007】Hide捉迷藏 括号序列+线段树/</id>
    <published>2018-03-21T16:00:00.000Z</published>
    <updated>2018-03-23T13:06:12.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【ZJOI2007】Hide捉迷藏"><a href="#【ZJOI2007】Hide捉迷藏" class="headerlink" title="【ZJOI2007】Hide捉迷藏"></a>【ZJOI2007】Hide捉迷藏</h3><p>$\mathrm{Time\;Limit:\;40\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>捉迷藏$\mathrm{Jiajia}$和$\mathrm{Wind}$是一对恩爱的夫妻，并且他们有很多孩子。某天，$\mathrm{Jiajia}$、$\mathrm{Wind}$和孩子们决定在家里玩捉迷藏游戏。他们的家很大且构造很奇特，由$N$个屋子和$N-1$条双向走廊组成，这$N-1$条走廊的分布使得任意两个屋子都互相可达。<br>游戏是这样进行的，孩子们负责躲藏，$\mathrm{Jiajia}$负责找，而$\mathrm{Wind}$负责操纵这$N$个屋子的灯。在起初的时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性，$\mathrm{Jiajia}$希望知道可能的最远的两个孩子的距离（即最远的两个关灯房间的距离）。<br>我们将以如下形式定义每一种操作：</p><ul><li>$\mathrm{C(hange)}\;i$ ：改变第$i$个房间的照明状态，若原来打开，则关闭；若原来关闭，则打开。</li><li>$\mathrm{G(ame)}$ ：开始一次游戏，查询最远的两个关灯房间的距离。</li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个整数$N$，表示房间的个数，房间将被编号为$1,2,3\cdots N$的整数。接下来$N-1$行每行两个整数$a,b$，表示房间$a$与房间$b$之间有一条走廊相连。接下来一行包含一个整数$Q$，表示操作次数。接着$Q$行，每行一个操作，如上文所示。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>对于每一个操作$\mathrm{G(ame)}$，输出一个非负整数，表示最远的两个关灯房间的距离。<br>若只有一个房间是关着灯的，输出$0$；若所有房间的灯都开着，输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">3 4</span><br><span class="line">3 5</span><br><span class="line">3 6</span><br><span class="line">6 7</span><br><span class="line">6 8</span><br><span class="line">7</span><br><span class="line">G</span><br><span class="line">C 1</span><br><span class="line">G</span><br><span class="line">C 2</span><br><span class="line">G</span><br><span class="line">C 1</span><br><span class="line">G</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于$100\%$的数据，$N\le10^5,\;M\le5\times10^5$。</p><p>标签：<code>括号序列</code> <code>线段树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>不会写动态点分，受<a href="http://www.shuizilong.com/house/archives/bzoj-1095-zjoi2007hide-%E6%8D%89%E8%BF%B7%E8%97%8F/" target="_blank" rel="noopener">小岛姐</a>的启发写了线段树，虽然有$7$个标记，但推出公式还是比较好写的。</p><p><strong>括号序列</strong><br>对于一棵树，我们可以将其$\mathrm{DFS}$序稍加优化，得到一个能记录每个点的子树结构的序列，即括号序列。<br>用左括号$($表示进入某点的子树，用右括号$)$表示走出某点的子树。<br><img src="https://images2015.cnblogs.com/blog/890886/201703/890886-20170304113106126-1381317123.png" alt=""></p><p>对于此树，括号序列为$(A(B)(C(D)(E)))$，可以看出括号序列有一个有用的性质，即仍两点之间的序列可以表示从前面的点走到后面的点的走法。例如对于点$B$和$E$，其中间的序列为$)(()($，如果去掉中间匹配的括号则变为$)(($，将$)$定义为向上走，将$($定义为向下走，那么可以看出$B$向上走两步，再向下走两步即可到$E$。那么如果维护此题中的树的括号序列，那么只需要知道任意两个黑点间的括号序列消除配对后的长度的最大值后即可得到答案。</p><p><strong>线段树维护</strong><br>对于一个序列的区间，可以用二元组$(a,b)$表示其消去配对后的序列，即有$a$个右括号和$b$个左括号。<br>对于区间$S_1(a_1,b_1)$和$S_2(a_2,b_2)$，它们合并起来的区间是$S(a,b)$，那么</p><ul><li>当$b_1&gt;a_2$时，$S_1$的左括号和$S_2$的右括号消去后一定会剩下$b_1-a_2$个左括号，因此$a=a_1-b_1+a_2$，$b=b_2$</li><li>当$b_1\le a_2$时，$S_1$的左括号和$S_2$的右括号消去后一定会剩下$a_2-b_1$个右括号，因此$a=a_1$，$b=-a_2+b_1+b_2$</li></ul><p>那么易得到几个推论：</p><ul><li>$a+b=a_1+a_2+|b_1-a_2|$</li><li>$a-b=a_1+a_2-b_1-b_2$</li><li>$b-a=-a_1-a_2+b_1+b_2$</li></ul><p>我们需要维护每个区间中两黑点间括号序列长度的最大值，那么我们还需要维护另外几个信息（有点像区间最大字段和）：</p><ul><li>$lp=\max\lbrace a+b|S’(a,b)是S的一个前缀，且一个黑点接在S’之后\rbrace$</li><li>$lm=\max\lbrace b-a|S’(a,b)是S的一个前缀，且一个黑点接在S’之后\rbrace$</li><li>$rp=\max\lbrace a+b|S’(a,b)是S的一个后缀，且S’接在一个黑点后\rbrace$</li><li>$rm=\max\lbrace a-b|S’(a,b)是S的一个后缀，且S’接在一个黑点后\rbrace$</li></ul><p>对于一个区间$S$，其两个子区间$S_1,S_2$的七个值分别为$a_1,b_1,lp_1,lm_1,rp_1,rm_1,dis_1$和$a_2,b_2,lp_2,lm_2,rp_2,rm_2,dis_2$，那么该区间的$dis$一定是以下四个值的最大值：</p><ul><li>$dis_1$</li><li>$dis_2$</li><li>$rp_1+lm_2$</li><li>$rm_1+lp_2$</li></ul><p>而对于维护的$4$个信息，观察发现可以这样计算：</p><ul><li>$lp=\max\lbrace lp_1,\;a_1-b_1+lp_2,\;a_1+b_1+lm_2\rbrace$</li><li>$lm=\max\lbrace lm_1,\;-a_1+b_1+lm_2\rbrace$</li><li>$rp=\max\lbrace rp_2,\;-a_2+b_2+rp_1,\;a_2+b_2+rm_1\rbrace$</li><li>$rm=\max\lbrace rm_2,\;a_2-b_2+rm_1\rbrace$</li></ul><p>这样以后我们就可以用线段树维护这七个标记了。<br>除了$update$有点长以外，其他都和裸线段树一样。</p><p>以后找时间把动态点分学一学吧。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, cnt, col[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> ind, seq[(MAX_N&lt;&lt;<span class="number">2</span>)+<span class="number">5</span>], dfn[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> a, b, lp, lm, rp, rm, dis;&#125; tr[(MAX_N&lt;&lt;<span class="number">4</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;G[u].push_back(v), G[v].push_back(u);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">seq[++ind] = <span class="number">-1</span>, seq[++ind] = u, dfn[u] = ind;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> ((v = G[u][i]) ^ f) DFS(v, u);</span><br><span class="line">seq[++ind] = <span class="number">-2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">tr[v].a = tr[v].b = <span class="number">0</span>, tr[v].dis = -INF;</span><br><span class="line"><span class="keyword">if</span> (seq[p] == <span class="number">-1</span>) tr[v].b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (seq[p] == <span class="number">-2</span>) tr[v].a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (seq[p] &gt; <span class="number">0</span> &amp;&amp; col[seq[p]])</span><br><span class="line">tr[v].lp = tr[v].lm = tr[v].rp = tr[v].rm = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> tr[v].lp = tr[v].lm = tr[v].rp = tr[v].rm = -INF;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = tr[v&lt;&lt;<span class="number">1</span>].a, b = tr[v&lt;&lt;<span class="number">1</span>].b;</span><br><span class="line"><span class="keyword">int</span> c = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].a, d = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].b;</span><br><span class="line">tr[v].a = b &lt; c ? a-b+c : a;</span><br><span class="line">tr[v].b = b &lt; c ? d : b-c+d;</span><br><span class="line">tr[v].lp = tr[v&lt;&lt;<span class="number">1</span>].lp, tr[v].rp = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rp;</span><br><span class="line">tr[v].lm = tr[v&lt;&lt;<span class="number">1</span>].lm, tr[v].rm = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rm;</span><br><span class="line">tr[v].lp = max(tr[v].lp, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lp+a-b);</span><br><span class="line">tr[v].lp = max(tr[v].lp, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm+a+b);</span><br><span class="line">tr[v].lm = max(tr[v].lm, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm-a+b);</span><br><span class="line">tr[v].rp = max(tr[v].rp, tr[v&lt;&lt;<span class="number">1</span>].rp-c+d);</span><br><span class="line">tr[v].rp = max(tr[v].rp, tr[v&lt;&lt;<span class="number">1</span>].rm+c+d);</span><br><span class="line">tr[v].rm = max(tr[v].rm, tr[v&lt;&lt;<span class="number">1</span>].rm+c-d);</span><br><span class="line">tr[v].dis = max(tr[v&lt;&lt;<span class="number">1</span>].dis, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].dis);</span><br><span class="line">tr[v].dis = max(tr[v].dis, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lm+tr[v&lt;&lt;<span class="number">1</span>].rp);</span><br><span class="line">tr[v].dis = max(tr[v].dis, tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lp+tr[v&lt;&lt;<span class="number">1</span>].rm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;init(v, s);<span class="keyword">return</span>;&#125;</span><br><span class="line">build(v&lt;&lt;<span class="number">1</span>, s, mid), build(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t);</span><br><span class="line">update(v, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) &#123;init(v, s);<span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= mid) modify(v&lt;&lt;<span class="number">1</span>, s, mid, p);</span><br><span class="line"><span class="keyword">else</span> modify(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, p);</span><br><span class="line">update(v, s, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), cnt = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) col[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; i++)</span><br><span class="line">read(u), read(v), addedge(u, v);</span><br><span class="line"><span class="keyword">int</span> T;read(T), DFS(<span class="number">1</span>, <span class="number">0</span>), build(<span class="number">1</span>, <span class="number">1</span>, ind);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line"><span class="keyword">char</span> opt[<span class="number">2</span>];<span class="built_in">scanf</span>(<span class="string">"%s"</span>, opt);</span><br><span class="line"><span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'C'</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> x;read(x);</span><br><span class="line">cnt += col[x] ? <span class="number">-1</span> : <span class="number">1</span>, col[x] ^= <span class="number">1</span>;</span><br><span class="line">modify(<span class="number">1</span>, <span class="number">1</span>, ind, dfn[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (opt[<span class="number">0</span>] == <span class="string">'G'</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!cnt) <span class="built_in">puts</span>(<span class="string">"-1"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tr[<span class="number">1</span>].dis);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【ZJOI2007】Hide捉迷藏&quot;&gt;&lt;a href=&quot;#【ZJOI2007】Hide捉迷藏&quot; class=&quot;headerlink&quot; title=&quot;【ZJOI2007】Hide捉迷藏&quot;&gt;&lt;/a&gt;【ZJOI2007】Hide捉迷藏&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;40\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;捉迷藏$\mathrm{Jiajia}$和$\mathrm{Wind}$是一对恩爱的夫妻，并且他们有很多孩子。某天，$\mathrm{Jiajia}$、$\mathrm{Wind}$和孩子们决定在家里玩捉迷藏游戏。他们的家很大且构造很奇特，由$N$个屋子和$N-1$条双向走廊组成，这$N-1$条走廊的分布使得任意两个屋子都互相可达。&lt;br&gt;游戏是这样进行的，孩子们负责躲藏，$\mathrm{Jiajia}$负责找，而$\mathrm{Wind}$负责操纵这$N$个屋子的灯。在起初的时候，所有的灯都没有被打开。每一次，孩子们只会躲藏在没有开灯的房间中，但是为了增加刺激性，孩子们会要求打开某个房间的电灯或者关闭某个房间的电灯。为了评估某一次游戏的复杂性，$\mathrm{Jiajia}$希望知道可能的最远的两个孩子的距离（即最远的两个关灯房间的距离）。&lt;br&gt;我们将以如下形式定义每一种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$\mathrm{C(hange)}\;i$ ：改变第$i$个房间的照明状态，若原来打开，则关闭；若原来关闭，则打开。&lt;/li&gt;
&lt;li&gt;$\mathrm{G(ame)}$ ：开始一次游戏，查询最远的两个关灯房间的距离。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含一个整数$N$，表示房间的个数，房间将被编号为$1,2,3\cdots N$的整数。接下来$N-1$行每行两个整数$a,b$，表示房间$a$与房间$b$之间有一条走廊相连。接下来一行包含一个整数$Q$，表示操作次数。接着$Q$行，每行一个操作，如上文所示。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;对于每一个操作$\mathrm{G(ame)}$，输出一个非负整数，表示最远的两个关灯房间的距离。&lt;br&gt;若只有一个房间是关着灯的，输出$0$；若所有房间的灯都开着，输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="括号序列" scheme="http://azrael.top/tags/%E6%8B%AC%E5%8F%B7%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1068【SCOI2007】压缩 &lt;区间DP&gt;</title>
    <link href="http://azrael.top/BZOJ1068%E3%80%90SCOI2007%E3%80%91%E5%8E%8B%E7%BC%A9%20%E5%8C%BA%E9%97%B4DP/"/>
    <id>http://azrael.top/BZOJ1068【SCOI2007】压缩 区间DP/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-03-21T15:08:41.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2007】压缩"><a href="#【SCOI2007】压缩" class="headerlink" title="【SCOI2007】压缩"></a>【SCOI2007】压缩</h3><p>$\mathrm{Time\;Limit:\;1\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母$\mathrm{R}$与$\mathrm{M}$，其中$\mathrm{M}$标记重复串的开始，$\mathrm{R}$重复从上一个$\mathrm{M}$（如果当前位置左边没有$\mathrm{M}$，则从串的开始算起）开始的解压结果（称为缓冲串）。 $\mathrm{bcdcdcdcd}$可以压缩为$\mathrm{bMcdRR}$，下面是解压缩的过程：<br><img src="http://www.lydsy.com/JudgeOnline/images/1068/1.jpg" alt=""></p><p>另一个例子是$\mathrm{abcabcdabcabcdxyxyz}$可以被压缩为$\mathrm{abcRdRMxyRz}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入仅一行，包含待压缩字符串，仅包含小写字母，长度为$n$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出仅一行，即压缩后字符串的最短长度。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><p><strong>Input #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaa</span><br></pre></td></tr></table></figure></p><p><strong>Input #2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bcdcdcdcdxcdcdcdcd</span><br></pre></td></tr></table></figure></p><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><p><strong>Output #1</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><p><strong>Output #2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure></p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p><strong>样例解释</strong><br>在第一个样例中，解为$\mathrm{aaaRa}$，在第二个例子中，解为$\mathrm{bMcdRRxMcdRR}$。<br><strong>数据规模</strong><br>$100\%$的数据满足$1\le n\le50$</p><p>标签：<code>区间DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>每次压缩的是连续的一段，考虑区间$\mathrm{DP}$。</p><p>设$f[l][r]$表示压缩字符串$s$的字串$s[l..r]$的最短长度，其中压缩后的串串首自带一个$\mathrm{M}$于是就会有两种转移：</p><ul><li>$f[l][r]=\min_{i=l}^{r-1}(f[l][i]+f[i+1][r])$</li><li>若$s[l..mid]=s[mid+1..r]$，则$f[l][r] = \min(f[l][r],f[l][mid]+2)$</li></ul><p>但这样是有锅的…压缩后串中间的$\mathrm{M}$会影响到后面的$\mathrm{R}$。<br>例如$\mathrm{orzwxhakakorzwxhakak}$，显然$\mathrm{orzwxhMakR}$为一种压缩，但其复制一遍形成的$\mathrm{MorzwxhMakRR}$表示的不是原串。这是因为中间的$\mathrm{M}$会使后面的$\mathrm{R}$少复制一截。</p><p>于是我们调整状态定义，定义$f[l][r][0]$表示压缩后除了串首不再含有任何一个$\mathrm{M}$，$f[l][r][1]$表示压缩后除了串首还含有其他$\mathrm{M}$，这样前者是可以整体复制的，而后者不行。<br>那么首先有边界条件$f[i][i][1]=2\;(i\in[1,n])$。<br>转移有三种：</p><ul><li>$f[l][r][0]=\min_{i=l}^{r-1}(f[l][i][0]+r-i)$，表示直接把后缀接上去</li><li>$f[l][r][0]=\min(f[l][r][0],f[l][mid][0]+1)$，其中$s[l..mid]=s[mid+1..r]$，表示把前一半复制一遍</li><li>$f[l][r][1]=\min_{i=l}^{r-1}(\min(f[l][i][0],f[l][i][1])+\min(f[i+1][r][0],f[i+1][r][1]))$，表示分成两半随便拼，只不过拼了以后不能复制，因为中间有$\mathrm{M}$</li></ul><p>直接记忆化即可，注意第三种情况要判左右边界。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, f[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>][<span class="number">2</span>];<span class="keyword">char</span> s[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DP</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> &amp;ret = f[l][r][x];</span><br><span class="line"><span class="keyword">if</span> (ret^INF) <span class="keyword">return</span> ret;</span><br><span class="line"><span class="keyword">if</span> (l == r &amp;&amp; !x) <span class="keyword">return</span> ret = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (x) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++) &#123;</span><br><span class="line">ret = min(ret, DP(l, i, <span class="number">0</span>)+DP(i+<span class="number">1</span>, r, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (l &lt; i) ret = min(ret, DP(l, i, <span class="number">0</span>)+DP(i+<span class="number">1</span>, r, <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (i+<span class="number">1</span> &lt; r) ret = min(ret, DP(l, i, <span class="number">1</span>)+DP(i+<span class="number">1</span>, r, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">if</span> (l &lt; i &amp;&amp; i+<span class="number">1</span> &lt; r) ret = min(ret, DP(l, i, <span class="number">1</span>)+DP(i+<span class="number">1</span>, r, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt; r; i++)</span><br><span class="line">ret = min(ret, DP(l, i, <span class="number">0</span>)+r-i);</span><br><span class="line"><span class="keyword">bool</span> flag = (r-l)%<span class="number">2</span> == <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = mid+<span class="number">1</span>; i &lt;= mid; i++, j++)</span><br><span class="line"><span class="keyword">if</span> (s[i]^s[j]) flag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) ret = min(ret, DP(l, mid, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>), n = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memset</span>(f, INF, <span class="keyword">sizeof</span> f), DP(<span class="number">1</span>, n, <span class="number">0</span>), DP(<span class="number">1</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>, min(f[<span class="number">1</span>][n][<span class="number">0</span>], f[<span class="number">1</span>][n][<span class="number">1</span>])<span class="number">-1</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2007】压缩&quot;&gt;&lt;a href=&quot;#【SCOI2007】压缩&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2007】压缩&quot;&gt;&lt;/a&gt;【SCOI2007】压缩&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;1\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母$\mathrm{R}$与$\mathrm{M}$，其中$\mathrm{M}$标记重复串的开始，$\mathrm{R}$重复从上一个$\mathrm{M}$（如果当前位置左边没有$\mathrm{M}$，则从串的开始算起）开始的解压结果（称为缓冲串）。 $\mathrm{bcdcdcdcd}$可以压缩为$\mathrm{bMcdRR}$，下面是解压缩的过程：&lt;br&gt;&lt;img src=&quot;http://www.lydsy.com/JudgeOnline/images/1068/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;另一个例子是$\mathrm{abcabcdabcabcdxyxyz}$可以被压缩为$\mathrm{abcRdRMxyRz}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入仅一行，包含待压缩字符串，仅包含小写字母，长度为$n$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出仅一行，即压缩后字符串的最短长度。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="区间DP" scheme="http://azrael.top/tags/%E5%8C%BA%E9%97%B4DP/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1857【SCOI2010】传送带 &lt;三分法&gt;</title>
    <link href="http://azrael.top/BZOJ1857%E3%80%90SCOI2010%E3%80%91%E4%BC%A0%E9%80%81%E5%B8%A6%20%E4%B8%89%E5%88%86%E6%B3%95/"/>
    <id>http://azrael.top/BZOJ1857【SCOI2010】传送带 三分法/</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-03-20T03:50:21.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2010】传送带"><a href="#【SCOI2010】传送带" class="headerlink" title="【SCOI2010】传送带"></a>【SCOI2010】传送带</h3><p>$\mathrm{Time\;Limit:\;1\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一个$2$维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段$AB$和线段$CD$。<br>$\mathrm{lxhgww}$在$AB$上的移动速度为$P$，在$CD$上的移动速度为$Q$，在平面上的移动速度$R$。<br>现在$\mathrm{lxhgww}$想从$A$点走到$D$点，他想知道最少需要走多长时间。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据第一行是$4$个整数，表示$A$和$B$的坐标，分别为$A_x,A_y,B_x,B_y$。<br>第二行是$4$个整数，表示$C$和$D$的坐标，分别为$C_x,C_y,D_x,D_y$。<br>第三行是$3$个整数，分别是$P,Q,R$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出数据为一行，表示$\mathrm{lxhgww}$从$A$点走到$D$点的最短时间，保留到小数点后$2$位。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 100</span><br><span class="line">100 0 100 100</span><br><span class="line">2 2 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">136.60</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于$100\%$的数据，$1\le A_x,A_y,B_x,B_y,C_x,C_y,D_x,D_y\le10^3$，$1\le P,Q,R\le10$。</p><p>标签：<code>三分法</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>三分套三分，据说有大学物理结论可以$\mathrm{O(1)}$做…<br>首先一定是从$A$走到$AB$上的一点$E$，然后走平面到$CD$上的一点$F$，最后从$F$沿$CD$走到$D$。<br>考虑确定$AB$上的$E$点，那么若将$F$点的所有位置都计算答案并画成函数图像，一定是一个单峰函数。那么确定$E$后可以三分法找到最佳$F$位置。<br>同样地，对于每个$E$位置的最佳答案，也会呈一个单峰函数。因此可以先对$E$在$AB$上进行三分，每次三分到的两个端点需要再对$F$在$CD$上进行三分找到最小时间。<br>这样一来，可以先在$AB$上三分$E$，每次三分找端点最值的时候再在$CD$上三分$F$，三分套三分即可找到答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xx first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> yy second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pdd pair<span class="meta-string">&lt;dnt,dnt&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line">pdd A, B, C, D;dnt P, Q, R;</span><br><span class="line"><span class="function">dnt <span class="title">sqr</span><span class="params">(dnt x)</span> </span>&#123;<span class="keyword">return</span> x*x;&#125;</span><br><span class="line"><span class="function">dnt <span class="title">dis</span><span class="params">(pdd x, pdd y)</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(sqr(x.xx-y.xx)+sqr(x.yy-y.yy));&#125;</span><br><span class="line"><span class="function">dnt <span class="title">tri_search_T</span><span class="params">(pdd l, pdd r, pdd S)</span> </span>&#123;</span><br><span class="line">dnt ret = dis(A, S)/dis(l, D)/Q+dis(S, l)/R;pdd llr, lrr;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(l.xx-r.xx) &gt; EPS || <span class="built_in">fabs</span>(l.yy-r.yy) &gt; EPS) &#123;</span><br><span class="line">llr = mp(l.xx+(r.xx-l.xx)/<span class="number">3</span>, l.yy+(r.yy-l.yy)/<span class="number">3</span>);</span><br><span class="line">lrr = mp(r.xx-(r.xx-l.xx)/<span class="number">3</span>, r.yy-(r.yy-l.yy)/<span class="number">3</span>);</span><br><span class="line">dnt tllr = dis(A, S)/P+dis(llr, D)/Q+dis(S, llr)/R;</span><br><span class="line">dnt tlrr = dis(A, S)/P+dis(lrr, D)/Q+dis(S, lrr)/R;</span><br><span class="line"><span class="keyword">if</span> (tllr &lt; tlrr) r = lrr; <span class="keyword">else</span> l = llr;</span><br><span class="line">ret = min(tllr, tlrr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">dnt <span class="title">tri_search_S</span><span class="params">(pdd l, pdd r)</span> </span>&#123;</span><br><span class="line">dnt ret = tri_search_T(C, D, l);pdd llr, lrr;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">fabs</span>(l.xx-r.xx) &gt; EPS || <span class="built_in">fabs</span>(l.yy-r.yy) &gt; EPS) &#123;</span><br><span class="line">llr = mp(l.xx+(r.xx-l.xx)/<span class="number">3</span>, l.yy+(r.yy-l.yy)/<span class="number">3</span>);</span><br><span class="line">lrr = mp(r.xx-(r.xx-l.xx)/<span class="number">3</span>, r.yy-(r.yy-l.yy)/<span class="number">3</span>);</span><br><span class="line">dnt tllr = tri_search_T(C, D, llr);</span><br><span class="line">dnt tlrr = tri_search_T(C, D, lrr);</span><br><span class="line"><span class="keyword">if</span> (tllr &lt; tlrr) r = lrr; <span class="keyword">else</span> l = lrr;</span><br><span class="line">ret = min(tllr, tlrr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(A.xx), read(A.yy), read(B.xx), read(B.yy);</span><br><span class="line">read(C.xx), read(C.yy), read(D.xx), read(D.yy);</span><br><span class="line">read(P), read(Q), read(R);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%.2lf\n"</span>, tri_search_S(A, B)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2010】传送带&quot;&gt;&lt;a href=&quot;#【SCOI2010】传送带&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2010】传送带&quot;&gt;&lt;/a&gt;【SCOI2010】传送带&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;1\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在一个$2$维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段$AB$和线段$CD$。&lt;br&gt;$\mathrm{lxhgww}$在$AB$上的移动速度为$P$，在$CD$上的移动速度为$Q$，在平面上的移动速度$R$。&lt;br&gt;现在$\mathrm{lxhgww}$想从$A$点走到$D$点，他想知道最少需要走多长时间。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入数据第一行是$4$个整数，表示$A$和$B$的坐标，分别为$A_x,A_y,B_x,B_y$。&lt;br&gt;第二行是$4$个整数，表示$C$和$D$的坐标，分别为$C_x,C_y,D_x,D_y$。&lt;br&gt;第三行是$3$个整数，分别是$P,Q,R$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出数据为一行，表示$\mathrm{lxhgww}$从$A$点走到$D$点的最短时间，保留到小数点后$2$位。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="三分法" scheme="http://azrael.top/tags/%E4%B8%89%E5%88%86%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3597【SCOI2014】方伯伯运椰子 &lt;费用流&gt;</title>
    <link href="http://azrael.top/BZOJ3597%E3%80%90SCOI2014%E3%80%91%E6%96%B9%E4%BC%AF%E4%BC%AF%E8%BF%90%E6%A4%B0%E5%AD%90%20%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ3597【SCOI2014】方伯伯运椰子 费用流/</id>
    <published>2018-03-14T16:00:00.000Z</published>
    <updated>2018-03-16T06:17:24.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2014】方伯伯运椰子"><a href="#【SCOI2014】方伯伯运椰子" class="headerlink" title="【SCOI2014】方伯伯运椰子"></a>【SCOI2014】方伯伯运椰子</h3><p>$\mathrm{Time\;Limit:\;30\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="http://www.lydsy.com/JudgeOnline/upload/201503/f1.PNG" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含二个整数$N$,$M$。<br>接下来$M$行代表$M$条边，表示这个交通网络。<br>每行六个整数，表示$U_i,V_i,A_i,B_i,C_i,D_i$。<br>接下来一行包含一条边，表示连接起点的边。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个浮点数，保留二位小数。表示答案，数据保证答案大于$0$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">1 5 13 13 0 412</span><br><span class="line">2 5 30 18 396 148</span><br><span class="line">1 5 33 31 0 39</span><br><span class="line">4 5 22 4 0 786</span><br><span class="line">4 5 13 32 0 561</span><br><span class="line">4 5 3 48 0 460</span><br><span class="line">2 5 32 47 604 258</span><br><span class="line">5 7 44 37 75 164</span><br><span class="line">5 7 34 50 925 441</span><br><span class="line">6 2 26 38 1000 22</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">103.00</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N\le5000$，$0\le M\le3000$，$1\le U_i,V_i\le N+2$，$0\le A_i,B_i\le500$，$0\le C_i\le10000$，$0\le D_i\le1000$。</p><p>标签：<code>费用流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>妙不可言的费用流。</p><p>首先肯定需要二分答案，设当前答案是$tans$，那么第$i$条边压缩$1$流量花费$a_i-d_i+tans$，扩容$1$流量花费$b_i+d_i+tans$。</p><p>对于二分后的$check$，发现修改的同时维护流量守恒比较麻烦，不妨考虑先将所有流量都退掉，随后再逐一把不用退的流量增广回来，这样每次增广都可以保证流量守恒。那么初始费用为$\sum_{i=1}^{m}(a_i-d_i+tans)\times c_i$。</p><p>建模：<br>对于原图的第$i$条边：</p><ul><li>$u_i\to v_i$，流量$c_i$，费用$-(a_i-d_i+tans)$</li><li>若$u_i\ne S$，则$u_i\to v_i$，流量$\infty$，费用$(b_i+d_i+tans)$</li></ul><p>这样跑最小费用最大流后判断$初始费用+最小增广费用&lt;0$是否成立即可判断是否有$X-Y\ge0$。</p><p>正确性：<br>由于跑费用流，会优先增广费用小的边，而$(b_i+d_i+tans)-[-(a_i-d_i+tans)]=a_i+b_i+2\times tans\ge 0$，因此第一类边比第二类边小，一定会先走第一类边补到原先流量后再继续走第二类边扩容。</p><p>本文参考<a href="https://www.cnblogs.com/qt666/p/6863985.html" target="_blank" rel="noopener">$qt66$的题解</a>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EPS 1e-5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)/2)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt; dnt w;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> u, v, a, b, c, d;&#125; e[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];dnt mic, tot;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = n+<span class="number">1</span>, t = n+<span class="number">2</span>, cnt = <span class="number">0</span>, mic = tot = <span class="number">0.0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, dnt w)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u], w&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, dnt w)</span> </span>&#123;insert(u, v, c, w), insert(v, u, <span class="number">0</span>, -w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;<span class="keyword">bool</span> inq[MAX_N+<span class="number">5</span>];<span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">dnt d[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> cr[MAX_N+<span class="number">5</span>];<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; i++) d[i] = INF;</span><br><span class="line">d[s] = <span class="number">0</span>, que.push(s), inq[s] = <span class="literal">true</span>, <span class="built_in">memset</span>(cr, <span class="number">-1</span>, <span class="keyword">sizeof</span> cr);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop(), inq[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;dnt w = E[i].w;</span><br><span class="line"><span class="keyword">if</span> (c &amp;&amp; d[u]+w &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u]+w, cr[v] = i;</span><br><span class="line"><span class="keyword">if</span> (!inq[v]) que.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(d[t]-INF) &lt;= EPS) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">int</span> flow = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) flow = min(flow, E[i].c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) E[i].c -= flow, E[i^<span class="number">1</span>].c += flow;</span><br><span class="line">mic += <span class="number">1.0</span>*flow*d[t];<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(dnt tans)</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">addedge(e[i].u, e[i].v, e[i].c, e[i].d-e[i].a-tans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="keyword">if</span> (e[i].u^s)</span><br><span class="line">addedge(e[i].u, e[i].v, INF, e[i].b+e[i].d+tans);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">tot += (e[i].a-e[i].d+tans)*e[i].c;</span><br><span class="line"><span class="keyword">while</span> (SPFA()) ;<span class="keyword">return</span> tot+mic &lt;= -EPS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">dnt <span class="title">bi_search</span><span class="params">(dnt l, dnt r)</span> </span>&#123;</span><br><span class="line">dnt ret = <span class="number">-1.0</span>;</span><br><span class="line"><span class="keyword">while</span> (r-l &gt;= EPS)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> ret = mid, l = mid;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">read(e[i].u), read(e[i].v), read(e[i].a), </span><br><span class="line">read(e[i].b), read(e[i].c), read(e[i].d);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%.2lf"</span>, bi_search(<span class="number">0.0</span>, <span class="number">30000.0</span>)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2014】方伯伯运椰子&quot;&gt;&lt;a href=&quot;#【SCOI2014】方伯伯运椰子&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2014】方伯伯运椰子&quot;&gt;&lt;/a&gt;【SCOI2014】方伯伯运椰子&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;30\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;http://www.lydsy.com/JudgeOnline/upload/201503/f1.PNG&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含二个整数$N$,$M$。&lt;br&gt;接下来$M$行代表$M$条边，表示这个交通网络。&lt;br&gt;每行六个整数，表示$U_i,V_i,A_i,B_i,C_i,D_i$。&lt;br&gt;接下来一行包含一条边，表示连接起点的边。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一个浮点数，保留二位小数。表示答案，数据保证答案大于$0$。&lt;br&gt;
    
    </summary>
    
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="费用流" scheme="http://azrael.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4443【SCOI2015】小凸玩矩阵 &lt;二分+网络流&gt;</title>
    <link href="http://azrael.top/BZOJ4443%E3%80%90SCOI2015%E3%80%91%E5%B0%8F%E5%87%B8%E7%8E%A9%E7%9F%A9%E9%98%B5%20%E4%BA%8C%E5%88%86+%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ4443【SCOI2015】小凸玩矩阵 二分+网络流/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-03-16T06:14:21.559Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2015】小凸玩矩阵"><a href="#【SCOI2015】小凸玩矩阵" class="headerlink" title="【SCOI2015】小凸玩矩阵"></a>【SCOI2015】小凸玩矩阵</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小凸和小方是好朋友，小方给小凸一个$N\times M\;(N\le M)$的矩阵$A$,要求小秃从其中选出$N$个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的$N$个数中第$K$大的数字的最小值是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行给出三个整数$N,M,K$<br>接下来$N$行，每行$M$个数字，用来描述这个矩阵</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示第$K$大数字的最小值<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 4 2</span><br><span class="line">1 5 6 6 </span><br><span class="line">8 3 4 3</span><br><span class="line">6 8 6 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le K\le N\le M\le250,\;1\le 矩阵元素\le10^9$</p><p>标签：<code>二分答案</code> <code>网络流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>套路$二分+网络流匹配验证$。</p><p>二分第$K$大数的值，将所有$A[i][j]\le tans$的位置加入网络流图中 。<br>建模：给每行每列设一个点，初始$S\to行_i\;(i\in[1,n])$流量$1$，$列_j\to T\;(j\in[1,m])$流量$1$。如果$A[i][j]\le tans$，则连边$行_i\to列_j$，流量$1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x7f7f7f7f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, mx, s, t, cnt, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>];<span class="keyword">int</span> mat[<span class="number">255</span>][<span class="number">255</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;cnt = <span class="number">0</span>, s = <span class="number">0</span>, t = n+m+<span class="number">1</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que;que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front();que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>;cpy();<span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec();<span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> tans)</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(s, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) addedge(i+n, t, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line"><span class="keyword">if</span> (mat[i][j] &lt;= tans) addedge(i, j+n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Dinic() &gt;= n-k+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = mid, r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">read(mat[i][j]), mx = max(mat[i][j], mx);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bi_search(<span class="number">0</span>, mx)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2015】小凸玩矩阵&quot;&gt;&lt;a href=&quot;#【SCOI2015】小凸玩矩阵&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2015】小凸玩矩阵&quot;&gt;&lt;/a&gt;【SCOI2015】小凸玩矩阵&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;小凸和小方是好朋友，小方给小凸一个$N\times M\;(N\le M)$的矩阵$A$,要求小秃从其中选出$N$个数，其中任意两个数字不能在同一行或同一列，现小凸想知道选出来的$N$个数中第$K$大的数字的最小值是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行给出三个整数$N,M,K$&lt;br&gt;接下来$N$行，每行$M$个数字，用来描述这个矩阵&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个整数，表示第$K$大数字的最小值&lt;br&gt;
    
    </summary>
    
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分答案" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3594【SCOI2014】方伯伯的玉米田 &lt;树状数组优化DP&gt;</title>
    <link href="http://azrael.top/BZOJ3594%E3%80%90SCOI2014%E3%80%91%E6%96%B9%E4%BC%AF%E4%BC%AF%E7%9A%84%E7%8E%89%E7%B1%B3%E7%94%B0%20%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E4%BC%98%E5%8C%96DP/"/>
    <id>http://azrael.top/BZOJ3594【SCOI2014】方伯伯的玉米田 树状数组优化DP/</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-03-18T07:20:28.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2014】方伯伯的玉米田"><a href="#【SCOI2014】方伯伯的玉米田" class="headerlink" title="【SCOI2014】方伯伯的玉米田"></a>【SCOI2014】方伯伯的玉米田</h3><p>$\mathrm{Time\;Limit:\;60\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。<br>这排玉米一共有$N$株，它们的高度参差不齐。<br>方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。<br>方伯伯可以选择一个区间，把这个区间的玉米全部拔高$1$单位高度，他可以进行最多$K$次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。<br>问能最多剩多少株玉米，来构成一排美丽的玉米。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第$1$行包含$2$个整数$N,K$，分别表示这排玉米的数目以及最多可进行多少次操作。<br>第$2$行包含$N$个整数，第$i$个数表示这排玉米，从左到右第$i$株玉米的高度$a_i$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$1$个整数，最多剩下的玉米数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">2 1 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>$1&lt;N&lt;10^4,\;1&lt;K\le500,\;1\le a_i\le5000$</p><p>标签：<code>DP</code> <code>树状数组</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>首先，显然每次拔高时，不管从哪里开始拔，区间右边界总是$N$肯定不会使答案变小。有此贪心后，考虑到第$i$株时前面拔高$j$次，那么第$i$株一定也已拔高$j$次。</p><p>令$f[i][j]$表示考虑前$i$株，共拔高了$j$次，最多可以剩下多少。那么有<br>$$<br>f[i][j]=\max{f[p][q]}+1\;\;\;\;(p&lt;i,\;q\le j,\;a[p]+q\le a[i]+j)<br>$$<br>对于$\mathrm{DP}$值$f[x][y]$，将其坐标设为$(x,a[x]+y)$，那么$\mathrm{DP}$到$f[i][j]$时，需要找的是坐标在$(0,0)\sim(j,a[i]+j-1)$范围内的最小值，可以二维树状数组维护。</p><p>注意$\mathrm{DP}$时第二层循环要倒着循环，以排除后效性，由于二维树状数组的坐标范围不能到$0$，可以把所有坐标的横纵值强行加$1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_A 5500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 500</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, a[MAX_N+<span class="number">5</span>], tr[MAX_M+<span class="number">5</span>][MAX_A+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = p; i &lt;= MAX_M+<span class="number">1</span>; i += (i&amp;-i))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = q; j &lt;= MAX_A; j += (j&amp;-j))</span><br><span class="line">tr[i][j] = max(tr[i][j], c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = p; i; i -= (i&amp;-i))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = q; j; j -= (j&amp;-j))</span><br><span class="line">ret = max(ret, tr[i][j]);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);<span class="keyword">int</span> f, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = m; ~j; j--)</span><br><span class="line">ans = max(ans, f = query(j+<span class="number">1</span>, a[i]+j)+<span class="number">1</span>), modify(j+<span class="number">1</span>, a[i]+j, f);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2014】方伯伯的玉米田&quot;&gt;&lt;a href=&quot;#【SCOI2014】方伯伯的玉米田&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2014】方伯伯的玉米田&quot;&gt;&lt;/a&gt;【SCOI2014】方伯伯的玉米田&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;60\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;方伯伯在自己的农田边散步，他突然发现田里的一排玉米非常的不美。&lt;br&gt;这排玉米一共有$N$株，它们的高度参差不齐。&lt;br&gt;方伯伯认为单调不下降序列很美，所以他决定先把一些玉米拔高，再把破坏美感的玉米拔除掉，使得剩下的玉米的高度构成一个单调不下降序列。&lt;br&gt;方伯伯可以选择一个区间，把这个区间的玉米全部拔高$1$单位高度，他可以进行最多$K$次这样的操作。拔玉米则可以随意选择一个集合的玉米拔掉。&lt;br&gt;问能最多剩多少株玉米，来构成一排美丽的玉米。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第$1$行包含$2$个整数$N,K$，分别表示这排玉米的数目以及最多可进行多少次操作。&lt;br&gt;第$2$行包含$N$个整数，第$i$个数表示这排玉米，从左到右第$i$株玉米的高度$a_i$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$1$个整数，最多剩下的玉米数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="树状数组" scheme="http://azrael.top/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3998【TJOI2015】弦论 &lt;后缀自动机&gt;</title>
    <link href="http://azrael.top/BZOJ3998%E3%80%90TJOI2015%E3%80%91%E5%BC%A6%E8%AE%BA%20%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://azrael.top/BZOJ3998【TJOI2015】弦论 后缀自动机/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-16T06:16:08.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【TJOI2015】弦论"><a href="#【TJOI2015】弦论" class="headerlink" title="【TJOI2015】弦论"></a>【TJOI2015】弦论</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>对于一个给定长度为$N$的字符串，求它的第$K$小子串是什么。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是一个仅由小写英文字母构成的字符串$S$。<br>第二行为两个整数$T$和$K$，$T$为$0$则表示不同位置的相同子串算作一个，$T=1$则表示不同位置的相同子串算作多个。$K$的意义如题所述。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出仅一行，为一个数字串，为第$K$小的子串。如果子串数目不足$K$个，则输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aabc</span><br><span class="line">0 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aab</span><br></pre></td></tr></table></figure><p>标签：<code>后缀自动机</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>后缀自动机的模板题。</p><p>对于两个询问的找到第$K$大，预处理出从每个状态节点向后有多少种符合规则的字符串，然后每次选择走哪个字符即可。</p><p>关于预处理：</p><ul><li>对于$T=0$，即计算后缀自动机所形成的$DAG$上有多少条从初始状态出发路径，将每一个状态节点初值赋为$1$后按拓扑序在$DAG$上$DP$即可。</li><li>对于$T=1$，类似上面，也是按拓扑序在$DAG$上作$DP$，只是此时只有表示原字符串每个前缀结束状态的节点的初值为$1$。</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s[MAX_N+<span class="number">5</span>];<span class="keyword">int</span> l, T, K, tot[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> rt, sz, lst, val[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>], sum[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> ch[<span class="number">26</span>], len, par;&#125; SAM[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> _len)</span> </span>&#123;SAM[++sz].len = _len; <span class="keyword">return</span> sz;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;sz = <span class="number">0</span>, rt = lst = newnode(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = lst, np = newnode(SAM[p].len+<span class="number">1</span>); lst = np, val[np] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !SAM[p].ch[c]; p = SAM[p].par) SAM[p].ch[c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;SAM[np].par = rt; <span class="keyword">return</span>;&#125;<span class="keyword">int</span> q = SAM[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (SAM[q].len == SAM[p].len+<span class="number">1</span>) &#123;SAM[np].par = q; <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> nq = newnode(SAM[p].len+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">memcpy</span>(SAM[nq].ch, SAM[q].ch, <span class="keyword">sizeof</span> SAM[q].ch);</span><br><span class="line">SAM[nq].par = SAM[q].par, SAM[q].par = SAM[np].par = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; SAM[p].ch[c] == q; p = SAM[p].par) SAM[p].ch[c] = nq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prt</span><span class="params">(<span class="keyword">int</span> c, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= val[c]) <span class="keyword">return</span> <span class="number">1</span>;k -= val[c];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span> &amp;&amp; k &gt; <span class="number">0</span>; k -= sum[SAM[c].ch[i++]])</span><br><span class="line"><span class="keyword">if</span> (SAM[c].ch[i] &amp;&amp; k &lt;= sum[SAM[c].ch[i]])</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">'a'</span>+i), prt(SAM[c].ch[i], k);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> que[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];init();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, s, &amp;T, &amp;K), l = (<span class="keyword">int</span>)<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) insert(s[i]-<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) tot[SAM[i].len]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; i++) tot[i] += tot[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i; i--) que[tot[SAM[i].len]--] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i; i--)</span><br><span class="line"><span class="keyword">if</span> (!T) val[que[i]] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> val[SAM[que[i]].par] += val[que[i]];</span><br><span class="line">val[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= sz; i++) sum[i] = val[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = sz; i; i--) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">sum[que[i]] += sum[SAM[que[i]].ch[j]];</span><br><span class="line"><span class="keyword">return</span> (K &gt; sum[rt] ? <span class="built_in">puts</span>(<span class="string">"-1"</span>) : prt(rt, K)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【TJOI2015】弦论&quot;&gt;&lt;a href=&quot;#【TJOI2015】弦论&quot; class=&quot;headerlink&quot; title=&quot;【TJOI2015】弦论&quot;&gt;&lt;/a&gt;【TJOI2015】弦论&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;对于一个给定长度为$N$的字符串，求它的第$K$小子串是什么。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行是一个仅由小写英文字母构成的字符串$S$。&lt;br&gt;第二行为两个整数$T$和$K$，$T$为$0$则表示不同位置的相同子串算作一个，$T=1$则表示不同位置的相同子串算作多个。$K$的意义如题所述。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出仅一行，为一个数字串，为第$K$小的子串。如果子串数目不足$K$个，则输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="字符串" scheme="http://azrael.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://azrael.top/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4516【SHOI2016】生成魔咒 &lt;后缀自动机&gt;</title>
    <link href="http://azrael.top/BZOJ4516%E3%80%90SHOI2016%E3%80%91%E7%94%9F%E6%88%90%E9%AD%94%E5%92%92%20%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    <id>http://azrael.top/BZOJ4516【SHOI2016】生成魔咒 后缀自动机/</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-21T14:42:24.400Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="BZOJ4516【SHOI2016】生成魔咒"><a href="#BZOJ4516【SHOI2016】生成魔咒" class="headerlink" title="BZOJ4516【SHOI2016】生成魔咒"></a>BZOJ4516【SHOI2016】生成魔咒</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1$,$2$ 拼凑起来形成一个魔咒串 $[1,2]$。<br>一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1]$,$[2]$,$[1,2]$,$[2,1]$,$[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1]$,$[1,1]$,$[1,1,1]$ 三种。<br>最初 $S$ 为空串。共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行一个整数 $n$。<br>第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符<br>$1\le n\le100000$，用来表示魔咒字符的数字 $x$ 满足 $1\le x\le10^9$</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出 $n$ 行，每行一个数。第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 3 3 3 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">9</span><br><span class="line">12</span><br><span class="line">17</span><br><span class="line">22</span><br></pre></td></tr></table></figure><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>鸣谢<code>Menci</code>上传</p><p>标签：<code>后缀自动机</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>后缀自动机的模板题。</p><p>按题意增量构建后缀自动机，考虑每次新增的一位能构成多少新串，贡献计入答案。</p><p>对于每次新增的结点$np$，若其在$parent$树上的父亲为$par$，那么前面有若干条路走到$par$从而得到的字符串与其走到$np$得到的字符串相同。由于走到$par$的字符串个数是$len_{par}$，走到$np$的字符串个数是$len_{np}$。因此新增字符串个数是$len_{np}-len_{par}$。维护即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mii map<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, rt, sz, lst;lnt ans;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>mii ch; <span class="keyword">int</span> len, par;&#125; SAM[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">newnode</span><span class="params">(<span class="keyword">int</span> _len)</span> </span>&#123;SAM[++sz].len = _len; <span class="keyword">return</span> sz;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;sz = <span class="number">0</span>, rt = lst = newnode(<span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = lst, np = newnode(SAM[p].len+<span class="number">1</span>);lst = np;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; !SAM[p].ch[c]; p = SAM[p].par) SAM[p].ch[c] = np;</span><br><span class="line"><span class="keyword">if</span> (!p) &#123;SAM[np].par = rt; <span class="keyword">return</span>;&#125;<span class="keyword">int</span> q = SAM[p].ch[c];</span><br><span class="line"><span class="keyword">if</span> (SAM[q].len == SAM[p].len+<span class="number">1</span>) &#123;SAM[np].par = q; <span class="keyword">return</span>;&#125;</span><br><span class="line"><span class="keyword">int</span> nq = newnode(SAM[p].len+<span class="number">1</span>); SAM[nq].ch = SAM[q].ch;</span><br><span class="line">SAM[nq].par = SAM[q].par, SAM[q].par = SAM[np].par = nq;</span><br><span class="line"><span class="keyword">for</span> (; p &amp;&amp; SAM[p].ch[c] == q; p = SAM[p].par) SAM[p].ch[c] = nq;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">upd</span><span class="params">()</span> </span>&#123;ans += SAM[lst].len-SAM[SAM[lst].par].len;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, x; i &lt; n; i++)</span><br><span class="line">read(x), insert(x), upd(), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;BZOJ4516【SHOI2016】生成魔咒&quot;&gt;&lt;a href=&quot;#BZOJ4516【SHOI2016】生成魔咒&quot; class=&quot;headerlink&quot; title=&quot;BZOJ4516【SHOI2016】生成魔咒&quot;&gt;&lt;/a&gt;BZOJ4516【SHOI2016】生成魔咒&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1$,$2$ 拼凑起来形成一个魔咒串 $[1,2]$。&lt;br&gt;一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1]$,$[2]$,$[1,2]$,$[2,1]$,$[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1]$,$[1,1]$,$[1,1,1]$ 三种。&lt;br&gt;最初 $S$ 为空串。共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行一个整数 $n$。&lt;br&gt;第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符&lt;br&gt;$1\le n\le100000$，用来表示魔咒字符的数字 $x$ 满足 $1\le x\le10^9$&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出 $n$ 行，每行一个数。第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="字符串" scheme="http://azrael.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="后缀自动机" scheme="http://azrael.top/tags/%E5%90%8E%E7%BC%80%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4569【SCOI2016】萌萌哒 &lt;并查集+ST表&gt;</title>
    <link href="http://azrael.top/BZOJ4569%E3%80%90SCOI2016%E3%80%91%E8%90%8C%E8%90%8C%E5%93%92%20%E5%B9%B6%E6%9F%A5%E9%9B%86+ST%E8%A1%A8/"/>
    <id>http://azrael.top/BZOJ4569【SCOI2016】萌萌哒 并查集+ST表/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-03-10T15:13:56.429Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2016】萌萌哒"><a href="#【SCOI2016】萌萌哒" class="headerlink" title="【SCOI2016】萌萌哒"></a>【SCOI2016】萌萌哒</h3><p>Time Limit: $20 Sec$<br>Memory Limit: $256 MB$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一个长度为$n$的大数，用$S_1S_2S_3\cdots S_n$表示，其中$S_i$表示数的第$i$位，$S_1$是数的最高位，告诉你一些限制条件，每个条件表示为四个数，$l_1$，$r_1$，$l_2$，$r_2$，即两个长度相同的区间，表示子串$S_{l_1}S_{l_1+1}S_{l_1+2}\cdots S_{r_1}$与$S_{l_2}S_{l_2+1}S_{l_2+2}\cdots S_{r_2}$完全相同。比如$n=6$时，某限制条件$l_1=1$，$r_1=3$，$l_2=4$，$r_2=6$，那么$123123$，$351351$均满足条件，但是$12012$，$131141$不满足条件，前者数的长度不为$6$，后者第二位与第五位不同。问满足以上所有条件的数有多少个。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行两个数$n$和$m$，分别表示大数的长度，以及限制条件的个数。接下来$m$行，对于第$i$行，有$4$个数$l_{i_1}$，$r_{i_1}$，$l_{i_2}$，$r_{i_2}$，分别表示该限制条件对应的两个区间。<br>$1\le n\le 10^5$，$1\le m\le 10^5$，$1\le l_{i_1},r_{i_1},l_{i_2},r_{i_2}\le n$；并且保证$r_{i_1}-l_{i_1}=r_{i_2}-l_{i_2}$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>一个数，表示满足所有条件且长度为$n$的大数的个数，答案可能很大，因此输出答案模$10^9+7$的结果即可。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 2 3 4 </span><br><span class="line">3 3 3 3</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure><p>标签：<code>并查集</code> <code>ST表</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>好题，把基础数据结构玩出了新花样。</p><p>首先朴素思想是用并查集维护每位的相同关系，每次暴力合并，最后统计有几个集合就有几个自由元。若有$cnt$个集合，那么答案为$Ans=9\times10^{cnt-1}$。</p><p>发现我们花费了很多时间再合并上，考虑用带$\log$数据结构优化合并。这里需要用到$ST$表。<br>考虑存$\log{n}$组并查集，第$i$组并查集的第$j$个元素维护的是区间$[j,j+2^i]$与其他长度为$2^i$的区间是否相同。这样对于关系$S_{l_1\sim r_1}=S_{l_2\sim r_2}$，令$len=r_1-l_1=r_2-l_2$，等同于$S_{l_1\sim(l_1+2^{\log{len}})}=S_{l_2\sim(l_2+2^{\log{len}})}$和$S_{(r_1-2^{\log{len}})\sim r_1}=S_{(r_2-2^{\log{len}})\sim r_2}$，那么合并第$\log{len}$组并查集中的$l_1$和$l_2$、第$\log{len}$组并查集中的$r_1-2^{\log{len}}$和$r_2-2^{\log{len}}$即可。随后像$ST$表一样自大区间向小区间合并信息，可得出最后的集合个数，计算答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, LOG2[MAX_N+<span class="number">5</span>], fa[LOG][MAX_N+<span class="number">5</span>];lnt ans = <span class="number">9L</span>L;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> d, <span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[d][x] == x ? x : fa[d][x] = getf(d, fa[d][x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) LOG2[i] = LOG2[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; LOG; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) fa[i][j] = j;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, l1, l2, e1, e2, l, d; i &lt; m; i++) &#123;</span><br><span class="line">read(l1), read(e1), read(l2), read(e2), l = e1-l1+<span class="number">1</span>, d = LOG2[l];</span><br><span class="line"><span class="keyword">if</span> (getf(d, l1)^getf(d, l2)) fa[d][fa[d][l1]] = fa[d][l2];</span><br><span class="line"><span class="keyword">if</span> (getf(d, l1+l-(<span class="number">1</span>&lt;&lt;d))^getf(d, l2+l-(<span class="number">1</span>&lt;&lt;d)))</span><br><span class="line">fa[d][fa[d][l1+l-(<span class="number">1</span>&lt;&lt;d)]] = fa[d][l2+l-(<span class="number">1</span>&lt;&lt;d)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG2[n]; i; i--) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n-(<span class="number">1</span>&lt;&lt;i)+<span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (getf(i<span class="number">-1</span>, j)^getf(i<span class="number">-1</span>, getf(i, j))) fa[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][j]] = fa[i<span class="number">-1</span>][fa[i][j]];</span><br><span class="line"><span class="keyword">if</span> (getf(i<span class="number">-1</span>, j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)))^getf(i<span class="number">-1</span>, getf(i,j)+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))))</span><br><span class="line">fa[i<span class="number">-1</span>][fa[i<span class="number">-1</span>][j+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))]] = fa[i<span class="number">-1</span>][fa[i][j]+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (getf(<span class="number">0</span>, i) == i) cnt++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; cnt; i++) (ans *= <span class="number">10L</span>L) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2016】萌萌哒&quot;&gt;&lt;a href=&quot;#【SCOI2016】萌萌哒&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2016】萌萌哒&quot;&gt;&lt;/a&gt;【SCOI2016】萌萌哒&lt;/h3&gt;&lt;p&gt;Time Limit: $20 Sec$&lt;br&gt;Memory Limit: $256 MB$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一个长度为$n$的大数，用$S_1S_2S_3\cdots S_n$表示，其中$S_i$表示数的第$i$位，$S_1$是数的最高位，告诉你一些限制条件，每个条件表示为四个数，$l_1$，$r_1$，$l_2$，$r_2$，即两个长度相同的区间，表示子串$S_{l_1}S_{l_1+1}S_{l_1+2}\cdots S_{r_1}$与$S_{l_2}S_{l_2+1}S_{l_2+2}\cdots S_{r_2}$完全相同。比如$n=6$时，某限制条件$l_1=1$，$r_1=3$，$l_2=4$，$r_2=6$，那么$123123$，$351351$均满足条件，但是$12012$，$131141$不满足条件，前者数的长度不为$6$，后者第二位与第五位不同。问满足以上所有条件的数有多少个。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行两个数$n$和$m$，分别表示大数的长度，以及限制条件的个数。接下来$m$行，对于第$i$行，有$4$个数$l_{i_1}$，$r_{i_1}$，$l_{i_2}$，$r_{i_2}$，分别表示该限制条件对应的两个区间。&lt;br&gt;$1\le n\le 10^5$，$1\le m\le 10^5$，$1\le l_{i_1},r_{i_1},l_{i_2},r_{i_2}\le n$；并且保证$r_{i_1}-l_{i_1}=r_{i_2}-l_{i_2}$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;一个数，表示满足所有条件且长度为$n$的大数的个数，答案可能很大，因此输出答案模$10^9+7$的结果即可。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="并查集" scheme="http://azrael.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="ST表" scheme="http://azrael.top/tags/ST%E8%A1%A8/"/>
    
  </entry>
  
</feed>
