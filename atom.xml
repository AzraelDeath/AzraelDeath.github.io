<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NIRVANA</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://azrael.top/"/>
  <updated>2018-05-03T08:54:40.649Z</updated>
  <id>http://azrael.top/</id>
  
  <author>
    <name>Azrael_Death</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BZOJ2006【NOI2010】超级钢琴 &lt;ST表+堆&gt;</title>
    <link href="http://azrael.top/BZOJ2006%E3%80%90NOI2010%E3%80%91%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%20ST%E8%A1%A8/"/>
    <id>http://azrael.top/BZOJ2006【NOI2010】超级钢琴 ST表/</id>
    <published>2018-05-02T16:00:00.000Z</published>
    <updated>2018-05-03T08:54:40.649Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SCOI2016】萌萌哒"><a href="#【SCOI2016】萌萌哒" class="headerlink" title="【SCOI2016】萌萌哒"></a>【SCOI2016】萌萌哒</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;512\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{小Z}$是一个小有名气的钢琴家，最近$\mathrm{C博士}$送给了$\mathrm{小Z}$一架超级钢琴，$\mathrm{小Z}$希望能够用这架钢琴创作出世界上最美妙的音乐。<br>这架超级钢琴可以弹奏出$n$个音符，编号为$1\sim n$。第$i$个音符的美妙度为$A_i$，其中$A_i$可正可负。<br>一个“超级和弦“由若干个编号连续的音符组成，包含的音符个数不少于$L$且不多于$R$。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。<br>$\mathrm{小Z}$决定创作一首由$k$个超级和弦组成的乐曲，为了使得乐曲更加动听，$\mathrm{小Z}$要求该乐曲由$k$个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。$\mathrm{小Z}$想知道他能够创作出来的乐曲美妙度最大值是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含四个正整数$n,k,L,R$。其中$n$为音符的个数，$k$为乐曲所包含的超级和弦个数，$L$和$R$分别是超级和弦所包含音符个数的下限和上限。<br>接下来$n$行，每行包含一个整数$A_i$，表示按编号从小到大每个音符的美妙度。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一个整数，表示乐曲美妙度的最大值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 3 2 3</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">-6</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>共有$5$种不同的超级和弦：<br>音符$1\sim2$，美妙度为$3 + 2 = 5$<br>音符$2\sim3$，美妙度为$2 + (-6) = -4$<br>音符$3\sim4$，美妙度为$(-6) + 8 = 2$<br>音符$1\sim3$，美妙度为$3 + 2 + (-6) = -1$<br>音符$2\sim4$，美妙度为$2 + (-6) + 8 = 4$<br>最优方案为：乐曲由和弦$1$,和弦$3$,和弦$5$组成，美妙度为$5 + 2 + 4 = 11$。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$N\le5\times10^5$，$k\le5\times10^5$，$-1000\le A_i\le1000$，$1\le L\le R\le N$<br>数据保证一定存在满足条件的乐曲</p><p>标签：<code>堆</code> <code>ST表</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>经典线段树例题，不过我用的是一种精妙的<code>ST表</code>。</p><p>找出第$k$大的差值，可以用一个堆维护，每次弹出堆顶。<br>首先将区间和处理为前缀和，这样问题变为给出一个数组$\lbrace s_n\rbrace$，求第$k$大的$s_i-s_j$，其中$i,j\in[1,n],\;i-R\le j\le i-L$。<br>考虑对于一个确定的$s_j$，使差值最大的$s_i$一定是$s_{i-R}\sim s_{i-L}$中的最小值，这个最小值可以在$O(1)$时间内用<code>ST表</code>找到。这个值取完后，对于其他以$j$作为终点的区间可以分成两部分，一部分为起点在$i-R\sim j-1$间的区间，另一部分为起点在$j+1\sim i-L$的区间，在这两个区间中分别找最大值插入堆中。<br>对于以每个位置为右端点的区间，我们维护四元组$(p,l,r,val)$，代表右端点位置，左端点的左右界，以及在此左右界中的最大差值。一开始插入以每个位置为右端点的区间中和最大的区间，随后每次弹出最大区间，将这个四元组拆成两部分，即若当前四元组为$(p,l,r,val)$，左端点取$t$时得到最大差值，以后不能取$t$，将四元组拆为$(p,l,t-1,val_1)$和$(p,t+1,r,val_2)$，其中$val_1$和$val_2$分别表示左端点在$[l,t-1]$和$[t+1,r]$间时的最大差值。<br>如此即可在$O(n\log{n})$的时间内找到前$k$大差值的和。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG Log[t-s]</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, L, R, s[MAX_N+<span class="number">5</span>], st[MAX_N+<span class="number">5</span>][<span class="number">25</span>], Log[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> p, l, r, val; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> t.val &gt; val;&#125;&#125; ;</span><br><span class="line">priority_queue &lt;node&gt; que;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;<span class="keyword">return</span> s[a] &lt; s[b] ? a : b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;<span class="keyword">return</span> s &gt; t ? <span class="number">-1</span> : Min(st[s][LOG], st[t-(<span class="number">1</span>&lt;&lt;LOG)+<span class="number">1</span>][LOG]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), read(L), read(R); lnt ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) Log[i] = Log[i&gt;&gt;<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(s[i]), s[i] += s[i<span class="number">-1</span>], st[i][<span class="number">0</span>] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; (<span class="number">1</span>&lt;&lt;j) &lt;= n; j++) <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>; i++)</span><br><span class="line">st[i][j] = Min(st[i][j<span class="number">-1</span>], st[i+(<span class="number">1</span>&lt;&lt;(j<span class="number">-1</span>))][j<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= n; i++)</span><br><span class="line">que.push((node)&#123;i, max(i-R, <span class="number">0</span>), i-L, s[i]-s[query(max(i-R, <span class="number">0</span>), i-L)]&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t, p; i &lt;= m; i++) &#123;</span><br><span class="line">node tp = que.top(); que.pop(), ans += tp.val, p = tp.p;</span><br><span class="line"><span class="keyword">int</span> ll = tp.l, rr = tp.r, lr = query(ll, rr)<span class="number">-1</span>, rl = query(ll, rr)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (~(t = query(ll, lr))) que.push((node)&#123;p, ll, lr, s[p]-s[t]&#125;);</span><br><span class="line"><span class="keyword">if</span> (~(t = query(rl, rr))) que.push((node)&#123;p, rl, rr, s[p]-s[t]&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SCOI2016】萌萌哒&quot;&gt;&lt;a href=&quot;#【SCOI2016】萌萌哒&quot; class=&quot;headerlink&quot; title=&quot;【SCOI2016】萌萌哒&quot;&gt;&lt;/a&gt;【SCOI2016】萌萌哒&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;512\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{小Z}$是一个小有名气的钢琴家，最近$\mathrm{C博士}$送给了$\mathrm{小Z}$一架超级钢琴，$\mathrm{小Z}$希望能够用这架钢琴创作出世界上最美妙的音乐。&lt;br&gt;这架超级钢琴可以弹奏出$n$个音符，编号为$1\sim n$。第$i$个音符的美妙度为$A_i$，其中$A_i$可正可负。&lt;br&gt;一个“超级和弦“由若干个编号连续的音符组成，包含的音符个数不少于$L$且不多于$R$。我们定义超级和弦的美妙度为其包含的所有音符的美妙度之和。两个超级和弦被认为是相同的，当且仅当这两个超级和弦所包含的音符集合是相同的。&lt;br&gt;$\mathrm{小Z}$决定创作一首由$k$个超级和弦组成的乐曲，为了使得乐曲更加动听，$\mathrm{小Z}$要求该乐曲由$k$个不同的超级和弦组成。我们定义一首乐曲的美妙度为其所包含的所有超级和弦的美妙度之和。$\mathrm{小Z}$想知道他能够创作出来的乐曲美妙度最大值是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含四个正整数$n,k,L,R$。其中$n$为音符的个数，$k$为乐曲所包含的超级和弦个数，$L$和$R$分别是超级和弦所包含音符个数的下限和上限。&lt;br&gt;接下来$n$行，每行包含一个整数$A_i$，表示按编号从小到大每个音符的美妙度。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;只有一个整数，表示乐曲美妙度的最大值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="NOI" scheme="http://azrael.top/tags/NOI/"/>
    
      <category term="ST表" scheme="http://azrael.top/tags/ST%E8%A1%A8/"/>
    
      <category term="堆" scheme="http://azrael.top/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3219 巡游 &lt;二分答案+点分治+单调队列&gt;</title>
    <link href="http://azrael.top/BZOJ3219%20%E5%B7%A1%E6%B8%B8%20%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88+%E7%82%B9%E5%88%86%E6%B2%BB+%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <id>http://azrael.top/BZOJ3219 巡游 二分答案+点分治+单调队列/</id>
    <published>2018-05-01T16:00:00.000Z</published>
    <updated>2018-05-03T08:31:09.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="巡游"><a href="#巡游" class="headerlink" title="巡游"></a>巡游</h3><p>$\mathrm{Time\;Limit:\;25\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Tar}$国正在准备每年一次的巡游活动。国王将会在一个城市$S$里召集人群，沿着城市间的道路进行游览，最终在一个城市$T$里发表他每年一次的著名演讲。<br>$\mathrm{Tar}$国有$N$个城市，由于国家的特殊要求，每两个城市之间存在一条唯一的简单通路。国王希望借着这个机会视察$\mathrm{Tar}$国的城市建设，因此他提出$S$到$T$的距离不能少于$L$条道路。<br>同时，国王的私人医生检查了他的身体情况后，断定国王的身体不适合做长途旅行，因此他要求$S$到$T$的距离不能多于$R$条道路。<br>另外，政府希望跟随国王的人民沿途不仅能看到城市风景，还能看到城市外的美丽乡村。因此每条道路定义了一个魅力值$C_i$，一条路径的魅力值定义为这条路径的中位数。更详细的说法是这样的：将路径上所有边的魅力值排序，得到序列$\lbrace A_i\rbrace$。假设$i=2k+c\;(0\le c\le 1)$，中位数就是$A_{k+1}$。<br>你的任务就是求出魅力值最大的路径，并输出这个魅力值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行是三个整数$N,L,R$，表示$\mathrm{Tar}$国的城市个数、路径的最小和最大长度。<br>接下来$N-1$行，每行$3$个整数$A_i,B_i,C_i$，表示有一条连接$A_i$和$B_i$且魅力值$C_i$的道路。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅一行，表示最大的魅力值。如果不存在这样的路径，输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 1 4</span><br><span class="line">1 2 1</span><br><span class="line">1 3 4</span><br><span class="line">3 4 7</span><br><span class="line">3 5 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据：$N\le10^5$，$1\le L\le R\le N-1$，$1\le C_i\le10^9$。</p><p>标签：<code>点分治</code> <code>二分答案</code> <code>单调队列</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>稍有码量的点分题。</p><p>首先策略是$二分答案+点分治验证$，二分答案魅力值，将所有的边权变为$1$和$-1$，分别表示大于等于魅力值和小于魅力值。这样验证问题转化为判断是否有一条长度在$[L,R]$间路径使得边权和大于等于$0$。</p><p>这个判断过程可以用点分治实现。对于每个分治中心，只考虑经过其的路径。在其点分树的不同子树中找两个点，使得其到分治中心的路径长度和在$[L,R]$之间，可以用两个桶，分别存已枚举的子树和当前子树中各个深度的最大路径边权和，需要用单调队列维护一下。这部分有些细节需要注意。</p><p>此题卡常，注意一些减小常数的细节：</p><ul><li>二分答案时，将原边权记下来排序，在排好的数组上二分，这样只会二分到边权值</li><li>一开始将点分树记下来，记录所有分治中心，这样每次二分$check$可以不用重新找重心</li><li>点分时在当前分治中心统计答案时用$\mathrm{BFS}$</li><li>预处理点分时在当前分治中心$\mathrm{BFS}$，若下一个点的距离大于$R$则退出</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, L, R, rt, cnt, ind, tot, f[MAX_N+<span class="number">5</span>], g[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pr[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>], w[MAX_N+<span class="number">5</span>], dfn[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> val[MAX_N+<span class="number">5</span>], dep[MAX_N+<span class="number">5</span>], d[MAX_N&lt;&lt;<span class="number">1</span>], ord[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>], vis[MAX_N+<span class="number">5</span>]; <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que, bin;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> v, c, w, nxt;&#125; E[MAX_N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span> </span>&#123;<span class="keyword">return</span> d[x] &lt; d[y];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (edge)&#123;v, c, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>, w[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (((v = E[i].v) ^ fa) &amp;&amp; !mrk[v])</span><br><span class="line">getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]);</span><br><span class="line"><span class="keyword">if</span> ((w[u] = max(w[u], tot-sz[u])) &lt; w[rt]) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; dfn[++ind] = u, mrk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v, mxd = <span class="number">0</span>; ~i; i = E[i].nxt, mxd = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v]) &#123;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">que.push(v), dep[v] = <span class="number">1</span>, vis[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = que.front(); que.pop();</span><br><span class="line"><span class="keyword">if</span> (dep[p] &gt;= R) <span class="keyword">continue</span>; mxd = max(mxd, dep[p]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = pr[p], q; ~j; j = E[j].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[q = E[j].v] &amp;&amp; !vis[q])</span><br><span class="line">que.push(q), dep[q] = dep[p]+<span class="number">1</span>, vis[q] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">d[ord[++num] = i] = mxd;</span><br><span class="line">&#125; <span class="keyword">else</span> d[ord[++num] = i] = n;</span><br><span class="line">sort(ord+<span class="number">1</span>, ord+num+<span class="number">1</span>, cmp), pr[u] = ord[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) E[ord[i]].nxt = ord[i+<span class="number">1</span>];</span><br><span class="line">E[ord[num]].nxt = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (sz[u] &lt; sz[v = E[i].v]) sz[v] = tot-sz[u];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v] &amp;&amp; sz[v] &gt; L)</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = sz[v], getrt(v, u), init(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> stp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (stp &gt; ind) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> u = dfn[stp], mxd = <span class="number">0</span>; f[<span class="number">0</span>] = <span class="number">0</span>, mrk[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = E[i].v]) &#123;</span><br><span class="line"><span class="keyword">int</span> s = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) que.pop();</span><br><span class="line"><span class="keyword">while</span> (!bin.empty()) bin.pop();</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = mxd; j &gt;= L; d[++t] = j--)</span><br><span class="line"><span class="keyword">while</span> (s &lt;= t &amp;&amp; f[d[t]] &lt;= f[j]) t--;</span><br><span class="line">que.push(v), dep[v] = <span class="number">1</span>, g[v] = E[i].c, vis[v] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> p = que.front(); que.pop(), bin.push(p);</span><br><span class="line"><span class="keyword">while</span> (s &lt;= t &amp;&amp; d[s]+dep[p] &gt; R) s++;</span><br><span class="line"><span class="keyword">if</span> (dep[p] &lt;= L) &#123;</span><br><span class="line"><span class="keyword">while</span> (s &lt;= t &amp;&amp; f[d[t]] &lt;= f[L-dep[p]]) t--;</span><br><span class="line">d[++t] = L-dep[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s &lt;= t &amp;&amp; f[d[s]]+g[p] &gt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (dep[p] &gt;= R) <span class="keyword">continue</span>; mxd = max(mxd, dep[p]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = pr[p], q; ~j; j = E[j].nxt)</span><br><span class="line"><span class="keyword">if</span> (!mrk[q = E[j].v] &amp;&amp; !vis[q])</span><br><span class="line">que.push(q), dep[q] = dep[p]+<span class="number">1</span>, </span><br><span class="line">g[q] = g[p]+E[j].c, vis[q] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x; !bin.empty(); bin.pop())</span><br><span class="line">x = bin.front(), f[dep[x]] = max(f[dep[x]], g[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= mxd; i++) f[i] = -n;</span><br><span class="line"><span class="keyword">return</span> DFS(stp+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> tans)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">E[i].c = E[i].w &lt; tans ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) f[i] = -n;</span><br><span class="line"><span class="built_in">memset</span>(mrk, <span class="literal">false</span>, <span class="keyword">sizeof</span> mrk);</span><br><span class="line"><span class="keyword">return</span> DFS(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bi_search</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(val[mid])) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> ret = val[mid], l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(L), read(R), <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt; n; i++)</span><br><span class="line">read(u), read(v), read(c), </span><br><span class="line">addedge(u, v, c), val[i] = c;</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = n, getrt(<span class="number">1</span>, <span class="number">0</span>), init(rt);</span><br><span class="line">sort(val+<span class="number">1</span>, val+n), m = (<span class="keyword">int</span>)(unique(val+<span class="number">1</span>, val+n)-val<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, bi_search(<span class="number">1</span>, m)), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;巡游&quot;&gt;&lt;a href=&quot;#巡游&quot; class=&quot;headerlink&quot; title=&quot;巡游&quot;&gt;&lt;/a&gt;巡游&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;25\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Tar}$国正在准备每年一次的巡游活动。国王将会在一个城市$S$里召集人群，沿着城市间的道路进行游览，最终在一个城市$T$里发表他每年一次的著名演讲。&lt;br&gt;$\mathrm{Tar}$国有$N$个城市，由于国家的特殊要求，每两个城市之间存在一条唯一的简单通路。国王希望借着这个机会视察$\mathrm{Tar}$国的城市建设，因此他提出$S$到$T$的距离不能少于$L$条道路。&lt;br&gt;同时，国王的私人医生检查了他的身体情况后，断定国王的身体不适合做长途旅行，因此他要求$S$到$T$的距离不能多于$R$条道路。&lt;br&gt;另外，政府希望跟随国王的人民沿途不仅能看到城市风景，还能看到城市外的美丽乡村。因此每条道路定义了一个魅力值$C_i$，一条路径的魅力值定义为这条路径的中位数。更详细的说法是这样的：将路径上所有边的魅力值排序，得到序列$\lbrace A_i\rbrace$。假设$i=2k+c\;(0\le c\le 1)$，中位数就是$A_{k+1}$。&lt;br&gt;你的任务就是求出魅力值最大的路径，并输出这个魅力值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行是三个整数$N,L,R$，表示$\mathrm{Tar}$国的城市个数、路径的最小和最大长度。&lt;br&gt;接下来$N-1$行，每行$3$个整数$A_i,B_i,C_i$，表示有一条连接$A_i$和$B_i$且魅力值$C_i$的道路。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅一行，表示最大的魅力值。如果不存在这样的路径，输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="二分答案" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"/>
    
      <category term="树分治" scheme="http://azrael.top/tags/%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
      <category term="单调队列" scheme="http://azrael.top/tags/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4974【Lydsy月赛201708】字符串大师 &lt;KMP+贪心构造&gt;</title>
    <link href="http://azrael.top/BZOJ4974%E3%80%90Lydsy1708%E6%9C%88%E8%B5%9B%E3%80%91%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%A7%E5%B8%88%20KMP+%E8%B4%AA%E5%BF%83%E6%9E%84%E9%80%A0/"/>
    <id>http://azrael.top/BZOJ4974【Lydsy1708月赛】字符串大师 KMP+贪心构造/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-05-02T07:19:00.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【Lydsy1708月赛】字符串大师"><a href="#【Lydsy1708月赛】字符串大师" class="headerlink" title="【Lydsy1708月赛】字符串大师"></a>【Lydsy1708月赛】字符串大师</h3><p>$\mathrm{Time\;Limit:\;1\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一个串$T$是$S$的循环节，当且仅当存在正整数$k$，使得$S$是$T$重复$k$次的前缀，比如<code>abcd</code>是<code>abcdabcdab</code>的循环节。<br>给定一个长度为$n$的仅由小写字符构成的字符串$S$，请对于每个$k\;(1\le k\le n)$，求出$S$长度为$k$的前缀的最短循环节的长度$per_i$。<br>字符串大师$\mathrm{小Q}$觉得这个问题过于简单，于是花了一分钟将其$\mathrm{AC}$了，他想检验你是否也是字符串大师。<br>$\mathrm{小Q}$告诉你$n$以及$per_1,per_2,\cdots,per_n$，请找到一个长度为$n$的小写字符串$S$，使得$S$能对应上$per$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含一个正整数$n\;(1\le n\le10^5)$，表示字符串的长度。<br>第二行包含$n$个正整数$per_1,per_2,\cdots,per_n\;(1\le per_i\le i)$，表示每个前缀的最短循环节长度。<br>输入数据保证至少存在一组可行解。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个长度为$n$的小写字符串$S$，即某个满足条件的$S$。<br>若有多个可行的$S$，输出字典序最小的那一个。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 2 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ababb</span><br></pre></td></tr></table></figure><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p><code>Claris</code>原创，本$\mathrm{OJ}$版权所有，翻版必究</p><p>标签：<code>KMP</code> <code>贪心</code> <code>构造</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{KMP}$好题。</p><p>$\bigstar$本文中所有数组和字符串下标从$0$开始。</p><p>首先有一个结论：$nxt_i=i-per_i$<br>证明：<br>对于字符串$P$，其最短循环节为$R$，除去循环节后多余的部分为$Q$，如图所示。</p><center><br><img src="https://i.loli.net/2018/05/02/5ae96516e82ca.png" alt="1.PNG"><br></center><p>那么再在上面接一个$R$，一定可以包含$P$，于是可以知道$Q$一定是$R$的前缀，所以有下图：</p><center><br><img src="https://i.loli.net/2018/05/02/5ae96516e8d6d.png" alt="2.PNG"><br></center><p>将$P$末尾循环节长度那么长去掉，得到$P_1$，将$P$第一个循环节去掉，得到$P_2$，发现两者是相同的（如下图）。而这显然是$P$的$boarder$，所以$P_1$的末尾位置为$n-per$，即$nxt[n]=n-per$</p><center><br><img src="https://i.loli.net/2018/05/02/5ae965170167b.png" alt="3.PNG"><br></center><p>这样根据给出的$per$可以将$nxt$数组处理出来。<br>从前往后构造，对于位置$i$：</p><ul><li>$nxt_i\ne-1$，一定有$s[i]=s[nxt_i]$，可以直接赋值</li><li>$nxt_i=-1$，那么在计算$nxt$的过程中，即将这个串与自己做匹配的时候，不断根据$nxt$向前跳到的位置一定不会和当前位置匹配，否则$nxt_i=最先能匹配的位置$。于是将能向前跳到的位置上的字符存下来，找一个最小的没有跳到过的字符作为这一位置的字符</li></ul><p>如此贪心构造即可得到最优解。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, nxt[MAX_N+<span class="number">5</span>], s[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) read(nxt[i]), nxt[i] = i-nxt[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt; n; p++) &#123;</span><br><span class="line"><span class="keyword">if</span> (~nxt[p]) s[p] = s[nxt[p]];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">memset</span>(mrk, <span class="literal">false</span>, <span class="keyword">sizeof</span> mrk);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> q = nxt[p<span class="number">-1</span>]; ~q; q = nxt[q])</span><br><span class="line">mrk[s[q+<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt; <span class="number">26</span>; c++)</span><br><span class="line"><span class="keyword">if</span> (!mrk[c]) &#123;s[p] = c; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%c"</span>, <span class="string">'a'</span>+s[i]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【Lydsy1708月赛】字符串大师&quot;&gt;&lt;a href=&quot;#【Lydsy1708月赛】字符串大师&quot; class=&quot;headerlink&quot; title=&quot;【Lydsy1708月赛】字符串大师&quot;&gt;&lt;/a&gt;【Lydsy1708月赛】字符串大师&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;1\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一个串$T$是$S$的循环节，当且仅当存在正整数$k$，使得$S$是$T$重复$k$次的前缀，比如&lt;code&gt;abcd&lt;/code&gt;是&lt;code&gt;abcdabcdab&lt;/code&gt;的循环节。&lt;br&gt;给定一个长度为$n$的仅由小写字符构成的字符串$S$，请对于每个$k\;(1\le k\le n)$，求出$S$长度为$k$的前缀的最短循环节的长度$per_i$。&lt;br&gt;字符串大师$\mathrm{小Q}$觉得这个问题过于简单，于是花了一分钟将其$\mathrm{AC}$了，他想检验你是否也是字符串大师。&lt;br&gt;$\mathrm{小Q}$告诉你$n$以及$per_1,per_2,\cdots,per_n$，请找到一个长度为$n$的小写字符串$S$，使得$S$能对应上$per$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含一个正整数$n\;(1\le n\le10^5)$，表示字符串的长度。&lt;br&gt;第二行包含$n$个正整数$per_1,per_2,\cdots,per_n\;(1\le per_i\le i)$，表示每个前缀的最短循环节长度。&lt;br&gt;输入数据保证至少存在一组可行解。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一行一个长度为$n$的小写字符串$S$，即某个满足条件的$S$。&lt;br&gt;若有多个可行的$S$，输出字典序最小的那一个。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="贪心" scheme="http://azrael.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="字符串" scheme="http://azrael.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="构造" scheme="http://azrael.top/tags/%E6%9E%84%E9%80%A0/"/>
    
      <category term="KMP" scheme="http://azrael.top/tags/KMP/"/>
    
      <category term="Lydsy月赛" scheme="http://azrael.top/tags/Lydsy%E6%9C%88%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3697 采药人的路径 &lt;点分治&gt;</title>
    <link href="http://azrael.top/BZOJ3697%20%E9%87%87%E8%8D%AF%E4%BA%BA%E7%9A%84%E8%B7%AF%E5%BE%84%20%E7%82%B9%E5%88%86%E6%B2%BB/"/>
    <id>http://azrael.top/BZOJ3697 采药人的路径 点分治/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-05-02T06:31:23.091Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="采药人的路径"><a href="#采药人的路径" class="headerlink" title="采药人的路径"></a>采药人的路径</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>采药人的药田是一个树状结构，每条路径上都种植着同种药材。<br>采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。<br>采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。<br>采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。<br>他想知道他一共可以选择多少种不同的路径。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第$1$行包含一个整数$N$。<br>接下来$N-1$行，每行包含三个整数$a_i,b_i,t_i$，表示$a_i$到$b_i$这条路上药材的类型为$t_i$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出符合采药人要求的路径数目。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">1 2 0</span><br><span class="line">3 1 1</span><br><span class="line">2 4 0</span><br><span class="line">5 2 0</span><br><span class="line">6 3 1</span><br><span class="line">5 7 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据，$N\le10^5$。</p><p>标签：<code>点分治</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>点分治基础题。</p><p>每次找重心作分治中心，同一子树内的路径数递归计算，只考虑经过当前分治中心的路径数。<br>对于当前分治中心，处理出其余未分治到的点与其的路径上有多少阴性和阳性道路。设阴性道路边权为$-1$，阳性为$1$，那么若两个点到分治中心的路径拼起来可以构成一条合法道路，一定需要满足两个条件：</p><ul><li>路径总长为$0$</li><li>在两条路径中一定有至少一条在路径上存在两个点，使得分治中心到这个两点的长度相同，并且这个长度不为$0$。特殊情况是两条路径的长度都为$0$也可。</li></ul><p>用$f[i][0/1]$表示现在枚举到的子树中，与当前分治中心距离为$i$的路径上有/没有两个离分治中心距离相同的点的路径条数；用$g[i][0/1]$表示同样的意义，只是是在前面已枚举的子树中这样的路径条数。那么从当前子树和前面的子树各选一条路径，拼成新路径，这样对答案的贡献是$f[x][0]\times g[-x][1]+f[x][1]\times g[-x][0]+f[x][1]\times g[-x][1]$。除此之外还需要加上两条不同子树中到分治中心长为$0$的路径组成的路径条数，即$f[0][0]\times g[0][0]$。</p><p>点分时每次$\mathrm{DFS}$预处理$f$,$g$统计即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, rt, tot, cnt[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>]; lnt ans;</span><br><span class="line"><span class="keyword">int</span> sz[MAX_N+<span class="number">5</span>], w[MAX_N+<span class="number">5</span>], dis[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> f[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>][<span class="number">2</span>], g[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>], E[MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;G[u].push_back(v), E[u].push_back(c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;<span class="keyword">if</span> (!c) c = <span class="number">-1</span>; insert(u, v, c), insert(v, u, c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getrt</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>, w[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v])</span><br><span class="line">getrt(v, u), sz[u] += sz[v], w[u] = max(w[u], sz[v]);</span><br><span class="line"><span class="keyword">if</span> ((w[u] = max(w[u], tot-sz[u])) &lt; w[rt]) rt = u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = dep;f[dis[u]][cnt[dis[u]]&gt;<span class="number">0</span>]++, cnt[dis[u]]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i]) ^ fa) &amp;&amp; !mrk[v])</span><br><span class="line">dis[v] = dis[u]+E[u][i], ret = max(ret, getdis(v, u, dep+<span class="number">1</span>));</span><br><span class="line">cnt[dis[u]]--;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = <span class="number">0</span>;mrk[u] = <span class="literal">true</span>, g[n][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v, d; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (!mrk[v = G[u][i]]) &#123;</span><br><span class="line">dis[v] = n+E[u][i], d = getdis(v, u, <span class="number">1</span>);</span><br><span class="line">r = max(r, d), ans += <span class="number">1L</span>L*f[n][<span class="number">0</span>]*(g[n][<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -d; j &lt;= +d; j++)</span><br><span class="line">ans += <span class="number">1L</span>L*f[n+j][<span class="number">1</span>]*g[n-j][<span class="number">1</span>], </span><br><span class="line">ans += <span class="number">1L</span>L*f[n+j][<span class="number">0</span>]*g[n-j][<span class="number">1</span>], </span><br><span class="line">ans += <span class="number">1L</span>L*f[n+j][<span class="number">1</span>]*g[n-j][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = -d; j &lt;= +d; j++)</span><br><span class="line">g[n+j][<span class="number">0</span>] += f[n+j][<span class="number">0</span>], f[n+j][<span class="number">0</span>] = <span class="number">0</span>, </span><br><span class="line">g[n+j][<span class="number">1</span>] += f[n+j][<span class="number">1</span>], f[n+j][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = -r; i &lt;= +r; i++) g[n+i][<span class="number">0</span>] = g[n+i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++) <span class="keyword">if</span> (!mrk[v = G[u][i]])</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = sz[v], getrt(v, u), DFS(rt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt; n; i++)</span><br><span class="line">read(u), read(v), read(c), addedge(u, v, c);</span><br><span class="line">w[rt = <span class="number">0</span>] = tot = n, getrt(<span class="number">1</span>, <span class="number">0</span>), DFS(rt);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;采药人的路径&quot;&gt;&lt;a href=&quot;#采药人的路径&quot; class=&quot;headerlink&quot; title=&quot;采药人的路径&quot;&gt;&lt;/a&gt;采药人的路径&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;采药人的药田是一个树状结构，每条路径上都种植着同种药材。&lt;br&gt;采药人以自己对药材独到的见解，对每种药材进行了分类。大致分为两类，一种是阴性的，一种是阳性的。&lt;br&gt;采药人每天都要进行采药活动。他选择的路径是很有讲究的，他认为阴阳平衡是很重要的，所以他走的一定是两种药材数目相等的路径。&lt;br&gt;采药工作是很辛苦的，所以他希望他选出的路径中有一个可以作为休息站的节点（不包括起点和终点），满足起点到休息站和休息站到终点的路径也是阴阳平衡的。&lt;br&gt;他想知道他一共可以选择多少种不同的路径。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第$1$行包含一个整数$N$。&lt;br&gt;接下来$N-1$行，每行包含三个整数$a_i,b_i,t_i$，表示$a_i$到$b_i$这条路上药材的类型为$t_i$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出符合采药人要求的路径数目。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="树分治" scheme="http://azrael.top/tags/%E6%A0%91%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4174 tty的求助 &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ4174%20tty%E7%9A%84%E6%B1%82%E5%8A%A9%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ4174 tty的求助 莫比乌斯反演/</id>
    <published>2018-04-28T16:00:00.000Z</published>
    <updated>2018-05-01T00:39:30.099Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="tty的求助"><a href="#tty的求助" class="headerlink" title="tty的求助"></a>tty的求助</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>求$\sum_{n=1}^{N}\sum_{m=1}^{M}\sum_{k=0}^{m-1}\lfloor\frac{nk+x}{m}\rfloor$，其中$x$为实数。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入仅有一行。<br>第一行仅有两个正整数$N,M$和一个实数$x$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出共一行，由于结果过大，所以请输出上式对$998244353$取模的结果。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>当$n=1,m=1$时，$sum=1$<br>当$n=1,m=2$时，$sum=1$<br>当$n=1,m=3$时，$sum=1$<br>当$n=2,m=1$时，$sum=1$<br>当$n=2,m=2$时，$sum=1$<br>当$n=2,m=3$时，$sum=2$<br>所以答案是$7$</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$N,M\le5\times10^5$，$0&lt;x\le10^5$，$x$精确到小数点后8位。</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$$<br>Ans=\sum_{n=1}^{N}\sum_{m=1}^{M}\sum_{k=0}^{m-1}\lfloor\frac{nk+x}{m}\rfloor\\<br>$$</p><p>对于最后一次求和：<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{k=0}^{m-1}\lfloor\frac{nk+x}{m}\rfloor\\<br>&amp;=\sum_{k=0}^{m-1}\lfloor\frac{nk-nk\%m+x+nk\%m}{m}\rfloor\\<br>&amp;=\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}+\frac{nk-nk\%m}{m}\rfloor\\<br>&amp;=\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}\rfloor+\sum_{k=0}^{m-1}\frac{nk}{m}-\sum_{k=0}^{m-1}\frac{nk\%m}{m}\\<br>\end{aligned}<br>$$</p><p>先考虑前一项：<br>设$d=\gcd(n,m)$，那么$n\cdot\frac{m}{d}\equiv0\mod{m}$。于是有$n(k+\frac{m}{d})\%m=nk\%m+\frac{nm}{d}\%m=nk\%m$，即可知$nk\%m=n(k\%\frac{m}{d})\%m$。<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=\sum_{k=0}^{m-1}\lfloor\frac{n(k\%\frac{m}{d})\%m+x}{m}\rfloor\\<br>&amp;=\frac{m}{\frac{m}{d}}\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{n(k\%\frac{m}{d})\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>\end{aligned}<br>$$</p><p>对于$k$取遍$\frac{0}{d},\frac{d}{d},\frac{2d}{d},\cdots,\frac{m-d}{d}$，$nk$的值依次为$\frac{n}{d}\cdot 0,\frac{n}{d}\cdot d,\frac{n}{d}\cdot 2d,\cdots,\frac{n}{d}\cdot (\frac{m}{d}-1)d$。由于$\frac{n}{d}$与$\lfloor\frac{m}{d}\rfloor$互质，所以$\frac{n}{d}\cdot k\%m$一定取遍$0,1,2,\cdots,(\frac{m}{d}-1)$，因而$nk\%m$一定取遍$0,d,2d,\cdots,(\frac{m}{d}-1)d$。故而有<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{kd+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{kd+x\%m+x-x\%m}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{kd+x\%m}{m}\rfloor+d\cdot\frac{m}{d}\cdot\frac{x-x\%m}{m}\\<br>\end{aligned}<br>$$</p><p>又发现$0\le kd+x\%m&lt;2m\Rightarrow0\le\lfloor\frac{kd+x\%m}{m}\rfloor&lt;2$，故<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{k=0}^{m-1}\lfloor\frac{nk\%m+x}{m}\rfloor\\<br>&amp;=d\sum_{k=0}^{\frac{m}{d}-1}\lfloor\frac{kd+x\%m}{m}\rfloor+d\cdot\frac{m}{d}\cdot\frac{x-x\%m}{m}\\<br>&amp;=d\times(\sum_{k=0}^{\frac{m}{d}-1}[kd\ge m-x\%m]+\frac{x-x\%m}{d})\\<br>&amp;=d\times(\sum_{k=0}^{\frac{m}{d}-1}[k\ge\lceil\frac{m-x\%m}{d}\rceil]+\frac{x-x\%m}{d})\\<br>&amp;=d\times(\lfloor\frac{x\%m}{d}\rfloor+\lfloor\frac{x}{d}\rfloor-\lfloor\frac{x\%m}{d}\rfloor)\\<br>&amp;=d\lfloor\frac{x}{d}\rfloor\\<br>\end{aligned}<br>$$</p><p>对于后两项：<br>$$<br>\sum_{k=0}^{m-1}\frac{nk}{m}=\frac{n\cdot m\cdot(m-1)}{2m}=\frac{nm-n}{2}\\<br>\sum_{k=0}^{m-1}\frac{nk\%m}{m}=d\sum_{k=0}^{\frac{m}{d}-1}\frac{kd}{m}=\frac{m-d}{2}\\<br>$$</p><p>将三项和前面两个求和连起来：<br>$$<br>\begin{aligned}<br>Let\;&amp;S_i=1+2+\cdots+i=\frac{i\times(i+1)}{2},\\<br>Ans&amp;=\sum_{n=1}^{N}\sum_{m=1}^{M}(d\lfloor\frac{x}{d}\rfloor+\frac{nm-n-m+d}{2})\\<br>&amp;=\sum_{n=1}^{N}\sum_{m=1}^{M}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})+\frac{1}{2}S_NS_M-\frac{M}{2}S_N-\frac{N}{2}S_M\\<br>&amp;=\sum_{n=1}^{N}\sum_{m=1}^{M}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})+\frac{1}{2}S_NS_M-\frac{M}{2}S_N-\frac{N}{2}S_M\\<br>\end{aligned}<br>$$</p><p>对前面的和式做莫比乌斯反演：<br>$$<br>\begin{aligned}<br>&amp;\;\;\;\;\sum_{n=1}^{N}\sum_{m=1}^{M}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})\\<br>&amp;=\sum_{d=1}^{\min(N,M)}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}[\gcd(i,j)=1]\\<br>&amp;=\sum_{d=1}^{\min(N,M)}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})\sum_{i=1}^{\lfloor\frac{N}{d}\rfloor}\sum_{j=1}^{\lfloor\frac{M}{d}\rfloor}\sum_{t|i,j}\mu(t)\\<br>&amp;=\sum_{d=1}^{\min(N,M)}(d\lfloor\frac{x}{d}\rfloor+\frac{d}{2})\sum_{t=1}^{\min(\lfloor\frac{N}{d}\rfloor,\lfloor\frac{M}{d}\rfloor)}\mu(t)\lfloor\frac{N}{td}\rfloor\lfloor\frac{M}{td}\rfloor\\<br>\end{aligned}<br>$$</p><p>直接枚举$d$数论分块即可，总时间复杂度约为$O(2n-2\sqrt{n})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 998244353</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inv2 499122177</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];dnt x;</span><br><span class="line"><span class="keyword">int</span> n, m, cnt, pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) mu[i] += mu[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), </span><br><span class="line">(ret += <span class="number">1L</span>L*(mu[r]-mu[l<span class="number">-1</span>])*(n/l)%MOD*(m/l)%MOD) %= MOD;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;n, &amp;m, &amp;x), init();</span><br><span class="line">lnt sn = <span class="number">1L</span>L*n*(n+<span class="number">1</span>)/<span class="number">2</span>%MOD, sm = <span class="number">1L</span>L*m*(m+<span class="number">1</span>)/<span class="number">2</span>%MOD;</span><br><span class="line">lnt ans = sn*sm%MOD<span class="number">-1L</span>L*m*sn%MOD<span class="number">-1L</span>L*n*sm%MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">1</span>; d &lt;= min(n, m); d++)</span><br><span class="line">(ans += (<span class="number">2L</span>L*d*(lnt)(x/d)+d)%MOD*calc(n/d, m/d)%MOD) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (ans*inv2%MOD+MOD)%MOD), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;tty的求助&quot;&gt;&lt;a href=&quot;#tty的求助&quot; class=&quot;headerlink&quot; title=&quot;tty的求助&quot;&gt;&lt;/a&gt;tty的求助&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;求$\sum_{n=1}^{N}\sum_{m=1}^{M}\sum_{k=0}^{m-1}\lfloor\frac{nk+x}{m}\rfloor$，其中$x$为实数。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入仅有一行。&lt;br&gt;第一行仅有两个正整数$N,M$和一个实数$x$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出共一行，由于结果过大，所以请输出上式对$998244353$取模的结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3994【SDOI2015】约数个数和 &lt;莫比乌斯反演&gt;</title>
    <link href="http://azrael.top/BZOJ3994%E3%80%90SDOI2015%E3%80%91%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%20%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <id>http://azrael.top/BZOJ3994【SDOI2015】约数个数和 莫比乌斯反演/</id>
    <published>2018-04-27T16:00:00.000Z</published>
    <updated>2018-04-30T11:46:43.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【SDOI2015】约数个数和"><a href="#【SDOI2015】约数个数和" class="headerlink" title="【SDOI2015】约数个数和"></a>【SDOI2015】约数个数和</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>设$d(x)$为$x$的约数个数，给定$N,M$，求$\sum_{i=1}^{n}\sum_{j=1}^{m}d(i\cdot j)$</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入文件包含多组测试数据。<br>第一行，一个整数$T$，表示测试数据的组数。<br>接下来的$T$行，每行两个整数$N,M$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>$T$行，每行一个整数，表示你所求的答案。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">7 4</span><br><span class="line">5 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">110</span><br><span class="line">121</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N,M\le50000,\;1\le T\le50000$</p><p>标签：<code>莫比乌斯反演</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>挺神的反演，没推出来，需要一个结论。</p><p>首先考虑如何把$d(x)$变为我们更为熟悉的数学语言。<br>对于$d(x\cdot y)$，考虑$x\times y$的约数，每个约数均可表示为$i\times \frac{y}{j}$，其中$i|x,j|y$。那么用$\sum_{i|x}\sum_{j|y}1$统计约数，一定会不漏地枚举到所有约数，但显然是有重复的。注意到这种重复的造成只有一种情况，即若$(i,j)$符合条件，那么$(i\times t,j\times t)$也符合条件，而两者所代表的最终约数是相同的，重复计数。也就是说只要$\gcd(i,j)\ne1$，那么一定是重复计算的。于是不重不漏地计算只需要把$\sum_{i|x}\sum_{j|y}1$中的$1$加上$\gcd(i,j)=1$的限制即可。<br>因此推出重要结论$d(x\cdot y)=\sum_{i|x}\sum_{j|y}[\gcd(i,j)=1]$。</p><p>接下来就可以推反演了：<br>$$<br>\begin{aligned}<br>Ans&amp;=\sum_{k=1}^{n}\sum_{w=1}^{m}d(k\cdot w)\\<br>&amp;=\sum_{k=1}^{n}\sum_{w=1}^{m}\sum_{i|k}\sum_{j|w}[\gcd(i,j)=1]\\<br>&amp;=\sum_{i=1}^{n}\sum_{j=1}^{m}\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{j}\rfloor[\gcd(i,j)=1]\\<br>&amp;=\sum_{i=1}^{n}\sum_{j=1}^{m}\lfloor\frac{n}{i}\rfloor\lfloor\frac{m}{j}\rfloor\sum_{d|i,d|j}\mu(d)\\<br>&amp;=\sum_{d=1}^{n}\mu(d)\sum_{i=1}^{\lfloor n/d\rfloor}\sum_{j=1}^{\lfloor m/d\rfloor}\lfloor\frac{n}{i\cdot d}\rfloor\lfloor\frac{m}{j\cdot d}\rfloor\\<br>&amp;=\sum_{d=1}^{n}\mu(d)\sum_{i=1}^{\lfloor n/d\rfloor}\lfloor\frac{n}{i\cdot d}\rfloor\sum_{j=1}^{\lfloor m/d\rfloor}\lfloor\frac{m}{j\cdot d}\rfloor\\<br>\end{aligned}<br>$$<br>如果能预处理出$F(x)=\sum_{i=1}^{x}\lfloor\frac{x}{i}\rfloor$的值，就可以根号分块计算答案。</p><p>考虑$\sum_{i=1}^{x}\lfloor\frac{x}{i}\rfloor​$的意义，即枚举一个数，统计其在$[1,x]​$内的倍数有多少个，可以理解为枚举约数，计算它在$1\sim x​$中是多少个数的约数，即计算其对$\sum_{i=1}^{x}d(i)​$的贡献。于是$F(x)=\sum_{i=1}^{x}d(i)​$，我们需要预处理出$d(x)​$。</p><p>由于$d(x)$是积性函数，对于$d(x\cdot p)\;(x\in \mathbb{N}^*,\;p&lt;x,\;p是质数)$，我们有：</p><ol><li>$p\nmid x$：$d(x\cdot p)=d(x)\cdot d(p)$</li><li>$p\mid x$：$d(x\cdot p)=d(\frac{x}{p^k}\cdot p^{k+1})=d(\frac{x}{p^k})\cdot d(p^{k+1})=\frac{d(x)\cdot(k+2)}{k+1}$，其中$p$一定为$x$的最小质因子</li></ol><p>为了应对情况$2$，我们需要预处理最小质因子次数$c(x)$，注意到$c(x)$也可以线性筛预处理：</p><ol><li>对于质数$p$，$c(p)=1$</li><li>对于正整数$x$和质数$p$，<ul><li>$p\nmid x$：$c(x\cdot p)=1$</li><li>$p\mid x$：$c(x\cdot p)=c(x)+1$</li></ul></li></ol><p>如此我们即可线性筛预处理出$c(x),\;d(x)$，计算$d(x)$前缀和$F(x)$，对于询问进行数论分块统计答案，时间复杂度$O(T\sqrt{n})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line">lnt mu[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>, d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>, c[i] = <span class="number">1</span>, d[i] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i], c[i*pri[j]] = <span class="number">1</span>, d[i*pri[j]] = d[i]*d[pri[j]];</span><br><span class="line"><span class="keyword">else</span> mu[i*pri[j]] = <span class="number">0</span>, c[i*pri[j]] = c[i]+<span class="number">1</span>, d[i*pri[j]] = d[i]*(c[i]+<span class="number">2</span>)/(c[i]+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (i%pri[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) mu[i] += mu[i<span class="number">-1</span>], d[i] += d[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, T; read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">read(n), read(m), ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= min(n, m); l = r+<span class="number">1</span>)</span><br><span class="line">r = min(n/(n/l), m/(m/l)), </span><br><span class="line">ans += (mu[r]-mu[l<span class="number">-1</span>])*d[n/l]*d[m/l];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【SDOI2015】约数个数和&quot;&gt;&lt;a href=&quot;#【SDOI2015】约数个数和&quot; class=&quot;headerlink&quot; title=&quot;【SDOI2015】约数个数和&quot;&gt;&lt;/a&gt;【SDOI2015】约数个数和&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;设$d(x)$为$x$的约数个数，给定$N,M$，求$\sum_{i=1}^{n}\sum_{j=1}^{m}d(i\cdot j)$&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入文件包含多组测试数据。&lt;br&gt;第一行，一个整数$T$，表示测试数据的组数。&lt;br&gt;接下来的$T$行，每行两个整数$N,M$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;$T$行，每行一个整数，表示你所求的答案。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="莫比乌斯反演" scheme="http://azrael.top/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3626【LNOI2014】LCA &lt;离线+树链剖分&gt;</title>
    <link href="http://azrael.top/BZOJ3626%E3%80%90LNOI2014%E3%80%91LCA%20%E7%A6%BB%E7%BA%BF+%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <id>http://azrael.top/BZOJ3626【LNOI2014】LCA 离线+树链剖分/</id>
    <published>2018-04-25T16:00:00.000Z</published>
    <updated>2018-04-26T15:09:01.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【LNOI2014】LCA"><a href="#【LNOI2014】LCA" class="headerlink" title="【LNOI2014】LCA"></a>【LNOI2014】LCA</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给出一个$n$个节点的有根树（编号为$0$到$n-1$，根节点为$0$）。一个点的深度定义为$这个节点到根的距离+1$。设$dep_i$表示点$i$的深度，$lca_{i,j}$表示$i$与$j$的最近公共祖先。<br>有$q$次询问，每次询问给出$l,r,z$，求$\sum_{l&lt;=i&lt;=r}dep_{lca_{i,z}}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行$2$个整数$n,q$。<br>接下来$n-1$行，分别表示点$1$到点$n-1$的父节点编号。<br>接下来$q$行，每行$3$个整数$l,r,z$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$q$行，每行表示一个询问的答案。每个答案对$201314$取模输出<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 2</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">1</span><br><span class="line">1 4 3</span><br><span class="line">1 4 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>共$5$组数据，$n$与$q$的规模分别为$10000$,$20000$,$30000$,$40000$,$50000$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>数据已加强$\;\mathrm{By\;}$<code>saffah</code></p><p>标签：<code>树链剖分</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>傻逼树链剖分，练手居然还$\mathrm{WA}$了一发…</p><p>首先有一个这样的暴力：对于每个询问，将$z$到根的路径打标记，枚举$l\sim r$，每次累加当前节点最近的标记节点的深度。<br>然后发现可以反转一下：对于每个询问，枚举$l\sim r$，每次将当前结点到根路径上的所有结点权值$+1$，统计$z$到根路径上的总权值即可。（权值$+1$相当于深度累加）。<br>这道题没有强制在线，于是可以把所有的询问都离线下来，拆成两个前缀询问$[1,l-1]$和$[1,r]$分别计算。如果将所有前缀询问按右端点位置排序，不难发现可以依次操作，每次将一个新的结点到根路径上的所有结点权值$+1$，操作完统计右端点在此结点上的所有前缀询问的答案。<br>注意模完两个前缀答案相减后可能出现负数，需要先加上$\mathrm{MOD}$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 201314</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> t, p, id; <span class="keyword">bool</span> f;&#125; opt[(MAX_N&lt;&lt;<span class="number">1</span>)+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, ind, ans[MAX_N+<span class="number">5</span>], tr[MAX_N&lt;&lt;<span class="number">2</span>], tag[MAX_N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> dep[MAX_N+<span class="number">5</span>], fa[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>], son[MAX_N+<span class="number">5</span>], top[MAX_N+<span class="number">5</span>], dfn[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;x, <span class="keyword">const</span> node &amp;y)</span> </span>&#123;<span class="keyword">return</span> x.t &lt;= y.t;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">sz[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)G[u].size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> v = G[u][i]; <span class="keyword">if</span> (v == fa[u]) <span class="keyword">continue</span>;</span><br><span class="line">dep[v] = dep[u]+<span class="number">1</span>, fa[v] = u, DFS(v), sz[u] += sz[v];</span><br><span class="line"><span class="keyword">if</span> (!son[u] || sz[son[u]] &lt; sz[v]) son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> tp)</span> </span>&#123;</span><br><span class="line">top[u] = tp, dfn[u] = ++ind; <span class="keyword">if</span> (son[u]) DFS(son[u], tp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (((v = G[u][i])^fa[u]) &amp;&amp; (v^son[u])) DFS(v, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;tr[v] = tr[v&lt;&lt;<span class="number">1</span>]+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tag[v]) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> x = tag[v]; tag[v] = <span class="number">0</span>;</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>] += x*(mid-s+<span class="number">1</span>)%MOD) %= MOD;</span><br><span class="line">(tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += x*(t-mid)%MOD) %= MOD;</span><br><span class="line">(tag[v&lt;&lt;<span class="number">1</span>] += x) %= MOD, (tag[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>] += x) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) &#123;</span><br><span class="line">(tr[v] += x*(t-s+<span class="number">1</span>)%MOD) %= MOD;</span><br><span class="line">(tag[v] += x) %= MOD; <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) modify(v&lt;&lt;<span class="number">1</span>, s, mid, l, r, x);</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) modify(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r, x);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s &gt;= l &amp;&amp; t &lt;= r) <span class="keyword">return</span> (tr[v]+MOD)%MOD;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>; downtag(v, s, t);</span><br><span class="line"><span class="keyword">if</span> (l &lt;= mid) (ret += query(v&lt;&lt;<span class="number">1</span>, s, mid, l, r)) %= MOD;</span><br><span class="line"><span class="keyword">if</span> (r &gt;= mid+<span class="number">1</span>) (ret += query(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t, l, r)) %= MOD;</span><br><span class="line"><span class="keyword">return</span> (ret%MOD+MOD)%MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (; u; u = fa[top[u]])</span><br><span class="line">modify(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[u]], dfn[u], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; u; u = fa[top[u]])</span><br><span class="line">(ret += query(<span class="number">1</span>, <span class="number">1</span>, n, dfn[top[u]], dfn[u])) %= MOD;</span><br><span class="line"><span class="keyword">return</span> (ret += MOD) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), G[x+<span class="number">1</span>].push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, l, r, p; i &lt;= m; i++)</span><br><span class="line">read(l), read(r), read(p), </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].p = opt[i*<span class="number">2</span>].p = p+<span class="number">1</span>, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].id = opt[i*<span class="number">2</span>].id = i, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].t = l, opt[i*<span class="number">2</span>].t = r+<span class="number">1</span>, </span><br><span class="line">opt[i*<span class="number">2</span><span class="number">-1</span>].f = <span class="literal">false</span>, opt[i*<span class="number">2</span>].f = <span class="literal">true</span>;</span><br><span class="line">sort(opt+<span class="number">1</span>, opt+m*<span class="number">2</span>+<span class="number">1</span>, cmp), DFS(<span class="number">1</span>), DFS(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m*<span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt; opt[i].t) change(++j);</span><br><span class="line"><span class="keyword">if</span> (opt[i].f) (ans[opt[i].id] += getsum(opt[i].p)) %= MOD;</span><br><span class="line"><span class="keyword">else</span> (ans[opt[i].id] += MOD-getsum(opt[i].p)) %= MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (ans[i]%MOD+MOD)%MOD);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【LNOI2014】LCA&quot;&gt;&lt;a href=&quot;#【LNOI2014】LCA&quot; class=&quot;headerlink&quot; title=&quot;【LNOI2014】LCA&quot;&gt;&lt;/a&gt;【LNOI2014】LCA&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给出一个$n$个节点的有根树（编号为$0$到$n-1$，根节点为$0$）。一个点的深度定义为$这个节点到根的距离+1$。设$dep_i$表示点$i$的深度，$lca_{i,j}$表示$i$与$j$的最近公共祖先。&lt;br&gt;有$q$次询问，每次询问给出$l,r,z$，求$\sum_{l&amp;lt;=i&amp;lt;=r}dep_{lca_{i,z}}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行$2$个整数$n,q$。&lt;br&gt;接下来$n-1$行，分别表示点$1$到点$n-1$的父节点编号。&lt;br&gt;接下来$q$行，每行$3$个整数$l,r,z$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$q$行，每行表示一个询问的答案。每个答案对$201314$取模输出&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树链剖分" scheme="http://azrael.top/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ3438 小M的作物 &lt;最小割&gt;</title>
    <link href="http://azrael.top/BZOJ3438%20%E5%B0%8FM%E7%9A%84%E4%BD%9C%E7%89%A9%20%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    <id>http://azrael.top/BZOJ3438 小M的作物 最小割/</id>
    <published>2018-04-25T16:00:00.000Z</published>
    <updated>2018-04-26T14:49:47.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="小M的作物"><a href="#小M的作物" class="headerlink" title="小M的作物"></a>小M的作物</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{小M}$在$\mathrm{MC}$里开辟了两块巨大的耕地$A$和$B$（你可以认为容量是无穷）。<br>现在，$\mathrm{小M}$有种$n$作物的种子，每种作物的种子有$1$个（就是可以种一棵作物）（用$1\sim n$编号），第$i$种作物种植在$A$中种植可以获得$a_i$的收益，在$B$中种植可以获得$b_i$的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益。<br>$\mathrm{小M}$找到了规则中共有$m$种作物组合，第$i$个组合中的作物共同种在$A$中可以获得$c_{i,1}$的额外收益，共同总在$B$中可以获得$c_{i,2}$的额外收益。<br>$\mathrm{小M}$很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包括一个整数$n$<br>第二行包括$n$个整数，表示$a_i$<br>第三行包括$n$个整数，表示$b_i$<br>第四行包括一个整数$m$<br>接下来$m$行，第$i$行依次输入：</p><ul><li>一个整数$k_i$，表示第$i$个作物组合中共有$k_i$种作物</li><li>两个整数$c_{i,1},c_{i,2}$，表示两种收益分别是多少</li><li>$k_i$个整数，表示该组合中的作物编号</li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>只有一行，包括一个整数，表示最大收益<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 2 1</span><br><span class="line">2 3 2</span><br><span class="line">1</span><br><span class="line">2 3 2 1 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>$A$耕地种$1,2$，$B$耕地种$3$，收益$4+2+3+2=11$</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le k&lt;n\le1000$, $0&lt;m\le1000$，保证所有数据及结果不超过$2\times10^9$</p><p>标签：<code>最小割</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>文理分科加强版，建模稍有变化。</p><p>首先容易想到将每个作物作为结点，对于作物$i$，连接$S\to i$容量$a_i$，连接$i\to T$容量$b_i$。割掉一条边表示不选对应的那片田，就可以以最小割的形式处理只考虑选$A$和选$B$收益，不考虑集团收益的问题。</p><p>对于每个组合，由于作物个数很多，不能像文理分科一样把失去的收益拆到$S\to i$和$i\to T$上。这里可以建立辅助结点，即给每个组合建立结点。由于存在两种贡献，需要拆成两个节点$p$和$q$，连接$S\to p$容量$c_1$，$q\to T$容量$c_2$。以$p$为例，$S\to p$需要被割去当且仅当此组合中任意作物选择$A$而非$B$，即此组合中存在作物$t$，$t\to T$并未被割掉。因此需要串联，即从$p$连边到此组合中的所有作物，容量$\infty$（从中间割断是没有意义的）。对应地，$q$的连法相同。</p><p>建模：</p><ul><li>对于每个作物$i\in[1,n]$，连接$S\to i$容量$a_i$，$i\to T$容量$b_i$</li><li>对于每个组合$i$，建立结点$p_i,q_i$，连接$S\to p_i$容量$c_1$，$q_i\to T$容量$c_2$</li><li>对于每个组合$i$，设其内作物为$x_1\sim x_k$，那么对每个作物$x_j$，连接$p_i\to x_j$容量$\infty$，$x_j\to q_i$容量$\infty$</li></ul><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 4000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 5000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, sum, d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = <span class="number">4000</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; cpy(); <span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec(); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) read(x), addedge(s, i, x), sum += x;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) read(x), addedge(i, t, x), sum += x;</span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, c1, c2, k; i &lt;= m; i++) &#123;</span><br><span class="line">read(k), read(c1), read(c2), sum += c1+c2;</span><br><span class="line">addedge(s, n+i*<span class="number">2</span><span class="number">-1</span>, c1), addedge(n+i*<span class="number">2</span>, t, c2);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>, x; j &lt; k; j++)</span><br><span class="line">read(x), addedge(n+i*<span class="number">2</span><span class="number">-1</span>, x, INF), addedge(x, n+i*<span class="number">2</span>, INF);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, sum-Dinic()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;小M的作物&quot;&gt;&lt;a href=&quot;#小M的作物&quot; class=&quot;headerlink&quot; title=&quot;小M的作物&quot;&gt;&lt;/a&gt;小M的作物&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{小M}$在$\mathrm{MC}$里开辟了两块巨大的耕地$A$和$B$（你可以认为容量是无穷）。&lt;br&gt;现在，$\mathrm{小M}$有种$n$作物的种子，每种作物的种子有$1$个（就是可以种一棵作物）（用$1\sim n$编号），第$i$种作物种植在$A$中种植可以获得$a_i$的收益，在$B$中种植可以获得$b_i$的收益，而且，现在还有这么一种神奇的现象，就是某些作物共同种在一块耕地中可以获得额外的收益。&lt;br&gt;$\mathrm{小M}$找到了规则中共有$m$种作物组合，第$i$个组合中的作物共同种在$A$中可以获得$c_{i,1}$的额外收益，共同总在$B$中可以获得$c_{i,2}$的额外收益。&lt;br&gt;$\mathrm{小M}$很快的算出了种植的最大收益，但是他想要考考你，你能回答他这个问题么？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包括一个整数$n$&lt;br&gt;第二行包括$n$个整数，表示$a_i$&lt;br&gt;第三行包括$n$个整数，表示$b_i$&lt;br&gt;第四行包括一个整数$m$&lt;br&gt;接下来$m$行，第$i$行依次输入：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个整数$k_i$，表示第$i$个作物组合中共有$k_i$种作物&lt;/li&gt;
&lt;li&gt;两个整数$c_{i,1},c_{i,2}$，表示两种收益分别是多少&lt;/li&gt;
&lt;li&gt;$k_i$个整数，表示该组合中的作物编号&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;只有一行，包括一个整数，表示最大收益&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="最小割" scheme="http://azrael.top/tags/%E6%9C%80%E5%B0%8F%E5%89%B2/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2440【中山市选2011】完全平方数 &lt;二分+莫比乌斯容斥&gt;</title>
    <link href="http://azrael.top/BZOJ2440%E3%80%90%E4%B8%AD%E5%B1%B1%E5%B8%82%E9%80%892011%E3%80%91%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0%20%E4%BA%8C%E5%88%86+%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%AE%B9%E6%96%A5/"/>
    <id>http://azrael.top/BZOJ2440【中山市选2011】完全平方数 二分+莫比乌斯容斥/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-25T04:52:39.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【中山市选2011】完全平方数"><a href="#【中山市选2011】完全平方数" class="headerlink" title="【中山市选2011】完全平方数"></a>【中山市选2011】完全平方数</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>小$\mathrm{X}$自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。<br>这天是小$\mathrm{X}$的生日，小$\mathrm{W}$想送一个数给他作为生日礼物。当然他不能送一个小$\mathrm{X}$讨厌的数。他列出了所有小$\mathrm{X}$不讨厌的数，然后选取了第$K$个数送给了小$\mathrm{X}$。小$\mathrm{X}$很开心地收下了。<br>然而现在小$\mathrm{W}$却记不起送给小$\mathrm{X}$的是哪个数了。你能帮他一下吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>包含多组测试数据。文件第一行有一个整数$T$，表示测试数据的组数。<br>第$2$至第$T+1$行每行有一个整数$K_i$，描述一组数据，含义如题目中所描述。 </p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>含$T$行，分别对每组数据作出回答。第$i$行输出相应的第$K_i$个不是完全平方数的正整数倍的数。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">13</span><br><span class="line">100</span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">19</span><br><span class="line">163</span><br><span class="line">2030745</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>对于$100\%$的数据有$1\le K_i\le10^9,\;T\le50$</p><p>标签：<code>二分答案</code> <code>莫比乌斯容斥</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>$\mathrm{QAQ}$没做起水题…</p><p>似乎答案不超过$2\times K$？不会证。</p><p>二分答案，对于当前尝试的答案$n$，统计$n$以下有多少个符合条件的数。<br>$符合条件的数的个数=n-完全平方数的倍数的个数$<br>容易发现为了避免算重复，可以约数容斥来算。另外，如果完全平方数的底数有平方因子，一定不会产生贡献。<br>设所有质数的集合为$S_1$，所有由两个不同质数相乘而得数的集合为$S_2$，…，由$q$个不同质数相乘而得的数的集合为$S_q$，那么符合条件的数的个数为：<br>$$<br>cnt=\sum_{i_2\in S_1}\lfloor\frac{n}{i^2}\rfloor-\sum_{i_2\in S_2}\lfloor\frac{n}{i_2^2}\rfloor+\sum_{i_3\in S_3}\lfloor\frac{n}{i_3^2}\rfloor-\cdots\\<br>$$<br>发现上面的式子可以用莫比乌斯函数简化，即<br>$$<br>cnt=\sum_{i=1}^{\sqrt{n}}\mu(i)\cdot\lfloor\frac{n}{i^2}\rfloor<br>$$<br>这样每次用$O(\sqrt{n})$时间$check$，总复杂度为$O(\sqrt{K}\log{K})$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid (l+((r-l)&gt;&gt;1))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> NotPri[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> pri[MAX_N+<span class="number">5</span>], mu[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAX_N; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!NotPri[i]) pri[cnt++] = i, mu[i] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cnt; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i*pri[j] &gt; MAX_N) <span class="keyword">break</span>;</span><br><span class="line">NotPri[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (i%pri[j]) mu[i*pri[j]] = -mu[i];</span><br><span class="line"><span class="keyword">else</span> &#123;mu[i*pri[j]] = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rk = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n); i; i--)</span><br><span class="line">rk += mu[i]*(n/i/i);</span><br><span class="line"><span class="keyword">return</span> rk &gt;= k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sol</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">2</span>*k, ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line"><span class="keyword">if</span> (!chk(mid, k)) l = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans = mid, r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, k;read(T), init();</span><br><span class="line"><span class="keyword">while</span> (T--) read(k), sol(k);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【中山市选2011】完全平方数&quot;&gt;&lt;a href=&quot;#【中山市选2011】完全平方数&quot; class=&quot;headerlink&quot; title=&quot;【中山市选2011】完全平方数&quot;&gt;&lt;/a&gt;【中山市选2011】完全平方数&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;小$\mathrm{X}$自幼就很喜欢数。但奇怪的是，他十分讨厌完全平方数。他觉得这些数看起来很令人难受。由此，他也讨厌所有是完全平方数的正整数倍的数。然而这丝毫不影响他对其他数的热爱。&lt;br&gt;这天是小$\mathrm{X}$的生日，小$\mathrm{W}$想送一个数给他作为生日礼物。当然他不能送一个小$\mathrm{X}$讨厌的数。他列出了所有小$\mathrm{X}$不讨厌的数，然后选取了第$K$个数送给了小$\mathrm{X}$。小$\mathrm{X}$很开心地收下了。&lt;br&gt;然而现在小$\mathrm{W}$却记不起送给小$\mathrm{X}$的是哪个数了。你能帮他一下吗？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;包含多组测试数据。文件第一行有一个整数$T$，表示测试数据的组数。&lt;br&gt;第$2$至第$T+1$行每行有一个整数$K_i$，描述一组数据，含义如题目中所描述。 &lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;含$T$行，分别对每组数据作出回答。第$i$行输出相应的第$K_i$个不是完全平方数的正整数倍的数。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="数论数学" scheme="http://azrael.top/tags/%E6%95%B0%E8%AE%BA%E6%95%B0%E5%AD%A6/"/>
    
      <category term="二分" scheme="http://azrael.top/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="容斥" scheme="http://azrael.top/tags/%E5%AE%B9%E6%96%A5/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1061【NOI2008】志愿者招募 &lt;线性规划转费用流&gt;</title>
    <link href="http://azrael.top/BZOJ1061%E3%80%90NOI2008%E3%80%91%E5%BF%97%E6%84%BF%E8%80%85%E6%8B%9B%E5%8B%9F%20%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E8%BD%AC%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ1061【NOI2008】志愿者招募 线性规划转费用流/</id>
    <published>2018-04-24T16:00:00.000Z</published>
    <updated>2018-04-26T12:40:25.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【NOI2008】志愿者招募"><a href="#【NOI2008】志愿者招募" class="headerlink" title="【NOI2008】志愿者招募"></a>【NOI2008】志愿者招募</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。<br>经过估算，这个项目需要$N$天才能完成，其中第$i$天至少需要$A_i$个人。布布通过了解得知，一共有$M$类志愿者可以招募。其中第$i$类可以从第$S_i$天工作到第$T_i$天，招募费用是每人$C_i$元。<br>新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个整数$N,M$，表示完成项目的天数和可以招募的志愿者的种类。<br>接下来的一行中包含$N$个非负整数，表示每天至少需要的志愿者人数。<br>接下来的$M$行中每行包含三个整数$S_i,T_i,C_i$，含义如上文所述。<br>为了方便起见，我们可以认为每类志愿者的数量都是无限多的。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>仅包含一个整数，表示你所设计的最优方案的总费用。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 3 4</span><br><span class="line">1 2 2</span><br><span class="line">2 3 5</span><br><span class="line">3 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N\le1000$，$1\le M\le10000$，题目中其他所涉及的数据均不超过$2^{31}-1$。</p><p>标签：<code>线性规划</code> <code>费用流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>经典线性规划转网络流。</p><p>由题意可知，共会有$N$个限制条件，还有一个需要最小化的表达式。以样例作例子，第$i$种招募$x_i$人，则有<br>$$<br>\begin{aligned}<br>x_1&amp;\ge2\\<br>x_2+x_3&amp;\ge3\\<br>x_2+x_3&amp;\ge4\\<br>we\;need\;to\;minimize\;&amp;2x_1+5x_2+2x_3\\<br>\end{aligned}<br>$$<br>接着设三个辅助变量$y_1,y_2,y_3\;(y_1,y_2,y_3\ge0)$，使得<br>$$<br>\begin{aligned}<br>x_1-y_1&amp;=2\\<br>x_2+x_3-y_2&amp;=3\\<br>x_2+x_3-y_3&amp;=4\\<br>\end{aligned}<br>$$<br>在最前面和最后面加入两个$0=0$，差分一下，得到<br>$$<br>\begin{aligned}<br>x_1-y_1-2&amp;=0\\<br>x_2+x_3-y_2-x_1+y_1-1&amp;=0\\<br>y_2-y_3-1&amp;=0\\<br>-x_2-x_3+y_3+4&amp;=0\\<br>\end{aligned}<br>$$<br>发现每个变量只出现两次，并且正、负各一次。这个性质其实一定成立。因为每种志愿者只在一个区间内出现，即每个变量只会在连续的式子中出现，这样差分后就会只剩一次正和一次负。辅助变量也有这个性质是显然的。<br>如果将每个式子看成一个结点，等式可以看作这个点的流量平衡方程。将正看成出流，负看成入流，即可构图。例如，对于$x_2$，其在第二个式子中出现正，在第四个式子中出现负，可以想成是从二号结点流出的$x_2$流量进入四号结点。对于辅助变量也是一样。而对于每个式子中的常数项，可以看成从源点流出或流入汇点，即若移到左边后为负，则为从源点流出这么多流量；若为正，则为向汇点流这么多流量。<br>这样一来，根据费用流一定跑出最大流（废话），跑出的流一定满足流量平衡方程（废话$\times$2），最后跑出的方案一定能满足所有限制。如果加上边权（即所要取最小值的式子的系数），可以跑最小费用最大流解出最小值。</p><p>建模：</p><ul><li>对于$\forall i\in[1,n+1]$，<ul><li>若$A_i\ge A_{i-1}$，连接$S\to i$，容量$A_i-A_{i-1}$，单位费用$0$</li><li>若$A_i&lt;A_{i-1}$，连接$i\to T$，容量$A_{i-1}-A_i$，单位费用$0$</li></ul></li><li>对于一种志愿者$l,r,w$，连接$l\to r+1$，容量$\infty$，单位费用$w$</li><li>辅助变量：对于$\forall i\in[2,n+1]$，连接$i\to i-1$，容量$\infty$，单位费用$0$</li></ul><p>跑最小费用最大流即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 50000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>], mxf, mic;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, w, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="keyword">int</span> a[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n+<span class="number">2</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;E[cnt] = (node)&#123;v, c, w, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c, <span class="keyword">int</span> w)</span> </span>&#123;insert(u, v, c, w), insert(v, u, <span class="number">0</span>, -w);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; <span class="keyword">bool</span> inq[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> d[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">memset</span>(inq, <span class="literal">false</span>, <span class="keyword">sizeof</span> inq), <span class="built_in">memset</span>(d, INF, <span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>, que.push(s), inq[s] = <span class="literal">true</span>, <span class="built_in">memset</span>(cr, <span class="number">-1</span>, <span class="keyword">sizeof</span> cr);</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop(), inq[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c, w = E[i].w;</span><br><span class="line"><span class="keyword">if</span> (c &amp;&amp; d[u]+w &lt; d[v]) &#123;</span><br><span class="line">d[v] = d[u]+w, cr[v] = i;</span><br><span class="line"><span class="keyword">if</span> (!inq[v]) que.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[t] == INF) <span class="keyword">return</span> <span class="literal">false</span>;<span class="keyword">int</span> flow = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) flow = min(flow, E[i].c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = cr[t]; ~i; i = cr[E[i^<span class="number">1</span>].v]) E[i].c -= flow, E[i^<span class="number">1</span>].c += flow;</span><br><span class="line">mxf += flow, mic += d[t]*flow;<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+<span class="number">1</span>; i++)</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= a[i<span class="number">-1</span>]) addedge(s, i, a[i]-a[i<span class="number">-1</span>], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> addedge(i, t, a[i<span class="number">-1</span>]-a[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt;= m; i++)</span><br><span class="line">read(u), read(v), read(w), addedge(u, v+<span class="number">1</span>, INF, w);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n+<span class="number">1</span>; i++) addedge(i, i<span class="number">-1</span>, INF, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">while</span> (SPFA()) ;<span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mic), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【NOI2008】志愿者招募&quot;&gt;&lt;a href=&quot;#【NOI2008】志愿者招募&quot; class=&quot;headerlink&quot; title=&quot;【NOI2008】志愿者招募&quot;&gt;&lt;/a&gt;【NOI2008】志愿者招募&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。&lt;br&gt;经过估算，这个项目需要$N$天才能完成，其中第$i$天至少需要$A_i$个人。布布通过了解得知，一共有$M$类志愿者可以招募。其中第$i$类可以从第$S_i$天工作到第$T_i$天，招募费用是每人$C_i$元。&lt;br&gt;新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个整数$N,M$，表示完成项目的天数和可以招募的志愿者的种类。&lt;br&gt;接下来的一行中包含$N$个非负整数，表示每天至少需要的志愿者人数。&lt;br&gt;接下来的$M$行中每行包含三个整数$S_i,T_i,C_i$，含义如上文所述。&lt;br&gt;为了方便起见，我们可以认为每类志愿者的数量都是无限多的。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;仅包含一个整数，表示你所设计的最优方案的总费用。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
      <category term="线性规划" scheme="http://azrael.top/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
      <category term="费用流" scheme="http://azrael.top/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
      <category term="NOI" scheme="http://azrael.top/tags/NOI/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4293【PA2015】Siano &lt;线段树&gt;</title>
    <link href="http://azrael.top/BZOJ4293%E3%80%90PA2015%E3%80%91Siano%20%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ4293【PA2015】Siano 线段树/</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2018-04-24T09:10:30.439Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【PA2015】Siano"><a href="#【PA2015】Siano" class="headerlink" title="【PA2015】Siano"></a>【PA2015】Siano</h3><p>$\mathrm{Time\;Limit:\;30\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>农夫$\mathrm{Byteasar}$买了一片$n$亩的土地，他要在这上面种草。<br>他在每一亩土地上都种植了一种独一无二的草，其中，第$i$亩土地的草每天会长高$a_i$厘米。<br>$\mathrm{Byteasar}$一共会进行$m$次收割，其中第$i$次收割在第$d_i$天，并把所有高度大于等于$b_i$的部分全部割去。<br>$\mathrm{Byteasar}$想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行包含两个正整数$n,m$，分别表示亩数和收割次数。<br>第二行包含$n$个正整数，其中第$i$个数为$a_i$，依次表示每亩种植的草的生长能力。<br>接下来$m$行，每行包含两个正整数$d_i,b_i$，依次描述每次收割。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出$m$行，每行一个整数，依次回答每次收割能得到的草的高度总和。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 2 4 3</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 0</span><br><span class="line">4 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">6</span><br><span class="line">18</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>第$1$天，草的高度分别为$1,2,4,3$，收割后变为$1,1,1,1$。<br>第$2$天，草的高度分别为$2,3,5,4$，收割后变为$2,2,2,2$。<br>第$3$天，草的高度分别为$3,4,6,5$，收割后变为$0,0,0,0$。<br>第$4$天，草的高度分别为$1,2,4,3$，收割后变为$1,2,4,3$。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le n,m\le5\times10^5$, $1\le a_i\le10^6$, $1\le d_i,b_i\le10^{12}$<br>数据保证$d_1&lt;d_2&lt;\cdots&lt;d_m$，并且任何时刻没有任何一亩草的高度超过$10^12$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>By <code>Claris</code></p><p>标签：<code>线段树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>比较灵活的线段树。</p><p>观察题目可以发现一个性质，即长速快的在任意时刻都比长速慢的高度高。这是由于每次修剪都是将所有的剪到同一高度，这样长速快的在修剪后的高度一定大于等于长速慢的在修剪后的高度。</p><p>将长速从低到高排序，不会影响询问，并且每次询问剪去的部分一定是一个后缀。那么可以在线段树上分治寻找剪和不剪的分界点，同时累加答案。</p><p>对于每个区间需要维护其长速之和、高度和两个基础元素。为了方便询问，需要维护高度的最大和最小值，即该区间最右边和最左边的苗的高度。这样如果当前区间的最大高度$mx\le b$，可知不用继续递归；如果当前区间最小高度$mi\ge b$，可知整个区间都要修剪，打区间标记后返回。而对于标记，每个区间需要维护三个元素$tc,td,ld$，分别表示该区间中的所有高度均变为$tc$，这个变化发生在$td$时刻，上一次递归到该区间的时间是$ld$。询问每次递归进入一个区间先计算从上次递归到该区间也就是$ld$到现在总共长了多少，更新信息。注意$td$和$ld$不能合并为一个变量，这是由于该区间上次被递归到时可能先更新了信息，但是并未打标记，即其下面的子区间没有更新信息，故$td$和$ld$不同。</p><p>一棵线段树即可维护，某些细节注意一下即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;lnt a[MAX_N+<span class="number">5</span>], b, d;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>lnt v, s, tc, td, ld, lv, rv;&#125; tr[MAX_N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">tr[v].v = tr[v&lt;&lt;<span class="number">1</span>].v+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].v;</span><br><span class="line">tr[v].s = tr[v&lt;&lt;<span class="number">1</span>].s+tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s;</span><br><span class="line">tr[v].lv = tr[v&lt;&lt;<span class="number">1</span>].lv, tr[v].rv = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rv;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">downtag</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[v].tc == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].s = tr[v].tc*(mid-s+<span class="number">1</span>);</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].s = tr[v].tc*(t-mid);</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].lv = tr[v&lt;&lt;<span class="number">1</span>].rv = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].lv = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].rv = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].tc = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].tc = tr[v].tc;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].td = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].td = tr[v].td;</span><br><span class="line">tr[v&lt;&lt;<span class="number">1</span>].ld = tr[v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].ld = tr[v].td;</span><br><span class="line">tr[v].tc = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">tr[v].tc = <span class="number">-1</span>;<span class="keyword">if</span> (s == t) &#123;tr[v].v = a[s]; <span class="keyword">return</span>;&#125;</span><br><span class="line">build(v&lt;&lt;<span class="number">1</span>, s, mid), build(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t), update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">lnt <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">0L</span>L;tr[v].s += (d-tr[v].ld)*tr[v].v;</span><br><span class="line">tr[v].lv += a[s]*(d-tr[v].ld), tr[v].rv += a[t]*(d-tr[v].ld);</span><br><span class="line"><span class="keyword">if</span> (tr[v].lv &gt;= b) &#123;</span><br><span class="line">ret = tr[v].s-b*(t-s+<span class="number">1</span>), tr[v].s = b*(t-s+<span class="number">1</span>);</span><br><span class="line">tr[v].lv = tr[v].rv = tr[v].tc = b, tr[v].td = d;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (tr[v].rv &gt; b) &#123;</span><br><span class="line">downtag(v, s, t);</span><br><span class="line">ret += query(v&lt;&lt;<span class="number">1</span>, s, mid);</span><br><span class="line">ret += query(v&lt;&lt;<span class="number">1</span>|<span class="number">1</span>, mid+<span class="number">1</span>, t);</span><br><span class="line">update(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tr[v].ld = d, ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) read(a[i]);</span><br><span class="line">sort(a+<span class="number">1</span>, a+n+<span class="number">1</span>), build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">while</span> (m--) read(d), read(b), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(<span class="number">1</span>, <span class="number">1</span>, n));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【PA2015】Siano&quot;&gt;&lt;a href=&quot;#【PA2015】Siano&quot; class=&quot;headerlink&quot; title=&quot;【PA2015】Siano&quot;&gt;&lt;/a&gt;【PA2015】Siano&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;30\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;农夫$\mathrm{Byteasar}$买了一片$n$亩的土地，他要在这上面种草。&lt;br&gt;他在每一亩土地上都种植了一种独一无二的草，其中，第$i$亩土地的草每天会长高$a_i$厘米。&lt;br&gt;$\mathrm{Byteasar}$一共会进行$m$次收割，其中第$i$次收割在第$d_i$天，并把所有高度大于等于$b_i$的部分全部割去。&lt;br&gt;$\mathrm{Byteasar}$想知道，每次收割得到的草的高度总和是多少，你能帮帮他吗？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行包含两个正整数$n,m$，分别表示亩数和收割次数。&lt;br&gt;第二行包含$n$个正整数，其中第$i$个数为$a_i$，依次表示每亩种植的草的生长能力。&lt;br&gt;接下来$m$行，每行包含两个正整数$d_i,b_i$，依次描述每次收割。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出$m$行，每行一个整数，依次回答每次收割能得到的草的高度总和。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="线段树" scheme="http://azrael.top/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="PA" scheme="http://azrael.top/tags/PA/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4299 FRBSUM &lt;主席树&gt;</title>
    <link href="http://azrael.top/BZOJ4299%20FRBSUM%20%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ4299 FRBSUM 主席树/</id>
    <published>2018-04-23T16:00:00.000Z</published>
    <updated>2018-04-24T09:17:30.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="FRBSUM"><a href="#FRBSUM" class="headerlink" title="FRBSUM"></a>FRBSUM</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>数集$S$的$\mathrm{Forbidden\;Sum}$定义为无法用$S$的某个子集（可以为空）的和表示的最小的非负整数。<br>例如，$S={1,1,3,7}$，则它的子集和中包含$0(S’=\emptyset)$，$1(S’={1})$，$2(S’={1,1})$，$3(S’={3})$，$4(S’={1,3})$，$5(S’={1,1,3})$，但是它无法得到$6$。因此$S$的$\mathrm{Forbidden\;Sum}$为$6$。<br>给定一个序列$A$，你的任务是回答该数列的一些子区间所形成的数集的$\mathrm{Forbidden\;Sum}$是多少。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入数据的第一行包含一个整数$N$，表示序列的长度。<br>接下来一行包含$N$个数，表示给定的序列$A$（从$1$标号）。<br>接下来一行包含一个整数$M$，表示询问的组数。<br>接下来$M$行，每行一对整数，表示一组询问。</p><h3 id="Ouput"><a href="#Ouput" class="headerlink" title="Ouput"></a>Ouput</h3><p>对于每组询问，输出一行表示对应的答案。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 4 9 10</span><br><span class="line">5</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于$100\%$的数据，$1\le N,M\le10^5$, $1\le A_i\le10^9$, $1\le A_1+A_2+\cdots+A_N\le10^9$。</p><h3 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h3><p>By <code>yts1999</code></p><p>标签：<code>主席树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>本题和<a href="https://www.lydsy.com/JudgeOnline/problem.php?id=4408" target="_blank" rel="noopener">【FJOI2016】神秘数</a>相同，双倍经验。</p><p>首先不难发现一个结论，若某集合当前能凑出$0\sim mx$中的所有数，加入一个数$x$，可凑出的数的值域扩展当且仅当$x\le mx+1$，并且会将值域扩展到$0\sim mx+x$。<br>如此，对于每个区间$[l,r]$，从小到大逐一将每个数加入到集合中，像上面那样不断扩展值域，如果加入某个数时$x&gt;mx+1$，值域无法继续扩充，那么$mx+1$即为最小的不能凑成的数。<br>这个过程可以用一棵值域主席树维护，每次将所有小于等于$mx+1$的数求和，作为新的$mx$，若$mx$在某次这样的操作中不变，则无法继续扩展，输出答案$mx+1$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mid ((s+t)&gt;&gt;1)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, rt[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> ls, rs, s;&#125; tr[MAX_N*<span class="number">32</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> o, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">tr[v] = tr[o], tr[v].s += p;<span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= mid) modify(tr[v].ls = ++cnt, tr[o].ls, s, mid, p);</span><br><span class="line"><span class="keyword">else</span> modify(tr[v].rs = ++cnt, tr[o].rs, mid+<span class="number">1</span>, t, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s == t) <span class="keyword">return</span> tr[r].s-tr[l].s;</span><br><span class="line"><span class="keyword">int</span> lsum = tr[tr[r].ls].s-tr[tr[l].ls].s;</span><br><span class="line"><span class="keyword">if</span> (p &lt;= mid) <span class="keyword">return</span> query(tr[l].ls, tr[r].ls, s, mid, p);</span><br><span class="line"><span class="keyword">return</span> lsum+query(tr[l].rs, tr[r].rs, mid+<span class="number">1</span>, t, p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++)</span><br><span class="line">read(x), modify(rt[i] = ++cnt, rt[i<span class="number">-1</span>], <span class="number">1</span>, INF, x);</span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> l, r;read(l), read(r);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mx = <span class="number">0</span>, lst = <span class="number">0</span>; ; lst = mx) &#123;</span><br><span class="line">mx = query(rt[l<span class="number">-1</span>], rt[r], <span class="number">1</span>, INF, mx+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (mx == lst) &#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, mx+<span class="number">1</span>); <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;FRBSUM&quot;&gt;&lt;a href=&quot;#FRBSUM&quot; class=&quot;headerlink&quot; title=&quot;FRBSUM&quot;&gt;&lt;/a&gt;FRBSUM&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;数集$S$的$\mathrm{Forbidden\;Sum}$定义为无法用$S$的某个子集（可以为空）的和表示的最小的非负整数。&lt;br&gt;例如，$S={1,1,3,7}$，则它的子集和中包含$0(S’=\emptyset)$，$1(S’={1})$，$2(S’={1,1})$，$3(S’={3})$，$4(S’={1,3})$，$5(S’={1,1,3})$，但是它无法得到$6$。因此$S$的$\mathrm{Forbidden\;Sum}$为$6$。&lt;br&gt;给定一个序列$A$，你的任务是回答该数列的一些子区间所形成的数集的$\mathrm{Forbidden\;Sum}$是多少。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入数据的第一行包含一个整数$N$，表示序列的长度。&lt;br&gt;接下来一行包含$N$个数，表示给定的序列$A$（从$1$标号）。&lt;br&gt;接下来一行包含一个整数$M$，表示询问的组数。&lt;br&gt;接下来$M$行，每行一对整数，表示一组询问。&lt;/p&gt;
&lt;h3 id=&quot;Ouput&quot;&gt;&lt;a href=&quot;#Ouput&quot; class=&quot;headerlink&quot; title=&quot;Ouput&quot;&gt;&lt;/a&gt;Ouput&lt;/h3&gt;&lt;p&gt;对于每组询问，输出一行表示对应的答案。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="主席树" scheme="http://azrael.top/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
    
      <category term="CodeChef" scheme="http://azrael.top/tags/CodeChef/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1913【APIO2010】信号覆盖 &lt;极角排序+双指针&gt;</title>
    <link href="http://azrael.top/BZOJ1913%E3%80%90APIO2010%E3%80%91%E4%BF%A1%E5%8F%B7%E8%A6%86%E7%9B%96%20%E6%9E%81%E8%A7%92%E6%8E%92%E5%BA%8F+%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://azrael.top/BZOJ1913【APIO2010】信号覆盖 极角排序+双指针/</id>
    <published>2018-04-22T16:00:00.000Z</published>
    <updated>2018-04-24T14:06:34.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2010】信号覆盖"><a href="#【APIO2010】信号覆盖" class="headerlink" title="【APIO2010】信号覆盖"></a>【APIO2010】信号覆盖</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><center><br><img src="https://www.lydsy.com/JudgeOnline/images/1913_1.jpg" alt=""><br></center><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入第一行包含一个正整数$n$，表示房子的总数。接下来有$n$行，分别表示每一个房子的位置。对于，$i=1,2,\cdots,n$第$i$个房子的坐标用一对整数$x_i$和$y_i$来表示，中间用空格隔开。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出文件包含一个实数，表示平均有多少个房子被信号所覆盖，需保证输出结果与精确值的绝对误差不超过$0.01$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">0 2</span><br><span class="line">4 4</span><br><span class="line">0 0</span><br><span class="line">2 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.500</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$40\%$的数据，$n\le100$<br>$70\%$的数据，$n\le500$<br>$100\%$的数据，$3\le n\le1500$<br>$100\%$的数据保证，对于$i=1,2,\cdots,n$，第$i$个房子的坐标$(x_i,y_i)$为整数且$-10^6\le x_i,y_i\le10^6$。<br>任何三个房子不在同一条直线上，任何四个房子不在同一个圆上。</p><p>标签：<code>极角排序</code> <code>双指针</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>总体思路是求出所有三元组形成的圆能<strong>多</strong>覆盖的点的总数$tot$，$ans=tot\div\binom{n}{3}+3$</p><p>对于任意四点构成的四边形，考虑任选其中任意三点形成的圆能否包括另一个点。<br>有两种情况：</p><ol><li>凹四边形：除凹进去的点外另外三点的外接圆可以包括凹进去的点外，其余三元组构成的圆一定不能包括第四点，故贡献为$1$。</li><li>凸四边形：由于不存在共圆四边形，对角和一定一个大于$180^\circ$，一个小于$180^\circ$。只有对角和大于$180^\circ$的两个角上三点的外接圆能包括另一点，故贡献为$2$。</li></ol><p>因此$tot=凹四边形数+2\times凸四边形数$。</p><p>接下来考虑如何求两种四边形的个数。由于$凹四边形数+凸四边形数=\binom{n}{4}$，我们只用求凹四边形个数即可。<br>枚举每个点，考虑其作为凹四边形凹进去的那个点又多少种情况。易知$情况数=\binom{n-1}{3}-含此点的凸多边形数$。于是需要求含此点$(p)$的凸多边形数。即枚举凸多边形上的另一个点$(q)$，看有多少点$(r)$使得$pr$和$pq$的夹角小于$180^\circ$。这个过程可以用极角排序后双指针扫一遍统计。这样$O(n^2)$计算出凹多边形数后即可得到最终答案。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Pi acos(-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 1500</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> dnt;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;dnt,dnt&gt; pdd;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n; lnt c1, c2; pdd p[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function">lnt <span class="title">C</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">1L</span>L;<span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ret *= <span class="number">1L</span>L*(n-i+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) ret /= i;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(p[i].x), read(p[i].y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, m = <span class="number">0</span>; i &lt;= n; i++, m = <span class="number">0</span>) &#123;</span><br><span class="line">lnt tot = <span class="number">0L</span>L; dnt a[MAX_N*<span class="number">2</span>+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (i^j)</span><br><span class="line">a[++m] = <span class="built_in">atan2</span>(p[j].y-p[i].y, p[j].x-p[i].x);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) <span class="keyword">if</span> (a[j] &lt; <span class="number">0</span>) a[j] += <span class="number">2</span>*Pi;</span><br><span class="line">sort(a+<span class="number">1</span>, a+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) a[m+j] = a[j]+<span class="number">2</span>*Pi;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">1</span>, v = <span class="number">1</span>; u &lt;= m; tot += C(v-u, <span class="number">2</span>), u++)</span><br><span class="line"><span class="keyword">while</span> (v &lt; (m&lt;&lt;<span class="number">1</span>) &amp;&amp; a[v+<span class="number">1</span>]-a[u] &lt; Pi) v++;</span><br><span class="line">c1 += C(m, <span class="number">3</span>)-tot;</span><br><span class="line">&#125;</span><br><span class="line">c2 = C(n, <span class="number">4</span>)-c1;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, (dnt)(c1+c2*<span class="number">2</span>)/(dnt)C(n, <span class="number">3</span>)+<span class="number">3</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2010】信号覆盖&quot;&gt;&lt;a href=&quot;#【APIO2010】信号覆盖&quot; class=&quot;headerlink&quot; title=&quot;【APIO2010】信号覆盖&quot;&gt;&lt;/a&gt;【APIO2010】信号覆盖&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/images/1913_1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入第一行包含一个正整数$n$，表示房子的总数。接下来有$n$行，分别表示每一个房子的位置。对于，$i=1,2,\cdots,n$第$i$个房子的坐标用一对整数$x_i$和$y_i$来表示，中间用空格隔开。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出文件包含一个实数，表示平均有多少个房子被信号所覆盖，需保证输出结果与精确值的绝对误差不超过$0.01$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="计算几何" scheme="http://azrael.top/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4069【APIO2015】巴厘岛的雕塑 &lt; DP &gt;</title>
    <link href="http://azrael.top/BZOJ4069%E3%80%90APIO2015%E3%80%91%E5%B7%B4%E5%8E%98%E5%B2%9B%E7%9A%84%E9%9B%95%E5%A1%91%20DP/"/>
    <id>http://azrael.top/BZOJ4069【APIO2015】巴厘岛的雕塑 DP/</id>
    <published>2018-04-21T16:00:00.000Z</published>
    <updated>2018-04-24T09:14:48.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2015】巴厘岛的雕塑"><a href="#【APIO2015】巴厘岛的雕塑" class="headerlink" title="【APIO2015】巴厘岛的雕塑"></a>【APIO2015】巴厘岛的雕塑</h3><p>$\mathrm{Time\;Limit: \;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;64\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。<br>在这条主干道上一共有$N$座雕塑，为方便起见，我们把这些雕塑从$1$到$N$连续地进行标号，其中第 i 座雕塑的年龄是$Y_i$年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。<br>下面是将雕塑分组的规则：<br>这些雕塑必须被分为恰好$X$组，其中$A\le X\le B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。<br>当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。<br>计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。<br>请问政府能得到的最小的最终优美度是多少?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含三个用空格分开的整数$N,A,B$。<br>第二行包含$N$个用空格分开的整数$Y_1,Y_2,\cdots,Y_N$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行一个数，表示最小的最终优美度。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 1 3</span><br><span class="line">8 1 2 1 5 4</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>将这些雕塑分为$2$组，$(8,1,2)$和$(1,5,4)$，它们的和是$(11)$和$(10)$，最终优美度是$(11\mid10)=11$。不难验证，这也是最终优美度的最小值。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><table><thead><tr><th style="text-align:center">子任务编号</th><th style="text-align:center">$N$</th><th style="text-align:center">$A,B$</th><th style="text-align:center">$Y_i$</th><th style="text-align:center">分值</th></tr></thead><tbody><tr><td style="text-align:center">$1$</td><td style="text-align:center">$1\le N\le20$</td><td style="text-align:center">$A,B\le N$</td><td style="text-align:center">$0\le Y_i\le10^9$</td><td style="text-align:center">$\mathrm{9\;pts}$</td></tr><tr><td style="text-align:center">$2$</td><td style="text-align:center">$1\le N\le 50$</td><td style="text-align:center">$A,B\le\min(20,N)$</td><td style="text-align:center">$0\le Y_i\le10$</td><td style="text-align:center">$\mathrm{16\;pts}$</td></tr><tr><td style="text-align:center">$3$</td><td style="text-align:center">$1\le N\le100$</td><td style="text-align:center">$A=1,\;B\le N$</td><td style="text-align:center">$0\le Y_i\le20$</td><td style="text-align:center">$\mathrm{21\;pts}$</td></tr><tr><td style="text-align:center">$4$</td><td style="text-align:center">$1\le N\le100$</td><td style="text-align:center">$A,B\le N$</td><td style="text-align:center">$0\le Y_i\le10^9$</td><td style="text-align:center">$\mathrm{25\;pts}$</td></tr><tr><td style="text-align:center">$5$</td><td style="text-align:center">$1\le N\le2000$</td><td style="text-align:center">$A=1,\;B\le N$</td><td style="text-align:center">$0\le Y_i\le10^9$</td><td style="text-align:center">$\mathrm{29\;pts}$</td></tr></tbody></table><p>标签：<code>DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>奇葩的面向数据编程题。</p><p>由于算答案是按位或，可以考虑从高位向低位贪心，每次判断在前面的位都取到最优情况下，这一位能否取$0$。这个判断的过程可以$\mathrm{DP}$实现。<br>$f[i][j]$表示考虑前$i$个雕塑，分成$j$个组，能否在当前位上取$0$。<br>那么$f[i][j]=true$当且仅当$\exists k\in[j-1,i)$，满足$f[k][j-1]=true$，并且$sum_{k+1,i}$和当前答案取或的结果还是当前答案（即不会使得前面位上不为最优解），还需要$sum_{k+1,j}$在当前位上的值为$0$（这样当前位才能取$0$）。<br>求出所有$f$后，判断是否$\exists t\in[A,B]$满足$f[n][t]=true$，如果存在则可以取$0$，否则此位取$1$。</p><p>然而这样并不能得满分。上面的方法是$O(n^3)$处理出所有$f$值，不能通过$n=2000$的$\mathrm{Subtask\;5}$。</p><p>而对于$\mathrm{Subtask\;5}$，发现$A=1$，则每次使得分的组数量尽量小肯定是最优的。于是用$g[i]$表示当前位考虑前$i$个雕塑，最少需要分成几组才能使当前位上可以取$0$。如果在当前位处理$g$后发现$g[n]&gt;B$，那么必须取$1$，否则可以取$0$。这样复杂度降成了$O(n^2)$，可以解决$\mathrm{Subtask\;5}$。</p><p>综上，特判数据分两种情况分别做即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 2000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, A, B; lnt s[MAX_N+<span class="number">5</span>], ans;</span><br><span class="line"><span class="keyword">bool</span> f[MAX_N+<span class="number">5</span>][MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> g[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = m, flag = <span class="number">1</span>; p; p--, flag = <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="literal">false</span>, <span class="keyword">sizeof</span> f), f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j<span class="number">-1</span>; k &lt; i; k++) <span class="keyword">if</span> (f[k][j<span class="number">-1</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> ((((s[i]-s[k])&gt;&gt;p)|ans)^ans) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((s[i]-s[k])&amp;(<span class="number">1L</span>L&lt;&lt;(p<span class="number">-1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">f[i][j] = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = A; i &lt;= B; i++)</span><br><span class="line"><span class="keyword">if</span> (f[n][i]) &#123;flag = <span class="number">0</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">(ans &lt;&lt;= <span class="number">1</span>) |= flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = m; p; p--) &#123;</span><br><span class="line"><span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> g), g[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line"><span class="keyword">if</span> ((((s[i]-s[k])&gt;&gt;p)|ans)^ans) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> ((s[i]-s[k])&amp;(<span class="number">1L</span>L&lt;&lt;(p<span class="number">-1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">g[i] = min(g[i], g[k]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">(ans &lt;&lt;= <span class="number">1</span>) |= (g[n] &gt; B);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(A), read(B);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(s[i]), s[i] += s[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (lnt i = s[n]; i; i &gt;&gt;= <span class="number">1</span>) m++;</span><br><span class="line"><span class="keyword">return</span> (A != <span class="number">1</span> ? sub1() : sub2()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2015】巴厘岛的雕塑&quot;&gt;&lt;a href=&quot;#【APIO2015】巴厘岛的雕塑&quot; class=&quot;headerlink&quot; title=&quot;【APIO2015】巴厘岛的雕塑&quot;&gt;&lt;/a&gt;【APIO2015】巴厘岛的雕塑&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit: \;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;64\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。&lt;br&gt;在这条主干道上一共有$N$座雕塑，为方便起见，我们把这些雕塑从$1$到$N$连续地进行标号，其中第 i 座雕塑的年龄是$Y_i$年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。&lt;br&gt;下面是将雕塑分组的规则：&lt;br&gt;这些雕塑必须被分为恰好$X$组，其中$A\le X\le B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。&lt;br&gt;当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。&lt;br&gt;计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。&lt;br&gt;请问政府能得到的最小的最终优美度是多少?&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含三个用空格分开的整数$N,A,B$。&lt;br&gt;第二行包含$N$个用空格分开的整数$Y_1,Y_2,\cdots,Y_N$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一行一个数，表示最小的最终优美度。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ4070【APIO2015】雅加达的摩天楼 &lt;分块+最短路&gt;</title>
    <link href="http://azrael.top/BZOJ4070%E3%80%90APIO2015%E3%80%91%E9%9B%85%E5%8A%A0%E8%BE%BE%E7%9A%84%E6%91%A9%E5%A4%A9%E6%A5%BC%20%E5%88%86%E5%9D%97+%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    <id>http://azrael.top/BZOJ4070【APIO2015】雅加达的摩天楼 分块+最短路/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-04-23T14:45:59.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2015】雅加达的摩天楼"><a href="#【APIO2015】雅加达的摩天楼" class="headerlink" title="【APIO2015】雅加达的摩天楼"></a>【APIO2015】雅加达的摩天楼</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>印尼首都雅加达市有$N$座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为$0$到$N-1$。除了这$N$座摩天楼外，雅加达市没有其他摩天楼。<br>有$M$只叫做$\mathrm{doge}$的神秘生物在雅加达市居住，它们的编号依次是$0$到$M-1$。编号为$i$的$\mathrm{doge}$最初居住于编号为$B_i$的摩天楼。每只$\mathrm{doge}$都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为$i$的$\mathrm{doge}$的跳跃能力为$P_i\;(P_i&gt;0)$。<br>在一次跳跃中，位于摩天楼$b$而跳跃能力为$p$的$\mathrm{doge}$可以跳跃到编号为$b-p$（如果$0\le b-p&lt;N$）或$b+p$（如果$0\le b+p&lt;N$）的摩天楼。<br>编号为$0$的$\mathrm{doge}$是所有$\mathrm{doge}$的首领，它有一条紧急的消息要尽快传送给编号为$1$的$\mathrm{doge}$。<br>任何一个收到消息的$\mathrm{doge}$有以下两个选择:</p><ul><li>跳跃到其他摩天楼上</li><li>将消息传递给它当前所在的摩天楼上的其他$\mathrm{doge}$</li></ul><p>请帮助$\mathrm{doge}$们计算将消息从$0$号$\mathrm{doge}$传递到$1$号$\mathrm{doge}$所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到$1$号$\mathrm{doge}$。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含两个整数$N$和$M$。<br>接下来$M$行，每行包含两个整数$B_i$和$P_i$。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一行，表示所需要的最少步数。<br>如果消息永远无法传递到$1$号$\mathrm{doge}$，输出$-1$。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">0 2</span><br><span class="line">1 1</span><br><span class="line">4 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="Explanation"><a href="#Explanation" class="headerlink" title="Explanation"></a>Explanation</h3><p>下面是一种步数为$5$的解决方案：<br>$0$号$\mathrm{doge}$跳跃到$2$号摩天楼，再跳跃到$4$号摩天楼（$2$步）。<br>$0$号$\mathrm{doge}$将消息传递给$2$号$\mathrm{doge}$。<br>$2$号$\mathrm{doge}$跳跃到$3$号摩天楼,接着跳跃到$2$号摩天楼，再跳跃到$1$号摩天楼（$3$步）。<br>$2$号$\mathrm{doge}$将消息传递给$1$号$\mathrm{doge}$。</p><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$1\le N,P_i\le3\times10^4,\;2\le M\le3\times 10^4,\;0\le B_i&lt;N$</p><p>标签：<code>最短路</code> <code>分块</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><code>分块</code>优化最短路建边。新姿势$\mathrm{get}$。</p><p>考虑直接建边，由于可以多次跳跃，最多会形成$n^2$条边，肯定不行。</p><p>正解是给每个结点建立若干个辅助结点，像分块一样把建边数降下来。<br>具体来说，设块大小为$\mathrm{MAGIC}$，</p><ul><li>对于$p_i&gt;\mathrm{MAGIC}$，连出的边数较少，可以直接连边</li><li>对于$p_i\le\mathrm{MAGIC}$，连出的边数较多，需要对每个点建立$\mathrm{MAGIC}$个中转节点，第$i$个点的第$k$个中转节点只会通向距离$i$距离恰为$k$的结点$j$的第$k$个中转节点。可以理解为建立的图为$\mathrm{MAGIC}$层的高架桥，越高层的道路每次走的距离越大。对于点$i$，连接第$0$层的$i$结点（表示$i$结点本身）到第$p_i$层的$i$结点（表示每次走的距离都是$p_i$）。</li></ul><p>初始化同节点层与层之间的连边，即对于$i$结点，连接其每个中转节点到其本身（即第$0$层的$i$结点）边权为$0$，这样如果在某节点$u$想要停止跳过来时的步长$x$，转用$u$结点本身的步长$y$，则可以从$i$的第$x$个中转节点花费$0$的代价走到$i$结点本身，再花费$0$的代价走到$i$的第$y$个中转节点。</p><p>如此，边数和点数都变成了$n\sqrt{n}​$级别，由于卡内存，可以把$\mathrm{MAGIC}​$调成$\min(\sqrt{n},100)​$。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir top().first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec top().second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 4000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 15000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; pii;</span><br><span class="line"><span class="keyword">typedef</span> priority_queue&lt;pii&gt; pri_que;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, MAGIC, b[MAX_N+<span class="number">5</span>], p[MAX_N+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>], cnt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="keyword">int</span> pr[MAX_N+<span class="number">5</span>]; pri_que que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> s = b[<span class="number">1</span>], t = b[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> d);</span><br><span class="line">d[s] = <span class="number">0</span>, que.push(mp(-d[s], s));</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.sec, w = -que.fir;</span><br><span class="line">que.pop(); <span class="keyword">if</span> (d[u]^w) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u], v, c; ~i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (d[u]+(c=E[i].c) &lt; d[v = E[i].v])</span><br><span class="line">d[v] = d[u]+c, que.push(mp(-d[v], v));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d[t] == INF ? <span class="number">-1</span> : d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);</span><br><span class="line">read(n), read(m), MAGIC = min((<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n), <span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(b[i]), read(p[i]), b[i]++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAGIC; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) addedge(i*n+j, j, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= MAGIC; i++) <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n-i; j++)</span><br><span class="line">addedge(i*n+j, i*n+i+j, <span class="number">1</span>), addedge(i*n+i+j, i*n+j, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">if</span> (p[i] &lt;= MAGIC) addedge(b[i], p[i]*n+b[i], <span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = b[i]+p[i]; j &lt;= n; j += p[i])</span><br><span class="line">addedge(b[i], j, (j-b[i])/p[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = b[i]-p[i]; j &gt;= <span class="number">1</span>; j -= p[i])</span><br><span class="line">addedge(b[i], j, (b[i]-j)/p[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Dijkstra()), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2015】雅加达的摩天楼&quot;&gt;&lt;a href=&quot;#【APIO2015】雅加达的摩天楼&quot; class=&quot;headerlink&quot; title=&quot;【APIO2015】雅加达的摩天楼&quot;&gt;&lt;/a&gt;【APIO2015】雅加达的摩天楼&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;印尼首都雅加达市有$N$座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为$0$到$N-1$。除了这$N$座摩天楼外，雅加达市没有其他摩天楼。&lt;br&gt;有$M$只叫做$\mathrm{doge}$的神秘生物在雅加达市居住，它们的编号依次是$0$到$M-1$。编号为$i$的$\mathrm{doge}$最初居住于编号为$B_i$的摩天楼。每只$\mathrm{doge}$都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为$i$的$\mathrm{doge}$的跳跃能力为$P_i\;(P_i&amp;gt;0)$。&lt;br&gt;在一次跳跃中，位于摩天楼$b$而跳跃能力为$p$的$\mathrm{doge}$可以跳跃到编号为$b-p$（如果$0\le b-p&amp;lt;N$）或$b+p$（如果$0\le b+p&amp;lt;N$）的摩天楼。&lt;br&gt;编号为$0$的$\mathrm{doge}$是所有$\mathrm{doge}$的首领，它有一条紧急的消息要尽快传送给编号为$1$的$\mathrm{doge}$。&lt;br&gt;任何一个收到消息的$\mathrm{doge}$有以下两个选择:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跳跃到其他摩天楼上&lt;/li&gt;
&lt;li&gt;将消息传递给它当前所在的摩天楼上的其他$\mathrm{doge}$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请帮助$\mathrm{doge}$们计算将消息从$0$号$\mathrm{doge}$传递到$1$号$\mathrm{doge}$所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到$1$号$\mathrm{doge}$。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含两个整数$N$和$M$。&lt;br&gt;接下来$M$行，每行包含两个整数$B_i$和$P_i$。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一行，表示所需要的最少步数。&lt;br&gt;如果消息永远无法传递到$1$号$\mathrm{doge}$，输出$-1$。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
      <category term="分块" scheme="http://azrael.top/tags/%E5%88%86%E5%9D%97/"/>
    
      <category term="最短路" scheme="http://azrael.top/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ1178【APIO2009】会议中心 &lt;贪心+倍增&gt;</title>
    <link href="http://azrael.top/BZOJ1178%E3%80%90APIO2009%E3%80%91%E4%BC%9A%E8%AE%AE%E4%B8%AD%E5%BF%83%20%E8%B4%AA%E5%BF%83+%E5%80%8D%E5%A2%9E/"/>
    <id>http://azrael.top/BZOJ1178【APIO2009】会议中心 贪心+倍增/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-20T12:58:24.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2009】会议中心"><a href="#【APIO2009】会议中心" class="headerlink" title="【APIO2009】会议中心"></a>【APIO2009】会议中心</h3><p>$\mathrm{Time\;Limit:\;15\;Sec}$<br>$\mathrm{Memory\;Limit:\;162\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Siruseri}$政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。<br>对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。<br>显然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有$4$个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。</p><table><thead><tr><th>公司</th><th>开始日期</th><th>结束日期</th></tr></thead><tbody><tr><td>$公司1$</td><td>$4$</td><td>$9$</td></tr><tr><td>$公司2$</td><td>$9$</td><td>$11$</td></tr><tr><td>$公司3$</td><td>$13$</td><td>$19$</td></tr><tr><td>$公司4$</td><td>$10$</td><td>$17$</td></tr></tbody></table><p>上例中，最多将会堂租借给两家公司。租借策略分别是租给$公司1$和$公司3$， 或是$公司2$和$公司3$，也可以是$公司1$和$公司4$。注意会议中心一天最多租借给 一个公司，所以$公司1$和$公司2$不能同时租借会议中心，因为他们在第九天重合 了。<br>销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小的候选策略作为最终的策略。<br>例中，会堂最终将被租借给$公司1$和$公司3$：$3$个候选策略是 $\lbrace(1,3),(2,3),(1,4)\rbrace$，而在字典序中$(1,3)&lt;(1,4)&lt;(2,3)$。<br>你的任务是帮助销售主管确定应该将会堂租借给哪些公司。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>第一行有一个整数$N\;(N\le2\times10^5)$，表示发出租借会堂申请的公司的个数。<br>第$2$到第$N+1$行每行有$2$个整数。第$i+1$行的整数表示第$i$家公司申请租借的起始和终止日期。<br>对于每个公司的申请，起始日期为不小于$1$的整数，终止日期为不大于$10^9$的整数。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出的第一行应有一个整数$M$，表示最多可以租借给多少家公司。<br>第二行应列出$M$个数，表示最终将会堂租借给哪些公司。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4 9</span><br><span class="line">9 11</span><br><span class="line">13 19</span><br><span class="line">10 17</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>修复数据$\mathrm{BUG}$，并新加数据一组。$\mathrm{By\;NanoApe\;2016.5.11}$<br><a href="http://www.lydsy.com/JudgeOnline/upload/201605/dd.rar" target="_blank" rel="noopener">修复后数据</a></p><p>标签：<code>贪心</code> <code>倍增</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>思路清奇的贪心…</p><p>如果没有“字典序最小”，直接无脑贪心即可。有输方案的要求后，就需要用另外一种贪心。</p><p>首先先做一遍贪心找到最多能有多少个会议，然后从$1$到$n$按编号枚举会议，看当前会议加入后会不会使答案变小，如果不会变小就贪心把这个会议加入到方案中。</p><p>具体地，首先以$r$从小到大为第一关键字，以$l$从大到小为第二关键字排序，去掉包含的区间。<br>找到一种方法（一会儿说）计算$F(p,q)$，表示$p\sim q$时间段最多可以放多少个会议。<br>对于会议$i$，其时间段是$[l,r]$，已经加入的会议中此会议的前驱的结束时间是$lr$，后继的开始时间是$rl$（前驱和后继用<code>set</code>维护）。</p><ul><li>若$l\le lr$或$r\ge rl$，那么一定不能放入。</li><li>若$F(lr+1,l-1)+F(r+1,rl-1)+1=F(lr+1,rl-1)$，那么放入后一定不会影响答案，输出编号后把此会议加入<code>set</code>即可。这个等式表示加入此会议后虽然把原区间分成了三个子区间，但最大值依旧不变。</li><li>若$F(lr+1,l-1)+F(r+1,rl-1)+1\ne F(lr+1,rl-1)$，那么不能放入。</li></ul><p>这样一来，就可以解决输出方案的问题了。</p><p>但如何计算$F(p,q)$呢？<br>如果直接算，是$O(n)$的，考虑把这个过程变成$O(\log n)$。<br>倍增预处理出$nxt[u][i]$，表示从区间$u$开始向后选$2^i$个连续区间，最后一个区间的编号。于是每次计算可以倍增跳累加答案。</p><p>$\mathrm{Problem\;solved.}$</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, L[MAX_N+<span class="number">5</span>], R[MAX_N+<span class="number">5</span>], nxt[MAX_N+<span class="number">5</span>][LOG+<span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> l, r; <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span>;&#125; a[MAX_N+<span class="number">5</span>], b[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bool</span> node::<span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp;t) <span class="keyword">const</span> &#123;<span class="keyword">return</span> r == t.r ? l &gt; t.l : r &lt; t.r;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> u = lower_bound(L+<span class="number">1</span>, L+m+<span class="number">1</span>, l)-L, ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (u &gt; m || R[u] &gt; r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = LOG; ~i; i--)</span><br><span class="line"><span class="keyword">if</span> (nxt[u][i] &amp;&amp; R[nxt[u][i]] &lt;= r)</span><br><span class="line">ret += <span class="number">1</span>&lt;&lt;i, u = nxt[u][i];</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n); <span class="built_in">set</span> &lt;node&gt; s;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(a[i].l), read(a[i].r), b[i] = a[i];</span><br><span class="line">sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>), m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span> (b[i].l &gt; b[m].l) b[++m] = b[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) L[i] = b[i].l, R[i] = b[i].r;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= m &amp;&amp; b[j].l &lt;= b[i].r) j++;</span><br><span class="line"><span class="keyword">if</span> (j &lt;= m) nxt[i][<span class="number">0</span>] = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= LOG; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">nxt[j][i] = nxt[nxt[j][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">s.insert((node)&#123;-INF, -INF&#125;), s.insert((node)&#123;INF, INF&#125;);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, calc(-INF, INF));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">set</span> &lt;node&gt; :: iterator ln = s.lower_bound(a[i]), rn = ln;</span><br><span class="line">ln--; <span class="keyword">int</span> l = a[i].l, r = a[i].r, lr = ln-&gt;r, rl = rn-&gt;l;</span><br><span class="line"><span class="keyword">if</span> (l &lt;= lr || r &gt;= rl) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (calc(lr+<span class="number">1</span>, rl<span class="number">-1</span>) == calc(lr+<span class="number">1</span>, l<span class="number">-1</span>)+calc(r+<span class="number">1</span>, rl<span class="number">-1</span>)+<span class="number">1</span>)</span><br><span class="line">s.insert(a[i]), <span class="built_in">printf</span>(<span class="string">"%d "</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">""</span>), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2009】会议中心&quot;&gt;&lt;a href=&quot;#【APIO2009】会议中心&quot; class=&quot;headerlink&quot; title=&quot;【APIO2009】会议中心&quot;&gt;&lt;/a&gt;【APIO2009】会议中心&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;15\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;162\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Siruseri}$政府建造了一座新的会议中心。许多公司对租借会议中心的会堂很感兴趣，他们希望能够在里面举行会议。&lt;br&gt;对于一个客户而言，仅当在开会时能够独自占用整个会堂，他才会租借会堂。会议中心的销售主管认为：最好的策略应该是将会堂租借给尽可能多的客户。&lt;br&gt;显然，有可能存在不止一种满足要求的策略。 例如下面的例子。总共有$4$个公司。他们对租借会堂发出了请求，并提出了他们所需占用会堂的起止日期（如下表所示）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;公司&lt;/th&gt;
&lt;th&gt;开始日期&lt;/th&gt;
&lt;th&gt;结束日期&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$公司1$&lt;/td&gt;
&lt;td&gt;$4$&lt;/td&gt;
&lt;td&gt;$9$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司2$&lt;/td&gt;
&lt;td&gt;$9$&lt;/td&gt;
&lt;td&gt;$11$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司3$&lt;/td&gt;
&lt;td&gt;$13$&lt;/td&gt;
&lt;td&gt;$19$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$公司4$&lt;/td&gt;
&lt;td&gt;$10$&lt;/td&gt;
&lt;td&gt;$17$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上例中，最多将会堂租借给两家公司。租借策略分别是租给$公司1$和$公司3$， 或是$公司2$和$公司3$，也可以是$公司1$和$公司4$。注意会议中心一天最多租借给 一个公司，所以$公司1$和$公司2$不能同时租借会议中心，因为他们在第九天重合 了。&lt;br&gt;销售主管为了公平起见，决定按照如下的程序来确定选择何种租借策略：首先，将租借给客户数量最多的策略作为候选，将所有的公司按照他们发出请求的 顺序编号。对于候选策略，将策略中的每家公司的编号按升序排列。最后，选出其中字典序最小的候选策略作为最终的策略。&lt;br&gt;例中，会堂最终将被租借给$公司1$和$公司3$：$3$个候选策略是 $\lbrace(1,3),(2,3),(1,4)\rbrace$，而在字典序中$(1,3)&amp;lt;(1,4)&amp;lt;(2,3)$。&lt;br&gt;你的任务是帮助销售主管确定应该将会堂租借给哪些公司。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;第一行有一个整数$N\;(N\le2\times10^5)$，表示发出租借会堂申请的公司的个数。&lt;br&gt;第$2$到第$N+1$行每行有$2$个整数。第$i+1$行的整数表示第$i$家公司申请租借的起始和终止日期。&lt;br&gt;对于每个公司的申请，起始日期为不小于$1$的整数，终止日期为不大于$10^9$的整数。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出的第一行应有一个整数$M$，表示最多可以租借给多少家公司。&lt;br&gt;第二行应列出$M$个数，表示最终将会堂租借给哪些公司。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="贪心" scheme="http://azrael.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="倍增" scheme="http://azrael.top/tags/%E5%80%8D%E5%A2%9E/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>【APIO2011】方格染色 &lt;带权并查集&gt;</title>
    <link href="http://azrael.top/BZOJ2303%E3%80%90APIO2011%E3%80%91%E6%96%B9%E6%A0%BC%E6%9F%93%E8%89%B2%20%E5%B8%A6%E6%9D%83%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://azrael.top/BZOJ2303【APIO2011】方格染色 带权并查集/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-20T12:21:28.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2011】方格染色"><a href="#【APIO2011】方格染色" class="headerlink" title="【APIO2011】方格染色"></a>【APIO2011】方格染色</h3><p>$\mathrm{Time\;Limit:\;20\;Sec}$<br>$\mathrm{Memory\;Limit:\;256MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>$\mathrm{Sam}$和他的妹妹$\mathrm{Sara}$有一个包含$n\times m$个方格的表格。她们想要将其的每个方格都染成红色或蓝色。<br>出于个人喜好，他们想要表格中每个$2\times 2$的方形区域都包含奇数个（$1$个或$3$个）红色方格。 可是昨天晚上，有人已经给表格中的一些方格染上了颜色！<br>现在$\mathrm{Sam}$和$\mathrm{Sara}$非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格仍然满足她们的要求。<br>如果可能的话，满足他们要求的染色方案数有多少呢？</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>输入的第一行包含三个整数$n$, $m$和$k$，分别代表表格的行数、列数和已被染色的方格数目。<br>之后的$k$行描述已被染色的方格。其中第$i$行包含三个整数$x_i$, $y_i$和$c_i$，分别代表第$i$个已被染色的方格的行编号、列编号和颜色。$c_i$为$1$表示方格被染成红色，$c_i$为$0$表示方格被染成蓝色。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个整数，表示可能的染色方案数目$W$模$10^9$得到的值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>对于所有的测试数据，$2\le n,m\le10^6$, $0\le k\le10^6$, $1\le x_i\le n$, $1\le y_i\le m$。<br>数据为国内数据+国际数据+修正版<br>鸣谢<code>GYZ</code></p><p>标签：<code>带权并查集</code> <code>异或方程组</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>并查集解异或方程组。</p><p>令$a_{i,j}$表示第$i$行第$j$列的格子最终是否被染，对于$\forall i\in[1,n),j\in[1,m)$，一定有$a_{i,j}\oplus a_{i,j+1}\oplus a_{i+1,j}\oplus a_{i+1,j+1}=1$。而易得到结论：确定一行一列的情况，即可确定最后是否能正确染色。</p><p>于是我们尝试确定第一行和第一列的情况，即做一个$n+m-1$个变量的异或方程组。<br>对于给定的$a_{x,y}=0/1$，我们如果把$i\in[1,x),j\in[1,y)$的所有上一段所属方程异或起来，那么相同元抵消，可知$a_{1,1}\oplus a_{i,1}\oplus a_{1,j}=a_{i,j}\oplus1$，如果我们知道$a_{1,1}$，那么就能确定$a_{i,1}\oplus a_{1,j}$的值，这时用一个带权并查集维护一下，即可得到联通块的个数。那么答案为$2^{自由元个数-1}$（$a_{1,1}$所在联通块的取值是一定的）。<br>如果我们预先不知道$a_{1,1}$的值，就可以枚举两种取值，分别计算后加起来即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 200000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k, f[MAX_N+<span class="number">5</span>], g[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> x[MAX_N+<span class="number">5</span>], y[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> f[x] == x ? x : getf(f[x]), g[x] ^= g[f[x]], f[x] = f[f[x]];&#125;</span><br><span class="line"><span class="function">lnt <span class="title">calc</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">lnt ret = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> (x[i] &gt; <span class="number">1</span> &amp;&amp; y[i] &gt; <span class="number">1</span>) c[i] ^= val;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n+m; i++) f[i] = i, g[i] = <span class="number">0</span>; f[n+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) <span class="keyword">if</span> ((x[i]^<span class="number">1</span>) || (y[i]^<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> u = getf(x[i]), v = getf(y[i]+n), w = g[x[i]]^g[y[i]+n]^c[i];</span><br><span class="line"><span class="keyword">if</span> (u^v) f[v] = u, g[v] = w; <span class="keyword">else</span> <span class="keyword">if</span> (w) <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t = <span class="number">0</span>; i &lt;= n+m; i++) <span class="keyword">if</span> (getf(i) == i)</span><br><span class="line">&#123;<span class="keyword">if</span> (t) (ret *= <span class="number">2L</span>L) %= MOD; <span class="keyword">else</span> t = <span class="number">1</span>;&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m), read(k);</span><br><span class="line"><span class="keyword">bool</span> f0 = <span class="literal">true</span>, f1 = <span class="literal">true</span>; lnt ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">read(x[i]), read(y[i]), read(c[i]);</span><br><span class="line"><span class="keyword">if</span> (!(x[i]%<span class="number">2</span>) &amp;&amp; !(y[i]%<span class="number">2</span>)) c[i] ^= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x[i] == <span class="number">1</span> &amp;&amp; y[i] == <span class="number">1</span>) c[i] ? f0 = <span class="literal">false</span> : f1 = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (f0) (ans += calc(<span class="number">0</span>)) %= MOD;</span><br><span class="line"><span class="keyword">if</span> (f1) (ans += calc(<span class="number">1</span>)) %= MOD;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2011】方格染色&quot;&gt;&lt;a href=&quot;#【APIO2011】方格染色&quot; class=&quot;headerlink&quot; title=&quot;【APIO2011】方格染色&quot;&gt;&lt;/a&gt;【APIO2011】方格染色&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;20\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;$\mathrm{Sam}$和他的妹妹$\mathrm{Sara}$有一个包含$n\times m$个方格的表格。她们想要将其的每个方格都染成红色或蓝色。&lt;br&gt;出于个人喜好，他们想要表格中每个$2\times 2$的方形区域都包含奇数个（$1$个或$3$个）红色方格。 可是昨天晚上，有人已经给表格中的一些方格染上了颜色！&lt;br&gt;现在$\mathrm{Sam}$和$\mathrm{Sara}$非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格仍然满足她们的要求。&lt;br&gt;如果可能的话，满足他们要求的染色方案数有多少呢？&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;输入的第一行包含三个整数$n$, $m$和$k$，分别代表表格的行数、列数和已被染色的方格数目。&lt;br&gt;之后的$k$行描述已被染色的方格。其中第$i$行包含三个整数$x_i$, $y_i$和$c_i$，分别代表第$i$个已被染色的方格的行编号、列编号和颜色。$c_i$为$1$表示方格被染成红色，$c_i$为$0$表示方格被染成蓝色。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个整数，表示可能的染色方案数目$W$模$10^9$得到的值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="并查集" scheme="http://azrael.top/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ5180【Baltic2016】Cities &lt;斯坦纳树&gt;</title>
    <link href="http://azrael.top/BZOJ5180%E3%80%90Baltic2016%E3%80%91Cities%20%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    <id>http://azrael.top/BZOJ5180【Baltic2016】Cities 斯坦纳树/</id>
    <published>2018-04-16T16:00:00.000Z</published>
    <updated>2018-04-23T13:53:16.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【Baltic2016】Cities"><a href="#【Baltic2016】Cities" class="headerlink" title="【Baltic2016】Cities"></a>【Baltic2016】Cities</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;256\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>给定$n$个点，$m$条双向边的图，其中有$k$个点是重要的，每条边都有一定的长度。<br>现在要你选定一些边来构成一个图，要使得$k$个重要的点相互连通，求边的长度和的最小值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>共$m+2$行<br>第$1$行读入$n,k,m$，表示$n$个点，$k$个重要的点，$m$条边<br>第$2$行读入$k$个重要点的编号<br>第$3$至第$m+2$行，每行包括$3$个数字$a,b,c$，表示有一条从$a$到$b$长度为$c$的双向路径</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>共$1$行，即最小长度和<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 3 6</span><br><span class="line">1 3 4</span><br><span class="line">1 2 4</span><br><span class="line">1 3 9</span><br><span class="line">1 4 6</span><br><span class="line">2 3 2</span><br><span class="line">2 4 5</span><br><span class="line">3 4 8</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p>$k\le5,\;n\le10^5,\;1\le m\le2\times10^5$</p><p>标签：<code>斯坦纳树</code> <code>状压DP</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>斯坦纳树裸题。</p><p>斯坦纳树的基本解法是状压$\mathrm{DP}$，压缩联通状态进行$\mathrm{DP}$，$f[s][i]$表示在$i$点，联通状态为$s$的最小花费。<br>有两种转移：</p><ul><li>状态$s$可以通过两个状态组合而来，对于$s$的一个子集$t$，有$f[s][i]=\max(f[s][i],f[t][i]+f[s-t][i])$</li><li>状态$s$也可以在同层向邻接点扩展，即最短路中的松弛操作，对于边$u,v$，有$f[s][v]=\max(f[s][v],f[s][u]+Edge_{u,v})$，可以跑最短路更新。</li></ul><p>此题有点卡，注意不要用<code>SPFA</code>，要用<code>堆优Dijkstra</code>。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fir first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sec second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp make_pair</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;lnt,<span class="keyword">int</span>&gt; pli;</span><br><span class="line"><span class="keyword">typedef</span> priority_queue&lt;pli&gt; pri_que;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, k; lnt f[<span class="number">32</span>][MAX_N+<span class="number">5</span>]; <span class="keyword">bool</span> mrk[<span class="number">32</span>][MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="built_in">vector</span> &lt;lnt&gt; E[MAX_N+<span class="number">5</span>]; pri_que que;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;G[u].push_back(v), E[u].push_back(c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, lnt c)</span> </span>&#123;insert(u, v, c), insert(v, u, c);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(k), read(m), <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, p; i &lt; k; i++) read(p), f[<span class="number">1</span>&lt;&lt;i][p] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, c; i &lt;= m; i++)</span><br><span class="line">read(u), read(v), read(c), addedge(u, v, c);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span>&lt;&lt;k); s++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> t = (s<span class="number">-1</span>)&amp;s; t; t = (t<span class="number">-1</span>)&amp;s)</span><br><span class="line">f[s][i] = min(f[s][i], f[t][i]+f[s^t][i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) que.push(mp(-f[s][i], i));</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.top().sec; que.pop();</span><br><span class="line"><span class="keyword">if</span> (mrk[s][u]) <span class="keyword">continue</span>; mrk[s][u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line"><span class="keyword">if</span> (f[s][v = G[u][i]] &gt; f[s][u]+E[u][i])</span><br><span class="line">f[s][v] = f[s][u]+E[u][i], que.push(mp(-f[s][v], v));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">lnt mi = <span class="number">1L</span>L&lt;&lt;<span class="number">62</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">mi = min(mi, f[(<span class="number">1</span>&lt;&lt;k)<span class="number">-1</span>][i]);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mi), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【Baltic2016】Cities&quot;&gt;&lt;a href=&quot;#【Baltic2016】Cities&quot; class=&quot;headerlink&quot; title=&quot;【Baltic2016】Cities&quot;&gt;&lt;/a&gt;【Baltic2016】Cities&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;256\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;给定$n$个点，$m$条双向边的图，其中有$k$个点是重要的，每条边都有一定的长度。&lt;br&gt;现在要你选定一些边来构成一个图，要使得$k$个重要的点相互连通，求边的长度和的最小值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;共$m+2$行&lt;br&gt;第$1$行读入$n,k,m$，表示$n$个点，$k$个重要的点，$m$条边&lt;br&gt;第$2$行读入$k$个重要点的编号&lt;br&gt;第$3$至第$m+2$行，每行包括$3$个数字$a,b,c$，表示有一条从$a$到$b$长度为$c$的双向路径&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;共$1$行，即最小长度和&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="DP" scheme="http://azrael.top/tags/DP/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="状压DP" scheme="http://azrael.top/tags/%E7%8A%B6%E5%8E%8BDP/"/>
    
      <category term="斯坦纳树" scheme="http://azrael.top/tags/%E6%96%AF%E5%9D%A6%E7%BA%B3%E6%A0%91/"/>
    
      <category term="Baltic" scheme="http://azrael.top/tags/Baltic/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ2809【APIO2012】Dispatching &lt;可并堆&gt;</title>
    <link href="http://azrael.top/BZOJ2809%E3%80%90APIO2012%E3%80%91Dispatching%20%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    <id>http://azrael.top/BZOJ2809【APIO2012】Dispatching 可并堆/</id>
    <published>2018-04-15T16:00:00.000Z</published>
    <updated>2018-04-16T08:51:55.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【APIO2012】Dispatching"><a href="#【APIO2012】Dispatching" class="headerlink" title="【APIO2012】Dispatching"></a>【APIO2012】Dispatching</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;128\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。<br>在这个帮派里，有一名忍者被称之为$\mathrm{Master}$。除了$\mathrm{Master}$以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。<br>现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，就不需要支付管理者的薪水。你的目标是在预算内使顾客的满意度最大。<br>这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。<br>写一个程序，给定每一个忍者$i$的上级$B_i$，薪水$C_i$，领导力$L_i$，以及支付给忍者们的薪水总预算$M$，输出在预算内满足上述要求时顾客满意度的最大值。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>从标准输入读入数据。<br>第一行包含两个整数$N$和$M$，其中$N$表示忍者的个数，$M$表示薪水的总预算。<br>接下来$N$行描述忍者们的上级、薪水以及领导力。其中的第$i$行包含三个整数$B_i,C_i,L_i$分别表示第$i$个忍者的上级，薪水以及领导力。$\mathrm{Master}$满足$B_i=0$，并且每一个忍者的老板的编号一定小于自己的编号。</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>输出一个数，表示在预算内顾客的满意度的最大值。<br><a id="more"></a></p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">0 3 3</span><br><span class="line">1 3 5</span><br><span class="line">2 2 2</span><br><span class="line">1 2 4</span><br><span class="line">2 3 1</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p><strong>样例解释</strong><br>如果我们选择编号为$1$的忍者作为管理者并且派遣第三个和第四个忍者，薪水总和为$4$，没有超过总预算$4$。<br>因为派遣了$2$个忍者并且管理者的领导力为$3$，用户的满意度为$6$，是可以得到的用户满意度的最大值。<br><strong>数据范围</strong><br>$1\le N\le10^5,\;1\le M\le10^9,\;0\le B_i&lt;i,\;1\le C_i\le M,\;1\le L_i\le10^9$</p><p>标签：<code>可并堆</code> <code>左偏树</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>可并堆基础题。</p><p>对于每个结点作领导的情况，贪心策略肯定在其子树中从小往大选，直到选不了为止。可以每个结点用一个堆维护，但遍历子树会导致复杂度爆炸。</p><p>考虑每次用已经算出的一些结点的答案。那么可以想到一种做法：<br>将每个结点子树中的所有点默认先选上，再从大往小去掉直到可行为止。这样在儿子结点中都没选到的点一定不会在父节点中选到。于是可以直接将每个结点最后选出的点加入到父亲的备选点集中。这样不难发现可以用可并堆维护，$\mathrm{DFS}$时将所有儿子结点的可并堆并起来，再从大往小$\mathrm{pop}$点，找到可行最大$size$后更新答案即可。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> lnt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> c, d, ls, rs;&#125; h[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> n, m, b[MAX_N+<span class="number">5</span>], c[MAX_N+<span class="number">5</span>], l[MAX_N+<span class="number">5</span>], sz[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; G[MAX_N+<span class="number">5</span>]; <span class="keyword">int</span> fa[MAX_N+<span class="number">5</span>]; lnt mx, s[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;<span class="keyword">return</span> fa[x] == x ? fa[x] : getf(fa[x]);&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> a^b;</span><br><span class="line"><span class="keyword">if</span> (h[a].c &lt; h[b].c) swap(a, b);</span><br><span class="line">h[a].rs = merge(h[a].rs, b), fa[h[a].rs] = a;</span><br><span class="line"><span class="keyword">if</span> (h[h[a].rs].d &gt; h[h[a].ls].d) swap(h[a].ls, h[a].rs);</span><br><span class="line">h[a].d = h[a].rs ? h[h[a].rs].d+<span class="number">1</span> : <span class="number">0</span>;<span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = h[a].ls, r = h[a].rs;</span><br><span class="line">h[a].ls = h[a].rs = h[a].c = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> fa[l] = l, fa[r] = r, merge(l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rt = u;s[u] = c[u], sz[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, v; i &lt; (<span class="keyword">int</span>)G[u].size(); i++)</span><br><span class="line">rt = merge(rt, DFS(v = G[u][i])), s[u] += s[v], sz[u] += sz[v];</span><br><span class="line"><span class="keyword">while</span> (s[u] &gt; m &amp;&amp; sz[u]) s[u] -= h[rt].c, sz[u]--, rt = pop(rt);</span><br><span class="line"><span class="keyword">return</span> mx = max(mx, <span class="number">1L</span>L*sz[u]*l[u]), rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">read(b[i]), read(c[i]), read(l[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">G[b[i]].push_back(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">fa[i] = i, h[i].c = c[i];</span><br><span class="line"><span class="keyword">return</span> DFS(<span class="number">1</span>), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mx), <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【APIO2012】Dispatching&quot;&gt;&lt;a href=&quot;#【APIO2012】Dispatching&quot; class=&quot;headerlink&quot; title=&quot;【APIO2012】Dispatching&quot;&gt;&lt;/a&gt;【APIO2012】Dispatching&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;128\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。&lt;br&gt;在这个帮派里，有一名忍者被称之为$\mathrm{Master}$。除了$\mathrm{Master}$以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。&lt;br&gt;现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，就不需要支付管理者的薪水。你的目标是在预算内使顾客的满意度最大。&lt;br&gt;这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。&lt;br&gt;写一个程序，给定每一个忍者$i$的上级$B_i$，薪水$C_i$，领导力$L_i$，以及支付给忍者们的薪水总预算$M$，输出在预算内满足上述要求时顾客满意度的最大值。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;从标准输入读入数据。&lt;br&gt;第一行包含两个整数$N$和$M$，其中$N$表示忍者的个数，$M$表示薪水的总预算。&lt;br&gt;接下来$N$行描述忍者们的上级、薪水以及领导力。其中的第$i$行包含三个整数$B_i,C_i,L_i$分别表示第$i$个忍者的上级，薪水以及领导力。$\mathrm{Master}$满足$B_i=0$，并且每一个忍者的老板的编号一定小于自己的编号。&lt;/p&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;输出一个数，表示在预算内顾客的满意度的最大值。&lt;br&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="数据结构" scheme="http://azrael.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="APIO" scheme="http://azrael.top/tags/APIO/"/>
    
      <category term="可并堆" scheme="http://azrael.top/tags/%E5%8F%AF%E5%B9%B6%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>BZOJ5251【2018多省省队联测】劈配 &lt;网络流&gt;</title>
    <link href="http://azrael.top/BZOJ5251%E3%80%902018%E5%A4%9A%E7%9C%81%E7%9C%81%E9%98%9F%E8%81%94%E6%B5%8B%E3%80%91%E5%8A%88%E9%85%8D%20%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <id>http://azrael.top/BZOJ5251【2018多省省队联测】劈配 网络流/</id>
    <published>2018-04-13T16:00:00.000Z</published>
    <updated>2018-04-16T08:38:56.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h2><h3 id="【2018多省省队联测】劈配"><a href="#【2018多省省队联测】劈配" class="headerlink" title="【2018多省省队联测】劈配"></a>【2018多省省队联测】劈配</h3><p>$\mathrm{Time\;Limit:\;10\;Sec}$<br>$\mathrm{Memory\;Limit:\;512\;MB}$</p><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>一年一度的综艺节目《中国新代码》又开始了。$\mathrm{Zayid}$从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。<br>轻车熟路的$\mathrm{Zayid}$顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：<br>总共$n$名参赛选手（编号从$1$至$n$）每人写出一份代码并介绍自己的梦想。接着由所有导师对这些选手进行排名。<br>为了避免后续的麻烦，规定不存在排名并列的情况。<br>同时，每名选手都将独立地填写一份志愿表，来对总共$m$位导师（编号从$1$至$m$）作出评价。志愿表上包含了共$m$档志愿。对于每一档志愿，选手被允许填写最多$C$位导师，每位导师最多被每位选手填写一次（放弃某些导师也是被允许的）。<br>在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。<br>节目组对“前$i$名的录取结果最优”作出如下定义：</p><ul><li>前$1$名的录取结果最优，当且仅当第$1$名被其最高非空志愿录取（特别地，如果第$1$名没有填写志愿表，那么该选手出局）。</li><li>前$i$名的录取结果最优，当且仅当在前$i-1$名的录取结果最优的情况下：第$i$名被其理论可能的最高志愿录取（特别地，如果第i名没有填写志愿表、或其所有志愿中的导师战队均已满员，那么该选手出局）。</li></ul><p>如果一种方案满足“前$n$名的录取结果最优”，那么我们可以简称这种方案是最优的。<br>举例而言，$2$位导师$T$老师、$F$老师的战队人数上限分别都是$1$人；$2$位选手$\mathrm{Zayid}$、$\mathrm{DuckD}$分列第$1、2$名。那么下面$3$种志愿表及其对应的最优录取结果如表中所示：</p><center><br><img src="https://www.lydsy.com/JudgeOnline/upload/201804/111(1).jpg" alt=""><br></center><p>可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。<br>每个人都有一个自己的理想值$s_i$，表示第$i$位同学希望自己被第$s_i$或更高的志愿录取，如果没有，那么他就会非常沮丧。<br>现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。<br>对于每一位选手，$\mathrm{Zayid}$都想知道下面两个问题的答案：</p><ul><li>在最优的录取方案中，他会被第几志愿录取。</li><li>在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。</li></ul><p>作为《中国新代码》的实力派代码手，$\mathrm{Zayid}$当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>每个测试点包含多组测试数据，第一行$2$个用空格隔开的非负整数$T,C$，分别表示数据组数、每档志愿最多允许填写的导师数目。<br>接下来依次描述每组数据，对于每组数据：</p><ul><li>第$1$行两个用空格隔开的正整数$n,m$。$n,m$分别表示选手的数量、导师的数量。</li><li>第$2$行$m$个用空格隔开的正整数：其中第$i$个整数为$b_i$。$B_i$表示编号为$i$的导师战队人数的上限。</li><li>第$3$行至第$n+2$行，每行$m$个用空格隔开的非负整数：其中第$i+2$行左起第$j$个数为$a_{i,j}$<ul><li>$a_{i,j}$表示编号为$i$的选手将编号为$j$的导师编排在了第$a_{i,j}$志愿。特别地，如果$a_{i,j}=0$，则表示该选手没有将该导师填入志愿表。</li><li>在这一部分，保证每行中不存在某一个正数出现超过$C$次（$0$可能出现超过$C$次），同时保证所有$a_{i,j}\le m$。</li></ul></li><li>第$n+3$行$n$个用空格隔开的正整数，其中第$i$个整数为$S_i$<ul><li>$S_i$表示编号为$i$的选手的理想值。</li><li>在这一部分，保证$S_i\le m$。</li></ul></li></ul><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>按顺序输出每组数据的答案。对于每组数据，输出$2$行：</p><ul><li>第$1$行输出$n$个用空格隔开的正整数，其中第$i$个整数的意义为：<ul><li>在最优的录取方案中，编号为$i$的选手会被该档志愿录取。</li><li>特别地，如果该选手出局，则这个数为$m+1$。</li></ul></li><li>第$2$行输出$n$个用空格隔开的非负整数，其中第$i$个整数的意义为：<ul><li>使编号为$i$的选手不沮丧，最少需要让他上升的排名数。</li><li>特别地，如果该选手一定会沮丧，则这个数为$i$。</li></ul></li></ul><a id="more"></a><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 2</span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">1 1</span><br><span class="line">0 1</span><br><span class="line">0 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">1 0</span><br><span class="line">1 2</span><br><span class="line">0 1</span><br><span class="line">1 3</span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><h3 id="HINT"><a href="#HINT" class="headerlink" title="HINT"></a>HINT</h3><p><strong>样例解释</strong><br>三组数据分别与题目描述中的三个表格对应。<br>对于第$1$组数据：由于选手$1$没有填写第一志愿，所以他一定无法被第一志愿录取，也就一定会沮丧。选手$2$按原排名就不沮丧，因此他不需要提升排名。<br>对于第$2$组和第$3$组数据：$1$号选手都不需要提升排名。而希望被第一志愿录取的$2$号选手都必须升到第$1$名才能如愿。<br><strong>数据范围</strong><br>$T\le 5,\;m\le n\le 200,\;B_i\le N$<br><a href="https://www.lydsy.com/JudgeOnline/upload/201804/day2(3).pdf" target="_blank" rel="noopener">原题面</a></p><p>标签：<code>网络流</code></p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>九省联考$\mathrm{Day2}$唯一一道有区分度的题。</p><p>容易看出本质就是一个二分图匹配。只不过每条边的优先度是有差别的。<br><strong>第一问</strong><br>先将源点到每个学员流量为$1$的边和导师到汇点的流量为$b$的边连上。<br>顺次考虑每个学员，每次将一个志愿中的所有导师的边加到图里，看能否使其找到匹配，找到就退出，标记此志愿为答案。</p><p><strong>第二问</strong><br>考虑像第一问那样判断，那么就可以每次加入一个学员，判断能否达到要求，当加入一个学员后不能达到要求时，$此时加入的学员数-1$为此人满足要求的最大名次，用其真实名次减去即可得到答案。注意特判无论如何都不能满足的情况。<br>另外，这里还可以二分答案，不过直接暴力加入在$\mathrm{BZOJ}$上已经可以过了。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 500</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">inline</span> <span class="title">void</span> <span class="title">read</span>(<span class="title">T</span> &amp;<span class="title">x</span>) &#123;</span></span><br><span class="line">x = <span class="number">0</span>; <span class="keyword">int</span> c = getchar(), f = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(c); c = getchar()) <span class="keyword">if</span> (c == <span class="number">45</span>) f = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (; <span class="built_in">isdigit</span>(c); c = getchar()) (x *= <span class="number">10</span>) += f*(c-<span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m, s, t, cnt, rk[MAX_N+<span class="number">5</span>], mi[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> b[MAX_N+<span class="number">5</span>], d[MAX_N+<span class="number">5</span>], pr[MAX_N+<span class="number">5</span>], cr[MAX_N+<span class="number">5</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span><span class="keyword">int</span> v, c, nxt;&#125; E[MAX_M+<span class="number">5</span>]; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; a[<span class="number">205</span>][<span class="number">205</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;s = <span class="number">0</span>, t = n+m+<span class="number">1</span>, cnt = <span class="number">0</span>, <span class="built_in">memset</span>(pr, <span class="number">-1</span>, <span class="keyword">sizeof</span> pr);&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;E[cnt] = (node)&#123;v, c, pr[u]&#125;, pr[u] = cnt++;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> c)</span> </span>&#123;insert(u, v, c), insert(v, u, <span class="number">0</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">BFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; que; que.push(s);</span><br><span class="line"><span class="built_in">memset</span>(d, <span class="number">-1</span>, <span class="keyword">sizeof</span> d), d[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = que.front(); que.pop();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (~d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>, que.push(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ~d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (u == t) <span class="keyword">return</span> flow;<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;i = pr[u]; ~i; i = E[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> v = E[i].v, c = E[i].c;</span><br><span class="line"><span class="keyword">if</span> (d[u]+<span class="number">1</span> != d[v] || !c) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = DFS(v, min(flow, c));</span><br><span class="line">E[i].c -= tmp, E[i^<span class="number">1</span>].c += tmp;</span><br><span class="line">flow -= tmp, ret += tmp;</span><br><span class="line"><span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ret) d[u] = <span class="number">-1</span>;<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpy</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) cr[i] = pr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rec</span><span class="params">()</span> </span>&#123;<span class="keyword">for</span> (<span class="keyword">int</span> i = s; i &lt;= t; i++) pr[i] = cr[i];&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;<span class="keyword">int</span> ret = <span class="number">0</span>; cpy(); <span class="keyword">while</span> (BFS()) ret += DFS(s, INF), rec(); <span class="keyword">return</span> ret;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) addedge(s, i, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) addedge(i+n, t, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; (<span class="keyword">int</span>)a[p][i].size(); j++)</span><br><span class="line">addedge(p, a[p][i][j]+n, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> Dinic();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, C; read(T), read(C);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) read(b[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">a[i][j].clear();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, x; j &lt;= m; j++)</span><br><span class="line">read(x), a[i][x].push_back(j);</span><br><span class="line">build();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">for</span> (rk[i] = <span class="number">1</span>; rk[i] &lt;= m; rk[i]++)</span><br><span class="line"><span class="keyword">if</span> (inc(i, rk[i], rk[i])) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k; i &lt;= n; i++) &#123;</span><br><span class="line">read(k), mi[i] = i, build();</span><br><span class="line"><span class="keyword">if</span> (!inc(i, <span class="number">1</span>, k)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; mi[i]--; j++) <span class="keyword">if</span> (rk[j] &lt;= m)</span><br><span class="line"><span class="keyword">if</span> (!inc(j, rk[j], rk[j])) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, rk[i]);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, mi[i]);<span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h2&gt;&lt;h3 id=&quot;【2018多省省队联测】劈配&quot;&gt;&lt;a href=&quot;#【2018多省省队联测】劈配&quot; class=&quot;headerlink&quot; title=&quot;【2018多省省队联测】劈配&quot;&gt;&lt;/a&gt;【2018多省省队联测】劈配&lt;/h3&gt;&lt;p&gt;$\mathrm{Time\;Limit:\;10\;Sec}$&lt;br&gt;$\mathrm{Memory\;Limit:\;512\;MB}$&lt;/p&gt;
&lt;h3 id=&quot;Description&quot;&gt;&lt;a href=&quot;#Description&quot; class=&quot;headerlink&quot; title=&quot;Description&quot;&gt;&lt;/a&gt;Description&lt;/h3&gt;&lt;p&gt;一年一度的综艺节目《中国新代码》又开始了。$\mathrm{Zayid}$从小就梦想成为一名程序员，他觉得这是一个展示自己的舞台，于是他毫不犹豫地报名了。&lt;br&gt;轻车熟路的$\mathrm{Zayid}$顺利地通过了海选，接下来的环节是导师盲选，这一阶段的规则是这样的：&lt;br&gt;总共$n$名参赛选手（编号从$1$至$n$）每人写出一份代码并介绍自己的梦想。接着由所有导师对这些选手进行排名。&lt;br&gt;为了避免后续的麻烦，规定不存在排名并列的情况。&lt;br&gt;同时，每名选手都将独立地填写一份志愿表，来对总共$m$位导师（编号从$1$至$m$）作出评价。志愿表上包含了共$m$档志愿。对于每一档志愿，选手被允许填写最多$C$位导师，每位导师最多被每位选手填写一次（放弃某些导师也是被允许的）。&lt;br&gt;在双方的工作都完成后，进行录取工作。每位导师都有自己战队的人数上限，这意味着可能有部分选手的较高志愿、甚至是全部志愿无法得到满足。&lt;br&gt;节目组对“前$i$名的录取结果最优”作出如下定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前$1$名的录取结果最优，当且仅当第$1$名被其最高非空志愿录取（特别地，如果第$1$名没有填写志愿表，那么该选手出局）。&lt;/li&gt;
&lt;li&gt;前$i$名的录取结果最优，当且仅当在前$i-1$名的录取结果最优的情况下：第$i$名被其理论可能的最高志愿录取（特别地，如果第i名没有填写志愿表、或其所有志愿中的导师战队均已满员，那么该选手出局）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一种方案满足“前$n$名的录取结果最优”，那么我们可以简称这种方案是最优的。&lt;br&gt;举例而言，$2$位导师$T$老师、$F$老师的战队人数上限分别都是$1$人；$2$位选手$\mathrm{Zayid}$、$\mathrm{DuckD}$分列第$1、2$名。那么下面$3$种志愿表及其对应的最优录取结果如表中所示：&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://www.lydsy.com/JudgeOnline/upload/201804/111(1).jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/center&gt;

&lt;p&gt;可以证明，对于上面的志愿表，对应的方案都是唯一的最优录取结果。&lt;br&gt;每个人都有一个自己的理想值$s_i$，表示第$i$位同学希望自己被第$s_i$或更高的志愿录取，如果没有，那么他就会非常沮丧。&lt;br&gt;现在，所有选手的志愿表和排名都已公示。巧合的是，每位选手的排名都恰好与它们的编号相同。&lt;br&gt;对于每一位选手，$\mathrm{Zayid}$都想知道下面两个问题的答案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在最优的录取方案中，他会被第几志愿录取。&lt;/li&gt;
&lt;li&gt;在其他选手相对排名不变的情况下，至少上升多少名才能使得他不沮丧。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为《中国新代码》的实力派代码手，$\mathrm{Zayid}$当然轻松地解决了这个问题。不过他还是想请你再算一遍，来检验自己计算的正确性。&lt;/p&gt;
&lt;h3 id=&quot;Input&quot;&gt;&lt;a href=&quot;#Input&quot; class=&quot;headerlink&quot; title=&quot;Input&quot;&gt;&lt;/a&gt;Input&lt;/h3&gt;&lt;p&gt;每个测试点包含多组测试数据，第一行$2$个用空格隔开的非负整数$T,C$，分别表示数据组数、每档志愿最多允许填写的导师数目。&lt;br&gt;接下来依次描述每组数据，对于每组数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第$1$行两个用空格隔开的正整数$n,m$。$n,m$分别表示选手的数量、导师的数量。&lt;/li&gt;
&lt;li&gt;第$2$行$m$个用空格隔开的正整数：其中第$i$个整数为$b_i$。$B_i$表示编号为$i$的导师战队人数的上限。&lt;/li&gt;
&lt;li&gt;第$3$行至第$n+2$行，每行$m$个用空格隔开的非负整数：其中第$i+2$行左起第$j$个数为$a_{i,j}$&lt;ul&gt;
&lt;li&gt;$a_{i,j}$表示编号为$i$的选手将编号为$j$的导师编排在了第$a_{i,j}$志愿。特别地，如果$a_{i,j}=0$，则表示该选手没有将该导师填入志愿表。&lt;/li&gt;
&lt;li&gt;在这一部分，保证每行中不存在某一个正数出现超过$C$次（$0$可能出现超过$C$次），同时保证所有$a_{i,j}\le m$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第$n+3$行$n$个用空格隔开的正整数，其中第$i$个整数为$S_i$&lt;ul&gt;
&lt;li&gt;$S_i$表示编号为$i$的选手的理想值。&lt;/li&gt;
&lt;li&gt;在这一部分，保证$S_i\le m$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;Output&quot;&gt;&lt;a href=&quot;#Output&quot; class=&quot;headerlink&quot; title=&quot;Output&quot;&gt;&lt;/a&gt;Output&lt;/h3&gt;&lt;p&gt;按顺序输出每组数据的答案。对于每组数据，输出$2$行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第$1$行输出$n$个用空格隔开的正整数，其中第$i$个整数的意义为：&lt;ul&gt;
&lt;li&gt;在最优的录取方案中，编号为$i$的选手会被该档志愿录取。&lt;/li&gt;
&lt;li&gt;特别地，如果该选手出局，则这个数为$m+1$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第$2$行输出$n$个用空格隔开的非负整数，其中第$i$个整数的意义为：&lt;ul&gt;
&lt;li&gt;使编号为$i$的选手不沮丧，最少需要让他上升的排名数。&lt;/li&gt;
&lt;li&gt;特别地，如果该选手一定会沮丧，则这个数为$i$。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="BZOJ" scheme="http://azrael.top/tags/BZOJ/"/>
    
      <category term="省选" scheme="http://azrael.top/tags/%E7%9C%81%E9%80%89/"/>
    
      <category term="图论" scheme="http://azrael.top/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="网络流" scheme="http://azrael.top/tags/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    
  </entry>
  
</feed>
